// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client;

import org.projectbuendia.client.sync.BuendiaSyncEngine.Phase;
import org.projectbuendia.client.sync.SyncManager;

/**
 * A {@link SyncManager} that does not attempt to sync any content but can be made to appear is if
 * it is syncing.
 */
public class FakeSyncManager extends SyncManager {
    private boolean mSyncing;

    // TODO/cleanup: Create a common interface between SyncManager and this class.
    public FakeSyncManager() {
        super(null);
    }

    /** Sets whether or not syncing should appear to be occurring. */
    public void setSyncing(boolean syncing) {
        mSyncing = syncing;
    }

    @Override public boolean isSyncRunningOrPending() {
        return mSyncing;
    }

    @Override public void syncAll() {
        mSyncing = true;
    }

    @Override public void setPeriodicSync(int periodSec, Phase... phases) { }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client;

import com.google.common.collect.ImmutableList;

import org.projectbuendia.models.LocationForest;

import java.util.Arrays;

/** Constructs a fake {@link LocationForest} for use in tests. */
public class FakeForestFactory {
    public static final String ROOT_UUID = "foo";
    public static final String SUSPECT_1_UUID = "tent_s1";
    public static final String SUSPECT_2_UUID = "tent_s2";

    public static final String SITE_NAME = "Fake Site";
    public static final String TRIAGE_ZONE_NAME = "Triage";
    public static final String DISCHARGED_ZONE_NAME = "Discharged";
    public static final String SUSPECT_ZONE_NAME = "Suspect";
    public static final String SUSPECT_1_TENT_NAME = "S1";
    public static final String SUSPECT_2_TENT_NAME = "S2";
    public static final String SUSPECT_ZONE_UUID = "test_location_suspect";
    public static final String TRIAGE_ZONE_UUID = "test_location_triage";
    public static final String DISCHARGED_ZONE_UUID = "test_location_discharged";

    /**
     * Builds an {@link LocationForest} with a facility, the Triage and Discharged zones, and
     * a Suspect zone containing two tents.
     * @return the constructed {@link LocationForest}
     */
    public static LocationForest build() {
        return new LocationForest(Arrays.asList(
            getSiteLocation(),
            getTriageZoneLocation(),
            getDischargedZoneLocation(),
            getSuspectZoneLocation(),
            getSuspect1TentLocation(),
            getSuspect2TentLocation()
        ));
    }

    private static LocationForest.Record getSiteLocation() {
        return new LocationForest.Record(ROOT_UUID, null, SITE_NAME, 0);
    }

    private static LocationForest.Record getTriageZoneLocation() {
        return new LocationForest.Record(TRIAGE_ZONE_UUID, ROOT_UUID, TRIAGE_ZONE_NAME, 0);
    }

    private static LocationForest.Record getDischargedZoneLocation() {
        return new LocationForest.Record(DISCHARGED_ZONE_UUID, ROOT_UUID, DISCHARGED_ZONE_NAME, 0);
    }

    private static LocationForest.Record getSuspectZoneLocation() {
        return new LocationForest.Record(SUSPECT_ZONE_UUID, ROOT_UUID, SUSPECT_ZONE_NAME, 0);
    }

    private static LocationForest.Record getSuspect1TentLocation() {
        return new LocationForest.Record(SUSPECT_1_UUID, SUSPECT_ZONE_UUID, SUSPECT_1_TENT_NAME, 0);
    }

    private static LocationForest.Record getSuspect2TentLocation() {
        return new LocationForest.Record(SUSPECT_2_UUID, SUSPECT_ZONE_UUID, SUSPECT_2_TENT_NAME, 0);
    }

    public static LocationForest emptyForest() {
        return new LocationForest(ImmutableList.of());
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client;

import android.app.Instrumentation;
import android.os.AsyncTask;
import android.util.Pair;

import org.projectbuendia.client.utils.AsyncTaskRunner;

import java.util.ArrayDeque;
import java.util.concurrent.Executor;

import static com.google.common.base.Preconditions.checkNotNull;

/** A fake {@link AsyncTaskRunner} for use in tests. */
public final class FakeAsyncTaskRunner implements AsyncTaskRunner {
    private static final Executor EXECUTOR = Runnable::run;
    private final ArrayDeque<Pair<AsyncTask<Object, Object, Object>, Object[]>>
        mQueuedTasks = new ArrayDeque<>();
    private final Instrumentation mInstrumentation;

    public FakeAsyncTaskRunner(Instrumentation instrumentation) {
        mInstrumentation = checkNotNull(instrumentation);
    }

    /** Blocks until all queued and running {@link AsyncTask}s are complete. */
    public void runUntilEmpty() {
        while (!mQueuedTasks.isEmpty()) {
            Pair<AsyncTask<Object, Object, Object>, Object[]> queuedTask = mQueuedTasks.pop();
            if (!queuedTask.first.isCancelled()) {
                queuedTask.first.executeOnExecutor(EXECUTOR, queuedTask.second);
            }
            mInstrumentation.waitForIdleSync();
        }
    }

    @SuppressWarnings("unchecked")
    @Override public <ParamsT, ProgressT, ResultT> void runTask(
        AsyncTask<ParamsT, ProgressT, ResultT> asyncTask, ParamsT... params) {
        mQueuedTasks.add(Pair.create(
            (AsyncTask<Object, Object, Object>) asyncTask,
            params));
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client;

import com.google.common.collect.Iterators;

import org.projectbuendia.models.TypedCursor;

import java.util.Iterator;

/** A {@link TypedCursor} that takes its contents as input for ease of testing. */
public class FakeTypedCursor<T> implements TypedCursor<T> {
    private final T[] mObjects;
    private boolean mIsClosed = false;

    /**
     * Creates a {@link FakeTypedCursor} that contains the specified objects.
     * @param objects the contents of the cursor
     */
    public FakeTypedCursor(T... objects) {
        mObjects = objects;
    }

    @Override public int getCount() {
        return mObjects.length;
    }

    @Override public T get(int position) {
        return mObjects[position];
    }

    @Override public void close() {
        mIsClosed = true;
    }

    @Override public Iterator<T> iterator() {
        return Iterators.forArray(mObjects);
    }

    public boolean isClosed() {
        return mIsClosed;
    }
}

package org.projectbuendia.client.smoke;

import android.content.Intent;
import android.support.test.annotation.UiThreadTest;
import android.support.test.espresso.Espresso;
import android.support.test.espresso.ViewAction;
import android.support.test.espresso.action.GeneralClickAction;
import android.support.test.espresso.action.GeneralLocation;
import android.support.test.espresso.action.Press;
import android.support.test.espresso.action.Tap;
import android.view.View;
import android.widget.AdapterView;
import android.widget.CheckBox;
import android.widget.DatePicker;
import android.widget.EditText;
import android.widget.ListAdapter;
import android.widget.NumberPicker;
import android.widget.RadioButton;
import android.widget.TextView;

import com.android.volley.toolbox.RequestFuture;

import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.hamcrest.TypeSafeMatcher;
import org.joda.time.DateTime;
import org.junit.Test;
import org.odk.collect.android.views.MediaLayout;
import org.odk.collect.android.views.ODKView;
import org.odk.collect.android.widgets2.group.TableWidgetGroup;
import org.odk.collect.android.widgets2.selectone.ButtonsSelectOneWidget;
import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.client.json.Datatype;
import org.projectbuendia.client.json.JsonEncounter;
import org.projectbuendia.client.json.JsonUser;
import org.projectbuendia.models.ConceptUuids;
import org.projectbuendia.models.Encounter;
import org.projectbuendia.models.Location;
import org.projectbuendia.models.LocationForest;
import org.projectbuendia.models.Obs;
import org.projectbuendia.client.net.OpenMrsServer;
import org.projectbuendia.client.sync.SyncManager;
import org.projectbuendia.client.ui.AuthorizationActivity;
import org.projectbuendia.client.ui.FunctionalTestCase;
import org.projectbuendia.client.ui.chart.PatientChartController;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;
import org.w3c.dom.Document;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import androidx.test.filters.MediumTest;

import static com.google.common.base.Preconditions.checkNotNull;
import static org.hamcrest.Matchers.greaterThan;
import static org.projectbuendia.client.acceptance.ListItemCountAssertion.hasItemCount;
import static org.projectbuendia.client.utils.Utils.eq;

/** A quick test suite that exercises all basic functionality. */
@MediumTest public class SmokeTest extends FunctionalTestCase {
    public static final String HOSTNAME = "buendia";
    public static final String OPENMRS_USERNAME = "tester";
    public static final String OPENMRS_PASSWORD = "tester";
    public static final Logger LOG = Logger.create();

    public static final String DEFAULT_LOCATION = "Suspect";
    public static final String TARGET_LOCATION = "Confirmed";
    public static final String FINAL_LOCATION = "Discharged";

    /** A test that exercises all the API methods and endpoints. */
    @Test @UiThreadTest public void testApi() {
        screenshot("Start");
        initSettings();  // step 0
        screenshot("Loaded users");
        final String id = "" + getNextAvailableId(R.id.users);
        addUser("Test" + id, "User" + id);  // step 1
        screenshot("Added new user");
        signInFullSync("Test" + id + " User" + id);  // step 2
        screenshot("Signed in");
        int targetCount = getPatientCount(TARGET_LOCATION);
        addPatient(id, "Given" + id, "Family" + id, 11);  // step 3
        screenshot("Added new patient");
        String patientUuid = PatientChartController.currentPatientUuid;
        movePatient(DEFAULT_LOCATION, TARGET_LOCATION);
        back();  // back to location list
        screenshot("Moved patient away");
        expectPatientCount(TARGET_LOCATION, targetCount + 1);
        int finalCount = getPatientCount(FINAL_LOCATION);
        internalMovePatient(patientUuid, internalGetLocationUuid(FINAL_LOCATION));
        internalIncrementalSync();  // step 4
        screenshot("Moved patient back");
        expectPatientCount(TARGET_LOCATION, targetCount);
        expectPatientCount(FINAL_LOCATION, finalCount + 1);
        goToPatientById(id, "Given" + id, "Family" + id);  // step 5
        screenshot("Opened chart by ID");
        editPatientAge(22);  // step 6
        screenshot("Edited patient age");
        rewindAdmissionDate(2, "Day 3");  // step 7
        screenshot("Edited admission date");
        openForm("Patient attributes");  // step 8
        screenshot("Opened form");
        answerMultipleCodedQuestion("Attributes", "Pregnant");
        submitForm(); // step 9
        screenshot("Submitted form");
        waitForViewThat(hasTextContaining("pregnant, 22 y"));
        addOrder("Sunshine", "25 rays", "Get outside!");  // step 10
        screenshot("Added new order");
        editOrder("Sunshine", "Exercise!");  // step 11
        screenshot("Edited order");
        deleteOrder("Sunshine");  // step 12
        screenshot("Deleted order");
        toast("Smoke test passed!");
    }

    private void authorize() {
        App.getSettings().setPeriodicSyncDisabled(true);
        App.getSyncManager().applyPeriodicSyncSettings();
        App.getSettings().setLocale("en");
        App.getSettings().deauthorize();
        getActivity().startActivity(
            new Intent(getActivity(), AuthorizationActivity.class)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)
        );
        clearAndType(HOSTNAME, R.id.server_field);
        clearAndType(OPENMRS_USERNAME, R.id.openmrs_user_field);
        clearAndType(OPENMRS_PASSWORD, R.id.openmrs_password_field);
        click(R.id.authorize_button);
    }

    private void initSettings() {
        App.getSettings().setPeriodicSyncDisabled(true);
        App.getSyncManager().applyPeriodicSyncSettings();
        App.getSettings().setLocale("en");
        Utils.restartActivity(getActivity());
        click(R.id.settings);
        click("Developer");
        clickIfUnchecked(viewThat(
            isA(CheckBox.class),
            whoseParent(hasSiblingThat(hasChildThat(hasText("Periodic sync disabled"))))
        ));
        click("General");
        enterSetting("Buendia server", HOSTNAME, "Apply and clear local data");
        enterSetting("OpenMRS username", OPENMRS_USERNAME, "Apply and clear local data");
        enterSetting("OpenMRS password", OPENMRS_PASSWORD, "Apply and clear local data");
        back();
    }

    private void enterSetting(String title, Object value) {
        enterSetting(title, value, "OK");
    }

    private void enterSetting(String title, Object value, String buttonText) {
        click(title);
        EditText editText = (EditText) getViewThat(
            isA(EditText.class),
            hasSiblingThat(hasText(""))
        );
        if (!eq(editText.getText().toString(), value)) {
            clearAndType(value, viewThat(
                isA(EditText.class),
                hasSiblingThat(hasText(""))
            ));
        }
        click(buttonText);
    }

    private void addUser(String given, String family) {
        click(R.id.action_new_user);
        type(given, R.id.given_name_field);
        type(family, R.id.family_name_field);
        click("OK");
        expect(given + " " + family);
    }

    private void signInFullSync(String name) {
        click(name);
        waitFor("Discharged");
    }

    private void addPatient(String id, String given, String family, int age) {
        click(R.id.action_new_patient);
        waitFor("New patient");

        type(id, R.id.patient_id);
        type(given, R.id.patient_given_name);
        type(family, R.id.patient_family_name);
        type(age, R.id.patient_age_years);
        click("Male");
        click("Female");
        click("Other");
        click("Other");
        click("OK");

        expect(id + ". " + given + " " + family);
        expectRegex("Sex unknown, " + age + " y");
    }

    private void movePatient(String oldLocation, String newLocation) {
        waitForViewThat(containsElementMatchingSelectorWithText(
            ".tile.concept-buendia_concept_placement .value", oldLocation));
        clickElementMatchingSelector(".tile.concept-buendia_concept_placement");
        click(newLocation);
        click("OK");
        waitForViewThat(containsElementMatchingSelectorWithText(
            ".tile.concept-buendia_concept_placement .value", newLocation));
    }

    private String internalGetLocationUuid(String name) {
        LocationForest forest = App.getModel().getForest();
        for (Location location : forest.allNodes()) {
            if (eq(location.name, name)) return location.uuid;
        }
        throw new RuntimeException("No location named \"" + name + "\" could be found");
    }

    /** Moves the patient on the server without updating the local data store. */
    private void internalMovePatient(String patientUuid, String locationUuid) {
        Encounter encounter = new Encounter(
            null, patientUuid, Utils.getProviderUuid(), DateTime.now(), new Obs[] {new Obs(
                null, null, patientUuid, Utils.getProviderUuid(), ConceptUuids.PLACEMENT_UUID,
                Datatype.TEXT, DateTime.now(), null, locationUuid, null
            )}
        );
        RequestFuture<JsonEncounter> future = RequestFuture.newFuture();
        App.getServer().addEncounter(encounter, future, future);
        try {
            JsonEncounter result = future.get(OpenMrsServer.TIMEOUT_SECONDS, TimeUnit.SECONDS);
        } catch (InterruptedException | ExecutionException | TimeoutException e) {
            throw new RuntimeException("Could not move patient", e);
        }
    }

    private void internalIncrementalSync() {
        sleep(500);
        App.getSyncManager().sync(SyncManager.SMALL_PHASES);
    }

    private void goToPatientById(String id, String given, String family) {
        click(R.id.action_go_to);
        type(id, R.id.go_to_patient_id);
        click("Go to chart");
        waitFor(id + ". " + given + " " + family);
    }

    private void editPatientAge(int age) {
        click(R.id.action_edit);
        click("Edit patient");
        clearAndType(age, R.id.patient_age_years);
        click("OK");
        waitForViewThat(hasTextContaining(age + " y"));
    }

    private void rewindAdmissionDate(int numDays, String expected) {
        clickElementMatchingSelector(".tile.concept-162622");
        ViewAction tapUp = new GeneralClickAction(
            Tap.SINGLE, GeneralLocation.TOP_CENTER, Press.FINGER);
        for (int i = 0; i < numDays; i++) {
            waitForViewThat(
                isA(NumberPicker.class),
                hasAncestorThat(isA(DatePicker.class)),
                hasChildThat(hasTextMatchingRegex("[0-9]{1,2}"))
            ).perform(tapUp);
            sleep(50);
        }
        click("OK");
        waitForViewThat(containsElementMatchingSelectorWithText(
            ".tile.concept-162622 .value", expected));
    }

    private void openForm(String titleSubstring) {
        click(R.id.action_edit);
        click(viewContainingText(titleSubstring));
    }

    private void submitForm() {
        click("Save");
    }

    private void addOrder(String medication, String dosage, String notes) {
        for (int i = 0; i < 10; i++) {
            clickElementMatchingSelector("#down");
            sleep(50);
        }
        clickElementMatchingSelector("#new-treatment");

        waitUntilVisible(viewThat(hasText("New treatment")));
        type(medication, R.id.order_drug);
        type(dosage, R.id.order_dosage);
        type(notes, R.id.order_notes);
        click("OK");

        waitForViewThat(containsElementMatchingSelector(
            ".order-" + Utils.toCssIdentifier(medication)));
    }

    private void editOrder(String medication, String notes) {
        clickElementMatchingSelector(".order-" + Utils.toCssIdentifier(medication) + " th");

        waitFor("Edit treatment");
        clearAndType(notes, R.id.order_notes);
        click("OK");

        waitForViewThat(containsElementMatchingSelectorWithText(
            ".order-" + Utils.toCssIdentifier(medication) + " .notes", notes));
    }

    private void deleteOrder(String medication) {
        clickElementMatchingSelector(".order-" + Utils.toCssIdentifier(medication) + " th");

        waitFor("Edit treatment");
        click("Delete this treatment");

        waitFor("Confirmation");
        click("Delete");

        waitForViewThat(
            containsElementMatchingSelector("#new-treatment"),
            containsNoElementMatchingSelector(".order-" + Utils.toCssIdentifier(medication))
        );
    }

    /** Matches Documents that do not have any elements with a given ID. */
    public static Matcher<Document> hasNoElementWithId(final String id) {
        checkNotNull(id);
        return new TypeSafeMatcher<Document>() {
            @Override public void describeTo(Description description) {
                description.appendText("has no element with id: " + id);
            }

            @Override public boolean matchesSafely(Document document) {
                return document.getElementById(id) == null;
            }
        };
    }

    private void answerTextQuestion(String questionSubstring, String answerText) {
        type(answerText, viewThat(
            isA(EditText.class),
            hasSiblingThat(
                isA(MediaLayout.class),
                hasDescendantThat(hasTextContaining(questionSubstring)))));
    }

    private void answerSingleCodedQuestion(String questionText, String answerText) {
        answerCodedQuestion(questionText, answerText,
            ButtonsSelectOneWidget.class, TableWidgetGroup.class);
    }

    private void answerMultipleCodedQuestion(String questionText, String answerText) {
        answerCodedQuestion(questionText, answerText,
            ButtonsSelectOneWidget.class, TableWidgetGroup.class, ODKView.class);
    }

    private void answerCodedQuestion(String questionText, String answerText,
                                     final Class<? extends View>... classes) {
        // Close the soft keyboard before answering any toggle questions -- on rare occasions,
        // if Espresso answers one of these questions and is then instructed to type into another
        // field, the input event will actually be generated as the keyboard is hiding and will be
        // lost, but Espresso won't detect this case.
        Espresso.closeSoftKeyboard();

        click(viewThat(
            isAnyOf(CheckBox.class, RadioButton.class),
            hasAncestorThat(
                isAnyOf(classes),
                hasDescendantThat(hasTextContaining(questionText))),
            hasTextContaining(answerText)));
    }

    private void expectPatientCount(String location, int count) {
        waitUntilVisible(viewThat(hasId(R.id.button), hasChildThat(
            hasChildThat(hasId(R.id.location_name), hasText(location)),
            hasChildThat(hasId(R.id.patient_count), hasText("" + count))
        )));
    }

    private int getPatientCount(String location) {
        TextView countView = (TextView) getViewThat(
            hasId(R.id.patient_count),
            hasSiblingThat(hasId(R.id.location_name), hasText(location))
        );
        String text = countView.getText().toString();
        try {
            return Integer.valueOf(text);
        } catch (NumberFormatException e) {
            return -1;
        }
    }

    private void expectListItemCount(int id, Matcher<Integer> matcher) {
        waitUntilVisible(viewWithId(R.id.users).check(hasItemCount(greaterThan(0))));
    }

    private int getNextAvailableId(int listId) {
        View listView = getViewThat(hasId(listId));
        ListAdapter adapter = ((AdapterView<ListAdapter>) listView).getAdapter();
        List<String> names = new ArrayList<>();
        for (int i = 0; i < adapter.getCount(); i++) {
            JsonUser user = (JsonUser) adapter.getItem(i);
            names.add(user.getName());
        }
        int nextId = 9000;
        while (names.contains("Test" + nextId + " User" + nextId)) {
            nextId++;
        }
        return nextId;
    }


}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui;

import android.app.Activity;
import android.content.res.Resources;
import android.support.annotation.Nullable;
import android.support.test.espresso.Espresso;
import android.support.test.espresso.IdlingPolicies;
import android.support.test.espresso.NoActivityResumedException;
import android.support.test.espresso.core.deps.guava.collect.Iterables;
import android.support.test.runner.lifecycle.ActivityLifecycleMonitorRegistry;
import android.support.test.runner.lifecycle.Stage;

import com.squareup.spoon.Spoon;

import org.joda.time.DateTime;
import org.junit.After;
import org.junit.Before;
import org.projectbuendia.client.R;
import org.projectbuendia.client.events.sync.SyncSucceededEvent;
import org.projectbuendia.client.events.user.KnownUsersLoadedEvent;
import org.projectbuendia.models.Patient;
import org.projectbuendia.client.ui.login.LoginActivity;
import org.projectbuendia.client.ui.matchers.TestCaseWithMatcherMethods;
import org.projectbuendia.client.ui.sync.EventBusIdlingResource;
import org.projectbuendia.client.utils.EventBusRegistrationInterface;
import org.projectbuendia.client.utils.EventBusWrapper;
import org.projectbuendia.client.utils.Logger;

import java.util.Date;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

import de.greenrobot.event.EventBus;

import static android.support.test.InstrumentationRegistry.getInstrumentation;
import static android.support.test.espresso.Espresso.pressBack;
import static android.support.test.espresso.matcher.RootMatchers.isDialog;
import static org.hamcrest.Matchers.is;
import static org.projectbuendia.client.ui.matchers.AppPatientMatchers.isPatientWithId;

/**
 * Base class for functional tests that sets timeouts to be permissive, optionally logs in as a
 * user before continuing, and provides some utility functions for convenience.
 */
public class FunctionalTestCase extends TestCaseWithMatcherMethods<LoginActivity> {
    private static final Logger LOG = Logger.create();

    public static final String LOCATION_NAME = "Triage";

    // For now, we create a new demo patient for tests using the real patient
    // creation UI on each test run (see {@link #inUserLoginInitDemoPatient()}).
    // TODO/robustness: Use externally preloaded demo data instead.
    protected static String sDemoPatientId = null;
    private boolean mWaitForUserSync = true;
    protected EventBusRegistrationInterface mEventBus;

    public FunctionalTestCase() {
        super(LoginActivity.class);
    }

    @Before
    public void setUp() throws Exception {
        // Give additional leeway for idling resources, as sync may be slow, especially on Edisons.
        // Increased to 5 minutes as certain operations (like initial sync) may take an exceedingly
        // long time.
        IdlingPolicies.setIdlingResourceTimeout(60, TimeUnit.SECONDS);
        IdlingPolicies.setMasterPolicyTimeout(60, TimeUnit.SECONDS);

        mEventBus = new EventBusWrapper(EventBus.getDefault());

        // Wait for users to sync.
        if (mWaitForUserSync) {
            EventBusIdlingResource<KnownUsersLoadedEvent> resource =
                new EventBusIdlingResource<>("USERS", mEventBus);
            Espresso.registerIdlingResources(resource);
        }
        // TODO(sdspikes): shouldn't be needed since launchActivity is set to true in the call to
        // the ActivityTestRule constructor, but without this we don't seem to launch anything.
        launchActivity(null);
    }

    public void setWaitForUserSync(boolean waitForUserSync) {
        mWaitForUserSync = waitForUserSync;
    }

    @After
    public void tearDown() {
        // Remove activities from the stack until the app is closed.  If we don't do this, the test
        // runner sometimes has trouble launching the activity to start the next test.
        try {
            closeAllActivities();
        } catch (Exception e) {
            LOG.e("Error tearing down test case; test isolation may be broken", e);
        }
    }

    /** Closes all activities on the stack. */
    protected void closeAllActivities() throws Exception {
        try {
            for (int i = 0; i < 20; i++) {
                pressBack();
                Thread.sleep(100);
            }
        } catch (NoActivityResumedException | InterruptedException e) {
            // nothing left to close
        }
    }

    protected void screenshot(String tag) {
        try {
            Spoon.screenshot(getCurrentActivity(), tag.replace(" ", ""));
        } catch (Throwable throwable) {
            LOG.w("Could not create screenshot with tag %s", tag);
        }
    }

    /**
     * Determines the currently loaded activity, rather than {@link #getActivity()},
     * which will always return the LoginActivity.
     */
    protected Activity getCurrentActivity() throws Throwable {
        getInstrumentation().waitForIdleSync();
        java.util.Collection<Activity> activities =
                ActivityLifecycleMonitorRegistry.getInstance()
                        .getActivitiesInStage(Stage.RESUMED);
        return Iterables.getOnlyElement(activities);
    }

    /** Idles until sync has completed. */
    protected void waitForInitialSync() {
        // Use a UUID as a tag so that we can wait for an arbitrary number of events, since
        // EventBusIdlingResource<> only works for a single event.
        LOG.i("Registering resource to wait for initial sync.");
        EventBusIdlingResource<SyncSucceededEvent> syncSucceededResource =
            new EventBusIdlingResource<>(UUID.randomUUID().toString(), mEventBus);
        Espresso.registerIdlingResources(syncSucceededResource);
    }

    // Broken, but hopefully fixed in Espresso 2.0.
    private void selectDateFromDatePickerDialog(DateTime dateTime) {
        selectDateFromDatePicker(dateTime);
        click(viewWithText("Set").inRoot(isDialog()));
    }

    protected void selectDateFromDatePicker(DateTime dateTime) {
        String year = dateTime.toString("yyyy");
        String monthOfYear = dateTime.toString("MMM");
        String dayOfMonth = dateTime.toString("dd");
        selectDateFromDatePicker(year, monthOfYear, dayOfMonth);
    }

    protected void selectDateFromDatePicker(
        @Nullable String year,
        @Nullable String monthOfYear,
        @Nullable String dayOfMonth) {
        LOG.e("Year: %s, Month: %s, Day: %s", year, monthOfYear, dayOfMonth);

        if (year != null) {
            setDateSpinner("year", year);
        }
        if (monthOfYear != null) {
            setDateSpinner("month", monthOfYear);
        }
        if (dayOfMonth != null) {
            setDateSpinner("day", dayOfMonth);
        }
    }

    // Broken, but hopefully fixed in Espresso 2.0.
    protected void setDateSpinner(String spinnerName, String value) {
        int numberPickerId =
            Resources.getSystem().getIdentifier("numberpicker_input", "id", "android");
        int spinnerId =
            Resources.getSystem().getIdentifier(spinnerName, "id", "android");
        LOG.i("%s: %s", spinnerName, value);
        LOG.i("numberPickerId: %d", numberPickerId);
        LOG.i("spinnerId: %d", spinnerId);
        type(value, viewThat(hasId(numberPickerId), whoseParent(hasId(spinnerId))));
    }

    /**
     * Prevents the current demo patient from being reused for the next test.
     * The default behaviour is to reuse the same demo patient for each test;
     * if a test modifies patient data, it should call this method so that the
     * next test will use a fresh demo patient.
     */
    protected void invalidateDemoPatient() {
        sDemoPatientId = null;
    }

    /**
     * Navigates to the location selection activity with a list of all the
     * patients opened (from tapping the search button).  Assumes that the UI is
     * in the user login activity.  Note: this function will not work during
     * {@link #setUp()} as it uses {@link #waitForProgressFragment()}.
     */
    protected void inUserLoginGoToPatientList() {
        inUserLoginGoToLocationSelection();
        // There may be a small delay before the search button becomes visible;
        // the button is not displayed while locations are loading.
        waitUntilVisible(3000, viewThat(hasId(R.id.action_search)));

        // Tap the search button to open the list of all patients.
        click(viewWithId(R.id.action_search));
    }

    /**
     * Navigates to the patient chart for the shared demo patient, creating the
     * demo patient if it doesn't exist yet.  Assumes that the UI is in the
     * user login activity.  Note: this function will not work during
     * {@link #setUp()} as it uses {@link #waitForProgressFragment()}.
     */
    protected String inUserLoginGoToDemoPatientChart() {
        // Create the patient
        inUserLoginGoToPatientCreation();
        screenshot("Test Start");
        String id = generateId();
        populateNewPatientFields(id);
        click(viewWithText("OK"));
        waitForProgressFragment();
        screenshot("On Patient Chart");
        return id;
    }

    /**
     * Navigates to the patient creation activity.  Assumes that the UI is
     * in the user login activity.  Note: this function will not work during
     * {@link #setUp()} as it uses {@link #waitForProgressFragment()}.
     */
    protected void inUserLoginGoToPatientCreation() {
        inUserLoginGoToLocationSelection();
        click(viewWithId(R.id.action_new_patient));
        expectVisible(viewWithText("New patient"));
    }

    /**
     * Navigates to the location selection activity from the user login
     * activity.  Note: this function will not work during {@link #setUp()}
     * as it uses {@link #waitForProgressFragment()}.
     */
    protected void inUserLoginGoToLocationSelection() {
        click(viewWithText("Guest User"));
        waitUntilVisible(20000, viewWithText("Discharged"));
        waitForProgressFragment(); // wait for locations to load
    }

    /**
     * Instructs espresso to wait for the {@link ProgressFragment} contained in the current
     * activity to finish loading, if such a fragment is present. Espresso will also wait every
     * subsequent time the {@link ProgressFragment} returns to the busy state, and
     * will period check whether or not the fragment is currently idle.
     * <p/>
     * <p>If the current activity does not contain a progress fragment, then this function will
     * throw an {@link IllegalArgumentException}.
     * <p/>
     * <p>Warning: This function will not work properly in setUp() as the current activity won't
     * be available. If you need to call this function during setUp(), use
     * {@link #waitForProgressFragment(ProgressFragment)}.
     * TODO/robustness: Investigate why the current activity isn't available during setUp().
     */
    protected void waitForProgressFragment() {
        /* TODO(sdspikes): determine if this function is needed (skipping it makes more tests pass).
         *   It seems to be a busy-loop, which seems not to play nicely with the ui thread, but it's
         *   possible that there's something I'm missing.
         */
        return;
        /*
        Activity activity;
        try {
            activity = getCurrentActivity();
        } catch (Throwable throwable) {
            throw new IllegalStateException("Error retrieving current activity", throwable);
        }

        if (!(activity instanceof FragmentActivity)) {
            throw new IllegalStateException("Activity is not a FragmentActivity");
        }

        FragmentActivity fragmentActivity = (FragmentActivity) activity;
        try {
            for (Fragment fragment : fragmentActivity.getSupportFragmentManager().getFragments()) {
                if (fragment instanceof ProgressFragment) {
                    waitForProgressFragment((ProgressFragment) fragment);
                    return;
                }
            }
        } catch (NullPointerException e) {
            LOG.w("Unable to wait for ProgressFragment to initialize.");
            return;
        }

        throw new IllegalStateException("Could not find a progress fragment to wait on.");
        */
    }

    /**
     * Instructs espresso to wait for a {@link ProgressFragment} to finish loading. Espresso will
     * also wait every subsequent time the {@link ProgressFragment} returns to the busy state, and
     * will period check whether or not the fragment is currently idle.
     */
    protected void waitForProgressFragment(ProgressFragment progressFragment) {
        // Use the ProgressFragment hashCode as the identifier so that multiple ProgressFragments
        // can be tracked, but only one resource will be registered to each fragment.
        ProgressFragmentIdlingResource idlingResource = new ProgressFragmentIdlingResource(
            Integer.toString(progressFragment.hashCode()), progressFragment);
        Espresso.registerIdlingResources(idlingResource);
    }

    /** Checks that the expected zones and tents are shown. */
    protected void inLocationSelectionCheckZonesAndTentsDisplayed() {
        // Should be at location selection screen
        waitUntilVisible(viewWithText("Discharged"));
        expectVisible(viewWithText(LOCATION_NAME));
    }

    /** In the location selection activity, click a location tile. */
    protected void inLocationSelectionClickLocation(String name) {
        click(viewThat(hasText(name)));
        waitForProgressFragment(); // Wait for search fragment to load.
    }

    /** In a patient list, click the first patient. */
    protected void inPatientListClickFirstPatient() {
        click(dataThat(is(Patient.class))
            .inAdapterView(hasId(R.id.fragment_patient_list))
            .atPosition(0));
    }

    /** In a patient list, click the patient with a specified ID. */
    protected void inPatientListClickPatientWithId(String id) {
        click(dataThat(isPatientWithId(id))
            .inAdapterView(hasId(R.id.fragment_patient_list))
            .atPosition(0));
    }

    /** Generates IDs to identify the newly created patient. */
    protected String generateId() {
        return "" + (new Date().getTime() % 100000);
    }

    /** Populates all the fields on the New Patient screen. */
    protected void populateNewPatientFields(String id) {
        screenshot("Before Patient Populated");
        String given = "Given" + id;
        String family = "Family" + id;
        type(id, viewWithId(R.id.patient_id));
        type(given, viewWithId(R.id.patient_given_name));
        type(family, viewWithId(R.id.patient_family_name));
        int i = Integer.parseInt(id);
        type("" + (i % 100), viewWithId(R.id.patient_age_years));
        type("" + (i % 10), viewWithId(R.id.patient_age_months));
        int sex = i % 2 == 0 ? R.id.patient_sex_female : R.id.patient_sex_male;
        click(viewWithId(sex));
        screenshot("After Patient Populated");
    }

    protected void toast(String message) {
        getActivity().runOnUiThread(() -> BigToast.show(message));
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui;

import android.support.test.espresso.NoMatchingViewException;
import android.view.View;

import org.junit.Assert;
import org.junit.Test;
import org.projectbuendia.client.R;

import androidx.test.annotation.UiThreadTest;

import static android.support.test.InstrumentationRegistry.getInstrumentation;
import static android.support.test.espresso.assertion.ViewAssertions.matches;
import static androidx.test.espresso.matcher.ViewMatchers.isDisplayed;
import static org.mockito.Mockito.mock;

public class SnackBarTest extends FunctionalTestCase {
    public static final String WIFI_DISABLED_MESSAGE = "Wi-Fi is disabled";

    @Test
    @UiThreadTest
    public void testSimpleMessageSnackBar() {
        final BaseActivity activity = getActivity();
        activity.runOnUiThread(() -> activity.snackBar(R.string.troubleshoot_wifi_disabled));
        waitUntilVisible(viewWithText(WIFI_DISABLED_MESSAGE));
    }

    @Test
    public void testSnackBarWithAction() {
        final View.OnClickListener mockListener = mock(View.OnClickListener.class);
        final BaseActivity activity = getActivity();
        getInstrumentation().runOnMainSync(() -> activity.snackBar(R.string.troubleshoot_wifi_disabled, R.string.troubleshoot_wifi_disabled_action_enable, mockListener));
        waitUntilVisible(viewWithText(WIFI_DISABLED_MESSAGE));
        expectVisible(viewWithId(R.id.snackbar_action));
        expectVisible(viewThat(hasText("Enable")));
        click(viewWithText("Enable"));
//        TODO(sdspikes): figure out why the mock listener isn't getting triggered by the click
//        verify(mockListener).onClick(any(View.class));
    }

    @Test
    @UiThreadTest
    public void testSnackBarDismiss() {
        final BaseActivity activity = getActivity();
        activity.runOnUiThread(() -> activity.snackBar(R.string.troubleshoot_wifi_disabled, 0, null, 1, true, 0));
        waitUntilVisible(viewWithText(WIFI_DISABLED_MESSAGE));
        expectVisible(viewWithId(R.id.snackbar_dismiss));
        click(viewWithId(R.id.snackbar_dismiss));

        try {
            viewWithText(WIFI_DISABLED_MESSAGE).check(matches(isDisplayed()));
            Assert.fail("Should have thrown NoMatchingViewException.");
        } catch(NoMatchingViewException e) {}


    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;

import org.projectbuendia.client.events.CrudEventBus;
import org.projectbuendia.client.utils.EventBusInterface;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import de.greenrobot.event.EventBus;

import static junit.framework.Assert.fail;

/**
 * Fake event bus implementation. The real {@link EventBus} is not suitable for unit tests
 * because it calls methods on a separate thread to the test thread. This is because the
 * 'main thread' is not the same as the test thread.
 */
public final class FakeEventBus implements EventBusInterface, CrudEventBus {

    private static final String METHOD_NAME_EVENT_RECEIVER_MAIN_THREAD = "onEventMainThread";
    private static final Set<String> IGNORED_METHOD_NAMES = ImmutableSet.of(
        "equals", "hashCode", "toString", "getClass", "notify", "notifyAll", "wait");

    private final Set<Object> mRegisteredReceivers = new HashSet<>();
    private final List<Object> mEventLog = Lists.newArrayList();

    @Override public void register(Object receiver) {
        for (Method method : receiver.getClass().getMethods()) {
            // Ignore methods generated by the compiler (e.g. to implement a lambda function).
            if (method.isSynthetic()) continue;
            // We only support a subset of the event bus functionality, so we check methods on the
            // receiver match a whitelist of supported methods. This should ensure the tests fail
            // in an explicit noisy way if the code under test is using event bus functionality that
            // we haven't implemented in this class.
            if (!IGNORED_METHOD_NAMES.contains((method.getName()))) {
                Preconditions.checkArgument(
                    method.getName().equals(METHOD_NAME_EVENT_RECEIVER_MAIN_THREAD),
                    "Method was called " + method.getName() + ". Fake event bus only supports "
                        + "methods called " + METHOD_NAME_EVENT_RECEIVER_MAIN_THREAD);
                Preconditions.checkArgument(
                    method.getParameterTypes().length == 1,
                    "The fake event bus only supports methods with a single parameter");
            }
        }
        mRegisteredReceivers.add(receiver);
    }

    @Override public void unregister(Object receiver) {
        mRegisteredReceivers.remove(receiver);
    }

    public int countRegisteredReceivers() {
        return mRegisteredReceivers.size();
    }

    /**
     * Fails the current test unless the event log contains a particular event.
     * @param event the event to search for
     */
    public void assertEventLogContains(Object event) {
        if (!mEventLog.contains(event)) {
            fail("Expected event not present. Actual events: " + mEventLog);
        }
    }

    public List<Object> getEventLog() {
        return ImmutableList.copyOf(mEventLog);
    }

    @Override public void post(Object event) {
        mEventLog.add(event);
        // Clone the receivers set so receivers can unregister themselves after responding to an
        // event.
        Set<Object> receivers = new HashSet<>(mRegisteredReceivers);
        for (Object receiver : receivers) {
            for (Method method : receiver.getClass().getMethods()) {
                if (method.getName().equals(METHOD_NAME_EVENT_RECEIVER_MAIN_THREAD)) {
                    Class<?> parameter = method.getParameterTypes()[0];
                    if (parameter.isInstance(event)) {
                        try {
                            method.invoke(receiver, event);
                        } catch (InvocationTargetException e) {
                            throw new RuntimeException(e.getCause());
                        } catch (IllegalAccessException | IllegalArgumentException e) {
                            throw new RuntimeException(e);
                        }
                    }
                }
            }
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui;

import android.support.test.espresso.IdlingResource;

/** An {@link IdlingResource} that waits for a ProgressFragment to be ready before continuing. */
public class ProgressFragmentIdlingResource implements IdlingResource {
    private String mName;
    private ProgressFragment mProgressFragment;
    private ResourceCallback mResourceCallback;

    /**
     * Constructs a new idling resource that will wait on the given {@link ProgressFragment} to
     * not be in the READY state before continuing. Resources with the same name as an
     * existing resource will be ignored.
     * @param name             a unique name for idempotency
     * @param progressFragment the {@link ProgressFragment} to monitor
     */
    public ProgressFragmentIdlingResource(String name, ProgressFragment progressFragment) {
        mName = name;
        mProgressFragment = progressFragment;
        mProgressFragment.registerSubscriber(new ProgressFragmentIdleSubscriber());
    }

    @Override public String getName() {
        return mName;
    }

    @Override public boolean isIdleNow() {
        return mProgressFragment.getState() == ReadyState.READY;
    }

    @Override public void registerIdleTransitionCallback(ResourceCallback resourceCallback) {
        mResourceCallback = resourceCallback;
    }

    private class ProgressFragmentIdleSubscriber implements ProgressFragment.ReadyStateSubscriber {

        @Override public void onChangeState(ReadyState newState) {
            if (mResourceCallback != null && isIdleNow()) {
                mResourceCallback.onTransitionToIdle();
                mProgressFragment.unregisterSubscriber(this);
            }
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.lists;

import android.support.test.annotation.UiThreadTest;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.projectbuendia.client.FakeForestFactory;
import org.projectbuendia.models.AppModel;
import org.projectbuendia.client.ui.matchers.SimpleSelectionFilterMatchers;

import static org.mockito.Matchers.argThat;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/** Tests for {@link PatientFilterController}. */
public class PatientFilterControllerTest {
    private static final String LOCALE = "en";
    private PatientFilterController mController;
    @Mock private AppModel mMockAppModel;
    @Mock private PatientFilterController.Ui mMockUi;

    @Before
    public void setup() {
        MockitoAnnotations.initMocks(this);
    }

    /** Tests that filters are correctly initialized once a location forest is retrieved. */
    @Test
    @UiThreadTest
    public void testSetupActionBarAsync_passesLocationFilters() {
        // GIVEN a valid location forest
        when(mMockAppModel.getForest()).thenReturn(FakeForestFactory.build());
        // WHEN the PatientFilterController starts
        mController = new PatientFilterController(mMockUi, mMockAppModel);
        // THEN location filters are passed to the Ui
        verify(mMockUi).populateActionBar(
            argThat(new SimpleSelectionFilterMatchers.ContainsFilterWithName("Triage")));
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.lists;

import android.support.test.annotation.UiThreadTest;
import android.support.test.runner.AndroidJUnit4;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.projectbuendia.client.events.sync.SyncEvent;
import org.projectbuendia.client.events.sync.SyncFailedEvent;
import org.projectbuendia.client.events.sync.SyncSucceededEvent;
import org.projectbuendia.client.sync.SyncManager;
import org.projectbuendia.client.ui.FakeEventBus;

import androidx.test.filters.SmallTest;

import static junit.framework.TestCase.assertEquals;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

/** Tests for {@link PatientListController}. */
@RunWith(AndroidJUnit4.class)
@SmallTest
public class PatientListControllerTest {
    private PatientListController mController;
    private FakeEventBus mFakeEventBus;
    @Mock private SyncManager mMockSyncManager;
    @Mock private PatientListController.Ui mMockUi;

    /** Tests whether refreshing results in a sync. */
    @Test
    @UiThreadTest
    public void testRefresh_RequestsSync() {
        // GIVEN initialized PatientListController
        mController.init();
        // WHEN PatientListController is refreshed
        mController.onRefreshRequested();
        // THEN SyncManager performs sync
        verify(mMockSyncManager).syncAll();
    }

    /** Tests that refreshing multiple times in quick succession results in only one sync. */
    @Test
    @UiThreadTest
    public void testRefresh_PreventsMultipleSimultaneousSyncs() {
        // GIVEN initialized PatientListController
        mController.init();
        // WHEN PatientListController is refreshed multiple times in quick succession
        mController.onRefreshRequested();
        mController.onRefreshRequested();
        // THEN SyncManager performs one, and only one, sync
        verify(mMockSyncManager, times(1)).syncAll();
    }

    /** Tests that refreshing again after a first successful sync results in a new sync. */
    @Test
    @UiThreadTest
    public void testRefresh_AllowsMultipleSequentialSyncsAfterSuccess() {
        // GIVEN initialized PatientListController
        mController.init();
        // WHEN PatientListController is refreshed successfully, then is later refreshed again
        mController.onRefreshRequested();
        mFakeEventBus.post(new SyncSucceededEvent());
        mController.onRefreshRequested();
        // THEN SyncManager performs sync each time
        verify(mMockSyncManager, times(2)).syncAll();
    }

    /** Tests that refreshing again after a first failed sync results in a new sync. */
    @Test
    @UiThreadTest
    public void testRefresh_AllowsMultipleSequentialSyncsAfterFailure() {
        // GIVEN initialized PatientListController
        mController.init();
        // WHEN PatientListController fails to refresh, then is later refreshed again
        mController.onRefreshRequested();
        mFakeEventBus.post(new SyncFailedEvent());
        mController.onRefreshRequested();
        // THEN SyncManager performs sync each time
        verify(mMockSyncManager, times(2)).syncAll();
    }

    /** Tests that the PatientListController listens for events when initialized. */
    @Test
    @UiThreadTest
    public void testInit_EnablesEventBusListener() {
        // GIVEN PatientListController
        // WHEN initialized
        mController.init();
        // THEN nothing happens
        assertEquals(1, mFakeEventBus.countRegisteredReceivers());
    }

    /** Tests that the PatientListController stops listening for events when suspended. */
    @Test
    @UiThreadTest
    public void testSuspend_DisablesEventBusListener() {
        // GIVEN suspended PatientListController
        mController.init();
        mController.suspend();
        // WHEN a SyncSucceededEvent occurs
        SyncEvent event = new SyncSucceededEvent();
        mFakeEventBus.post(event);
        // THEN nothing happens
        assertEquals(0, mFakeEventBus.countRegisteredReceivers());
    }

    /** Tests that the failure of a requested sync results in an error being displayed. */
    @Test
    @UiThreadTest
    public void testForcedSyncFailure_DisplaysSyncError() {
        // GIVEN initialized PatientListController with a forced sync
        mController.init();
        mController.onRefreshRequested();
        // WHEN a forced sync fails
        SyncEvent event = new SyncFailedEvent();
        mFakeEventBus.post(event);
        // THEN an error is shown
        verify(mMockUi).showRefreshError();
    }

    /** Tests that a background sync does not result in a sync error being displayed. */
    @Test
    @UiThreadTest
    public void testBackgroundSyncFailure_DoesNotDisplaySyncError() {
        // GIVEN initialized PatientListController
        mController.init();
        // WHEN a background sync fails
        SyncEvent event = new SyncFailedEvent();
        mFakeEventBus.post(event);
        // THEN no error is shown
        verify(mMockUi, times(0)).showRefreshError();
    }

    /** Tests that a successful sync hides the refresh indicator. */
    @Test
    @UiThreadTest
    public void testSyncSuccess_StopsRefresh() {
        // GIVEN initialized PatientListController
        mController.init();
        // WHEN a sync succeeds
        SyncEvent event = new SyncSucceededEvent();
        mFakeEventBus.post(event);
        // THEN the refresh indicator disappears
        verify(mMockUi).stopRefreshAnimation();
    }

    /** Tests that a failed sync hides the refresh indicator. */
    @Test
    @UiThreadTest
    public void testSyncFailure_StopsRefresh() {
        // GIVEN initialized PatientListController
        mController.init();
        // WHEN a sync fails
        SyncEvent event = new SyncFailedEvent();
        mFakeEventBus.post(event);
        // THEN the refresh indicator disappears
        verify(mMockUi).stopRefreshAnimation();
    }

    @Before
    public void setup() {
        MockitoAnnotations.initMocks(this);

        mFakeEventBus = new FakeEventBus();
        mController = new PatientListController(mMockUi, mMockSyncManager, mFakeEventBus);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.lists;

import android.support.test.annotation.UiThreadTest;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.projectbuendia.client.AppSettings;
import org.projectbuendia.client.FakeForestFactory;
import org.projectbuendia.client.FakeSyncManager;
import org.projectbuendia.client.events.actions.SyncCancelRequestedEvent;
import org.projectbuendia.client.events.sync.SyncCancelledEvent;
import org.projectbuendia.client.events.sync.SyncFailedEvent;
import org.projectbuendia.client.events.sync.SyncSucceededEvent;
import org.projectbuendia.models.AppModel;
import org.projectbuendia.client.ui.FakeEventBus;
import org.projectbuendia.client.ui.ReadyState;

import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertTrue;
import static org.junit.Assert.assertFalse;
import static org.mockito.Mockito.atLeast;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/** Tests for {@link LocationListController}. */
public final class LocationListControllerTest {

    private LocationListController mController;
    private FakeEventBus mFakeEventBus;
    private FakeSyncManager mFakeSyncManager;
    @Mock private AppModel mMockAppModel;
    @Mock private AppSettings mMockSettings;
    @Mock private LocationListController.Ui mMockUi;
    @Mock private LocationListController.LocationListFragmentUi mMockFragmentUi;
    @Mock private PatientSearchController mMockSearchController;

    /** Tests that locations are loaded during initialization, when available. */
    @Test
    @UiThreadTest
    public void testInit_RequestsLoadLocationsWhenDataModelAvailable() {
        // GIVEN initialized data model and the controller hasn't previously fetched the location forest
        when(mMockAppModel.isReady()).thenReturn(true);
        // WHEN the controller is initialized
        mController.init();
        // THEN the controller asks the location manager to provide the location forest
        verify(mMockAppModel).getForest();
    }

    /** Tests that init does not result in a new sync if data model is available. */
    @Test
    @UiThreadTest
    public void testInit_DoesNotStartSyncWhenDataModelAvailable() {
        // GIVEN initialized data model and an available forest
        when(mMockAppModel.isReady()).thenReturn(true);
        when(mMockAppModel.getForest()).thenReturn(FakeForestFactory.build());
        // WHEN the controller is initialized
        mController.init();
        // THEN the controller does not start a new sync
        assertFalse(mFakeSyncManager.isSyncRunningOrPending());
    }

    /** Tests that init kicks off a sync if the data model is unavailable. */
    @Test
    @UiThreadTest
    public void testInit_StartsSyncWhenDataModelUnavailable() {
        // GIVEN uninitialized data model,the controller hasn't previously fetched the location
        // forest, and no sync is already in progress
        mFakeSyncManager.setSyncing(false);
        when(mMockAppModel.isReady()).thenReturn(false);
        // WHEN the controller is initialized
        mController.init();
        // THEN the controller requests a sync
        assertTrue(mFakeSyncManager.isSyncRunningOrPending());
    }

    /** Tests that suspend() unregisters any subscribers from the event bus. */
    @Test
    @UiThreadTest
    public void testSuspend_UnregistersFromEventBus() {
        // GIVEN an initialized controller
        mController.init();
        // WHEN the controller is suspended
        mController.suspend();
        // THEN the controller unregisters from the event bus
        assertEquals(0, mFakeEventBus.countRegisteredReceivers());
    }

    /** Tests that the spinner is hidden after locations are loaded. */
    @Test
    @UiThreadTest
    public void testLoadLocations_HidesSpinner() {
        // GIVEN a valid location forest and sync not in progress
        mFakeSyncManager.setSyncing(false);
        when(mMockAppModel.isReady()).thenReturn(true);
        when(mMockAppModel.getForest()).thenReturn(FakeForestFactory.build());
        // GIVEN an initialized controller with a fragment attached
        mController.init();
        mController.attachFragmentUi(mMockFragmentUi);
        // THEN the controller hides the progress spinner
        verify(mMockFragmentUi).setReadyState(ReadyState.READY);
    }

    /** Tests that the spinner is not shown while a sync is in progress if the model and locations are available. */
    @Test
    @UiThreadTest
    public void testLoadLocations_DoesNotShowSpinnerWhenSyncInProgress() {
        // GIVEN a valid location forest while sync is still in progress
        mFakeSyncManager.setSyncing(true);
        when(mMockAppModel.isReady()).thenReturn(true);
        when(mMockAppModel.getForest()).thenReturn(FakeForestFactory.build());
        // WHEN a controller starts with a fragment attached
        mController.init();
        mController.attachFragmentUi(mMockFragmentUi);
        // THEN the controller does not show the progress spinner
        verify(mMockFragmentUi).setReadyState(ReadyState.READY);
    }

    /** Tests that the spinner is hidden if locations are loaded and a sync is completed. */
    @Test
    @UiThreadTest
    public void testSpinnerHiddenAfterSyncCompletes() {
        // GIVEN an incomplete model while sync is still in progress
        mFakeSyncManager.setSyncing(true);
        when(mMockAppModel.isReady()).thenReturn(false);
        // WHEN a controller starts with a fragment attached
        mController.init();
        mController.attachFragmentUi(mMockFragmentUi);
        // THEN the controller shows the sync progress bar
        verify(mMockFragmentUi).setReadyState(ReadyState.SYNCING);
        // WHEN the sync succeeds
        when(mMockAppModel.getForest()).thenReturn(FakeForestFactory.build());
        mFakeEventBus.post(new SyncSucceededEvent());
        // THEN the controller shows the spinner, loads the tree, and hides the spinner
        verify(mMockFragmentUi, atLeast(0)).setReadyState(ReadyState.LOADING);
        verify(mMockFragmentUi).setReadyState(ReadyState.READY);
    }

    /** Tests that a sync failure causes the error dialog to appear when no locations are present. */
    @Test
    @UiThreadTest
    public void testSyncFailureShowsErrorDialog_noLocations() {
        // GIVEN an initialized controller with a fragment attached
        mController.init();
        mController.attachFragmentUi(mMockFragmentUi);
        // WHEN the location forest is loaded BUT sync has failed
        mFakeSyncManager.setSyncing(true);
        mFakeEventBus.post(new SyncFailedEvent());
        // THEN the controller shows the sync failure dialog
        verify(mMockUi).showSyncFailedDialog(true);
    }

    /**
     * Tests that if, for some reason, a sync succeeds while the sync dialog is showing, the
     * sync dialog disappears and the locations are usable.
     */
    @Test
    @UiThreadTest
    public void testSyncSuccessHidesSyncDialog() {
        // GIVEN an initialized controller with an incomplete model
        when(mMockAppModel.isReady()).thenReturn(false);
        when(mMockAppModel.getForest()).thenReturn(FakeForestFactory.build());
        mController.init();
        mController.attachFragmentUi(mMockFragmentUi);
        // WHEN a sync fails, the sync failed dialog is shown
        mFakeEventBus.post(new SyncFailedEvent());
        verify(mMockUi).showSyncFailedDialog(true);
        verify(mMockFragmentUi).setReadyState(ReadyState.ERROR);
        // WHEN a sync succeeds
        mFakeEventBus.post(new SyncSucceededEvent());
        // THEN the controller hides the sync failed dialog, loads the forest, and is ready for use
        verify(mMockUi).showSyncFailedDialog(false);
        verify(mMockFragmentUi, atLeast(0)).setReadyState(ReadyState.LOADING);
        verify(mMockFragmentUi).setReadyState(ReadyState.READY);
    }

    /** Tests that loading an empty location forest results in a new sync if sync has completed. */
    @Test
    @UiThreadTest
    public void testFetchingIncompleteForest_causesNewSync() {
        // GIVEN an initialized controller with a fragment attached
        mController.init();
        mController.attachFragmentUi(mMockFragmentUi);
        // WHEN an empty location forest is loaded after sync completed
        mFakeEventBus.post(new SyncSucceededEvent());
        when(mMockAppModel.getForest()).thenReturn(FakeForestFactory.build());
        // THEN the controller starts a new sync
        assertTrue(mFakeSyncManager.isSyncRunningOrPending());
    }

    /** Tests that loading an empty location forest does not hide the sync failed dialog. */
    @Test
    @UiThreadTest
    public void testFetchingIncompleteForest_retainsSyncFailedDialog() {
        // GIVEN an empty forest
        when(mMockAppModel.getForest()).thenReturn(FakeForestFactory.emptyForest());
        // WHEN the controller starts up and a fragment is attached
        mController.init();
        mController.attachFragmentUi(mMockFragmentUi);
        // THEN the sync failed dialog is not hidden
        verify(mMockUi, times(0)).showSyncFailedDialog(false);
    }

    /** Tests that loading an empty location forest does not hide the loading dialog. */
    @Test
    @UiThreadTest
    public void testFetchingIncompleteForest_retainsLoadingDialog() {
        // GIVEN an empty forest
        when(mMockAppModel.isReady()).thenReturn(true);
        when(mMockAppModel.getForest()).thenReturn(FakeForestFactory.emptyForest());
        // WHEN the controller starts up and a fragment is attached
        mController.init();
        mController.attachFragmentUi(mMockFragmentUi);
        // THEN the sync progress bar is shown
        verify(mMockFragmentUi).setReadyState(ReadyState.SYNCING);
    }

    /** Tests that loading a populated location forest does not result in a new sync. */
    @Test
    @UiThreadTest
    public void testFetchingPopulatedForest_doesNotCauseNewSync() {
        // GIVEN a valid model and a populated forest
        when(mMockAppModel.isReady()).thenReturn(true);
        when(mMockAppModel.getForest()).thenReturn(FakeForestFactory.build());
        // WHEN the controller starts up and a fragment is attached
        mController.init();
        mController.attachFragmentUi(mMockFragmentUi);
        // THEN the controller does not start a new sync
        assertTrue(!mFakeSyncManager.isSyncRunningOrPending());
    }

    /**
     * Tests that attaching a fragment UI does not show the spinner when locations are present,
     * even if a sync is occurring.
     */
    @Test
    @UiThreadTest
    public void testAttachFragmentUi_doesNotShowSpinnerDuringSyncWhenLocationsPresent() {
        // GIVEN a sync in progress and a valid location forest
        mFakeSyncManager.setSyncing(true);
        when(mMockAppModel.isReady()).thenReturn(true);
        when(mMockAppModel.getForest()).thenReturn(FakeForestFactory.build());
        // WHEN a fragment is attached to a new controller
        mController.init();
        mController.attachFragmentUi(mMockFragmentUi);
        // THEN the loading spinner is hidden
        verify(mMockFragmentUi).setReadyState(ReadyState.READY);
    }

    /**
     * Tests that attaching a fragment UI shows the spinner if performing during a sync,
     * when location forest is empty.
     */
    @Test
    @UiThreadTest
    public void testAttachFragmentUi_showsSpinnerDuringSyncWhenForestEmpty() {
        // GIVEN a sync in progress and an empty location forest
        mFakeSyncManager.setSyncing(true);
        when(mMockAppModel.isReady()).thenReturn(true);
        when(mMockAppModel.getForest()).thenReturn(FakeForestFactory.emptyForest());
        // WHEN a fragment is attached to a new controller
        mController.init();
        mController.attachFragmentUi(mMockFragmentUi);
        // THEN the sync progress bar is shown
        verify(mMockFragmentUi).setReadyState(ReadyState.SYNCING);
    }

    /**
     * Tests that attaching a fragment UI shows the spinner if performing during a sync,
     * when location forest is not present.
     */
    @Test
    @UiThreadTest
    public void testAttachFragmentUi_showsSpinnerDuringSyncWhenLocationsNotPresent() {
        // GIVEN an initialized controller with a sync in progress and no location forest
        mFakeSyncManager.setSyncing(true);
        when(mMockAppModel.isReady()).thenReturn(false);
        mController.init();
        // WHEN a fragment is attached
        mController.attachFragmentUi(mMockFragmentUi);
        // THEN the sync progress bar is shown
        verify(mMockFragmentUi).setReadyState(ReadyState.SYNCING);
    }

    /** Tests that user-initiated sync cancellation closes the activity. */
    @Test
    @UiThreadTest
    public void testSyncCancellation_closesActivityWhenUserInitiated() {
        // GIVEN an initialized controller and no location forest
        mController.init();
        // WHEN user initiates and completes a sync cancellation
        mFakeEventBus.post(new SyncCancelRequestedEvent());
        mFakeEventBus.post(new SyncCancelledEvent());
        // THEN the activity is closed
        verify(mMockUi).finish();
    }

    /**
     * Tests that user-initiated sync cancellation closes the activity even when the data model has
     * become available since cancellation was requested.
     */
    @Test
    @UiThreadTest
    public void testSyncCancellation_closesActivityWhenUserInitiatedAndDataModelAvailable() {
        // GIVEN an initialized controller
        mController.init();
        // WHEN user initiates a sync cancellation right before the data model is fetched
        mFakeEventBus.post(new SyncCancelRequestedEvent());
        when(mMockAppModel.getForest()).thenReturn(FakeForestFactory.build());
        mFakeEventBus.post(new SyncCancelledEvent());
        // THEN the activity is closed
        verify(mMockUi).finish();
    }

    /** Tests that sync cancellations requested by the Android OS do not close the activity. */
    @Test
    @UiThreadTest
    public void testSyncCancellation_doesNotCloseActivityIfNotUserInitiated() {
        // GIVEN an initialized controller and no location forest
        mController.init();
        // WHEN a sync is canceled, but not by the user
        mFakeEventBus.post(new SyncCancelledEvent());
        // THEN the activity is not closed
        verify(mMockUi, times(0)).finish();
    }

    /** Tests that 'sync failed' messages are ignored when the data model is already available. */
    @Test
    @UiThreadTest
    public void testSyncFailed_ignoredWhenDataModelAvailable() {
        // GIVEN an initialized controller with a location forest
        when(mMockAppModel.isReady()).thenReturn(true);
        when(mMockAppModel.getForest()).thenReturn(FakeForestFactory.build());
        mController.init();
        // WHEN a periodic sync fails
        mFakeEventBus.post(new SyncFailedEvent());
        // THEN the activity does not show the Sync Failed dialog
        verify(mMockUi, times(0)).showSyncFailedDialog(true);
    }

    @Before
    public void setup() {
        MockitoAnnotations.initMocks(this);

        mFakeEventBus = new FakeEventBus();
        mFakeSyncManager = new FakeSyncManager();
        mController = new LocationListController(
            mMockAppModel,
            mMockSettings,
            mFakeEventBus,
            mMockUi,
            mFakeEventBus,
            mFakeSyncManager,
            mMockSearchController);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.lists;

import android.support.test.annotation.UiThreadTest;

import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.projectbuendia.client.R;
import org.projectbuendia.models.Patient;
import org.projectbuendia.client.ui.FunctionalTestCase;

import static android.support.test.espresso.matcher.ViewMatchers.withId;
import static org.hamcrest.Matchers.is;

/** Tests for {@link FilteredPatientListActivity}. */
public class FilteredPatientListActivityTest extends FunctionalTestCase {

    @Before
    public void setUp() throws Exception {
        super.setUp();
        click(viewWithText("Guest User"));
    }

    /** Opens the patient list. */
    private void openPatientList() {
        throw new UnsupportedOperationException("There's no button to get to the patient list any more.");
    }

    /** Looks for the filter menu. */
    @Test
    @UiThreadTest
    @Ignore
    public void testFilterMenu() {
        getActivity();
        openPatientList();
        screenshot("Test Start");
        click(viewWithText("All present patients"));
        waitForProgressFragment();
        expectVisible(viewWithText("Triage"));
        expectVisible(viewWithText("Pregnant"));
        screenshot("In Filter Menu");
    }

    /** Looks for one zone heading and at least one patient. */
    @Test
    @UiThreadTest
    public void testZoneAndPatientDisplayed() {
        openPatientList();
        screenshot("Test Start");
        // There should be at least one patient in Triage.
        waitUntilVisible(viewThat(hasTextContaining("Triage")));
        // Click the first patient
        click(dataThat(is(Patient.class))
            .inAdapterView(withId(R.id.fragment_patient_list))
            .atPosition(0));
        screenshot("After Patient Clicked");
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.lists;

import android.support.test.annotation.UiThreadTest;
import android.support.test.runner.AndroidJUnit4;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.projectbuendia.client.FakeForestFactory;
import org.projectbuendia.client.FakeTypedCursor;
import org.projectbuendia.client.events.CrudEventBus;
import org.projectbuendia.client.events.data.TypedCursorLoadedEvent;
import org.projectbuendia.client.events.data.TypedCursorLoadedEventFactory;
import org.projectbuendia.client.events.sync.SyncSucceededEvent;
import org.projectbuendia.client.filter.db.SimpleSelectionFilter;
import org.projectbuendia.client.filter.db.patient.PatientDbFilters;
import org.projectbuendia.models.AppModel;
import org.projectbuendia.models.Patient;
import org.projectbuendia.models.Sex;
import org.projectbuendia.models.TypedCursor;
import org.projectbuendia.client.sync.SyncManager;
import org.projectbuendia.client.ui.FakeEventBus;
import org.projectbuendia.client.ui.matchers.SimpleSelectionFilterMatchers;

import androidx.test.filters.SmallTest;

import static junit.framework.TestCase.assertTrue;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.argThat;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/** Tests for {@link PatientSearchController}. */
@RunWith(AndroidJUnit4.class)
@SmallTest
public class PatientSearchControllerTest {
    private PatientSearchController mController;
    private FakeEventBus mFakeCrudEventBus;
    private FakeEventBus mFakeGlobalEventBus;
    @Mock private SyncManager mSyncManager;
    @Mock private AppModel mMockAppModel;
    @Mock private PatientSearchController.Ui mMockUi;
    @Mock private PatientSearchController.FragmentUi mFragmentMockUi;

    /** Tests that results are reloaded when a sync event occurs. */
    @Test
    @UiThreadTest
    public void testSyncSubscriber_reloadsResults() {
        // GIVEN initialized PatientSearchController
        initController(false);
        // WHEN a sync event completes
        mFakeGlobalEventBus.post(new SyncSucceededEvent());
        // THEN results should be reloaded
        verify(mMockAppModel).loadPatients(
            any(CrudEventBus.class), any(SimpleSelectionFilter.class), anyString());
    }

    /** Tests that results are reloaded when a sync event occurs. */
    @Test
    @UiThreadTest
    public void testSyncSubscriber_doesNotShowSpinnerDuringReload() {
        // GIVEN initialized PatientSearchController
        initController(false);
        // WHEN a sync event completes
        mFakeGlobalEventBus.post(new SyncSucceededEvent());
        // THEN the spinner is not shown
        verify(mFragmentMockUi, times(0)).showSpinner(true);
    }

    /** Tests that patients are passed to fragment UI's after retrieval. */
    @Test
    @UiThreadTest
    public void testFilterSubscriber_passesPatientsToFragments() {
        // GIVEN initialized PatientSearchController
        initController(false);
        mController.loadSearchResults();
        // WHEN patients are retrieved
        TypedCursorLoadedEvent event = TypedCursorLoadedEventFactory.createEvent(
            Patient.class, getFakeAppPatientCursor());
        mFakeCrudEventBus.post(event);
        // THEN patients are passed to fragment UI's
        verify(mFragmentMockUi).setPatients(any(TypedCursor.class), FakeForestFactory.build());
    }

    private TypedCursor<Patient> getFakeAppPatientCursor() {
        Patient patient = new Patient("", "", "Given", "Family", Sex.OTHER, null, false, "", "");
        return new FakeTypedCursor<>(new Patient[] {patient});
    }

    /** Tests that patients are passed to the activity UI after retrieval. */
    @Test
    @UiThreadTest
    public void testFilterSubscriber_passesPatientsToActivity() {
        // GIVEN initialized PatientSearchController
        initController(false);
        mController.loadSearchResults();
        // WHEN patients are retrieved
        TypedCursorLoadedEvent event = TypedCursorLoadedEventFactory.createEvent(
            Patient.class, getFakeAppPatientCursor());
        mFakeCrudEventBus.post(event);
        // THEN patients are passed to activity UI
        verify(mMockUi).setPatients(any(TypedCursor.class));
    }

    /** Tests that any old patient cursor is closed after results are reloaded. */
    @Test
    @UiThreadTest
    public void testFilterSubscriber_closesExistingPatientCursor() {
        // GIVEN initialized PatientSearchController with existing results
        initController(false);
        mController.loadSearchResults();
        TypedCursorLoadedEvent event = TypedCursorLoadedEventFactory.createEvent(
            Patient.class, getFakeAppPatientCursor());
        mFakeCrudEventBus.post(event);
        // WHEN new results are retrieved
        mController.loadSearchResults();
        TypedCursorLoadedEvent reloadEvent = TypedCursorLoadedEventFactory.createEvent(
            Patient.class, getFakeAppPatientCursor());
        mFakeCrudEventBus.post(reloadEvent);
        // THEN old patients cursor is closed
        assertTrue(((FakeTypedCursor<Patient>) event.cursor).isClosed());
    }

    /** Tests that retrieving a new cursor results in the closure of any existing cursor. */
    @Test
    @UiThreadTest
    public void testSuspend_closesExistingPatientCursor() {
        // GIVEN initialized PatientSearchController with existing results
        initController(false);
        mController.loadSearchResults();
        TypedCursorLoadedEvent event = TypedCursorLoadedEventFactory.createEvent(
            Patient.class, getFakeAppPatientCursor());
        mFakeCrudEventBus.post(event);
        // WHEN controller is suspended
        mController.suspend();
        // THEN patient cursor is closed
        assertTrue(((FakeTypedCursor<Patient>) event.cursor).isClosed());
    }

    /** Tests that suspend() does not attempt to close a null cursor. */
    @Test
    @UiThreadTest
    public void testSuspend_ignoresNullPatientCursor() {
        // GIVEN initialized PatientSearchController with no search results
        initController(false);
        // WHEN controller is suspended
        mController.suspend();
        // THEN nothing happens (no runtime exception thrown)
    }

    /** Tests that search results are loaded properly after a cycle of init() and suspend(). */
    @Test
    @UiThreadTest
    public void testLoadSearchResults_functionalAfterInitSuspendCycle() {
        // GIVEN initialized PatientSearchController with existing results
        initController(false);
        mController.loadSearchResults();
        TypedCursorLoadedEvent event = TypedCursorLoadedEventFactory.createEvent(
            Patient.class, getFakeAppPatientCursor());
        mFakeCrudEventBus.post(event);
        // WHEN a suspend()/init() cycle occurs
        mController.suspend();
        mController.init();
        // THEN search results can be loaded successfully
        mController.loadSearchResults();
        TypedCursorLoadedEvent reloadEvent = TypedCursorLoadedEventFactory.createEvent(
            Patient.class, getFakeAppPatientCursor());
        mFakeCrudEventBus.post(reloadEvent);
        verify(mFragmentMockUi, times(2)).setPatients(any(TypedCursor.class), FakeForestFactory.build());
    }

    /**
     * Tests that loadSearchResults() is called, and patients correctly filtered, when the location
     * forest is retrieved.
     */
    @Test
    @UiThreadTest
    public void testLoadSearchResults_fetchesFilteredPatientsOnceLocationsPresent() {
        // GIVEN PatientSearchController with locations available and specified Triage root
        initController(true);
        mController.setLocationFilter(FakeForestFactory.TRIAGE_ZONE_UUID);
        // WHEN search results are requested
        mController.loadSearchResults();
        // THEN patients are fetched from Triage
        verify(mMockAppModel).loadPatients(
            any(CrudEventBus.class),
            argThat(new SimpleSelectionFilterMatchers.IsFilterGroupWithLocationFilter(
                FakeForestFactory.TRIAGE_ZONE_UUID)),
            anyString());
    }

    /** Tests that the spinner is shown when loadSearchResults() is called. */
    @Test
    @UiThreadTest
    public void testLoadSearchResults_showsSpinner() {
        // GIVEN initialized PatientSearchController
        initController(false);
        // WHEN search results are requested
        mController.loadSearchResults();
        // THEN spinner is shown
        verify(mFragmentMockUi).showSpinner(true);
    }

    /** Tests that the spinner is shown when loadSearchResults() is called. */
    @Test
    @UiThreadTest
    public void testLoadSearchResults_hidesSpinnerWhenRequested() {
        // GIVEN initialized PatientSearchController
        initController(false);
        // WHEN search results are requested with no spinner
        mController.loadSearchResults(false);
        // THEN spinner is shown
        verify(mFragmentMockUi, times(0)).showSpinner(true);
    }

    /** Tests that the spinner is hidden after results are retrieved. */
    @Test
    @UiThreadTest
    public void testFilterSubscriber_hidesSpinner() {
        // GIVEN initialized PatientSearchController
        initController(false);
        mController.loadSearchResults();
        // WHEN patients are retrieved
        TypedCursorLoadedEvent event =
            TypedCursorLoadedEventFactory.createEvent(
                Patient.class, getFakeAppPatientCursor());
        mFakeCrudEventBus.post(event);
        // THEN patients are passed to fragment UI's
        verify(mFragmentMockUi).showSpinner(false);
    }

    /** Tests that the controller correctly filters when the search term changes. */
    @Test
    @UiThreadTest
    public void testOnQuerySubmitted_filtersBySearchTerm() {
        // GIVEN initialized PatientSearchController with no root location
        initController(true);
        // WHEN search term changes
        mController.onQuerySubmitted("foo");
        // THEN results are requested with that search term
        verify(mMockAppModel).loadPatients(
            mFakeCrudEventBus, PatientDbFilters.getDefaultFilter(), "foo");
    }

    @Before
    public void setup() {
        MockitoAnnotations.initMocks(this);

        mFakeCrudEventBus = new FakeEventBus();
        mFakeGlobalEventBus = new FakeEventBus();
    }

    public void initController(boolean withForest) {
        if (withForest) {
            when(mMockAppModel.getForest()).thenReturn(FakeForestFactory.build());
        }
        mController = new PatientSearchController(
            mMockUi, mFakeCrudEventBus, mFakeGlobalEventBus, mMockAppModel, mSyncManager);
        mController.attachFragmentUi(mFragmentMockUi);
        mController.init();
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.lists;

import android.support.test.annotation.UiThreadTest;

import org.junit.Before;
import org.junit.Test;
import org.projectbuendia.client.R;
import org.projectbuendia.models.Patient;
import org.projectbuendia.client.ui.FunctionalTestCase;

import static android.support.test.espresso.matcher.ViewMatchers.withId;
import static org.hamcrest.Matchers.is;

/** Test case for {@link SingleLocationActivity}. */
public class RoundActivityTest extends FunctionalTestCase {
    /**
     * Initializes the test by entering the Round view for Triage.
     * @throws Exception if anything goes wrong
     */
    @Before
    public void setUp() throws Exception {
        super.setUp();
        click(viewWithText("Guest User"));
        waitForProgressFragment();
        click(viewWithText("Triage"));
    }

    /** Checks for a populated title. */
    @Test
    @UiThreadTest
    public void testTitlePopulation() {
        // TODO/completeness: Check that title count actually matches patient count.
        screenshot("Test Start");
        assert getActivity().getTitle().toString().matches("$Triage \\((No|[0-9]+) Patients\\)");
    }

    /** Checks that at least one patient is displayed. */
    @Test
    @UiThreadTest
    public void testAtLeastOnePatientDisplayed() {
        screenshot("Test Start");
        // Click the first patient
        click(dataThat(is(Patient.class))
            .inAdapterView(withId(R.id.fragment_patient_list))
            .atPosition(0));
        screenshot("After Patient Clicked");
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.lists;

import android.support.test.annotation.UiThreadTest;

import org.junit.Test;
import org.projectbuendia.client.R;
import org.projectbuendia.client.ui.FunctionalTestCase;

import static android.support.test.espresso.Espresso.pressBack;

/** Tests for {@link LocationListActivity}. */
public class LocationListActivityTest extends FunctionalTestCase {

    private static final String ALL_PATIENTS_LABEL = "ALL PATIENTS";

    /** Looks for the expected zones and tents. */
    @Test
    @UiThreadTest
    public void testZonesAndTentsDisplayed() {
        inUserLoginGoToLocationSelection();
        inLocationSelectionCheckZonesAndTentsDisplayed();
    }

    /** Tests that zones and tents are still displayed after returning from round view. */
    @Test
    @UiThreadTest
    public void testZonesAndTentsDisplayed_afterRoundView() {
        inUserLoginGoToLocationSelection();
        inLocationSelectionClickLocation(LOCATION_NAME);
        pressBack();
        inLocationSelectionCheckZonesAndTentsDisplayed();
    }

    /** Tests that zones and tents are still displayed after returning from list view. */
    @Test
    @UiThreadTest
    public void testZonesAndTentsDisplayed_afterPatientListView() {
        inUserLoginGoToLocationSelection();
        // TODO/i18n: Use a string resource instead of the literal button text.
        inLocationSelectionClickLocation(ALL_PATIENTS_LABEL);
        pressBack();
        inLocationSelectionCheckZonesAndTentsDisplayed();
    }

    /** Tests that zones and tents are still displayed after returning from settings view. */
    @Test
    @UiThreadTest
    public void testZonesAndTentsDisplayed_afterSettingsView() {
        inUserLoginGoToLocationSelection();

        // Enter settings view and return.
        click(firstViewWithText("GU"));
        click(viewWithId(R.id.button_settings));
        pressBack();
        inLocationSelectionCheckZonesAndTentsDisplayed();
    }

    /** Tests that zones and tents are still displayed after returning from chart view. */
    @Test
    @UiThreadTest
    public void testZonesAndTentsDisplayed_afterChartView() {
        inUserLoginGoToPatientCreation();
        screenshot("Test Start");
        String id = generateId();
        populateNewPatientFields(id);
        click(viewWithText("OK"));
        waitForProgressFragment();
        pressBack(); // back to location selection screen
        inLocationSelectionCheckZonesAndTentsDisplayed();
    }

    /** Tests that zones and tents are still displayed after changing a patient's location. */
    @Test
    @UiThreadTest
    public void testZonesAndTentsDisplayed_afterPatientLocationChanged() {
        inUserLoginGoToPatientCreation();
        screenshot("Test Start");
        String id = generateId();
        populateNewPatientFields(id);
        click(viewWithText("OK"));
        waitForProgressFragment();
        screenshot("On Patient Chart");

        // Assign a location to the patient
        clickElementMatchingSelector(".tile.location");
        screenshot("After Location Dialog Shown");
        click(viewWithText(LOCATION_NAME));
        screenshot("After Location Selected");
        click(viewWithText("OK"));

        pressBack(); // back to location selection screen
        inLocationSelectionCheckZonesAndTentsDisplayed();
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.chart;

import android.support.test.annotation.UiThreadTest;
import android.support.test.espresso.Espresso;
import android.support.test.espresso.IdlingResource;
import android.support.test.espresso.ViewInteraction;
import android.support.test.espresso.web.webdriver.Locator;
import android.view.View;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.RadioButton;

import org.junit.Ignore;
import org.junit.Test;
import org.odk.collect.android.views.MediaLayout;
import org.odk.collect.android.views.ODKView;
import org.odk.collect.android.widgets2.group.TableWidgetGroup;
import org.odk.collect.android.widgets2.selectone.ButtonsSelectOneWidget;
import org.projectbuendia.client.R;
import org.projectbuendia.client.events.FetchXformSucceededEvent;
import org.projectbuendia.client.events.SubmitXformSucceededEvent;
import org.projectbuendia.client.ui.FunctionalTestCase;
import org.projectbuendia.client.ui.sync.EventBusIdlingResource;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.util.UUID;

import androidx.test.filters.MediumTest;

import static android.support.test.espresso.matcher.ViewMatchers.isJavascriptEnabled;
import static android.support.test.espresso.web.assertion.WebViewAssertions.webMatches;
import static android.support.test.espresso.web.sugar.Web.onWebView;
import static android.support.test.espresso.web.webdriver.DriverAtoms.findElement;
import static android.support.test.espresso.web.webdriver.DriverAtoms.getText;
import static org.hamcrest.Matchers.containsString;

/** Functional tests for {@link PatientChartActivity}. */
@MediumTest
public class PatientChartActivityTest extends FunctionalTestCase {
    private static final Logger LOG = Logger.create();

    private static final String NO = "";
    private static final String YES = "";

    private static final String BP_SYS = "BP, systolic";
    private static final String BP_DIA = "BP, diastolic";

    private static final int ROW_HEIGHT = 84;

    private static final String VITALS_FORM = "Vitals and physical exam";
    private static final String ATTRIBUTES_FORM = "Patient attributes";

    public PatientChartActivityTest() {
        super();
    }


    /**
     * Tests that the general condition dialog successfully changes general condition.
     * TODO/completeness: Currently disabled because this is now rendered in a WebView.
     * A new test needs to be written that interacts with the WebView.
     */
    /*
    @Test
    @UiThreadTest
    public void testGeneralConditionDialog_AppliesGeneralConditionChange() {
        inUserLoginGoToDemoPatientChart();
        click(viewWithId(R.id.patient_chart_vital_general_parent));
        screenshot("General Condition Dialog");
        click(viewWithText(R.string.status_well));

        // Wait for a sync operation to update the chart.
        EventBusIdlingResource<SyncStoppedEvent> syncFinishedIdlingResource =
            new EventBusIdlingResource<>(UUID.randomUUID().toString(), mEventBus);
        Espresso.registerIdlingResources(syncFinishedIdlingResource);

        // Check for updated vital view.
        expectVisibleSoon(viewWithText(R.string.status_well));

        // Check for updated chart view.
        expectVisible(viewThat(
            hasText(R.string.status_short_desc_well),
            not(hasId(R.id.patient_chart_vital_general_condition_number))));
    }
    */

    /** Tests that the encounter form can be opened more than once. */
    @Test
    @UiThreadTest
    @Ignore
    // TODO(sdspikes): re-enable if it can be made less flaky
    public void testPatientChart_CanOpenEncounterFormMultipleTimes() {
        inUserLoginGoToDemoPatientChart();
        // Load the form once and dismiss it
        openEncounterForm(ATTRIBUTES_FORM);
        click(viewWithText("Discard"));

        try {
            Thread.sleep(5000);
        } catch (InterruptedException ignored) {
        }


        // Load the form again and dismiss it
        openEncounterForm(ATTRIBUTES_FORM);
        click(viewWithText("Discard"));
    }

    /**
     * Tests that the admission date is correctly displayed in the header.
     * TODO/completeness: Currently disabled. Re-enable once date picker
     * selection works (supposedly works in Espresso 2.0).
     */
    /*@UiThreadTest
    public void testPatientChart_ShowsCorrectAdmissionDate() {
        mDemoPatient.admissionDate = Optional.of(DateTime.now().minusDays(5));
        inUserLoginGoToDemoPatientChart();
        expectVisible(viewThat(
                hasAncestorThat(hasId(R.id.attribute_admission_days)),
                hasText("Day 6")));
        screenshot("Patient Chart");
    }*/

    /**
     * Tests that the patient chart shows the correct symptoms onset date.
     * TODO/completeness: Currently disabled. Re-enable once date picker
     * selection works (supposedly works in Espresso 2.0).
     */
    /*@UiThreadTest
    public void testPatientChart_ShowsCorrectSymptomsOnsetDate() {
        inUserLoginGoToDemoPatientChart();
        expectVisible(viewThat(
                hasAncestorThat(hasId(R.id.attribute_symptoms_onset_days)),
                hasText("Day 8")));
        screenshot("Patient Chart");
    }*/

    /**
     * Tests that the patient chart shows all days, even when no observations are present.
     * TODO/completeness: Currently disabled. Re-enable once date picker
     * selection works (supposedly works in Espresso 2.0).
     */
     /*@UiThreadTest
    public void testPatientChart_ShowsAllDaysInChartWhenNoObservations() {
        inUserLoginGoToDemoPatientChart();
        expectVisibleWithin(5000, viewThat(hasTextContaining("Today (Day 6)")));
        screenshot("Patient Chart");
    }*/

    // TODO/completeness: Disabled as there seems to be no easy way of
    // scrolling correctly with no adapter view.

    /** Tests that encounter time can be set to a date in the past and still displayed correctly. */
    /*@UiThreadTest
    public void testCanSubmitObservationsInThePast() {
        inUserLoginGoToDemoPatientChart();
        openEncounterForm();
        selectDateFromDatePicker("2015", "Jan", null);
        answerTextQuestion("Temperature", "29.1");
        saveForm();
        checkObservationValueEquals(0, "29.1", "1 Jan"); // Temperature
    }*/

    // TODO(sdspikes): this method is somewhat flaky, the click sometimes doesn't bring up the menu
    protected void openEncounterForm(String menuLabel) {
        // Wait until the edit menu button is available.
        waitUntilVisible(viewWithId(R.id.action_edit));
        click(viewWithId(R.id.action_edit));

        EventBusIdlingResource<FetchXformSucceededEvent> xformIdlingResource =
                new EventBusIdlingResource<>(UUID.randomUUID().toString(), mEventBus);
        ViewInteraction testForm = viewWithText(menuLabel);
        waitUntilVisible(testForm);
        click(testForm);
        Espresso.registerIdlingResources(xformIdlingResource);

        // Give the form time to be parsed on the client (this does not result in an event firing).
        waitUntilVisible(viewWithText("Encounter"));
    }

    /** Tests that dismissing a form immediately closes it if no changes have been made. */
    @Test
    @UiThreadTest
    @Ignore
    public void testDismissButtonReturnsImmediatelyWithNoChanges() {
        inUserLoginGoToDemoPatientChart();
        openEncounterForm(ATTRIBUTES_FORM);
        click(viewWithText("Discard"));
    }

    /** Tests that dismissing a form results in a dialog if changes have been made. */
    @Test
    @UiThreadTest
    public void testDismissButtonShowsDialogWithChanges() {
        inUserLoginGoToDemoPatientChart();
        openEncounterForm(VITALS_FORM);
        answerTextQuestion("Temperature", "29.2");

        // Try to discard and give up.
        click(viewWithText("Discard"));
        expectVisible(viewWithText(getString(R.string.title_discard_observations)));
        click(viewWithText("No"));

        // Try to discard and actually go back.
        click(viewWithText("Discard"));
        expectVisible(viewWithText(getString(R.string.title_discard_observations)));
        click(viewWithText("Yes"));
    }

    private void answerTextQuestion(String questionText, String answerText) {
        type(answerText, viewThat(
            isA(EditText.class),
            hasSiblingThat(
                isA(MediaLayout.class),
                hasDescendantThat(hasTextContaining(questionText)))));
    }

    private void answerSingleCodedQuestion(String questionText, String answerText) {
        answerCodedQuestion(questionText, answerText, ButtonsSelectOneWidget.class,
            TableWidgetGroup.class);
    }

    private void answerMultipleCodedQuestion(String questionText, String answerText) {
        answerCodedQuestion(questionText, answerText, ButtonsSelectOneWidget.class,
            TableWidgetGroup.class, ODKView.class);
    }

    private void answerCodedQuestion(String questionText, String answerText,
                                     final Class<? extends View>... classes) {
        // Close the soft keyboard before answering any toggle questions -- on rare occasions,
        // if Espresso answers one of these questions and is then instructed to type into another
        // field, the input event will actually be generated as the keyboard is hiding and will be
        // lost, but Espresso won't detect this case.
        Espresso.closeSoftKeyboard();

        click(viewThat(
            isAnyOf(CheckBox.class, RadioButton.class),
            hasAncestorThat(
                isAnyOf(classes),
                hasDescendantThat(hasTextContaining(questionText))),
            hasText(answerText)));
    }

    private void saveForm() {
        IdlingResource xformWaiter = getXformSubmissionIdlingResource();
        click(viewWithText("Save"));
        Espresso.registerIdlingResources(xformWaiter);
    }

    private IdlingResource getXformSubmissionIdlingResource() {
        return new EventBusIdlingResource<SubmitXformSucceededEvent>(
            UUID.randomUUID().toString(),
            mEventBus);
    }

    /**
     * Tests that, when multiple encounters for the same encounter time are submitted within a short
     * period of time, that only the latest encounter is present in the relevant column.
     */
    @Test
    @UiThreadTest
    @Ignore
    // TODO(sdspikes): re-enable if it can be made less flaky (menu doesn't always load in time)
    public void testEncounter_latestEncounterIsAlwaysShown() {
        inUserLoginGoToDemoPatientChart();

        // Update a vital tile (pulse) as well as a couple of observations (temperature, vomiting
        // count), and verify that the latest value is visible for each.
        for (int i = 0; i < 3; i++) {
            openEncounterForm(VITALS_FORM);

            String temp = Integer.toString(i + 35) + ".7";
            String respiratoryRate = Integer.toString(i + 80);
            String bpSystolic = Integer.toString(i + 80);
            String bpDiastolic = Integer.toString(i + 100);

            answerTextQuestion("Temperature", temp);
            answerTextQuestion("Respiratory rate", respiratoryRate);
            answerTextQuestion(BP_SYS, bpSystolic);
            answerTextQuestion(BP_DIA, bpDiastolic);
            saveForm();

            waitForProgressFragment();

            // TODO: implement IdlingResource for webview to remove this sleep.
            // Wait a bit for the chart to update it's values.
//            try{
//                Thread.sleep(500);
//            } catch (InterruptedException ignored){}

            //checkVitalValueContains("Pulse", pulse);
//            TODO(sdspikes): debug why these checks always time out
//            checkObservationValueEquals("Temperature (C)", temp);
//            checkObservationValueEquals("Respiratory rate (bpm)", respiratoryRate);
//            checkObservationValueEquals(BP_SYS, bpSystolic);
//            checkObservationValueEquals(BP_SYS, bpDiastolic);
        }
    }

    private void checkVitalValueContains(String vitalName, String vitalValue) {
        // Check for updated vital view.
        waitUntilVisible(viewThat(
            hasTextContaining(vitalValue),
            hasSiblingThat(hasTextContaining(vitalName))));
    }

    //TODO: check the todo bellow and remove this commented method
//    private void checkObservationValueEquals(int row, String value, String dateKey) {
//        // TODO/completeness: actually check dateKey
//
//        scrollToAndExpectVisible(viewThat(
//            hasText(value),
//            hasAncestorThat(isInRow(row, ROW_HEIGHT))));
//    }

    /**
     * Look for the informed value on the last cell of the Observation named row.
     * @param obsName the class name added to the tr where the value is. The class name is the
     *                  name of the observation with all non alphanumeric chars replaced by "_".
     * @param value the text inside the table cell.
     */
    private void checkObservationValueEquals(String obsName, String value) {
        String cssSelector = "tr." + Utils.toCssIdentifier(obsName) + " td:last-child";
        onWebView()
            .withElement(findElement(Locator.CSS_SELECTOR, cssSelector))
            .check(webMatches(getText(), containsString(value)));
    }


    /** Ensures that non-overlapping observations for the same encounter are combined. */
    @Test
    public void testCombinesNonOverlappingObservationsForSameEncounter() {
        inUserLoginGoToDemoPatientChart();
        waitForProgressFragment();

        // Enter first set of observations for this encounter.
        openEncounterForm(VITALS_FORM);
        answerTextQuestion("Temperature", "36.5");
        answerTextQuestion("Respiratory rate", "23");
        answerTextQuestion("saturation", "95");
        answerTextQuestion(BP_SYS, "80");
        answerTextQuestion(BP_DIA, "100");
        answerMultipleCodedQuestion("Other symptoms", "Nausea");
        saveForm();

        // Enter second set of observations for this encounter.
        waitUntilVisible(10000, viewWithId(R.id.chart_webview));
        openEncounterForm(VITALS_FORM);
        answerSingleCodedQuestion("Consciousness", "Responds to voice");
        answerMultipleCodedQuestion("Other symptoms", "Cough");
        saveForm();

        // Enter third set of observations for this encounter.
        waitUntilVisible(10000, viewWithId(R.id.chart_webview));
        openEncounterForm(VITALS_FORM);
        answerTextQuestion("Temperature", "37.7");
        answerSingleCodedQuestion("Condition", "Unwell");
        answerTextQuestion("Notes", "Call family");
        saveForm();

        // Check that all values are now visible.
        // Expect a WebView with JS enabled to be visible soon (the chart).
        waitUntilVisible(10000, viewThat(isJavascriptEnabled()));
        checkObservationValueEquals("Temperature (C)", "37.7");
        checkObservationValueEquals("Respiratory rate (bpm)", "23");
        checkObservationValueEquals("O saturation", "95");
        checkObservationValueEquals(BP_SYS, "80");
        checkObservationValueEquals(BP_DIA, "100");
        checkObservationValueEquals("AVPU", "V");
        checkObservationValueEquals("Cough", YES);
        checkObservationValueEquals("Nausea", YES);
        checkObservationValueEquals("Condition", "2");
        checkObservationValueEquals("Notes", "Call ");
    }

    private void checkObservationSet(int row, String dateKey) {
        // TODO/completeness: actually check dateKey
        scrollToAndExpectVisible(viewThat(
            hasAncestorThat(isInRow(row, ROW_HEIGHT)),
            hasBackground(getActivity().getResources().getDrawable(R.drawable.chart_cell_active))));
    }

    /** Exercises all fields in the encounter form, except for encounter time. */
    @Test
    @UiThreadTest
    public void testEncounter_allFieldsWorkOtherThanEncounterTime() {
        inUserLoginGoToDemoPatientChart();
        waitForProgressFragment();

        openEncounterForm(VITALS_FORM);
        answerTextQuestion("Heart rate", "70");
        answerTextQuestion("Respiratory rate", "23");
        answerTextQuestion("saturation", "95");
        answerTextQuestion(BP_SYS, "110");
        answerTextQuestion(BP_DIA, "75");
        answerTextQuestion("Cap Refill Time", "2");
        answerTextQuestion("Temperature", "36.1");
        answerSingleCodedQuestion("Consciousness", "U. Unresponsive");
        answerSingleCodedQuestion("Urinary function", "Oliguria");
        answerSingleCodedQuestion("Anorexia", "++");

        answerTextQuestion("Vomiting", "1");
        answerTextQuestion("Diarrhea", "2");

        scrollToAndExpectVisible(firstViewWithText("Other symptoms"));
        scrollToAndExpectVisible(firstViewWithText("Condition"));
        answerMultipleCodedQuestion("Other symptoms", "Headache");
        answerMultipleCodedQuestion("Other symptoms", "Asthenia");
        answerMultipleCodedQuestion("Other symptoms", "Cough");
        answerMultipleCodedQuestion("Other symptoms", "Chest pain");
        answerMultipleCodedQuestion("Other symptoms", "Nausea");
        answerMultipleCodedQuestion("Other symptoms", "Back pain");
        answerMultipleCodedQuestion("Other symptoms", "Photophobia");
        answerMultipleCodedQuestion("Other symptoms", "Dysphagia");
        answerMultipleCodedQuestion("Other symptoms", "Hiccups");
        answerMultipleCodedQuestion("Other symptoms", "Dyspnea");
        answerMultipleCodedQuestion("Other symptoms", "Abdominal pain");
        answerMultipleCodedQuestion("Other symptoms", "Myalgia");

        scrollToAndExpectVisible(firstViewWithText("Bleeding"));
        answerSingleCodedQuestion("Condition", "1. Stable");
        answerMultipleCodedQuestion("Appearance", "Pallor");
        answerMultipleCodedQuestion("Appearance", "Jaundice");
        answerMultipleCodedQuestion("Appearance", "Cyanosis");
        answerSingleCodedQuestion("Dehydration", "A. Mild");
        answerSingleCodedQuestion("Neuro", "Confusion");

        scrollToAndExpectVisible(firstViewWithText("Respiratory"));
        answerMultipleCodedQuestion("Bleeding", "Conjunctival injection");
        answerMultipleCodedQuestion("Bleeding", "Gingival hemorrhage");
        answerMultipleCodedQuestion("Bleeding", "Epistaxis");
        answerMultipleCodedQuestion("Bleeding", "Hemoptysis");
        answerMultipleCodedQuestion("Bleeding", "Hematemesis");
        answerMultipleCodedQuestion("Bleeding", "Melaena");
        answerMultipleCodedQuestion("Bleeding", "Hematuria");
        answerMultipleCodedQuestion("Bleeding", "Vaginal bleeding");
        answerMultipleCodedQuestion("Bleeding", "Injection site bleeding");
        answerMultipleCodedQuestion("Bleeding", "Petechiae");

        scrollToAndExpectVisible(firstViewWithText("Notes"));
        answerSingleCodedQuestion("Respiratory", "Mild dyspnea");
        answerMultipleCodedQuestion("Circulation", "Weak pulse");
        answerMultipleCodedQuestion("Abdomen", "Soft");
        answerMultipleCodedQuestion("Abdomen", "Distended");
        answerMultipleCodedQuestion("Abdomen", "Painful");
        answerMultipleCodedQuestion("Abdomen", "Hepatomegaly");
        answerMultipleCodedQuestion("Abdomen", "Splenomegaly");

        answerTextQuestion("Notes", "Possible malaria.");
        saveForm();

        // Expect a WebView with JS enabled to be visible soon (the chart).
        waitUntilVisible(10000, viewThat(isJavascriptEnabled()));
        // Wait for WebView to render and scripts to run.
        try { Thread.sleep(10000); } catch (InterruptedException e) { }

        // Check that all values are now visible.
        checkObservationValueEquals("Heart rate", "70");
        checkObservationValueEquals("Respiratory rate", "23");
        checkObservationValueEquals("O saturation", "95");
        checkObservationValueEquals(BP_SYS, "110");
        checkObservationValueEquals(BP_DIA, "75");
        checkObservationValueEquals("Cap Refill Time (s)", "2");
        checkObservationValueEquals("Temperature (C)", "36.1");
        checkObservationValueEquals("AVPU", "U");
        checkObservationValueEquals("Oliguria", YES);
        checkObservationValueEquals("Anorexia", "++");

        checkObservationValueEquals("Vomiting in 24h", "1");
        checkObservationValueEquals("Diarrhea in 24h", "2");
        checkObservationValueEquals("Anorexia", "++");

        checkObservationValueEquals("Headache", YES);
        checkObservationValueEquals("Asthenia", YES);
        checkObservationValueEquals("Cough", YES);
        checkObservationValueEquals("Chest pain", YES);
        checkObservationValueEquals("Nausea", YES);
        checkObservationValueEquals("Back pain", YES);
        checkObservationValueEquals("Photophobia", YES);
        checkObservationValueEquals("Dysphagia", YES);
        checkObservationValueEquals("Hiccups", YES);
        checkObservationValueEquals("Dyspnea", YES);
        checkObservationValueEquals("Abdominal pain", YES);
        checkObservationValueEquals("Myalgia", YES);

        checkObservationValueEquals("Condition", "1");
        checkObservationValueEquals("Pallor", YES);
        checkObservationValueEquals("Jaundice", YES);
        checkObservationValueEquals("Cyanosis", YES);
        checkObservationValueEquals("Dehydration", "A");
        checkObservationValueEquals("Confusion", YES);

        checkObservationValueEquals("Conjunctival injection", YES);
        checkObservationValueEquals("Gingival hemorrhage", YES);
        checkObservationValueEquals("Epistaxis", YES);
        checkObservationValueEquals("Hemoptysis", YES);
        checkObservationValueEquals("Hematemesis", YES);
        checkObservationValueEquals("Melaena", YES);
        checkObservationValueEquals("Hematuria", YES);
        checkObservationValueEquals("Vaginal bleeding", YES);
        checkObservationValueEquals("Injection site bleeding", YES);
        checkObservationValueEquals("Petechiae", YES);

        checkObservationValueEquals("Mild dyspnea", YES);
        checkObservationValueEquals("Weak pulse", YES);
        checkObservationValueEquals("Soft", YES);
        checkObservationValueEquals("Distended", YES);
        checkObservationValueEquals("Painful", YES);
        checkObservationValueEquals("Hepatomegaly", YES);
        checkObservationValueEquals("Splenomegaly", YES);

        checkObservationValueEquals("Notes", "Possi");
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.chart;

import android.support.test.annotation.UiThreadTest;
import android.support.test.runner.AndroidJUnit4;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;

import org.joda.time.DateTime;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.projectbuendia.client.AppSettings;
import org.projectbuendia.client.R;
import org.projectbuendia.client.events.FetchXformFailedEvent;
import org.projectbuendia.client.events.FetchXformSucceededEvent;
import org.projectbuendia.client.events.SubmitXformFailedEvent;
import org.projectbuendia.client.events.SubmitXformSucceededEvent;
import org.projectbuendia.client.events.data.ItemLoadedEvent;
import org.projectbuendia.client.json.Datatype;
import org.projectbuendia.models.AppModel;
import org.projectbuendia.models.Chart;
import org.projectbuendia.models.ConceptUuids;
import org.projectbuendia.models.Obs;
import org.projectbuendia.models.Patient;
import org.projectbuendia.models.Sex;
import org.projectbuendia.client.sync.ChartDataHelper;
import org.projectbuendia.client.sync.SyncManager;
import org.projectbuendia.client.ui.FakeEventBus;
import org.projectbuendia.client.ui.chart.PatientChartController.MinimalHandler;
import org.projectbuendia.client.ui.chart.PatientChartController.OdkResultSender;

import java.util.ArrayDeque;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import androidx.test.filters.SmallTest;

import static junit.framework.TestCase.assertEquals;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/** Tests for {@link PatientChartController}. */
@RunWith(AndroidJUnit4.class)
@SmallTest
public final class PatientChartControllerTest {
    private static final String PATIENT_UUID_1 = "patient-uuid-1";
    private static final String PATIENT_NAME_1 = "Bob";
    private static final String PATIENT_ID_1 = "patient-id-1";
    private static final Patient PATIENT =
        new Patient(PATIENT_UUID_1, PATIENT_ID_1, "Given", "Family", Sex.OTHER, null, false, "", "");

    private static final Obs OBS_1 = new Obs(
        null, null, PATIENT_ID_1, null,
        ConceptUuids.ADMISSION_DATETIME_UUID, Datatype.DATETIME,
        new DateTime(1568091838123L), null, "1546308184789", ""
    );

    private PatientChartController mController;

    @Mock private AppModel mMockAppModel;
    @Mock private AppSettings mMockSettings;
    @Mock private PatientChartController.Ui mMockUi;
    @Mock private OdkResultSender mMockOdkResultSender;
    @Mock private ChartDataHelper mMockChartHelper;
    @Mock private SyncManager mMockSyncManager;
    private FakeEventBus mFakeCrudEventBus;
    private FakeEventBus mFakeGlobalEventBus;
    private FakeHandler mFakeHandler;
    private Chart mFakeChart = new Chart("Test Chart");


    /** Tests that suspend() unregisters from the event bus. */
    @Test
    @UiThreadTest
    public void testSuspend_UnregistersFromEventBus() {
        // GIVEN an initialized controller
        mController.init();
        // WHEN the controller is suspended
        mController.suspend();
        // THEN the controller unregisters from the event bus
        assertEquals(0, mFakeCrudEventBus.countRegisteredReceivers());
    }

    /** Tests that init() requests a single patient from the app model. */
    @Test
    @UiThreadTest
    public void testInit_RequestsPatientDetails() {
        // WHEN the controller is inited
        mController.init();
        // THEN it requests that patient's details be fetched
        mMockAppModel.loadSinglePatient(mFakeCrudEventBus, PATIENT_UUID_1);
    }

    /** Tests that observations are updated in the UI when patient details fetched. */
    @Test
    @UiThreadTest
    public void testPatientDetailsLoaded_SetsObservationsOnUi() {
        // GIVEN the observations provider is set up to return some dummy data
        List<Obs> allObservations =
            ImmutableList.of(OBS_1);
        Map<String, Obs> recentObservations =
            ImmutableMap.of(OBS_1.conceptUuid, OBS_1);
        when(mMockChartHelper.getObservations(PATIENT_UUID_1))
            .thenReturn(allObservations);
        when(mMockChartHelper.getLatestObservations(PATIENT_UUID_1))
            .thenReturn(recentObservations);
        // GIVEN controller is initialized
        mController.init();
        // WHEN that patient's details are loaded
        mFakeCrudEventBus.post(new ItemLoadedEvent<>(PATIENT));
        // TODO: When the handler UI updating hack in PatientChartController is removed, this can
        // also be removed.
        mFakeHandler.runUntilEmpty();
        // THEN the controller puts observations on the UI
        verify(mMockUi).updateTilesAndGrid(
                mFakeChart, recentObservations, allObservations, ImmutableList.of());
    }

    /** Tests that the UI is given updated patient data when patient data is fetched. */
    @Test
    @UiThreadTest
    public void testPatientDetailsLoaded_UpdatesUi() {
        // GIVEN controller is initialized
        mController.init();
        // WHEN that patient's details are loaded
        mFakeCrudEventBus.post(new ItemLoadedEvent<>(PATIENT));
        // THEN the controller updates the UI
        verify(mMockUi).updatePatientDetailsUi(PATIENT);
    }

    /** Tests that selecting a form from the menu shows loading dialog. */
    @Test
    @UiThreadTest
    public void testOpenForm_showsLoadingDialog() {
        // GIVEN controller is initialized
        mController.init();
        // WHEN a vital is pressed
        mController.onFormRequested("foo");
        // THEN the controller displays the loading dialog
        verify(mMockUi).showFormLoadingDialog(true);
    }

    /** Tests that the xform can be fetched again if the first fetch fails. */
    @Test
    @UiThreadTest
    public void testXformLoadFailed_ReenablesXformFetch() {
        // GIVEN controller is initialized
        mController.init();
        // WHEN an xform request fails
        mFakeGlobalEventBus.post(new FetchXformFailedEvent(FetchXformFailedEvent.Reason.UNKNOWN));
//        verify(mMockUi).reEnableFetch();
    }

    /** Tests that an error message is displayed when the xform fails to load. */
    @Test
    @UiThreadTest
    public void testXformLoadFailed_ShowsError() {
        // GIVEN controller is initialized
        mController.init();
        // WHEN an xform request fails
        mFakeGlobalEventBus.post(new FetchXformFailedEvent(FetchXformFailedEvent.Reason.UNKNOWN));
        // THEN the controller displays an error message
        verify(mMockUi).showError(R.string.fetch_xform_failed_unknown_reason);
    }

    /** Tests that a failed xform fetch hides the loading dialog. */
    @Test
    @UiThreadTest
    public void testXformLoadFailed_HidesLoadingDialog() {
        // GIVEN controller is initialized
        mController.init();
        // WHEN an xform request fails
        mFakeGlobalEventBus.post(new FetchXformFailedEvent(FetchXformFailedEvent.Reason.UNKNOWN));
        // THEN the controller hides the loading dialog
        verify(mMockUi).showFormLoadingDialog(false);
    }

    /** Tests that the xform can be fetched again if the first fetch succeeds. */
    @Test
    @UiThreadTest
    public void testXformLoadSucceeded_ReenablesXformFetch() {
        // GIVEN controller is initialized
        mController.init();
        // WHEN an xform request succeeds
        mFakeGlobalEventBus.post(new FetchXformSucceededEvent());
        // THEN the controller re-enables xform fetch
//        verify(mMockUi).reEnableFetch();
    }

    /** Tests that a successful xform fetch hides the loading dialog. */
    @Test
    @UiThreadTest
    public void testXformLoadSucceeded_HidesLoadingDialog() {
        // GIVEN controller is initialized
        mController.init();
        // WHEN an xform request succeeds
        mFakeGlobalEventBus.post(new FetchXformSucceededEvent());
        // THEN the controller hides the loading dialog
        verify(mMockUi).showFormLoadingDialog(false);
    }

    /** Tests that errors in xform submission are reported to the user. */
    @Test
    @UiThreadTest
    public void testXformSubmitFailed_ShowsErrorMessage() {
        // GIVEN controller is initialized
        mController.init();
        // WHEN an xform fails to submit
        mFakeGlobalEventBus.post(new SubmitXformFailedEvent(SubmitXformFailedEvent.Reason.UNKNOWN));
        // THEN the controller shows an error
        verify(mMockUi).showError(R.string.submit_xform_failed_unknown_reason);
    }

    // TODO/completeness: Test that starting an xform submission shows the submission dialog.

    /** Tests that errors in xform submission hide the submission dialog. */
    @Test
    @UiThreadTest
    public void testXformSubmitFailed_HidesSubmissionDialog() {
        // GIVEN controller is initialized
        mController.init();
        // WHEN an xform fails to submit
        mFakeGlobalEventBus.post(new SubmitXformFailedEvent(SubmitXformFailedEvent.Reason.UNKNOWN));
        // THEN the controller hides the submission dialog
        verify(mMockUi).showFormSubmissionDialog(false);
    }

    /** Tests that successful xform submission hides the submission dialog. */
    @Test
    @UiThreadTest
    public void testXformSubmitSucceeded_EventuallyHidesSubmissionDialog() {
        // GIVEN controller is initialized
        mController.init();
        // WHEN an xform submits successfully
        mFakeGlobalEventBus.post(new SubmitXformSucceededEvent());
        // THEN the controller hides the submission dialog
        // TODO: When the handler UI updating hack in PatientChartController is removed, this can
        // also be removed.
        mFakeHandler.runUntilEmpty();
        verify(mMockUi).showFormSubmissionDialog(false);
    }

    @Before
    public void setup() {
        MockitoAnnotations.initMocks(this);
        List<Chart> charts = ImmutableList.of(mFakeChart);
        when(mMockChartHelper.getCharts(AppSettings.APP_DEFAULT_LOCALE)).thenReturn(charts);

        mFakeCrudEventBus = new FakeEventBus();
        mFakeGlobalEventBus = new FakeEventBus();
        mFakeHandler = new FakeHandler();
        when(mMockSettings.getLocale()).thenReturn(new Locale("en"));
        mController = new PatientChartController(
            mFakeGlobalEventBus,
            mFakeCrudEventBus,
            mMockUi,
            PATIENT_UUID_1,
            mMockOdkResultSender,
            mMockChartHelper,
            mFakeHandler);
    }

    private final class FakeHandler implements MinimalHandler {
        private final ArrayDeque<Runnable> mTasks = new ArrayDeque<>();

        @Override public void post(Runnable runnable) {
            mTasks.add(runnable);
        }

        public void runUntilEmpty() {
            while (!mTasks.isEmpty()) {
                Runnable runnable = mTasks.pop();
                runnable.run();
            }
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.chart;

import android.support.test.annotation.UiThreadTest;
import android.support.test.runner.AndroidJUnit4;

import androidx.test.filters.SmallTest;

import com.mitchellbosecke.pebble.extension.Filter;

import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.joda.time.Instant;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.HashMap;
import java.util.Map;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.is;

/** Test cases for {@link PebbleExtension}. */
@RunWith(AndroidJUnit4.class)
@SmallTest
public class PebbleExtensionTest   {

    private DateTime mNowGMT;
    private Instant mNowUTC;
    private Map<String, Object> mArgs;
    private static final String TIME_FORMAT = "HH:mm";

    @Test
    @UiThreadTest
    public void testFormatTimeFilter_mustReturnTimeFormattedInDefaultTimeZone() throws Exception {
        mArgs.put("pattern", TIME_FORMAT);
        Filter filter = new  PebbleExtension.FormatTimeFilter();

        String result = (String) filter.apply(mNowUTC, mArgs);

        assertThat(result, is(equalTo("12:00")));
    }

    @Before
    public void setup() {

        mArgs = new HashMap<>();
        mNowGMT = new DateTime("2000-01-01T12:00", DateTimeZone.getDefault());
        mNowUTC = new Instant(mNowGMT);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.dialogs;

import android.support.annotation.IdRes;
import android.support.test.annotation.UiThreadTest;
import android.support.test.runner.AndroidJUnit4;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.projectbuendia.client.R;
import org.projectbuendia.client.ui.FunctionalTestCase;
import org.projectbuendia.client.ui.chart.PatientChartActivity;

import androidx.test.filters.SmallTest;

import static junit.framework.TestCase.assertTrue;

/** Tests for adding a new patient. */
@RunWith(AndroidJUnit4.class)
@SmallTest
public class PatientDialogFragmentTest extends FunctionalTestCase {

    /**
     * Tests adding a new patient;
     * Tests initial location of the patient;
     * Test symptom date;
     * Test last observation date;
     * Test admission date;
     * Tests adding a location to the patient;
     */
    @Test
    @UiThreadTest
    public void testNewPatient() {
        // Create the patient
        String id = inUserLoginGoToDemoPatientChart();

        waitUntilVisible(viewThat(hasTextContaining("Triage")));

        waitFor(viewThat(containsElementMatchingSelectorWithText(
            ".tile.concept-162622 .value", "Day 1")));

        // The symptom onset date should not be assigned a default value.
        waitFor(viewThat(containsElementMatchingSelectorWithText(
            ".tile.concept-1730 .value", "")));

        // Assign a location to the patient
        clickElementMatchingSelector(".tile.location");
        screenshot("After Location Dialog Shown");
        click(viewWithText(LOCATION_NAME));
        screenshot("After Location Selected");

        waitUntilVisible(viewThat(hasTextContaining(LOCATION_NAME)));
    }

    @Test
    @UiThreadTest
    public void testPatientCreation() throws Throwable {
        inUserLoginGoToPatientCreation();
        screenshot("Test Start");
        String id = generateId();
        // Populate the patient info
        screenshot("Before Patient Populated");
        String given = "Giv" + id.substring(id.length() - 2);
        String family = "Fam" + id.substring(id.length() - 4, id.length() - 2);
        type(id, viewWithId(R.id.patient_id));
        type(given, viewWithId(R.id.patient_given_name));
        type(family, viewWithId(R.id.patient_family_name));
        type(4, viewWithId(R.id.patient_age_years));
        type(2, viewWithId(R.id.patient_age_months));
        boolean female = Integer.parseInt(id) % 2 == 0;
        @IdRes int sexButton = female ? R.id.patient_sex_female : R.id.patient_sex_male;
        click(viewWithId(sexButton));
        screenshot("After Patient Populated");
        click(viewWithText("OK"));
        waitForProgressFragment();
        screenshot("On Patient Chart");

        // Make sure we're on a PatientChartActivity
        // TODO(sdspikes): shouldn't this already be on ui thread because of @UiThreadTest annotation?
        runOnUiThread(() -> {
            try {
                assertTrue("Expected PatientChartActivity, got something else",
                        getCurrentActivity() instanceof PatientChartActivity);
            } catch (Throwable throwable) {
                throwable.printStackTrace();
            }
        });

        // Now read off the patient info and check that it's all there.
        // It should all be in the action bar.
        expectVisible(viewThat(hasTextContaining(id + ".")));
        expectVisible(viewThat(hasTextContaining(given)));
        expectVisible(viewThat(hasTextContaining(family)));
        if (female) {
            expectVisible(viewThat(hasTextContaining("F,")));
        } else {
            expectVisible(viewThat(hasTextContaining("M,")));
        }
        expectVisible(viewThat(hasTextContaining((4 * 12 + 2) + " mo")));
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.matchers;

import android.support.test.espresso.matcher.BoundedMatcher;

import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.projectbuendia.models.Patient;
import org.projectbuendia.models.PatientDelta;

/** Matchers for {@link Patient} objects. */
public class AppPatientMatchers {
    /**
     * Provides a {@link Matcher} that matches any patient with the given patient id.
     * @param id the id to match
     */
    public static Matcher<Object> isPatientWithId(final String id) {
        return new BoundedMatcher<Object, Patient>(Patient.class) {
            @Override public void describeTo(Description description) {
                description.appendText("is an Patient with id " + id);
            }

            @Override public boolean matchesSafely(Patient patient) {
                return id.equals(patient.id);
            }
        };
    }

    /**
     * Matches {@link PatientDelta} objects based on their JSON representations. It is assumed
     * that these JSON representations are stable and include all relevant fields, so two
     * {@link PatientDelta} objects with the same JSON representation should represent the
     * same patient.
     */
    public static Matcher<PatientDelta> matchesPatientDelta(final PatientDelta other) {
        return new BoundedMatcher<PatientDelta, PatientDelta>(PatientDelta.class) {
            @Override public void describeTo(Description description) {
                description.appendText("matches patientDelta: " + other.toString());
            }

            @Override public boolean matchesSafely(PatientDelta patientDelta) {
                return other.toString().equals(patientDelta.toString());
            }
        };
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.matchers;

import android.app.Activity;
import android.graphics.drawable.Drawable;
import android.os.SystemClock;
import android.support.test.InstrumentationRegistry;
import android.support.test.espresso.DataInteraction;
import android.support.test.espresso.Espresso;
import android.support.test.espresso.UiController;
import android.support.test.espresso.ViewAction;
import android.support.test.espresso.ViewInteraction;
import android.support.test.espresso.action.GeneralClickAction;
import android.support.test.espresso.action.GeneralLocation;
import android.support.test.espresso.action.Press;
import android.support.test.espresso.action.Tap;
import android.support.test.espresso.action.ViewActions;
import android.support.test.espresso.matcher.ViewMatchers;
import android.support.test.espresso.web.assertion.WebAssertion;
import android.support.test.espresso.web.model.Atom;
import android.support.test.espresso.web.model.ElementReference;
import android.support.test.rule.ActivityTestRule;
import android.view.View;
import android.webkit.ValueCallback;
import android.webkit.WebView;
import android.widget.Checkable;

import com.estimote.sdk.internal.Preconditions;
import com.google.common.base.Joiner;

import org.hamcrest.BaseMatcher;
import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.hamcrest.Matchers;
import org.hamcrest.StringDescription;
import org.hamcrest.TypeSafeMatcher;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.text.MessageFormat;

import static android.support.test.espresso.Espresso.pressBack;
import static android.support.test.espresso.assertion.ViewAssertions.matches;
import static android.support.test.espresso.web.sugar.Web.onWebView;
import static android.support.test.espresso.web.webdriver.DriverAtoms.webClick;
import static org.hamcrest.Matchers.allOf;
import static org.projectbuendia.client.utils.Utils.eq;

/** Matchers for {@link View}s. */
public class TestCaseWithMatcherMethods<T extends Activity> extends ActivityTestRule<T> {
    private static Logger LOG = Logger.create();

    public TestCaseWithMatcherMethods(Class<T> startingActivity) {
        super(startingActivity, true, true);
    }

    // More concise ways of expressing common constructions like
    // onView(hasId(...)), onView(...).check(matches(...)), onView(...).perform(...).

    public static ViewInteraction viewWithId(int id) {
        return Espresso.onView(hasId(id));
    }

    public static Matcher<View> hasId(int id) {
        return new MatcherWithDescription<>(ViewMatchers.withId(id), "has ID " + id);
    }

    public static ViewInteraction viewWithText(Object obj) {
        return Espresso.onView(hasText(obj));
    }

    public static ViewInteraction viewContainingText(String text) {
        return Espresso.onView(hasTextContaining(text));
    }

    public static ViewInteraction viewMatchingRegex(String regex) {
        return Espresso.onView(hasTextMatchingRegex(regex));
    }

    public static ViewInteraction firstViewWithText(Object obj) {
        return firstViewThat(hasText(obj));
    }

    public static ViewInteraction firstViewContainingText(String text) {
        return firstViewThat(hasTextContaining(text));
    }

    public static Matcher<View> hasText(Object obj) {
        String text = "" + obj;
        return new MatcherWithDescription<>(ViewMatchers.withText(text),
            "has the exact text \"" + quote(text) + "\"");
    }

    public static ViewInteraction viewWithTextString(int resourceId) {
        return Espresso.onView(hasTextString(resourceId));
    }

    public static Matcher<View> hasTextString(int resourceId) {
        return new MatcherWithDescription<>(ViewMatchers.withText(resourceId),
            "has string resource " + resourceId + " as its text");
    }

    public static ViewInteraction firstViewThat(Matcher<View>... matchers) {
        final Matcher matcher = combinedMatcher(matchers);
        return Espresso.onView(new TypeSafeMatcher<View>() {
            int currentIndex = 0;
            View foundView = null;

            @Override
            public void describeTo(Description description) {
                description.appendText("is the first match that ");
                matcher.describeTo(description);
            }

            @Override
            public boolean matchesSafely(View view) {
                if (view == foundView || matcher.matches(view)) {
                    if (foundView == null) foundView = view;
                }
                return (view == foundView);
            }
        });
    }

    @SafeVarargs public static ViewInteraction viewThat(Matcher<View>... matchers) {
        return Espresso.onView(combinedMatcher(matchers));
    }

    public View getViewThat(Matcher<View>... matchers) {
        final View[] holder = {null};
        Matcher capturer = new TypeSafeMatcher<View>() {
            @Override protected boolean matchesSafely(View item) {
                holder[0] = item;
                return true;
            }
            @Override public void describeTo(Description description) { }
        };
        waitUntilVisible(viewThat(combinedMatcher(matchers), capturer));
        return holder[0];
    }

    public static DataInteraction dataThat(Matcher... matchers) {
        return Espresso.onData(matchers.length > 1 ? allOf(matchers) : matchers[0]);
    }

    @SafeVarargs public static void expect(ViewInteraction vi, Matcher<View>... matchers) {
        Matcher matcher = combinedMatcher(matchers);
        vi.check(matches(matcher));
        LOG.i("Found expected view that " + StringDescription.asString(matcher));
    }

    @SafeVarargs public static void expect(DataInteraction di, Matcher<View>... matchers) {
        di.check(matches(combinedMatcher(matchers)));
    }

    public static Matcher<View> combinedMatcher(Matcher<View>... matchers) {
        return matchers.length == 0 ? exists() :
            matchers.length > 1 ? allOf(matchers) : matchers[0];
    }

    public static Matcher<View> exists() {
        return new TypeSafeMatcher<View>() {
            @Override public void describeTo(Description description) {
                description.appendText("exists");
            }

            @Override public boolean matchesSafely(View view) {
                return view != null;
            }
        };
    }

    public static void expectVisible(ViewInteraction vi) {
        expect(vi, isVisible());
    }

    public static void expectVisible(DataInteraction di) {
        expect(di, isVisible());
    }

    public static Matcher<View> isVisible() {
        return new MatcherWithDescription<>(ViewMatchers.isDisplayed(), "is visible");
    }

    public static void click(DataInteraction di) {
        di.perform(ViewActions.click());
    }

    public static void openActionBarOptionsMenu() {
        Espresso.openActionBarOverflowOrOptionsMenu(InstrumentationRegistry.getTargetContext());
    }

    public static void optionallyScrollTo(ViewInteraction vi) {
        try {
            vi.perform(ViewActions.scrollTo());
        } catch (RuntimeException e) {
            /* if scrolling isn't possible, proceed anyway */
        }
    }

    public static void click(ViewInteraction vi) {
        optionallyScrollTo(vi);
        vi.perform(ViewActions.click());
    }

    public static void clickIfUnchecked(ViewInteraction vi) {
        optionallyScrollTo(vi);
        vi.perform(clickIfUncheckedAction());
    }

    public static void act(ViewInteraction vi, ViewAction action) {
        vi.perform(action);
    }

    public static void type(Object obj, ViewInteraction vi) {
        waitFor(vi);
        optionallyScrollTo(vi);
        vi.perform(ViewActions.typeText(obj.toString()));
    }

    public static void clearAndType(Object obj, ViewInteraction vi) {
        waitFor(vi);
        vi.perform(ViewActions.clearText()).perform(ViewActions.typeText(obj.toString()));
    }

    public static void expect(int id) {
        expect(viewWithId(id));
    }

    public static void expect(String text) {
        expect(firstViewWithText(text));
    }

    public static void expectRegex(String regex) {
        expect(firstViewThat(hasTextMatchingRegex(regex)));
    }

    public static void click(int id) {
        click(viewWithId(id));
    }

    public static void click(String text) {
        click(firstViewWithText(text));
    }

    public static void type(Object obj, int id) {
        type(obj, viewWithId(id));
    }

    public static void clearAndType(Object obj, int id) {
        clearAndType(obj, viewWithId(id));
    }

    public static void act(int id, ViewAction action) {
        act(viewWithId(id), action);
    }

    public static void act(String text, ViewAction action) {
        act(firstViewWithText(text), action);
    }

    public static void expect(Atom<ElementReference> atom) {
        onWebView().check(elementExists(atom));
    }

    public static WebAssertion<ElementReference> elementExists(Atom<ElementReference> atom) {
        return new WebAssertion<ElementReference>(atom) {
            @Override public void checkResult(WebView view, ElementReference result) {
                ViewMatchers.assertThat(result, new BaseMatcher<ElementReference>() {
                    @Override public void describeTo(Description description) {
                        description.appendText("exists");
                    }

                    @Override public boolean matches(Object item) {
                        return item != null;
                    }
                });
            }
        };
    }

    public static void click(Atom<ElementReference> atom) {
        onWebView().withElement(atom).perform(webClick());
    }

    // Matchers with better descriptions than those in espresso.matcher.ViewMatchers.

    public static void scrollToAndExpectVisible(ViewInteraction vi) {
        optionallyScrollTo(vi);
        vi.check(matches(isVisible()));
    }

    public static Matcher<View> isA(final Class<? extends View> cls) {
        String name = cls.getSimpleName();
        return new MatcherWithDescription<>(
            ViewMatchers.isAssignableFrom(cls),
            (name.matches("^[AEIOU]") ? "is an " : "is a ") + quote(name));
    }

    // Names of Espresso matchers form expressions that don't make any grammatical sense,
    // such as withParent(withSibling(isVisible())).  Instead of prepositional
    // phrases like "withFoo", matcher names should be verb phrases like "hasFoo" or
    // connecting verb phrases ending in "That", yielding more readable expressions
    // such as whoseParent(hasSiblingThat(isVisible())).

    public static Matcher<View> isAnyOf(final Class<? extends View>... classes) {
        Preconditions.checkArgument(classes.length >= 1);
        return new TypeSafeMatcher<View>() {
            @Override public boolean matchesSafely(View obj) {
                for (Class cls : classes) {
                    if (cls.isInstance(obj)) return true;
                }
                return false;
            }

            @Override public void describeTo(Description description) {
                String[] names = new String[classes.length];
                for (int i = 0; i < classes.length; i++) {
                    names[i] = classes[i].getSimpleName();
                }
                String list = Joiner.on(", ").join(names);
                if (names.length == 2) {
                    list = list.replace(", ", " or ");
                } else if (names.length > 2) {
                    list = list.replaceAll(", ([^,]*)$", ", or $1");
                }
                description.appendText(
                    (names[0].matches("^[AEIOU]") ? "is an " : "is a ") + list);
            }
        };
    }

    @SafeVarargs
    public static Matcher<View> whoseParent(Matcher<View>... matchers) {
        Matcher<View> matcher = matchers.length > 1 ? allOf(matchers) : matchers[0];
        return new MatcherWithDescription<>(ViewMatchers.withParent(matcher),
            "whose parent {0}", matcher);
    }

    @SafeVarargs
    public static Matcher<View> hasChildThat(Matcher<View>... matchers) {
        Matcher<View> matcher = matchers.length > 1 ? allOf(matchers) : matchers[0];
        return new MatcherWithDescription<>(ViewMatchers.withChild(matcher),
            "has a child that {0}", matcher);
    }

    @SafeVarargs
    public static Matcher<View> hasAncestorThat(Matcher<View>... matchers) {
        Matcher<View> matcher = matchers.length > 1 ? allOf(matchers) : matchers[0];
        return new MatcherWithDescription<>(ViewMatchers.isDescendantOfA(matcher),
            "has an ancestor that {0}", matcher);
    }

    @SafeVarargs
    public static Matcher<View> hasDescendantThat(Matcher<View>... matchers) {
        Matcher<View> matcher = matchers.length > 1 ? allOf(matchers) : matchers[0];
        return new MatcherWithDescription<>(ViewMatchers.hasDescendant(matcher),
            "has a descendant that {0}", matcher);
    }

    @SafeVarargs
    public static Matcher<View> hasSiblingThat(Matcher<View>... matchers) {
        Matcher<View> matcher = matchers.length > 1 ? allOf(matchers) : matchers[0];
        return new MatcherWithDescription<>(ViewMatchers.hasSibling(matcher),
            "has a sibling that {0}", matcher);
    }

    public static Matcher<View> isChecked() {
        return new MatcherWithDescription<>(ViewMatchers.isChecked(), "is checked");
    }

    public static Matcher<View> isNotChecked() {
        return new MatcherWithDescription<>(ViewMatchers.isNotChecked(), "is unchecked");
    }

    @SafeVarargs
    public static Matcher<View> hasText(Matcher<String>... matchers) {
        Matcher<String> matcher = matchers.length > 1 ? allOf(matchers) : matchers[0];
        return new MatcherWithDescription<>(ViewMatchers.withText(matcher),
            "has text {0}", matcher);
    }

    public static Matcher<View> hasTextContaining(String text) {
        return new MatcherWithDescription<>(ViewMatchers.withText(Matchers.containsString(text)),
            "has text containing \"" + quote(text) + "\"");
    }

    public static Matcher<View> hasTextMatchingRegex(String regex) {
        return new MatcherWithDescription<>(
            ViewMatchers.withText(StringMatchers.matchesRegex(regex)),
            "has text matching regex /" + quote(regex) + "/");
    }

    public static Matcher<View> isAtLeastNPercentVisible(int percentage) {
        return new MatcherWithDescription<>(ViewMatchers.isDisplayingAtLeast(percentage),
            "is at least " + percentage + "% visible");
    }

    /** Matcher that matches any view in the given row, assuming all rows have the specified height. */
    public static TypeSafeMatcher<View> isInRow(final int rowNumber, final int rowHeight) {
        return new TypeSafeMatcher<View>() {
            @Override public boolean matchesSafely(View view) {
                return view.getY() >= getMinY() && view.getY() < getMaxY();
            }

            private int getMaxY() {
                return (rowNumber + 1)*rowHeight;
            }

            private int getMinY() {
                return rowNumber*rowHeight;
            }

            @Override public void describeTo(Description description) {
                description.appendText("has " + getMinY() + " <= y < " + getMaxY());
            }
        };
    }

    /** Matcher that matches any view in the given column, assuming all columns have the specified with. */
    public static TypeSafeMatcher<View> isInColumn(final int colNumber, final int colWidth) {
        return new TypeSafeMatcher<View>() {
            @Override public boolean matchesSafely(View view) {
                return view.getX() >= getMinX() && view.getX() < getMaxX();
            }

            private int getMaxX() {
                return (colNumber + 1)*colWidth;
            }

            private int getMinX() {
                return colNumber*colWidth;
            }

            @Override public void describeTo(Description description) {
                description.appendText("has " + getMinX() + " <= x < " + getMaxX());
            }
        };
    }

    /** Matcher that matches any view with the given background drawable. */
    public static TypeSafeMatcher<View> hasBackground(final Drawable background) {
        return new TypeSafeMatcher<View>() {
            @Override public boolean matchesSafely(View view) {
                return background != null && view.getBackground() != null &&
                    background.getConstantState().equals(
                        view.getBackground().getConstantState());
            }

            @Override public void describeTo(Description description) {
                description.appendText("has background " + background.toString());
            }
        };
    }

    /** Matcher that matches a view with the background drawable specified by ID. */
    public static TypeSafeMatcher<View> hasBackground(final int resourceId) {
        return new TypeSafeMatcher<View>() {
            @Override public boolean matchesSafely(View view) {
                Drawable background = view.getResources().getDrawable(resourceId);
                return background != null && view.getBackground() != null &&
                    background.getConstantState().equals(
                        view.getBackground().getConstantState());
            }

            @Override public void describeTo(Description description) {
                description.appendText("has drawable resource " + resourceId + " as its background");
            }
        };
    }

    protected static ViewInteraction waitFor(int id) {
        return waitForViewThat(hasId(id));
    }

    protected static ViewInteraction waitFor(String text) {
        return waitForViewThat(hasText(text));
    }

    protected static ViewInteraction waitForViewThat(Matcher<View>... matchers) {
        Matcher matcher = combinedMatcher(matchers);
        LOG.i("Waiting for view that " + StringDescription.asString(matcher));
        ViewInteraction vi = firstViewThat(matcher);
        waitUntil(vi, exists());
        return vi;
    }

    protected static ViewInteraction waitFor(ViewInteraction vi) {
        waitUntil(vi, exists());
        return vi;
    }

    protected static ViewInteraction waitUntil(ViewInteraction vi, Matcher<View>... matchers) {
        return waitUntil(30000, vi, matchers);
    }

    protected static ViewInteraction waitUntilVisible(ViewInteraction vi) {
        return waitUntilVisible(30000, vi);
    }

    protected static ViewInteraction waitUntilVisible(int timeoutMs, ViewInteraction vi) {
        return waitUntil(timeoutMs, vi, isVisible());
    }

    protected static ViewInteraction waitUntil(int timeoutMs, ViewInteraction vi, Matcher<View>... matchers) {
        Matcher matcher = combinedMatcher(matchers);
        String description = StringDescription.asString(matcher);
        long deadline = System.currentTimeMillis() + timeoutMs;
        while (true) {
            try {
                LOG.i("Waiting for view that " + description);
                expect(vi, matcher);
                return vi;
            } catch (Throwable t) {
                if (System.currentTimeMillis() > deadline) throw t;
            }
            LOG.i("Could not find view that " + description + ", retrying in 100 ms");
            sleep(100);
        }
    }

    public static void back() {
        pressBack();
        sleep(500);
    }

    public static void sleep(int millis) {
        SystemClock.sleep(millis);
    }

    /** Replaces the description of an existing matcher. */
    static class MatcherWithDescription<T> extends TypeSafeMatcher<T> {
        Matcher mMatcher;
        String mFormat;
        Matcher[] mArgMatchers;

        public MatcherWithDescription(Matcher<T> matcher, String format, Matcher... argMatchers) {
            mMatcher = matcher;
            mFormat = format;
            mArgMatchers = argMatchers;
        }

        public boolean matchesSafely(T obj) {
            return mMatcher.matches(obj);
        }

        public void describeTo(Description description) {
            Object[] args = new String[mArgMatchers.length];
            for (int i = 0; i < mArgMatchers.length; i++) {
                StringDescription argDescription = new StringDescription();
                mArgMatchers[i].describeTo(argDescription);
                args[i] = argDescription.toString();
            }
            description.appendText(MessageFormat.format(mFormat, args));
        }
    }

    /** Quotes a string for use in a MessageFormat. */
    private static String quote(String text) {
        if (Utils.isEmpty(text)) return "";
        return "'" + text.replaceAll("'", "''") + "'";
    }

    /** Clicks a checkbox only if it is currently unchecked. */
    static ViewAction clickIfUncheckedAction() {
        return new ViewAction() {
            @Override public BaseMatcher<View> getConstraints() {
                return new BaseMatcher<View>() {
                    @Override public boolean matches(Object item) {
                        return Matchers.isA(Checkable.class).matches(item); }

                    @Override public void describeMismatch(Object item, Description description) { }

                    @Override public void describeTo(Description description) { }
                };
            }

            @Override public String getDescription() {
                return null;
            }

            @Override public void perform(UiController uiController, View view) {
                Checkable checkableView = (Checkable) view;
                if (!checkableView.isChecked()) {
                    new GeneralClickAction(Tap.SINGLE, GeneralLocation.VISIBLE_CENTER, Press.FINGER)
                        .perform(uiController, view);
                }
            }
        };
    }

    /** This matcher is designed only to be used repeatedly in a waitFor() call. */
    protected Matcher<View> containsElementMatchingSelector(String selector) {
        return new TypeSafeMatcher<View>() {
            private View matchedView = null;

            @Override protected boolean matchesSafely(View view) {
                if (view == matchedView) return true;
                LOG.i("Looking for element matching %s", Utils.repr(selector));
                evalJs(view, "document.querySelector(" + jsQuote(selector) + ")", result -> {
                    if (!eq(result, "null")) {
                        matchedView = view;
                        LOG.i("Found element matching %s", Utils.repr(selector));
                    }
                });
                return false;
            }

            @Override public void describeTo(Description description) {
                description.appendText(
                    "is a WebView containing an element matching the selector " + Utils.repr(selector));
            }
        };
    }

    protected void clickElementMatchingSelector(String selector) {
        waitFor(viewThat(containsElementMatchingSelector(selector))).perform(new ViewAction() {
            @Override public String getDescription() {
                return "click element matching selector " + Utils.repr(selector);
            }

            @Override public Matcher<View> getConstraints() {
                return isA(WebView.class);
            }

            @Override public void perform(UiController controller, View view) {
                LOG.i("Clicking element matching %s", Utils.repr(selector));
                evalJs(view, "var e = document.querySelector(" + jsQuote(selector) + "); " +
                    "e.dispatchEvent(new Event('touchstart')); e.click()", null);
            }
        });
    }

    /** This matcher is designed only to be used repeatedly in a waitFor() call. */
    protected Matcher<View> containsElementMatchingSelectorWithText(String selector, String text) {
        return new TypeSafeMatcher<View>() {
            private View matchedView = null;

            @Override protected boolean matchesSafely(View view) {
                if (view == matchedView) return true;
                LOG.i("Looking for element matching %s with text %s", Utils.repr(selector), Utils.repr(text));
                evalJs(view, "(document.querySelector(" + jsQuote(selector) + ") || {}).textContent", result -> {
                    if (eq(result, '"' + text + '"')) {
                        matchedView = view;
                        LOG.i("Found element matching %s with text %s", Utils.repr(selector), Utils.repr(text));
                    }
                });
                return false;
            }

            @Override public void describeTo(Description description) {
                description.appendText(
                    "is a WebView containing an element matching the selector " +
                        Utils.repr(selector) + " that has text " + Utils.repr(text));
            }
        };
    }

    /** This matcher is designed only to be used repeatedly in a waitFor() call. */
    protected Matcher<View> containsNoElementMatchingSelector(String selector) {
        return new TypeSafeMatcher<View>() {
            private View matchedView = null;

            @Override protected boolean matchesSafely(View view) {
                LOG.i("Waiting until no element matches %s", Utils.repr(selector));
                if (view == matchedView) return true;
                evalJs(view, "document.querySelector(" + jsQuote(selector) + ")", result -> {
                    if (eq(result, "null")) {
                        matchedView = view;
                        LOG.i("Confirmed that no matches for %s are present", Utils.repr(selector));
                    }
                });
                return false;
            }

            @Override public void describeTo(Description desc) {
                desc.appendText(
                    "is a WebView containing no element matching the selector " + Utils.repr(selector));
            }
        };
    }

    protected String getString(int id, Object... args) {
        return getActivity().getString(id, args);
    }

    private void evalJs(View view, String script, ValueCallback<String> callback) {
        if (view instanceof WebView) ((WebView) view).evaluateJavascript(script, callback);
    }

    private static String jsQuote(String str) {
        return '"' + str.replace("\\", "\\\\").replace("'", "\\'") + '"';
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.matchers;

import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.hamcrest.TypeSafeMatcher;

import java.util.regex.Pattern;

/** Matchers for matching {@link String} objects. */
public class StringMatchers {
    /**
     * Provides a {@link Matcher} that matches any String that matches the given regular expression.
     * @param regex the regular expression pattern to match
     */
    public static Matcher<String> matchesRegex(final String regex) {
        return new TypeSafeMatcher<String>() {
            @Override public void describeTo(Description description) {
                description.appendText("matches regex: " + regex);
            }

            @Override public boolean matchesSafely(String specimen) {
                return Pattern.matches(regex, specimen);
            }
        };
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.matchers;

import org.mockito.ArgumentMatcher;
import org.projectbuendia.client.filter.db.SimpleSelectionFilter;
import org.projectbuendia.client.filter.db.SimpleSelectionFilterGroup;
import org.projectbuendia.client.filter.db.patient.LocationUuidFilter;

import java.util.List;

/** Matchers for {@link SimpleSelectionFilter} objects and arrays. */
public class SimpleSelectionFilterMatchers {
    /** Matches any list of filters containing a filter with the specified name. */
    public static class ContainsFilterWithName implements ArgumentMatcher<List<SimpleSelectionFilter<?>>> {
        private String mFilterName;

        public ContainsFilterWithName(String filterName) {
            mFilterName = filterName;
        }

        /**
         * Matches any array of filters containing a filter with the specified name.
         * @param filters an array of {@link SimpleSelectionFilter}'s
         * @return true if the array contains a filter with the specified name
         */
        @Override
        public boolean matches(List<SimpleSelectionFilter<?>> filters) {
            for (SimpleSelectionFilter filter : filters) {
                if (filter.toString().equals(mFilterName)) {
                    return true;
                }
            }
            return false;
        }
    }

    /**
     * Matches any {@link SimpleSelectionFilter} that is or wraps (via a
     * {@link SimpleSelectionFilterGroup}) a {@link LocationUuidFilter} filtering by the specified
     * location UUID.
     */
    public static class IsFilterGroupWithLocationFilter
            implements ArgumentMatcher<SimpleSelectionFilter<?>> {
        private String mLocationUuid;

        public IsFilterGroupWithLocationFilter(String locationUuid) {
            mLocationUuid = locationUuid;
        }

        /**
         * Matches any {@link SimpleSelectionFilter} that is or wraps (via a
         * {@link SimpleSelectionFilterGroup}) a {@link LocationUuidFilter} filtering by the
         * specified location UUID.
         */
        public boolean matches(SimpleSelectionFilter filter) {
            if (isMatchingLocationFilter(filter)) {
                return true;
            }

            if (isMatchingFilterGroup(filter)) {
                return true;
            }

            return false;
        }

        private boolean isMatchingFilterGroup(SimpleSelectionFilter filter) {
            if (!(filter instanceof SimpleSelectionFilterGroup)) {
                return false;
            }

            List<SimpleSelectionFilter> filterList =
                ((SimpleSelectionFilterGroup) filter).getFilters();
            for (SimpleSelectionFilter internalFilter : filterList) {
                if (matches(internalFilter)) {
                    return true;
                }
            }

            return false;
        }

        private boolean isMatchingLocationFilter(SimpleSelectionFilter filter) {
            if (!(filter instanceof LocationUuidFilter)) {
                return false;
            }

            return ((LocationUuidFilter) filter).getFilterRootUuid().equals(mLocationUuid);
        }
    }

    private SimpleSelectionFilterMatchers() {
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.sync;

import android.support.test.espresso.Espresso;

import androidx.test.annotation.UiThreadTest;

import org.junit.Ignore;
import org.junit.Test;
import org.projectbuendia.client.R;
import org.projectbuendia.client.events.sync.SyncCancelledEvent;

import java.util.UUID;

/** Test case for behavior during and immediately after an initial sync. */
public class InitialSyncTest extends SyncTestCase {

    @Override public void setUp() throws Exception {
        super.setUp();
        click(viewWithText("Guest User"));
    }

    /** Expects zones and tents to appear within Espresso's idling period (60s). */
    @Test
    @UiThreadTest
    @Ignore
    public void testZonesAndTentsDisplayed() {
        screenshot("Before Sync Completed");
        waitForProgressFragment();
        try {
            Thread.sleep(5000);
        } catch (InterruptedException ignored) {
        }


        inLocationSelectionCheckZonesAndTentsDisplayed();
    }

    /** Tests that search functionality works right after initial sync. */
    @Test
    @UiThreadTest
    @Ignore
    // TODO(sdspikes): re-enable once there is a working waitForProgressFragment
    public void testSearchAfterSync() throws Throwable {
        screenshot("Before Sync Completed");

        waitForProgressFragment();
        screenshot("After Sync Completed");

        click(viewWithId(R.id.action_search));
        screenshot("After Search Clicked");

        // Check that at least one patient is returned (since clicking search
        // should show all patients).
        inPatientListClickFirstPatient(); // open patient chart
        screenshot("Final State");
    }

    /** Tests the behavior of the sync cancel button. */
    @Test
    @UiThreadTest
    @Ignore
    // TODO(sdspikes): should there be a cancel button on sync screen?
    public void testSyncCancelButton() {
        // Cancel the sync.
        EventBusIdlingResource<SyncCancelledEvent> syncCanceledResource =
            new EventBusIdlingResource<>(UUID.randomUUID().toString(), mEventBus);
        // There may be a slight delay before the cancel button appears.
        waitUntilVisible(viewWithId(R.id.cancel_action));
        click(viewWithId(R.id.cancel_action));
        Espresso.registerIdlingResources(syncCanceledResource);

        // Select guest user again -- give plenty of time for cancellation to occur since canceling
        // certain network operations can take an exceedingly long time.
        waitUntilVisible(90000, viewWithText("Guest User"));
        click(viewWithText("Guest User"));

        // The second sync should actually complete.
        waitForProgressFragment();
        waitUntilVisible(viewWithText("ALL PRESENT PATIENTS"));
        waitUntilVisible(viewWithText(LOCATION_NAME));
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.sync;

import android.support.test.annotation.UiThreadTest;

import org.junit.Ignore;
import org.junit.Test;
import org.projectbuendia.client.R;

import static android.support.test.espresso.Espresso.pressBack;

/** Test cases for handling when the initial sync fails on the location selection screen. */
public class LocationSelectionFailingSyncTest extends SyncTestCase {
    @Override public void setUp() throws Exception {
        super.setUp();

        click(viewWithText("Guest User"));
    }

    /** Tests that sync failure results in the sync failed dialog appearing. */
    @Test
    @UiThreadTest
    @Ignore
    public void testSyncFailedDialogAppearsWhenSyncFails() {
        setWifiEnabled(false);
        try (WifiDisabler wd = new WifiDisabler()) {
            waitForSyncFailure();

            waitUntilVisible(viewWithText(R.string.sync_failed_dialog_message));
            screenshot("After Sync Fails");

            expectVisible(viewWithText(R.string.sync_failed_settings));
            expectVisible(viewWithText(R.string.sync_failed_retry));
            click(viewWithText("Back"));
            screenshot("Test Finish");
        }
    }

    /** Tests that the back button in the sync failed dialog returns to user selection. */
    @Test
    @UiThreadTest
    @Ignore
    public void testSyncFailedDialog_backButtonReturnsToUserSelection() {
        try (WifiDisabler wd = new WifiDisabler()) {
            waitForSyncFailure();

            waitUntilVisible(viewWithText(R.string.sync_failed_dialog_message));

            click(viewWithText(R.string.sync_failed_back));
            screenshot("After Sync Fails");
            waitForProgressFragment(); // Wait for user screen to display.
            expectVisible(viewWithText("Guest User"));
            screenshot("Test Finish");
        }
    }

    /** Tests that clicking 'Settings' in sync failed dialog loads settings activity. */
    @Test
    @UiThreadTest
    @Ignore
    // TODO(sdspikes): Sync appears to successfully complete despite wifi being off, maybe due to data connection?
    public void testSyncFailedDialog_SettingsButtonLoadsSettings() {
        setWifiEnabled(false);
        waitForSyncFailure();

        waitUntilVisible(viewWithText(R.string.sync_failed_settings));
        screenshot("After Sync Fails");

        click(viewWithText(R.string.sync_failed_settings));
        screenshot("After Settings Clicked");

        expectVisible(viewWithText("Advanced"));
        click(viewWithText("Advanced"));

        expectVisible(viewWithText("OpenMRS base URL"));

        // Go back to user selection before cleaning up wifi, or a sync will start.
        pressBack();
        cleanupWifi();
    }

    /** Tests that clicking 'Retry' in sync failed dialog reshows the progress bar. */
    // TODO/robustness: This test is flaky because of a real bug -- Volley is
    // unresponsive to changes in connectivity state, so a sync may not fail
    // for seconds or even minutes after wifi is turned off.
    /*@UiThreadTest
    public void testSyncFailedDialog_RetryButtonRetainsProgressBar() {
        screenshot("Test Start");
        waitForSyncFailure();
        setWifiEnabled(false);

        expectVisibleSoon(viewWithText(R.string.sync_failed_retry));
        screenshot("After Sync Failed");

        click(viewWithText(R.string.sync_failed_retry));

        setWifiEnabled(true);
        Espresso.registerIdlingResources(new WifiStateIdlingResource());
        // Showing progress bar may be slow as the spinner may show while sync is still starting up.
        expectVisibleSoon(viewWithId(R.id.progress_fragment_progress_bar));
        screenshot("After Retry Clicked");
    }*/

    /** Tests that 'Retry' actually works if the the retried sync is successful. */
    @Test
    @UiThreadTest
    @Ignore
    // TODO(sdspikes): should there be a sync failed message?
    public void testSyncFailedDialog_RetryButtonActuallyRetries() {
        try (WifiDisabler wd = new WifiDisabler()) {
            waitForSyncFailure();

            waitUntilVisible(viewWithText(R.string.sync_failed_retry));
            screenshot("After Sync Failed");

            setWifiEnabled(true);
            click(viewWithText(R.string.sync_failed_retry));

            waitForInitialSync();
            waitForProgressFragment();
            screenshot("After Retry Clicked");

            // Should be at location selection screen with locations available.
            expectVisible(viewWithText("Triage"));
            expectVisible(viewWithText("Discharged"));

            screenshot("After Sync Completed");
        }
    }

    /**
     * Tests that clicking 'Settings' in sync failed dialog and returning to
     * this activity results in the progress bar still being shown.
     */
    // TODO/robustness: This test is flaky because of a real bug -- Volley is
    // unresponsive to changes in connectivity state, so a sync may not fail
    // for seconds or even minutes after wifi is turned off.
    /*@UiThreadTest
    public void testSyncFailedDialog_ReturningFromSettingsRetainsProgressBar() {
        setWifiEnabled(false);
        waitForSyncFailure();

        expectVisibleSoon(viewWithText(R.string.sync_failed_settings));
        screenshot("After Sync Failed");

        click(viewWithText(R.string.sync_failed_settings));
        screenshot("After Settings Clicked");

        setWifiEnabled(true);
        pressBack();
        expectVisibleSoon(viewWithId(R.id.progress_fragment_progress_bar));
        screenshot("After Back Pressed");

        cleanupWifi();
    }*/
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.sync;

import android.support.test.annotation.UiThreadTest;

import org.junit.After;
import org.junit.Test;
import org.projectbuendia.client.App;
import org.projectbuendia.client.R;

/** Test cases for handling user sync failure on the user login screen. */
public class UserLoginFailingSyncTest extends SyncTestCase {
    @Override public void setUp() throws Exception {
        setWaitForUserSync(false);
        // TODO/cleanup: Remove all this manual UserManager management once daggered.
        App.getUserManager().reset();
        // Force all user sync tasks to fail. If you need a sync task to pass,
        // remember to reset this to false!
        App.getUserManager().setAutoCancelEnabled(true);
        super.setUp();
    }

    @After
    public void tearDown() {
        App.getUserManager().setAutoCancelEnabled(false);
        super.tearDown();
    }

    /** Tests that sync failure results in the sync failed dialog appearing. */
    @Test
    @UiThreadTest
    public void testSyncFailedDialogAppearsWhenSyncFails() {
        screenshot("Test Start");
        expectVisible(viewWithText(R.string.user_sync_failed_dialog_message));
        App.getUserManager().setAutoCancelEnabled(false);
        screenshot("After Sync Fails");

        expectVisible(viewWithText(R.string.sync_failed_settings));
        expectVisible(viewWithText(R.string.sync_failed_retry));
        screenshot("Test Finish");
    }

    /** Tests that clicking 'Settings' in sync failed dialog loads settings activity. */
    @Test
    @UiThreadTest
    public void testSyncFailedDialog_SettingsButtonLoadsSettings() {
        screenshot("Test Start");
        expectVisible(viewWithText(R.string.sync_failed_settings));
        App.getUserManager().setAutoCancelEnabled(false);
        screenshot("After Sync Fails");

        click(viewWithText(R.string.sync_failed_settings));
        screenshot("After Settings Clicked");

        expectVisible(viewWithText(R.string.pref_title_server));
    }

    /** Tests that 'Retry' actually works if the the retried sync is successful. */
    @Test
    @UiThreadTest
    public void testSyncFailedDialog_RetryButtonActuallyRetries() {
        screenshot("Test Start");
        expectVisible(viewWithText(R.string.sync_failed_retry));
        App.getUserManager().setAutoCancelEnabled(false);
        screenshot("After Sync Failed");

        click(viewWithText(R.string.sync_failed_retry));

        waitForProgressFragment();
        screenshot("After Retry Clicked");

        // Should be at user selection screen with users available.
        expectVisible(firstViewWithText("GU"));

        screenshot("After Sync Completed");
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.sync;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.wifi.WifiManager;
import android.support.test.espresso.IdlingResource;

import org.projectbuendia.client.App;

import java.util.UUID;

/**
 * {@link IdlingResource} that is busy when wifi is disabled or disconnected.
 * <p/>
 * <p>Note: until tests are migrated to Espresso 2.0, this resource will be configured to idle
 * forever after its first idle transition, to maintain test isolation.
 */
public class WifiStateIdlingResource implements IdlingResource {

    // Because you can't unregister idling resources in Espresso 1.1, each WifiStateIdlingResource
    // needs to fire its state transition only once and then be idle forever. Once we switch to
    // Espresso 2.0, this is no longer necesssary.
    private static final boolean ONE_TIME_ONLY = true;
    private final WifiManager mWifiManager =
        (WifiManager) App.getInstance().getSystemService(Context.WIFI_SERVICE);
    private final ConnectivityManager mConnectivityManager =
        (ConnectivityManager) App.getInstance().getSystemService(Context.CONNECTIVITY_SERVICE);
    private final WifiChangeBroadcastReceiver mWifiStateChangedReceiver =
        new WifiChangeBroadcastReceiver();
    private final String mName = UUID.randomUUID().toString();
    private ResourceCallback mResourceCallback;
    private boolean mIdleTransitionOccurred = false;

    public WifiStateIdlingResource() {
        App.getInstance().registerReceiver(mWifiStateChangedReceiver, getIntentFilter());
    }

    private static IntentFilter getIntentFilter() {
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
        intentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);

        return intentFilter;
    }

    @Override public String getName() {
        return mName;
    }

    @Override public void registerIdleTransitionCallback(ResourceCallback resourceCallback) {
        mResourceCallback = resourceCallback;
        if (isIdleNow()) {
            onIdleTransition();
        }
    }

    @Override public boolean isIdleNow() {
        if (ONE_TIME_ONLY && mIdleTransitionOccurred) {
            return true;
        }

        int wifiState = mWifiManager.getWifiState();
        if (wifiState != WifiManager.WIFI_STATE_ENABLING
            && wifiState != WifiManager.WIFI_STATE_ENABLED) {
            return false;
        }
        NetworkInfo networkInfo = mConnectivityManager.getActiveNetworkInfo();
        return networkInfo != null && networkInfo.isConnected();
    }

    private void onIdleTransition() {
        if (!ONE_TIME_ONLY || !mIdleTransitionOccurred) {
            mIdleTransitionOccurred = true;
            if (ONE_TIME_ONLY) {
                App.getInstance().unregisterReceiver(mWifiStateChangedReceiver);
            }
            if (mResourceCallback != null) {
                mResourceCallback.onTransitionToIdle();
            }
        }
    }

    private class WifiChangeBroadcastReceiver extends BroadcastReceiver {
        @Override public void onReceive(Context context, Intent intent) {
            if (isIdleNow()) {
                onIdleTransition();
            }
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.sync;

import android.support.test.annotation.UiThreadTest;

import com.google.common.base.Optional;

import org.joda.time.LocalDate;
import org.junit.Test;
import org.projectbuendia.client.R;
import org.projectbuendia.models.Patient;
import org.projectbuendia.models.PatientDelta;
import org.projectbuendia.models.Sex;

import java.util.UUID;

import static android.support.test.espresso.matcher.ViewMatchers.withId;
import static org.hamcrest.Matchers.is;

/** Tests the loading of the encounter xform from the patient chart activity. */
public class PatientChartActivityXformSyncTest extends SyncTestCase {
    @Override public void setUp() throws Exception {
        super.setUp();

       // click(viewWithText("Guest User"));
    }

    /**
     * Tests that clicking the load xform button after a fresh sync causes the xform to
     * eventually load.
     */
    @Test
    @UiThreadTest
    public void testXformRetrievedFromServer() {
        /*
        loadChart();
        screenshot("Patient Chart");
        EventBusIdlingResource<FetchXformSucceededEvent> xformIdlingResource =
            new EventBusIdlingResource<FetchXformSucceededEvent>(
                UUID.randomUUID().toString(),
                mEventBus);
        click(viewWithId(R.id.action_update_chart));
        Espresso.registerIdlingResources(xformIdlingResource);
        // This check is known to be particularly flaky.
        expectVisibleWithin(45000, viewWithText("Encounter"));
        screenshot("Xform Loaded");
        click(viewWithText(R.string.form_entry_discard));
        */
    }

    private void loadChart() {
        waitForProgressFragment();
        // Open patient list.
        click(viewWithId(R.id.action_search));
        // waitForProgressFragment() doesn't quite work here as we're actually waiting on the
        // search button in the action bar to finish its loading task.
        waitUntilVisible(viewThat(hasTextContaining("Triage (")));
        // Click first patient.
        click(dataThat(is(Patient.class))
            .inAdapterView(withId(R.id.fragment_patient_list))
            .atPosition(0));
    }

    private PatientDelta getBasicDemoPatient() {
        PatientDelta newPatient = new PatientDelta();
        newPatient.familyName = Optional.of("XformSyncTest");
        newPatient.givenName = Optional.of("TestPatientFor");
        newPatient.sex = Optional.of(Sex.FEMALE);
        newPatient.id = Optional.of(UUID.randomUUID().toString().substring(30));
        newPatient.birthdate = Optional.of(LocalDate.now().minusYears(12).minusMonths(3));
        return newPatient;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.sync;

import android.support.test.espresso.IdlingResource;

import org.projectbuendia.client.utils.EventBusRegistrationInterface;
import org.projectbuendia.client.utils.Logger;

/**
 * An {@link IdlingResource} that is busy until one of an event of a particular type fires on an
 * {@link EventBusRegistrationInterface}. Once the event fires, this IdlingResource unregisters
 * from future events, since we only know that this resource is "busy" because an event signifying
 * completion hasn't fired. Once such an event has fired, we don't know when another async task may
 * have started.
 */
public class EventBusIdlingResource<T> implements IdlingResource {
    private static final Logger LOG = Logger.create();

    private final EventBusRegistrationInterface mEventBus;
    private final String mName;
    private final EventSubscriber mSubscriber = new EventSubscriber();
    private ResourceCallback mResourceCallback;

    private boolean mEventFired = false;

    /**
     * Listens for events on the given EventBusRegistrationInterface. Resources with the same name
     * as existing resources may be ignored, so be sure to use different names when registering
     * multiple resources.
     * @param name     a unique name for idempotency
     * @param eventBus {@link EventBusRegistrationInterface} to register for user events
     */
    public EventBusIdlingResource(String name, EventBusRegistrationInterface eventBus) {
        mName = name;
        mEventBus = eventBus;
        mEventBus.register(mSubscriber);
    }

    @Override public String getName() {
        return mName;
    }

    @Override public void registerIdleTransitionCallback(ResourceCallback resourceCallback) {
        mResourceCallback = resourceCallback;
        if (isIdleNow()) {
            mResourceCallback.onTransitionToIdle();
        }
    }

    @Override public boolean isIdleNow() {
        return mEventFired;
    }

    private class EventSubscriber {
        public void onEventMainThread(T e) {
            LOG.i("Detected event in EventBusIdlingResource %s", getName());
            mEventFired = true;
            if (mResourceCallback != null) {
                LOG.v("Calling ResourceCallback in EventBusIdlingResource %s", getName());
                mResourceCallback.onTransitionToIdle();
            }
            mEventBus.unregister(this);
        }
    }


}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.sync;

import android.content.Context;
import android.net.wifi.WifiManager;
import android.preference.PreferenceManager;
import android.support.test.espresso.Espresso;

import android.database.sqlite.SQLiteException;

import org.projectbuendia.client.App;
import org.projectbuendia.client.events.sync.SyncFailedEvent;
import org.projectbuendia.client.sync.Database;
import org.projectbuendia.client.ui.FunctionalTestCase;
import org.projectbuendia.client.utils.Logger;

import java.sql.SQLException;
import java.util.UUID;

/**
 * A {@link FunctionalTestCase} that clears the application database as part of set up, allowing for
 * sync behavior to be tested more easily. This class does NOT currently clear ODK forms, which are
 * stored separately as flat files.
 * <p/>
 * <p>WARNING: Syncing may require the transfer of large quantities of data, so {@link SyncTestCase}
 * tests will almost always be very large tests.
 */
public class SyncTestCase extends FunctionalTestCase {
    private static final Logger LOG = Logger.create();
    // The database may still be holding a lock after a test, so clearing the database may not
    // be successful right away.
    private static final int MAX_DATABASE_CLEAR_RETRIES = 10;

    @Override public void setUp() throws Exception {
        // Clearing the database can be flaky if previous tests are temporarily holding a DB lock,
        // so try a few times before failing.
        boolean cleared = false;
        int retriesRemaining = MAX_DATABASE_CLEAR_RETRIES;
        while (!cleared && retriesRemaining > 0) {
            try {
                clearDatabase();
                clearPreferences();
                cleared = true;
            } catch (SQLiteException e) {
                Thread.sleep(500);
                retriesRemaining--;
            }
        }

        super.setUp();
    }

    /** Clears all contents of the database (note: this does not include ODK forms or instances). */
    public void clearDatabase() throws SQLException {
        Database db = new Database(App.getContext());
        db.onUpgrade(db.getWritableDatabase(), 0, 1);
        db.close();
    }

    /** Clears all shared preferences of the application. */
    public void clearPreferences() {
        PreferenceManager.getDefaultSharedPreferences(App.getInstance()).edit().clear().commit();
    }

    /** Cleans up post-test wifi state. Won't work during tearDown(). */
    public void cleanupWifi() {
        setWifiEnabled(true);
        // Wait until wifi connection has been re-established.
        Espresso.registerIdlingResources(new WifiStateIdlingResource());
    }

    /** Turns wifi on or off. */
    protected void setWifiEnabled(boolean enabled) {
        LOG.i("Setting wifi state: %b", enabled);
        WifiManager wifiManager =
            (WifiManager) App.getInstance().getSystemService(Context.WIFI_SERVICE);
        wifiManager.setWifiEnabled(enabled);
    }

    /** Delays all ViewActions until sync has failed once. */
    protected void waitForSyncFailure() {
        EventBusIdlingResource<SyncFailedEvent> syncFailedEventIdlingResource =
            new EventBusIdlingResource<>(UUID.randomUUID().toString(), mEventBus);
        Espresso.registerIdlingResources(syncFailedEventIdlingResource);
    }

    class WifiDisabler implements AutoCloseable {
        public WifiDisabler() {
            setWifiEnabled(false);
        }

        public void close() {
            cleanupWifi();
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.login;

import android.support.test.annotation.UiThreadTest;
import android.support.test.runner.AndroidJUnit4;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.projectbuendia.client.AppSettings;
import org.projectbuendia.client.diagnostics.Troubleshooter;
import org.projectbuendia.client.diagnostics.TroubleshootingAction;
import org.projectbuendia.client.events.diagnostics.TroubleshootingActionsChangedEvent;
import org.projectbuendia.client.events.user.KnownUsersLoadFailedEvent;
import org.projectbuendia.client.events.user.KnownUsersLoadedEvent;
import org.projectbuendia.client.events.user.UserAddFailedEvent;
import org.projectbuendia.client.events.user.UserAddedEvent;
import org.projectbuendia.client.json.JsonNewUser;
import org.projectbuendia.client.json.JsonUser;
import org.projectbuendia.client.ui.FakeEventBus;
import org.projectbuendia.client.user.UserManager;

import androidx.test.filters.SmallTest;

import static junit.framework.TestCase.assertEquals;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/** Tests for {@link LoginController}. */
@RunWith(AndroidJUnit4.class)
@SmallTest
public class LoginControllerTest {

    private LoginController mController;
    @Mock private UserManager mMockUserManager;
    @Mock private LoginController.Ui mMockUi;
    @Mock private LoginController.FragmentUi mMockFragmentUi;
    @Mock private Troubleshooter mTroubleshooter;
    @Mock private AppSettings mAppSettings;
    private FakeEventBus mFakeEventBus;

    /** Tests that init() attempts to load known users. */
    @Test
    @UiThreadTest
    public void testInit_SetsKnownUserLoadGoing() {
        // WHEN the controller is inited
        mController.init();
        // THEN it requests that the user manager loads the list of users
        mMockUserManager.loadKnownUsers();
    }

    /** Tests that suspend() unregisters subscribers from the event bus. */
    @Test
    @UiThreadTest
    public void testSuspend_UnregistersFromEventBus() {
        // GIVEN an initialized controller
        mController.init();
        // WHEN the controller is suspended
        mController.suspend();
        // THEN the controller unregisters from the event bus
        assertEquals(0, mFakeEventBus.countRegisteredReceivers());
    }

    /** Tests that the UI updates when users are loaded. */
    @Test
    @UiThreadTest
    public void testKnownUsersLoadedEvent_UpdatesUi() throws Exception {
        // GIVEN the controller is inited
        mController.init();
        // WHEN a KnownUsersLoadedEvent is sent over the event bus
        JsonUser user = new JsonUser("idA", "nameA");
        mFakeEventBus.post(new KnownUsersLoadedEvent(ImmutableSet.of(user)));
        // THEN the UI is updated
        verify(mMockFragmentUi).showUsers(ImmutableList.of(user));
    }

    /** Tests that settings are shown when requested. */
    @Test
    @UiThreadTest
    public void testSettingsPress_ShowsSettings() {
        // GIVEN an inited controller
        mController.init();
        // WHEN the settings button is pressed
        mController.onSettingsPressed();
        // THEN the settings screen is opened
        verify(mMockUi).showSettings();
    }

    /** Tests that selecting a user causes a transition to the tent selection screen. */
    @Test
    @UiThreadTest
    public void testSelectingUser_SetsUserAndOpensTentSelection() throws Exception {
        // GIVEN an controller inited controller with users loaded
        mController.init();
        JsonUser user = new JsonUser("idA", "nameA");
        mFakeEventBus.post(new KnownUsersLoadedEvent(ImmutableSet.of(user)));
        // WHEN one of the users is selected
        mController.onUserSelected(user);
        // THEN that user is set as the active user
        verify(mMockUserManager).setActiveUser(user);
        // THEN the tent selection screen is shown
        verify(mMockUi).showTentSelectionScreen();
    }

    /** Tests that spinner is shown when the controller is first initialized. */
    @Test
    @UiThreadTest
    public void testInit_showsSpinner() {
        // WHEN controller is inited
        mController.init();
        // THEN spinner is shown
        verify(mMockFragmentUi).showSpinner(true);
    }

    /** Tests that successful user load hides the spinner. */
    @Test
    @UiThreadTest
    public void testUsersLoaded_hidesSpinner() {
        // GIVEN initialized controller
        mController.init();
        // WHEN users are loaded
        JsonUser user = new JsonUser("idA", "nameA");
        mFakeEventBus.post(new KnownUsersLoadedEvent(ImmutableSet.of(user)));
        // THEN the spinner is hidden
        verify(mMockFragmentUi).showSpinner(false);
    }

    /** Tests that the sync failed dialog appears when loading users fails. */
    @Test
    @UiThreadTest
    public void testUserLoadFails_showsSyncFailedDialog() {
        // GIVEN initialized controller
        mController.init();
        // WHEN users fail to load
        mFakeEventBus.post(new KnownUsersLoadFailedEvent(KnownUsersLoadFailedEvent.REASON_UNKNOWN));
        // THEN the sync fail dialog is shown
        verify(mMockUi).showSyncFailedDialog(true);
    }

    /** Tests that the sync failed dialog is hidden when users are successfully loaded. */
    @Test
    @UiThreadTest
    public void testUserLoaded_hidesSyncFailedDialog() {
        // GIVEN initialized controller
        mController.init();
        // WHEN users are loaded
        JsonUser user = new JsonUser("idA", "nameA");
        mFakeEventBus.post(new KnownUsersLoadedEvent(ImmutableSet.of(user)));
        // THEN the sync fail dialog is hidden
        verify(mMockUi).showSyncFailedDialog(false);
    }

    /** Tests that users are requested when a retry is requested. */
    @Test
    @UiThreadTest
    public void testOnSyncRetry_requestsUsers() {
        // GIVEN initialized controller
        mController.init();
        // WHEN onSyncRetry is called
        mController.onSyncRetry();
        // THEN users are requested
        // Note: already called once in init().
        verify(mMockUserManager, times(2)).loadKnownUsers();
    }

    /** Tests that the spinner is shown when a retry is requested. */
    @Test
    @UiThreadTest
    public void testOnSyncRetry_showsSpinner() {
        // GIVEN initialized controller
        mController.init();
        // WHEN onSyncRetry is called
        mController.onSyncRetry();
        // THEN spinner is shown
        // Note: already shown once in init().
        verify(mMockFragmentUi, times(2)).showSpinner(true);
    }

    /** Tests that the spinner is hidden whenever a user is added. */
    @Test
    @UiThreadTest
    public void testOnUserAdded_showsSpinner() {
        // GIVEN initialized controller
        mController.init();
        // WHEN a user is added
        JsonUser user = new JsonUser("idA", "nameA");
        mFakeEventBus.post(new UserAddedEvent(user));
        // THEN spinner is hidden
        verify(mMockFragmentUi).showSpinner(false);
    }

    /** Tests that the spinner is hidden whenever a user add operation fails. */
    @Test
    @UiThreadTest
    public void testOnUserAddFailed_showsSpinner() {
        // GIVEN initialized controller
        mController.init();
        // WHEN a user fails to be added
        JsonUser user = new JsonUser("uuid1", "name1");
        mFakeEventBus.post(new UserAddFailedEvent(new JsonNewUser("given", "family"), 0));
        // THEN spinner is hidden
        verify(mMockFragmentUi).showSpinner(false);
    }

    /** Tests that users are reloaded if the server becomes healthy and users are unavailable. */
    @Test
    @UiThreadTest
    public void testOnServerHealthy_reloadsUsersIfNotAvailable() {
        // GIVEN initialized controller, no users loaded, server unhealthy
        when(mTroubleshooter.isServerHealthy()).thenReturn(false);
        mController.init();
        // WHEN server becomes healthy
        when(mTroubleshooter.isServerHealthy()).thenReturn(true);
        mFakeEventBus.post(new TroubleshootingActionsChangedEvent(
            ImmutableSet.of(TroubleshootingAction.CHECK_PACKAGE_SERVER_CONFIGURATION), null));
        // THEN users are reloaded
        // Note: already called once in init()
        verify(mMockUserManager, times(2)).loadKnownUsers();
    }

    /** Tests that users are not reloaded if the server becomes healthy and users are available. */
    @Test
    @UiThreadTest
    public void testOnServerHealthy_doesNothingIfUsersAvailable() {
        // GIVEN initialized controller, users loaded, server unhealthy
        when(mTroubleshooter.isServerHealthy()).thenReturn(false);
        mController.init();
        JsonUser user = new JsonUser("idA", "nameA");
        mFakeEventBus.post(new KnownUsersLoadedEvent(ImmutableSet.of(user)));
        // WHEN server becomes healthy
        when(mTroubleshooter.isServerHealthy()).thenReturn(true);
        mFakeEventBus.post(new TroubleshootingActionsChangedEvent(
            ImmutableSet.of(TroubleshootingAction.CHECK_PACKAGE_SERVER_CONFIGURATION), null));
        // THEN users are not reloaded
        verify(mMockUserManager, times(1)).loadKnownUsers();
    }

    /**
     * Tests that TroubleshootingActionsChangedEvents do not trigger user reload if server is still
     * unhealthy.
     */
    @Test
    @UiThreadTest
    public void testOnTroubleshootingActionsChanged_checksServerHealthy() {
        // GIVEN initialized controller, no users loaded, server unhealthy
        when(mTroubleshooter.isServerHealthy()).thenReturn(false);
        mController.init();
        // WHEN TroubleshootingActions change but server is still unhealthy
        mFakeEventBus.post(new TroubleshootingActionsChangedEvent(
            ImmutableSet.of(TroubleshootingAction.CHECK_PACKAGE_SERVER_CONFIGURATION), null));
        // THEN users are not reloaded
        // Note: this function is called once during init(), so expect it to be called once, but
        //       only once.
        verify(mMockUserManager, times(1)).loadKnownUsers();
    }

    @Before
    public void setup() {
        MockitoAnnotations.initMocks(this);

        mFakeEventBus = new FakeEventBus();
        mController = new LoginController(
            mMockUserManager,
            mFakeEventBus,
            mTroubleshooter,
            mMockUi,
            mMockFragmentUi,
            mAppSettings);

    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.login;

import android.support.test.annotation.UiThreadTest;

import org.junit.Test;
import org.mockito.Mock;
import org.projectbuendia.client.R;
import org.projectbuendia.client.ui.FunctionalTestCase;

import java.util.Date;

/** Tests for {@link LoginActivity}. */
public class LoginActivityTest extends FunctionalTestCase {

    @Mock
    private LoginController.Ui mMockUi;

    /** Adds a new user and logs in. */
    @Test
    @UiThreadTest
    public void testAddUser() {
        screenshot("Test Start");
        final long n = new Date().getTime()%100000;
        final String given = "Testgiven" + n;
        final String family = "Testfamily" + n;

        // Add new user
        click(viewWithId(R.id.action_new_user));
        screenshot("After Add User Clicked");
        type(given, viewWithId(R.id.given_name_field));
        type(family, viewWithId(R.id.family_name_field));
        screenshot("After User Populated");
        click(viewWithText("OK"));
        screenshot("After OK Pressed");

        waitForProgressFragment();

//        verify(mMockUi).populateActionBar(
//                argThat(new UserMatchers.HasFullName(given + " " + family)));
        // Click new user

        final String fullName = given + " " + family;

        expectVisible(viewWithText(fullName));

        screenshot("In User Selection");
        click(viewWithText(fullName));

        // Should be logged in
        screenshot("After User Selected");

        click(viewWithText("TT"));
        expectVisible(viewWithText(fullName));
        screenshot("After User Selected in Action Bar");
    }

    /** Logs in as the guest user and logs out. */
    @Test
    @UiThreadTest
    public void testGuestLoginLogout() {
        // Click guest user
        expectVisible(firstViewWithText("GU"));
        screenshot("Test Start");
        click(viewWithText("Guest User"));

        // Should be logged in; log out
        expectVisible(viewWithText(R.string.title_location_list));
        screenshot("After Guest User Clicked");
        click(viewWithText("GU"));
        expectVisible(viewWithText("Guest User"));
        screenshot("After Guest User Selected in Action Bar");
        click(viewWithId(R.id.button_log_out));

        waitForProgressFragment();

        // Should be back at the user list
        click(viewWithId(R.id.action_new_user));
        screenshot("After Logout");
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.net;

import android.support.test.runner.AndroidJUnit4;

import androidx.test.filters.SmallTest;

import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.File;
import java.util.UUID;

import static junit.framework.TestCase.assertEquals;

/** Test cases for {@link OdkDatabaseTest}. */
@RunWith(AndroidJUnit4.class)
@SmallTest
public class OdkDatabaseTest   {

    @Test
    public void testNonExistentFile_getFormIdForPathMustReturnOneNegative() throws Exception {
        File nonExistentFile = new File("/nonExistentPath_ " + UUID.randomUUID().toString());
        long expectedFormId = -1;

        long actualFormId = OdkDatabase.getFormIdForPath(nonExistentFile);

        assertEquals("Given an non existent file, the form id must be -1", expectedFormId,
            actualFormId);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.utils;

import com.google.common.base.Joiner;

import org.joda.time.LocalDate;
import org.junit.Test;
import org.projectbuendia.client.ui.dialogs.ObsDetailDialogFragment;
import org.projectbuendia.client.ui.dialogs.ObsDetailDialogFragment.Group;
import org.projectbuendia.client.ui.dialogs.ObsDetailDialogFragment.GroupComparator;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import static org.junit.Assert.assertEquals;

public class UtilsTest {
    @Test public void testAlphanumericComparator() {
        String[] elements = {
            "b1", "a11a", "a11", "a2", "a2b", "a02b", "a2a", "a1",
            "b7465829459273654782634", "b7465829459273654782633"};
        String[] sorted = elements.clone();
        Arrays.sort(sorted, Utils.ALPHANUMERIC_COMPARATOR);
        Joiner joiner = Joiner.on("/");
        String[] expected = {
            "a1", "a2", "a2a", "a02b", "a2b", "a11", "a11a", "b1",
            "b7465829459273654782633", "b7465829459273654782634"};
        assertEquals(joiner.join(expected), joiner.join(sorted));
    }

    @Test public void testSectionComparator() {
        String[] conceptUuids = {"5", "1", "3"};

        List<ObsDetailDialogFragment.Group> groups = Arrays.asList(
            new ObsDetailDialogFragment.Group(new LocalDate(2019, 1, 7), "1"),
            new ObsDetailDialogFragment.Group(new LocalDate(2019, 1, 4), "1"),
            new ObsDetailDialogFragment.Group(new LocalDate(2019, 1, 8), "2"),
            new ObsDetailDialogFragment.Group(new LocalDate(2019, 1, 3), "2"),
            new Group(new LocalDate(2019, 1, 4), "3"),
            new Group(new LocalDate(2019, 1, 4), "4"),
            new Group(new LocalDate(2019, 1, 4), "5")
        );

        Collections.sort(groups, new GroupComparator(conceptUuids));

        assertEquals("2019-01-03/2", toString(groups.get(0)));
        assertEquals("2019-01-04/5", toString(groups.get(1)));
        assertEquals("2019-01-04/1", toString(groups.get(2)));
        assertEquals("2019-01-04/3", toString(groups.get(3)));
        assertEquals("2019-01-04/4", toString(groups.get(4)));
        assertEquals("2019-01-07/1", toString(groups.get(5)));
        assertEquals("2019-01-08/2", toString(groups.get(6)));
    }

    private String toString(ObsDetailDialogFragment.Group group) {
        return group.date.toString() + "/" + group.conceptUuid;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.utils.date;

import android.support.test.runner.AndroidJUnit4;

import org.joda.time.DateTime;
import org.joda.time.LocalDate;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.projectbuendia.client.utils.RelativeDateTimeFormatter;

import androidx.test.filters.SmallTest;

import static junit.framework.TestCase.assertEquals;

/** Test cases for {@link RelativeDateTimeFormatter}. */
@RunWith(AndroidJUnit4.class)
@SmallTest
public class RelativeDateTimeFormatterTest   {

    private RelativeDateTimeFormatter mFormatter;
    private DateTime mNow;
    private LocalDate mToday;

    @Test
    public void testFormat_rightNow() throws Exception {
        assertEquals("right now", mFormatter.format(mNow, mNow));
    }

    @Test
    public void testFormat_inTheFuture() throws Exception {
        assertEquals("in the future", mFormatter.format(mNow.plusDays(1), mNow));
    }

    @Test
    public void testFormat_17minutesAgo() throws Exception {
        assertEquals("17 min ago", mFormatter.format(mNow.minusMinutes(17), mNow));
    }


    @Test
    public void testFormat_60minutesAgo() throws Exception {
        assertEquals("60 min ago", mFormatter.format(mNow.minusHours(1), mNow));
    }

    @Test
    public void testFormat_yesterday() throws Exception {
        assertEquals("yesterday", mFormatter.format(mToday.minusDays(1), mToday));
    }

    @Test
    public void testFormat_daysAgo() throws Exception {
        assertEquals("2 days ago", mFormatter.format(mNow.minusDays(2), mNow));
    }

    // Regression test for https://github.com/projectbuendia/client/issues/389
    @Test public void testFormat_moreThanAMonthAgo() throws Exception {
        assertEquals("99 days ago", mFormatter.format(mNow.minusDays(99), mNow));
    }

    @Test
    public void testFormatLocalDate_today() {
        assertEquals("today", mFormatter.format(mToday, mToday));
    }

    @Before
    public void setup() {
        mFormatter = new RelativeDateTimeFormatter();
        mNow = DateTime.parse("2000-01-01T12:00Z");
        mToday = LocalDate.parse("2000-01-01");
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.user;

import android.support.test.runner.AndroidJUnit4;

import com.google.common.collect.ImmutableSet;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.projectbuendia.client.FakeAsyncTaskRunner;
import org.projectbuendia.client.events.user.KnownUsersLoadFailedEvent;
import org.projectbuendia.client.events.user.KnownUsersLoadedEvent;
import org.projectbuendia.client.json.JsonUser;
import org.projectbuendia.client.ui.FakeEventBus;

import androidx.test.filters.SmallTest;

import static android.support.test.InstrumentationRegistry.getInstrumentation;
import static junit.framework.TestCase.assertTrue;
import static org.junit.Assert.assertNull;
import static org.mockito.Mockito.when;

/** Tests for {@link UserManager}. */
@RunWith(AndroidJUnit4.class)
@SmallTest
public final class UserManagerTest   {

    private static final JsonUser USER = new JsonUser("id", "name");

    private UserManager mUserManager;
    private FakeEventBus mFakeEventBus;
    private FakeAsyncTaskRunner mFakeAsyncTaskRunner;
    @Mock private UserStore mMockUserStore;

    /** Tests that getActiveUser() returns null if the user is never set. */
    @Test
    public void testGetActiveUser_ReturnsNullInitially() {
        // GIVEN a new UserManager instance (user never set)
        // WHEN getActiveUser is called
        // THEN it returns null
        assertNull(mUserManager.getActiveUser());
    }

    /** Tests that an event is posted when users are loaded successfully. */
    @Test
    public void testLoadKnownUsers_GeneratesEventOnSucess() throws Exception {
        // GIVEN the user store returns a set of users
        when(mMockUserStore.loadKnownUsers()).thenReturn(ImmutableSet.of(USER));
        // WHEN loadKnownUsers is called and the async task is run
        mUserManager.loadKnownUsers();
        mFakeAsyncTaskRunner.runUntilEmpty();
        // THEN the user manager fires off a KnownUsersLoadedEvent
        assertTrue(mFakeEventBus.getEventLog().contains(
            new KnownUsersLoadedEvent(ImmutableSet.of(USER))));
    }

    /** Tests that an event is posted when users fail to load. */
    @Test
    public void testLoadKnownUsers_GeneratesEventOnFailure() throws Exception {
        // GIVEN the user store throws an exception when trying to load the users
        when(mMockUserStore.loadKnownUsers()).thenAnswer(invocationOnMock -> {
            throw new InterruptedException("INTENDED FOR TEST");
        });
        // WHEN loadKnownUsers is called and the async task is run
        mUserManager.loadKnownUsers();
        mFakeAsyncTaskRunner.runUntilEmpty();
        // THEN the user manager fires off a KnownUsersLoadFailedEvent
        mFakeEventBus.assertEventLogContains(
            new KnownUsersLoadFailedEvent(KnownUsersLoadFailedEvent.REASON_UNKNOWN));
    }

    @Before
    public void setup() {
        MockitoAnnotations.initMocks(this);

        mFakeEventBus = new FakeEventBus();
        mFakeAsyncTaskRunner = new FakeAsyncTaskRunner(getInstrumentation());
        mUserManager = new UserManager(
            mMockUserStore,
            mFakeEventBus,
            mFakeAsyncTaskRunner);
    }
}

package org.projectbuendia.client.acceptance;

import android.support.test.espresso.NoMatchingViewException;
import android.support.test.espresso.ViewAssertion;
import android.support.test.espresso.matcher.ViewMatchers;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ListAdapter;

import org.hamcrest.Matcher;

import static org.hamcrest.Matchers.is;

public class ListItemCountAssertion implements ViewAssertion {
    private final Matcher<Integer> matcher;

    public static ListItemCountAssertion hasItemCount(Matcher<Integer> matcher) {
        return new ListItemCountAssertion(matcher);
    }

    public static ListItemCountAssertion hasItemCount(int count) {
        return new ListItemCountAssertion(is(count));
    }

    public ListItemCountAssertion(Matcher<Integer> matcher) {
        this.matcher = matcher;
    }

    @Override public void check(View view, NoMatchingViewException noViewFoundException) {
        if (noViewFoundException != null) {
            throw noViewFoundException;
        }
        ListAdapter adapter = ((AdapterView<ListAdapter>) view).getAdapter();
        ViewMatchers.assertThat(adapter.getCount(), matcher);
    }
}

package org.projectbuendia.client.acceptance;

import android.support.test.espresso.NoMatchingViewException;
import android.support.test.espresso.ViewAssertion;
import android.view.View;

public class FoundAssertion implements ViewAssertion {
    public static ViewAssertion exists() {
        return new FoundAssertion();
    }

    @Override public void check(View view, NoMatchingViewException noViewFoundException) {
        if (noViewFoundException != null) {
            throw noViewFoundException;
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.filter.matchers;

import android.support.test.runner.AndroidJUnit4;

import org.junit.Test;
import org.junit.runner.RunWith;

import androidx.test.filters.SmallTest;

import static junit.framework.TestCase.assertTrue;
import static org.junit.Assert.assertFalse;

/** Tests for {@link MatchingFilterGroup}. */
@RunWith(AndroidJUnit4.class)
@SmallTest
public class MatchingFilterGroupTest {
    private static final MatchingFilter<String> PREFIX_FILTER =
        (object, constraint) -> object.startsWith(constraint.toString());

    private static final MatchingFilter<String> SUFFIX_FILTER =
        (object, constraint) -> object.endsWith(constraint.toString());

    private static final MatchingFilterGroup<String> AND_FILTER_GROUP =
        new MatchingFilterGroup<>(
            MatchingFilterGroup.FilterType.AND, PREFIX_FILTER, SUFFIX_FILTER);

    private static final MatchingFilterGroup<String> OR_FILTER_GROUP =
        new MatchingFilterGroup<>(
            MatchingFilterGroup.FilterType.OR, PREFIX_FILTER, SUFFIX_FILTER);

    /** Tests that OR filter groups match on any of their filters. */
    @Test
    public void testMatches_multiFilterOr() {
        assertTrue(OR_FILTER_GROUP.matches("foobar", "foo"));
        assertTrue(OR_FILTER_GROUP.matches("foobar", "bar"));
        assertTrue(OR_FILTER_GROUP.matches("foobar", "foobar"));
    }

    /** Tests that AND filter groups must match on all of their filters. */
    @Test
    public void testMatches_multiFilterAnd() {
        assertFalse(AND_FILTER_GROUP.matches("foobar", "foo"));
        assertFalse(AND_FILTER_GROUP.matches("foobar", "bar"));
        assertTrue(AND_FILTER_GROUP.matches("foobar", "foobar"));
    }

    /** Tests that OR filter groups with only one filter work like an ordinary filter. */
    @Test
    public void testMatches_singleFilterOr() {
        MatchingFilterGroup<String> singleFilterGroup =
            new MatchingFilterGroup<>(MatchingFilterGroup.FilterType.OR, PREFIX_FILTER);
        assertTrue(singleFilterGroup.matches("foobar", "foo"));
        assertFalse(singleFilterGroup.matches("foobar", "bar"));
    }

    /** Tests that AND filter groups with only one filter work like an ordinary filter. */
    @Test
    public void testMatches_singleFilterAnd() {
        MatchingFilterGroup<String> singleFilterGroup =
            new MatchingFilterGroup<>(MatchingFilterGroup.FilterType.AND, PREFIX_FILTER);
        assertTrue(singleFilterGroup.matches("foobar", "foo"));
        assertFalse(singleFilterGroup.matches("foobar", "bar"));
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.filter.matchers;

import android.support.test.runner.AndroidJUnit4;

import com.google.common.collect.Iterators;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.projectbuendia.client.FakeTypedCursor;
import org.projectbuendia.models.TypedCursor;

import java.util.Iterator;

import androidx.test.filters.SmallTest;

import static junit.framework.TestCase.assertEquals;

/** Tests for {@link FilteredCursor}. */
@RunWith(AndroidJUnit4.class)
@SmallTest
public class FilteredCursorWrapperTest {
    private static final MatchingFilter<String> SUBSTRING_FILTER = String::contains;

    private static final String[] SAMPLE_DATA = new String[] {
        "apple", "orange", "pear", "grapefruit"
    };

    private static final TypedCursor<String> SAMPLE_CURSOR = new FakeTypedCursor<>(SAMPLE_DATA);

    /** Tests that getCount() returns the expected number of matches. */
    @Test
    public void testGetCount_returnsNumberOfMatches() {
        assertEquals(2, filterWithConstraint("pe").getCount());
        assertEquals(1, filterWithConstraint("pea").getCount());
        assertEquals(0, filterWithConstraint("peak").getCount());
    }

    private FilteredCursor<String> filterWithConstraint(String constraint) {
        return new FilteredCursor<>(SAMPLE_CURSOR, SUBSTRING_FILTER, constraint);
    }

    /** Tests that get() returns any and all matched entries. */
    @Test
    public void testGet_returnsMatchedEntries() {
        FilteredCursor<String> cursor = filterWithConstraint("pe");
        assertEquals("pear", cursor.get(0));
        assertEquals("grapefruit", cursor.get(1));
    }

    /** Tests that the iterator returned by iterator() only iterates on matched entries. */
    @Test
    public void testIterator_returnsIteratorForMatchedEntries() {
        Iterator<String> iterator = filterWithConstraint("pe").iterator();
        String[] iteratorValues = Iterators.toArray(iterator, String.class);
        assertEquals(2, iteratorValues.length);
        assertEquals("pear", iteratorValues[0]);
        assertEquals("grapefruit", iteratorValues[1]);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.filter.matchers.patient;

import android.support.test.runner.AndroidJUnit4;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.projectbuendia.models.Patient;
import org.projectbuendia.models.Sex;
import org.projectbuendia.client.utils.Utils;

import androidx.test.filters.SmallTest;

import static junit.framework.TestCase.assertTrue;
import static org.junit.Assert.assertFalse;

/** Tests for {@link NameFilter}. */
@RunWith(AndroidJUnit4.class)
@SmallTest
public class NameFilterTest {
    private NameFilter mNameFilter;

    @Before
    public void createNameFilter() throws Exception {
        mNameFilter = new NameFilter();
    }

    /** Tests that name matching works when a matching full name is provided. */
    @Test
    public void testMatches_exactMatchOnFullName() {
        assertTrue(mNameFilter.matches(getPatientWithName("John", "Doe"), "John Doe"));
    }

    private Patient getPatientWithName(String givenName, String familyName) {
        return new Patient(
            null, "1",
            Utils.orDefault(givenName, "\u2013"),
            Utils.orDefault(familyName, "\u2013"),
            Sex.OTHER, null /* birthdate */, false /* pregnancy */,
            "" /* location_uuid */, "" /* bed_number */);
    }

    /** Tests that name matching works on just the given name. */
    @Test
    public void testMatches_exactMatchOnGivenName() {
        assertTrue(mNameFilter.matches(getPatientWithName("John", "Doe"), "John"));
    }

    /** Tests that name matching works on just the family name. */
    @Test
    public void testMatches_exactMatchOnFamilyName() {
        assertTrue(mNameFilter.matches(getPatientWithName("John", "Doe"), "Doe"));
    }

    /** Tests that name matching works on just the prefix of a given name. */
    @Test
    public void testMatches_prefixMatchOnGivenName() {
        assertTrue(mNameFilter.matches(getPatientWithName("John", "Doe"), "Jo"));
    }

    /** Tests that name watching works on just the prefix of a family name. */
    @Test
    public void testMatches_prefixMatchOnFamilyName() {
        assertTrue(mNameFilter.matches(getPatientWithName("John", "Doe"), "Do"));
    }

    /** Tests that prefix matching works when multiple parts of the name are given. */
    @Test
    public void testMatches_prefixMatchOnGivenAndFamilyName() {
        assertTrue(mNameFilter.matches(getPatientWithName("John", "Doe"), "John D"));
    }

    /** Tests that prefix matching on given names works when the given name has multiple words. */
    @Test
    public void testMatches_prefixMatchOnMultiwordGivenName() {
        assertTrue(mNameFilter.matches(getPatientWithName("Anna Marie", "Smith"), "Anna Ma"));
    }

    /** Tests that prefix matching on family names works when the family name has multiple words. */
    @Test
    public void testMatches_prefixMatchOnMultiwordFamilyName() {
        assertTrue(mNameFilter.matches(getPatientWithName("Dick", "Van Dyke"), "Van Dy"));
    }

    /** Tests that name matching is case-insensitive. */
    @Test
    public void testMatches_isCaseInsensitive() {
        assertTrue(mNameFilter.matches(getPatientWithName("John", "Doe"), "JOHN"));
    }

    /** Tests that name matching works on unicode names. */
    @Test
    public void testMatches_supportsUnicode() {
        assertTrue(mNameFilter.matches(getPatientWithName("", ""), ""));
    }

    /** Tests that a non-matching search query does not match. */
    @Test
    public void testMatches_negativeMatch() {
        assertFalse(mNameFilter.matches(getPatientWithName("John", "Doe"), "Jim"));
    }

    /** Tests that a query with a dash matches a patient with an unknown family name. */
    @Test
    public void testMatches_dashMatchesUnknownFamilyName() {
        assertTrue(mNameFilter.matches(getPatientWithName("John", null), "-"));
    }

    /** Tests that a query with a dash matches a patient with an unknown given name. */
    @Test
    public void testMatches_dashMatchesUnknownGivenName() {
        assertTrue(mNameFilter.matches(getPatientWithName(null, "Doe"), "-"));
    }

    /** Tests that a query with a dash matches a patient with unknown family AND given names. */
    @Test
    public void testMatches_dashMatchesCompletelyUnknownName() {
        assertTrue(mNameFilter.matches(getPatientWithName(null, null), "-"));
    }

    /**
     * Tests that a query with multiple dashes matches a patient with unknown family AND given
     * names.
     */
    @Test
    public void testMatches_doubleDashMatchesCompletelyUnknownName() {
        assertTrue(mNameFilter.matches(getPatientWithName(null, null), "- -"));
    }

    /** Tests that a Unicode dash still matches an unknown name. */
    @Test
    public void testMatches_unicodeDashMatchesUnknownName() {
        assertTrue(mNameFilter.matches(getPatientWithName(null, "Doe"), ""));
    }

    /**
     * Tests that a query with both a dash and a family name matches a patient with an unknown given
     * name and matching family name.
     */
    @Test
    public void testMatches_unknownGivenNameWithMatchingFamilyName() {
        assertTrue(mNameFilter.matches(getPatientWithName(null, "Doe"), "- Doe"));
    }

    /**
     * Tests that a query with both a dash and a given name matches a patient with an unknown family
     * name and matching given name.
     */
    @Test
    public void testMatches_unknownFamilyNameWithMatchingGivenName() {
        assertTrue(mNameFilter.matches(getPatientWithName("John", null), "John -"));
    }

    /** Tests that a dash does not match a patient with a fully-known name. */
    @Test
    public void testMatches_dashDoesNotMatchKnownName() {
        assertFalse(mNameFilter.matches(getPatientWithName("John", "Doe"), "-"));
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.filter.matchers.patient;

import android.support.test.runner.AndroidJUnit4;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.projectbuendia.models.Patient;
import org.projectbuendia.models.Sex;

import androidx.test.filters.SmallTest;

import static junit.framework.TestCase.assertTrue;
import static org.junit.Assert.assertFalse;

/** Tests for {@link IdFilter}. */
@RunWith(AndroidJUnit4.class)
@SmallTest
public class IdFilterTest {
    private IdFilter mIdFilter;

    @Before
    public void createIdFilter() throws Exception {
        mIdFilter = new IdFilter();
    }

    /** Tests that id matching works in the base case. */
    @Test
    public void testMatches_exactMatch() {
        assertTrue(mIdFilter.matches(getPatientWithId("123"), "123"));
    }

    private Patient getPatientWithId(String id) {
        return new Patient(null, id, "Given", "Family", Sex.OTHER,
            null /* birthdate */, false /* pregnancy */,
            "" /* location_uuid */, "" /* bed_number */);
    }

    /** Tests that id matching allows for a prefix match. */
    @Test
    public void testMatches_matchesPrefix() {
        assertTrue(mIdFilter.matches(getPatientWithId("123"), "12"));
    }

    /** Tests that id matching allows for a suffix match. */
    @Test
    public void testMatches_matchesSuffix() {
        assertTrue(mIdFilter.matches(getPatientWithId("123"), "23"));
    }

    /** Tests that id matching allows for an internal substring match. */
    @Test
    public void testMatches_matchesSubstring() {
        assertTrue(mIdFilter.matches(getPatientWithId("123"), "2"));
    }

    /** Tests that id matching supports unicode. */
    @Test
    public void testMatches_allowsUnicode() {
        assertTrue(mIdFilter.matches(getPatientWithId(""), ""));
    }

    /** Tests that id matching does not return false positives. */
    @Test
    public void testMatches_negativeMatch() {
        assertFalse(mIdFilter.matches(getPatientWithId("123"), "4"));
    }

    /** Tests that id matching is case-insensitive. */
    @Test
    public void testMatches_ignoresCase() {
        assertTrue(mIdFilter.matches(getPatientWithId("abc"), "ABC"));
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client;

/** The modules used for injection in a release build. */
final class Modules {

    private Modules() {
    }

    static Object[] list(App app) {
        return new Object[] {
            new AppModule(app)
        };
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models;

import android.content.ContentValues;
import android.database.Cursor;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;

import org.joda.time.DateTime;
import org.joda.time.Days;
import org.joda.time.Duration;
import org.joda.time.Interval;
import org.joda.time.LocalDate;
import org.json.JSONException;
import org.json.JSONObject;
import org.projectbuendia.client.App;
import org.projectbuendia.client.json.JsonOrder;
import org.projectbuendia.models.Catalog.Drug;
import org.projectbuendia.client.providers.Contracts.Orders;
import org.projectbuendia.client.utils.Utils;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

import javax.annotation.concurrent.Immutable;

import static org.projectbuendia.client.utils.Utils.eq;

/**
 * An order for a scheduled treatment.
 *
 * There are two types of orders: unary orders and series orders.  Unary orders
 * represent a single dose scheduled at a point in time, and have no frequency.
 * Series orders represent a series of doses scheduled at regular intervals from
 * a start time until an optional stop time, and have a frequency specified as
 * an integer number of doses per day.  A series with no stop time represents a
 * treatment to be continued indefinitely.
 *
 * Each dose is modelled as a "dose interval"; a dose is considered to be given
 * "on time" if the actual time of administration falls within the dose interval.
 * A unary order has one dose interval, from the prescribed time until the end
 * of that day.  A series order has a series of dose intervals, formed by dividing
 * each day into equal divisions according to its frequency, and consisting of all
 * the divisions that contain or come after the start time but do not contain or
 * come after the stop time.  Note that the divisions (and hence the dose intervals)
 * for a given order are not necessarily of uniform length, because certain days
 * are longer or shorter than 24 hours.  Also note that the first dose interval
 * does not end at a fixed length of time after the start time, because divisions
 * are aligned to the day, not to the start time.
 *
 * The OpenMRS Order data type has no fields for the drug, dosage, or frequency;
 * our hack to get around this is to format these fields into one string that
 * is stored in the "instructions" field.
 */
public final @Immutable class Order extends Model implements Serializable {
    public static final char NON_BREAKING_SPACE = '\u00a0';

    public final String patientUuid;
    public final String providerUuid;
    public final Instructions instructions;
    // TODO(ping): Data model time fields should be Instants instead of DateTimes.
    public final DateTime start;
    public final @Nullable DateTime stop;  // null if unary, non-null if series

    public static Order fromJson(JsonOrder order) {
        return new Order(
            order.uuid, order.patient_uuid, order.provider_uuid,
            order.instructions, order.start_time, order.stop_time
        );
    }

    public static Order load(Cursor cursor) {
        return new Order(
            cursor.getString(cursor.getColumnIndex(Orders.UUID)),
            cursor.getString(cursor.getColumnIndex(Orders.PATIENT_UUID)),
            cursor.getString(cursor.getColumnIndex(Orders.PROVIDER_UUID)),
            cursor.getString(cursor.getColumnIndex(Orders.INSTRUCTIONS)),
            cursor.getLong(cursor.getColumnIndex(Orders.START_MILLIS)),
            cursor.getLong(cursor.getColumnIndex(Orders.STOP_MILLIS))
        );
    }

    public Order(@Nullable String uuid, String patientUuid, String providerUuid,
                 Instructions instructions, DateTime start, @Nullable DateTime stop) {
        super(uuid);
        this.patientUuid = patientUuid;
        this.providerUuid = providerUuid;
        this.instructions = instructions;
        this.start = start;
        this.stop = stop;
    }

    public Order(
        @Nullable String uuid, String patientUuid, String providerUuid,
        String instructionsText, DateTime start, @Nullable DateTime stop) {
        this(uuid, patientUuid, providerUuid, new Instructions(instructionsText), start, stop);
    }

    public Order(
        @Nullable String uuid, String patientUuid, String providerUuid,
        String instructionsText, Long startMillis, @Nullable Long stopMillis) {
        this(
            uuid, patientUuid, providerUuid, instructionsText,
            Utils.toLocalDateTime(startMillis),
            stopMillis != null ? Utils.toLocalDateTime(stopMillis) : null
        );
    }

    public boolean isContinuous() {
        return instructions.isContinuous();
    }

    public boolean isSeries() {
        return instructions.isSeries();
    }

    public Interval getInterval() {
        return Utils.toInterval(start, stop == null ? Utils.MAX_DATETIME : stop);
    }

    public LocalDate getStartDay() {
        return start.toLocalDate();
    }

    /** Gets the index of the division containing the given time.  See getDivision(). */
    public int getDivisionIndex(DateTime time) {
        LocalDate day = time.toLocalDate();
        Interval daySpan = day.toInterval();
        int dayIndex = Days.daysBetween(start.toLocalDate(), day).getDays();
        Duration timeOfDay = new Duration(daySpan.getStart(), time);
        float fractionOfDay = (float) timeOfDay.getMillis() / daySpan.toDurationMillis();
        return (int) ((dayIndex + fractionOfDay) * getNumDivisionsPerDay());
    }

    /**
     * Gets the division corresponding to the given index, where the first
     * division of the starting day has index 0, the next division has index 1,
     * and so on.  Divisions preceding the starting day have negative index values.
     */
    public Interval getDivision(int index) {
        int numDivisions = getNumDivisionsPerDay();
        int dayIndex = Utils.floorDiv(index, numDivisions);
        LocalDate day = start.toLocalDate().plusDays(dayIndex);
        Interval daySpan = day.toInterval();

        long startMillis = daySpan.getStartMillis();
        long dayMillis = daySpan.toDurationMillis();
        int i = Utils.floorMod(index, numDivisions);

        // Pick out the i-th division out of 'numDivisions' divisions of the day.
        long prevMillis = startMillis + dayMillis * i / numDivisions;
        long nextMillis = startMillis + dayMillis * (i + 1) / numDivisions;
        return new Interval(prevMillis, nextMillis);
    }

    /** Divides a given day into equal intervals according to the order's frequency. */
    public List<Interval> getDivisionsOfDay(LocalDate day) {
        List<Interval> divisions = new ArrayList<>();
        Interval daySpan = day.toInterval();

        int numDivisions = getNumDivisionsPerDay();
        long startMillis = daySpan.getStartMillis();
        long dayMillis = daySpan.toDurationMillis();

        // Divide the day into 'numDivisions' equal parts, ending exactly at end of day.
        long prevMillis = startMillis;
        for (int i = 0; i < numDivisions; i++) {
            long nextMillis = startMillis + dayMillis * (i + 1) / numDivisions;
            divisions.add(new Interval(prevMillis, nextMillis));
            prevMillis = nextMillis;
        }
        return divisions;
    }

    /** Returns the number of divisions per day (always positive, 1 for a unary order). */
    public int getNumDivisionsPerDay() {
        Quantity freq = instructions.frequency;
        if (freq != null) {
            if (freq.unit == Unit.get("PER_DAY") || freq.unit == Unit.UNSPECIFIED) {
                return (int) freq.mag;
            }
        }
        return 1;
    }

    /** Returns all the scheduled dose intervals for this order on a given day. */
    public List<Interval> getDoseIntervalsOnDay(LocalDate day) {
        List<Interval> intervals = new ArrayList<>();
        if (!isSeries()) {
            // For a single dose, the interval lasts until the end of the day.
            LocalDate doseDay = start.toLocalDate();
            if (day.equals(doseDay)) {
                intervals.add(new Interval(start, Utils.getDayEnd(doseDay)));
            }
        } else {
            // Otherwise, each day is divided into 'frequency' equal parts, and doses
            // are scheduled for a contiguous series of these divisions.  The starting
            // division is the one containing the start time; the stopping division is
            // the one containing the stop time.  The series consists of the divisions
            // from the starting division inclusive to the stopping division exclusive.
            for (Interval division : getDivisionsOfDay(day)) {
                if (stop != null && (division.contains(stop) || division.isAfter(stop))) break;
                if (division.contains(start) || division.isAfter(start)) {
                    intervals.add(division);
                }
            }
        }
        return intervals;
    }

    /**
     * Counts the number of doses in the given interval.  To ensure that the total
     * count of doses in a given period is the same regardless of how that period
     * is divided up into contiguous intervals, each dose is counted according to
     * whether the center of its scheduled interval falls within the given interval.
     */
    public int countScheduledDosesIn(Interval interval) {
        int count = 0;
        LocalDate firstDay = interval.getStart().toLocalDate();
        LocalDate lastDay = interval.getEnd().toLocalDate();
        for (LocalDate day = firstDay; !day.isAfter(lastDay); day = day.plusDays(1)) {
            for (Interval dose : getDoseIntervalsOnDay(day)) {
                if (interval.contains(Utils.centerOf(dose))) {
                    count++;
                }
            }
        }
        return count;
    }

    @Override public boolean equals(Object other) {
        // This compares all fields because ChartRenderer relies on this
        // equals() method to decide whether to re-render the chart grid.
        if (other instanceof Order) {
            Order o = (Order) other;
            return eq(uuid, o.uuid)
                && eq(patientUuid, o.patientUuid)
                && eq(instructions, o.instructions)
                && eq(start, o.start)
                && eq(stop, o.stop);
        }
        return false;
    }

    public JSONObject toJson() throws JSONException {
        JSONObject json = new JSONObject();
        json.put("patient_uuid", patientUuid);
        json.put("instructions", instructions.format());
        json.put("start_time", Utils.formatUtc8601(start));
        // Use `JSONObject.NULL` instead of `null` so that the value is actually set.
        json.put("stop_time", stop != null ? Utils.formatUtc8601(stop) : JSONObject.NULL);
        return json;
    }

    public ContentValues toContentValues() {
        ContentValues cv = new ContentValues();
        cv.put(Orders.UUID, uuid);
        cv.put(Orders.PATIENT_UUID, patientUuid);
        cv.put(Orders.PROVIDER_UUID, providerUuid);
        cv.put(Orders.INSTRUCTIONS, instructions.format());
        cv.put(Orders.START_MILLIS, start.getMillis());
        cv.put(Orders.STOP_MILLIS, Utils.toNullableMillis(stop));
        return cv;
    }

    /**
     * A record of a medication, route of administration, dosage, and frequency.
     * An OpenMRS Order does not have any of these specific fields; rather, it
     * only has a string field called "instructions".  Our workaround is for the
     * Instructions class to know how to pack these fields into a single String,
     * in a way that is vaguely human-readable and can also be unambiguously
     * unpacked into the original fields.
     */
    public static class Instructions implements Serializable {
        // All String fields are empty if missing, but never null.
        public final @NonNull String code;  // drug or format code (or free-text name)
        public final Quantity amount;  // amount of drug (mass or volume)
        public final Quantity duration;  // duration of administration, if continuously administered
        public final @NonNull String route;  // route code
        public final Quantity frequency;  // frequency of repeats, if a series order
        public final @NonNull String notes;

        // ASCII 30 is the "record separator" character; it renders as a space.
        public static final String RS = "\u001e";

        // ASCII 31 is the "unit separator" character; it renders as a space.
        public static final String US = "\u001f";

        public Instructions(String code, Quantity amount, Quantity duration, String route, Quantity frequency, String notes) {
            this.code = Utils.toNonnull(code);
            this.amount = amount;
            this.duration = duration;
            this.route = Utils.toNonnull(route);
            this.frequency = frequency;
            this.notes = Utils.toNonnull(notes);
        }

        public Instructions(String instructionsText) {
            // Instructions are serialized to a String consisting of records
            // separated by RS, and fields within those records separated by US.
            // The records and fields within them are as follows:
            //   - Record 0: code, route
            //   - Record 1: amount, amount unit, duration, duration unit
            //   - Record 2: frequency, frequency unit
            //   - Record 3: notes
            String[] records = Utils.splitFields(instructionsText, RS, 4);

            // Drug and route
            String[] fields = Utils.splitFields(records[0], US, 2);
            code = fields[0].trim();
            route = fields[1].trim();

            // Dosage
            fields = Utils.splitFields(records[1], US, 4);
            Quantity q = new Quantity(
                Utils.toDoubleOrDefault(fields[0], 0), Unit.get(fields[1]));
            amount = q.mag != 0 ? q : null;
            q = new Quantity(
                Utils.toDoubleOrDefault(fields[2], 0), Unit.get(fields[3]));
            duration = q.mag != 0 ? q : null;

            // Frequency
            fields = Utils.splitFields(records[2], US, 2);
            q = new Quantity(
                Utils.toDoubleOrDefault(fields[0], 0), Unit.get(fields[1]));
            frequency = q.mag != 0 ? q : null;

            // Notes
            fields = Utils.splitFields(records[3], US, 2);
            notes = fields[0].trim();
        }

        /** Packs all the fields into a single instruction string. */
        public String format() {
            return (code + US + route)
                + RS + (formatFields(amount) + US + formatFields(duration))
                + RS + (formatFields(frequency))
                + RS + (notes);
        }

        private String formatFields(Quantity q) {
            return q != null ? Utils.format(q.mag, 6) + US + q.unit : "";
        }

        public boolean isContinuous() {
            return duration != null;
        }

        public boolean isSeries() {
            return frequency != null;
        }

        public boolean equals(Object other) {
            if (other instanceof Instructions) {
                Instructions o = (Instructions) other;
                return eq(code, o.code)
                    && eq(amount, o.amount)
                    && eq(duration, o.duration)
                    && eq(route, o.route)
                    && eq(frequency, o.frequency)
                    && eq(notes, o.notes);
            }
            return false;
        }

        public String getDrugName() {
            Drug drug = MsfCatalog.INDEX.getDrug(code);
            return eq(drug, Drug.UNSPECIFIED) ? code : App.localize(drug.name);
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models;

import android.content.ContentValues;

import org.json.JSONException;
import org.json.JSONObject;
import org.projectbuendia.client.json.JsonForm;
import org.projectbuendia.client.providers.Contracts;
import org.projectbuendia.client.utils.Utils;

import javax.annotation.concurrent.Immutable;

@Immutable public final class Form extends Model implements Comparable<Form> {
    public final String name;
    public final String version;

    public Form(String uuid, String name, String version) {
        super(uuid);
        this.name = name;
        this.version = version;
    }

    public static Form fromJson(JsonForm form) {
        return new Form(form.uuid, form.name, form.version);
    }

    public int compareTo(Form other) {
        int result = Utils.ALPHANUMERIC_COMPARATOR.compare(name, other.name);
        if (result != 0) return result;
        return version.compareTo(other.version);
    }

    public JSONObject toJson() throws JSONException {
        JSONObject json = new JSONObject();
        json.put("uuid", uuid);
        json.put("name", name);
        json.put("version", version);
        return json;
    }

    public ContentValues toContentValues() {
        ContentValues cv = new ContentValues();
        cv.put(Contracts.Forms.UUID, uuid);
        cv.put(Contracts.Forms.NAME, name);
        cv.put(Contracts.Forms.VERSION, version);
        return cv;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models;

import android.support.annotation.Nullable;

import org.projectbuendia.client.utils.Intl;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import javax.annotation.Nonnull;

import static org.projectbuendia.client.utils.Utils.eq;

/** An ordered hierarchy of locations with their localized names. */
public class LocationForest {
    private static final Logger LOG = Logger.create();

    private final Location[] locations;
    private final Map<String, Location> locationsByUuid = new HashMap<>();
    private final Map<String, String> parentUuidsByUuid = new HashMap<>();
    private final Map<String, String> pathsByUuid = new HashMap<>();
    private final Set<String> nonleafUuids = new HashSet<>();
    private final Location defaultLocation;
    private final Map<String, Integer> numPatientsAtNode = new HashMap<>();
    private final Map<String, Integer> numPatientsInSubtree = new HashMap<>();
    private int totalNumPatients;

    private final Object patientCountLock = new Object();
    private Runnable onPatientCountsUpdatedListener = null;

    public LocationForest(List<Record> records) {
        this(records, null);
    }

    public LocationForest(List<Record> records, Locale locale) {
        List<String> uuids = new ArrayList<>();
        Map<String, String> namesByUuid = new HashMap<>();
        Map<String, String> shortIdsByUuid = new HashMap<>();
        int totalNumPatients = 0;

        for (Record record : records) {
            uuids.add(record.uuid);
            parentUuidsByUuid.put(record.uuid, record.parentUuid);
            nonleafUuids.add(record.parentUuid);
            namesByUuid.put(record.uuid, record.name);
            numPatientsAtNode.put(record.uuid, record.numPatients);
            numPatientsInSubtree.put(record.uuid, 0);  // counts will be added below
            totalNumPatients += record.numPatients;
        }

        // Sort into a global ordering consistent with the desired ordering for
        // any group of siblings, then use it to assign each item a numeric ID.
        Collections.sort(uuids, (a, b) -> Utils.ALPHANUMERIC_COMPARATOR.compare(
            namesByUuid.get(a), namesByUuid.get(b)
        ));
        for (int i = 0; i < uuids.size(); i++) {
            shortIdsByUuid.put(uuids.get(i), "" + i);
        }

        locations = new Location[uuids.size()];
        String defaultUuid = null;
        for (int i = 0; i < uuids.size(); i++) {
            // Parts of the name that are enclosed in square brackets are not
            // shown; this makes it possible to attach extra information to
            // locations using only the normal OpenMRS web interface:
            //   - Putting a number in a bracketed prefix will control the
            //     sorting order of locations, because locations are sorted
            //     alphanumerically by name (e.g. "2" will come before "11").
            //   - Putting an asterisk in a bracketed prefix will set a
            //     location as the default location for new patients.
            //   - Bracketed parts starting with a language tag and a colon
            //     can specify localized names, e.g. "cat [fr:chat] [es:gato]"
            String uuid = uuids.get(i);
            String name = namesByUuid.get(uuid);
            if (name.contains("*")) defaultUuid = uuid;
            Intl intl = new Intl(name);

            // Use the short IDs to construct a sortable path string for each node.
            // Each path component ends with a terminating character so that
            // a.path.startsWith(b.path) if and only if a is in b's subtree.
            String path = "";
            int count = numPatientsAtNode.get(uuid);
            for (String u = uuid; u != null; u = parentUuidsByUuid.get(u)) {
                path = shortIdsByUuid.get(u) + "/" + path;
                numPatientsInSubtree.put(u, numPatientsInSubtree.get(u) + count);
            }

            locations[i] = new Location(uuid, intl.loc(locale));
            pathsByUuid.put(uuid, path);
            locationsByUuid.put(uuid, locations[i]);
        }

        // Finally, sort by path, yielding an array of nodes in depth-first
        // order with every subtree in the proper order.
        sort(locations);

        // The default location is either set with an asterisk in the name
        // (see above) or defaults to the first leaf node.
        for (Location location : locations) {
            if (defaultUuid == null && isLeaf(location)) {
                defaultUuid = location.uuid;
                break;
            }
        }
        defaultLocation = locationsByUuid.get(defaultUuid); // nullable

        LOG.i("Loaded LocationForest with %d locations; default = %s",
            locations.length, defaultLocation);
    }

    public void sort(Location[] locations) {
        Arrays.sort(locations, (a, b) -> Utils.ALPHANUMERIC_COMPARATOR.compare(
            pathsByUuid.get(a.uuid), pathsByUuid.get(b.uuid)
        ));
    }

    public void updatePatientCounts(Map<String, Integer> patientCountsByLocationUuid) {
        synchronized (patientCountLock) {
            totalNumPatients = 0;
            numPatientsAtNode.clear();
            numPatientsInSubtree.clear();

            for (Location location : locations) {
                int count = Utils.getOrDefault(patientCountsByLocationUuid, location.uuid, 0);
                numPatientsAtNode.put(location.uuid, count);
                for (String u = location.uuid; u != null; u = parentUuidsByUuid.get(u)) {
                    numPatientsInSubtree.put(u,
                        Utils.getOrDefault(numPatientsInSubtree, u, 0) + count);
                }
            }
            LOG.i("Updated existing LocationForest; total patients: %d", totalNumPatients);
        }
        if (onPatientCountsUpdatedListener != null) {
            onPatientCountsUpdatedListener.run();
        }
    }

    public void setOnPatientCountsUpdatedListener(Runnable listener) {
        onPatientCountsUpdatedListener = listener;
    }

    /** Returns true if the specified location exists in this forest. */
    public boolean contains(Location location) {
        return locationsByUuid.containsKey(location.uuid);
    }

    /** Gets the location with a given UUID. */
    public @Nullable Location get(@Nullable String uuid) {
        return locationsByUuid.get(uuid);
    }

    /** Gets the number of locations in this forest. */
    public int size() {
        return locations.length;
    }

    /** Gets the parent location of the given location. */
    public @Nullable Location getParent(@Nonnull Location location) {
        return get(parentUuidsByUuid.get(location.uuid));
    }

    /** Returns the depth of a node (zero for root nodes, -1 for nonexistent nodes). */
    public int getDepth(@Nonnull Location location) {
        String path = Utils.getOrDefault(pathsByUuid, location.uuid, "");
        // Note: split() omits trailing empty parts; "foo/".split("/").length is 1.
        return path.split("/").length - 1;
    }

    /** Returns true if the given location is a leaf node. */
    public boolean isLeaf(@Nullable Location location) {
        return location != null && !nonleafUuids.contains(location.uuid);
    }

    /** Given a UUID, counts the patients just at its node. */
    public int countPatientsAt(@Nonnull Location node) {
        synchronized (patientCountLock) {
            return Utils.getOrDefault(numPatientsAtNode, node.uuid, 0);
        }
    }

    /** Given a UUID, counts all the patients in its subtree. */
    public int countPatientsIn(@Nonnull Location root) {
        synchronized (patientCountLock) {
            return Utils.getOrDefault(numPatientsInSubtree, root.uuid, 0);
        }
    }

    /** Gets the count of all patients in the forest. */
    public int countAllPatients() {
        synchronized (patientCountLock) {
            return totalNumPatients;
        }
    }

    /** Iterate over all the nodes in depth-first order. */
    public @Nonnull Collection<Location> allNodes() {
        return Arrays.asList(locations);
    }

    /** Gets a list of all the leaf nodes in depth-first order. */
    public @Nonnull List<Location> getLeaves() {
        List<Location> leaves = new ArrayList<>();
        for (Location location : locations) {
            if (isLeaf(location)) leaves.add(location);
        }
        return leaves;
    }

    /** Given a node, returns an ordered list of its immediate children. */
    public @Nonnull List<Location> getChildren(@Nonnull Location parent) {
        List<Location> children = new ArrayList<>();
        for (Location location : locations) {
            if (eq(parentUuidsByUuid.get(location.uuid), parent.uuid)) {
                children.add(location);
            }
        }
        return children;
    }

    /** Given a node, returns a list containing it and its descendants in depth-first order. */
    public @Nonnull List<Location> getSubtree(@Nonnull Location root) {
        List<Location> descendants = new ArrayList<>();
        String rootPath = pathsByUuid.get(root.uuid);
        if (rootPath != null) {
            for (Location location : locations) {
                if (pathsByUuid.get(location.uuid).startsWith(rootPath)) {
                    descendants.add(location);
                }
            }
        }
        return descendants;
    }

    /** Returns the default location where new patients will be placed. */
    public @Nullable Location getDefaultLocation() {  // null only when size() == 0
        return defaultLocation;
    }

    /** The information about each location from which a LocationForest is built. */
    public static class Record {
        public final String uuid;
        public final String parentUuid;
        public final String name;
        public final int numPatients;

        public Record(String uuid, String parentUuid, String name, int numPatients) {
            this.uuid = uuid;
            this.parentUuid = parentUuid;
            this.name = name;
            this.numPatients = numPatients;
        }
    }
}

package org.projectbuendia.models;

import org.projectbuendia.client.App;
import org.projectbuendia.client.utils.Intl;
import org.projectbuendia.client.utils.Utils;

import static org.projectbuendia.client.utils.Utils.eq;

/**
 * A namespace for all the data types that represent a catalog of medications.
 * At the highest level of organization are categories, each of which contains
 * a list of drugs, each of which is associated with a list of formats.
 *
 * A Category is a group of drugs that are administered in the same general
 * fashion (e.g. orally, by injection, by infusion, or externally); thus the
 * category determines the set of possible administration routes (e.g. for the
 * injectable category, the possible routes are IV, SC, and IM).  The category
 * also determines the form in which a dosage is specified (e.g. as a single
 * amount given at once, or as an amount of liquid given continuously over a
 * period of time), which we call a DosingType.
 *
 * A Drug is a substance, or what is sometimes called an "active ingredient"
 * (e.g. aspirin is a drug).  A combination of substances is also considered
 * a drug (e.g. artemether-lumefantrine is a drug).  Each drug may have zero
 * or more captions, which are hints to the user about the therapeutic function
 * of the drug (e.g. "analgesic") to help reduce the likelihood of error.  When
 * the same substance exists in multiple categories (e.g. amoxicillin can be
 * taken orally or injected), there is a separate Drug object in each category.
 *
 * A Format is a formulation of a drug, i.e. the manner in which the substance
 * is prepared for administration.  A format typically specifies the size and
 * mechanism of a unit of delivery (e.g. 300 mg tablets, drops, puffs), or a
 * concentration of the substance in solution (e.g. glucose 5%).  The format
 * determines the dosage unit, i.e. the unit in which doses are prescribed
 * (e.g. number of tablets, milligrams of liquid).
 *
 * Thus, the data structure hierarchy is as follows:
 *
 *         Category (dosingType, routes)
 *            -->* Drug (captions)
 *                  -->* Format (unit)
 *
 * Every Category, Drug, Format, Route, and Unit has a "code", a short, unique,
 * language-independent string identifier, which is used for serialization.
 *
 * In the MSF scheme, each Category has a four-letter code that is a prefix of
 * the Drug code, and each Drug has an eight-letter code that is a prefix of
 * the Format code.  However, these prefix relationships are not used by any
 * application logic.
 *
 * Note that, currently, we use stock codes as Format codes, which conflates
 * the formulation of drugs with the ordering of drug supplies.  This design
 * issue is as yet unresolved.
 */
public interface Catalog {
    enum DosingType {QUANTITY, QUANTITY_OVER_DURATION};

    class Category {
        public static final Category UNSPECIFIED = new Category("", "", false);

        public final String code;  // category identifier, e.g. "DORA", "DINJ", "DEXT"
        public final Intl name;  // drug category, e.g. "oral", "injectable", "external"
        public final boolean isContinuous;  // dosed continuously, in quantity over time
        public final Route[] routes;  // routes of administration
        public final Drug[] drugs;  // drugs in this category

        public Category(String code, Intl name, boolean isContinuous, Route[] routes, Drug[] drugs) {
            this.code = code;
            this.name = name;
            this.isContinuous = isContinuous;
            this.routes = routes;
            this.drugs = drugs;
        }

        public Category(String code, String name, boolean isContinuous, Route[] routes, Drug[] drugs) {
            this(code, new Intl(name), isContinuous, routes, drugs);
        }

        public Category(String code, String name, boolean isContinuous, Route... routes) {
            this(code, name, isContinuous, routes, new Drug[0]);
        }

        public Category withDrugs(Drug... drugs) {
            return new Category(code, name, isContinuous, routes, drugs);
        }

        @Override public boolean equals(Object other) {
            return other instanceof Category && eq(code, ((Category) other).code);
        }
    }

    class Drug {
        public static final Drug UNSPECIFIED = new Drug("", " ").withFormats(Format.UNSPECIFIED);

        public final String code;  // drug identifier, e.g. "DORAACSA"
        public final Intl name;  // active ingredient, title case, e.g. "Acetylsalicylic Acid"
        public final Intl[] aliases;  // alternative names, title case, e.g. {"Aspirin", "ASA"}
        public final Intl[] captions;  // therapeutic action, lowercase noun, e.g. {"analgesic", "antipyretic"}
        public final Format[] formats;

        public Drug(String code, Intl name, Intl[] aliases, Intl[] captions, Format[] formats) {
            this.code = code;
            this.name = name;
            this.aliases = aliases;
            this.captions = Utils.orDefault(captions, new Intl[0]);
            this.formats = Utils.orDefault(formats, new Format[0]);
        }

        public Drug(String code, String name, String... aliases) {
            this(code, new Intl(name), Intl.newArray(aliases), null, null);
        }

        public Drug withCaptions(Intl... captions) {
            return new Drug(code, name, aliases, captions, formats);
        }

        public Drug withFormats(Format... formats) {
            return new Drug(code, name, aliases, captions, formats);
        }

        @Override public boolean equals(Object other) {
            return other instanceof Drug && eq(code, ((Drug) other).code);
        }
    }

    class Format {
        public static final Format UNSPECIFIED = new Format("", " ", Unit.UNSPECIFIED);

        public final String code;  // stock code, e.g. "DORAACSA3TD"
        public final Intl description;  // amount, concentration, form, e.g. "300 mg, disp. tab."
        public final Unit dosageUnit;  // null means this format takes no dosage specification

        public Format(String code, String description, Unit dosageUnit) {
            this(code, new Intl(description), dosageUnit);
        }

        public Format(String code, Intl description, Unit dosageUnit) {
            this.code = code;
            this.description = description;
            this.dosageUnit = dosageUnit;
        }

        @Override public boolean equals(Object other) {
            return other instanceof Format && eq(code, ((Format) other).code);
        }

        @Override public String toString() {
            return App.localize(description);
        }
    }

    class Route {
        public static final Route UNSPECIFIED = new Route("", " ", "");

        public final String code;  // identifier code, e.g. "IV"
        public final Intl name;  // route of administration, e.g. "intravenous"
        public final Intl abbr;  // abbreviation, e.g. "IV"

        public Route(String code, String name, String abbr) {
            this.code = code;
            this.name = new Intl(name);
            this.abbr = new Intl(abbr);
        }

        @Override public boolean equals(Object other) {
            return other instanceof Route && eq(code, ((Route) other).code);
        }

        @Override public String toString() {
            return App.localize(abbr);
        }
    }

}

package org.projectbuendia.models;

import org.projectbuendia.client.utils.Intl;

import java.util.HashMap;
import java.util.Map;

import static org.projectbuendia.client.utils.Utils.eq;

public class Unit {
    private static final Map<String, Unit> registry = new HashMap<>();

    public static final Unit UNSPECIFIED = new Unit("", " ", " ", " ", "");

    public static final Unit G = new Unit("G", "gram [fr:gramme]", "grams [fr:grammes]", "g");
    public static final Unit MG = new Unit("MG", "milligram [fr:milligramme]", "milligrams [fr:milligrammes]", "mg");
    public static final Unit MCG = new Unit("MCG", "microgram [fr:microgramme]", "micrograms [fr:microgrammes]", "g");
    public static final Unit L = new Unit("L", "liter [fr:litre]", "liters [fr:litres]", "L");
    public static final Unit ML = new Unit("ML", "milliliter [fr:millilitre]", "milliliters [fr:millilitres]", "mL");
    public static final Unit IU = new Unit("IU", "IU [fr:UI]", "IU [fr:UI]", "IU");
    public static final Unit TABLET = new Unit("TABLET", "tablet [fr:comprim]", "tablets [fr:comprims]", "tab. [fr:comp.]");
    public static final Unit CAPSULE = new Unit("CAPSULE", "capsule", "capsules", "caps.");
    public static final Unit DROP = new Unit("DROP", "drop [fr:goutte]", "drops [fr:gouttes]", "drop [fr:goutte]");
    public static final Unit PUFF = new Unit("PUFF", "puff [fr:bouffe]", "puffs [fr:bouffes]", "puff [fr:bouffe]");
    public static final Unit AMPOULE = new Unit("AMPOULE", "ampoule", "ampoules", "amp.");
    public static final Unit SACHET = new Unit("SACHET", "sachet", "sachets", "sach.");
    public static final Unit OVULE = new Unit("OVULE", "ovule", "ovules", "ov.");
    public static final Unit SUPP = new Unit("SUPP", "suppository [fr:suppositoire]", "suppositories [fr:suppositoires]", "supp.");

    public static final Unit DAY = new Unit("DAY", "day [fr:jour]", "days [fr:jours]", "d [fr:j]", "d [fr:j]");
    public static final Unit HOUR = new Unit("HOUR", "hour [fr:heure]", "hours [fr:heures]", "hr", "h");
    public static final Unit MINUTE = new Unit("MINUTE", "minute", "minutes", "min");
    public static final Unit SECOND = new Unit("SECOND", "second", "seconds", "sec", "s");
    public static final Unit PER_DAY = new Unit("PER_DAY", "time per day [fr:fois par jour]", "times per day [fr:fois par jour]", "\bx per day [fr:\bx par jour]", "\bx/day [fr:\bx/jour]");

    public final String code;  // identifier code, e.g. "SECOND"
    public final Intl singular;  // singular prose, e.g. "second"
    public final Intl plural;  // plural prose, e.g. "seconds"
    public final Intl terse;  // informal short form, e.g. "sec"
    public final Intl abbr;  // standard abbreviation, e.g. "s"

    public Unit(String code, String singular, String plural, String terse) {
        this(code, singular, plural, terse, terse);
    }

    public Unit(String code, String singular, String plural, String terse, String abbr) {
        this(code, new Intl(singular), new Intl(plural), new Intl(terse), new Intl(abbr));
    }

    public Unit(String code, Intl singular, Intl plural, Intl terse, Intl abbr) {
        this.code = code;
        this.singular = singular;
        this.plural = plural;
        this.terse = terse;
        this.abbr = abbr;
        if (!code.isEmpty()) registry.put(code, this);
    }

    @Override public boolean equals(Object other) {
        return other instanceof Unit && eq(code, ((Unit) other).code);
    }

    public String toString() {
        return code;
    }

    public Intl forCount(double count) {
        return count == 1 ? singular : plural;
    }

    public Intl forCount(int count) {
        return count == 1 ? singular : plural;
    }

    public static Unit get(String code) {
        Unit unit = registry.get(code);
        return unit != null ? unit : Unit.UNSPECIFIED;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models;

import android.database.ContentObserver;
import android.database.Cursor;
import android.util.SparseArray;

import java.util.Iterator;

/**
 * A {@link TypedCursor} that uses a {@link CursorLoader} to load items from a {@link Cursor}.
 * <p/>
 * <p>This data structure is NOT thread-safe. It should only be accessed from one thread at a time,
 * generally the main thread. Furthermore, only one {@link Iterator} should be created on it at a
 * time.
 * <p/>
 * <p>This data structure does NOT notify anyone when the data set changes (i.e., it does not
 * provide a mechanism to access {@link Cursor#registerDataSetObserver}). This is because the
 * associated {@link Cursor#requery} and {@link Cursor#deactivate} methods have been deprecated. It
 * does, however, pass along {@link ContentObserver} callbacks.
 */
public class TypedCursorWithLoader<T> implements TypedCursor<T> {
    private final CursorLoader<T> mLoader;
    private final Cursor mCursor;

    private final SparseArray<T> mLoadedItems;

    public TypedCursorWithLoader(Cursor cursor, CursorLoader<T> loader) {
        mLoader = loader;
        mCursor = cursor;
        mLoadedItems = new SparseArray<>();
    }

    /**
     * {@inheritDoc}
     * <p/>
     * <p>If the backing {@link Cursor} is a database cursor, calling this method may be expensive.
     * Wherever possible, prefer to iterate.
     */
    @Override public int getCount() {
        if (mCursor.isClosed()) {
            return 0;
        }

        return mCursor.getCount();
    }

    @Override public T get(int position) {
        if (mCursor.isClosed()) {
            return null;
        }

        T convertedItem = mLoadedItems.get(position);
        if (convertedItem == null) {
            int originalPosition = mCursor.getPosition();

            if (!mCursor.moveToPosition(position)) {
                return null;
            }

            convertedItem = mLoader.load(mCursor);
            mCursor.moveToPosition(originalPosition);

            mLoadedItems.put(position, convertedItem);
        }

        return convertedItem;
    }

    @Override public Iterator<T> iterator() {
        return new LazyLoaderIterator();
    }

    @Override public void close() {
        mCursor.close();
    }

    private class LazyLoaderIterator implements Iterator<T> {

        @Override public boolean hasNext() {
            return !mCursor.isLast() && !mCursor.isAfterLast();
        }

        @Override public T next() {
            if (!mCursor.moveToNext()) {
                throw new IllegalStateException("Cannot move cursor past its last entry.");
            }

            int position = mCursor.getPosition();

            T loadedItem = mLoadedItems.get(position);
            if (loadedItem == null) {
                loadedItem = mLoader.load(mCursor);
                mLoadedItems.put(position, loadedItem);
            }

            return loadedItem;
        }

        @Override public void remove() {
            throw new UnsupportedOperationException(
                "Elements cannot be removed from an iterator backed by a cursor.");
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models;

import android.content.ContentValues;

import com.google.common.base.Optional;

import org.joda.time.LocalDate;
import org.json.JSONException;
import org.json.JSONObject;
import org.projectbuendia.client.providers.Contracts;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

/** Represents the data to write to a new patient or the data to update on a patient. */
public class PatientDelta {
    public Optional<String> id = Optional.absent();
    public Optional<String> givenName = Optional.absent();
    public Optional<String> familyName = Optional.absent();
    public Optional<Sex> sex = Optional.absent();
    public Optional<LocalDate> birthdate = Optional.absent();
    private static final Logger LOG = Logger.create();

    /** Returns the {@link ContentValues} corresponding to the delta. */
    public ContentValues toContentValues() {
        ContentValues cv = new ContentValues();

        if (id.isPresent()) {
            cv.put(Contracts.Patients.ID, id.get());
        }
        if (givenName.isPresent()) {
            cv.put(Contracts.Patients.GIVEN_NAME, givenName.get());
        }
        if (familyName.isPresent()) {
            cv.put(Contracts.Patients.FAMILY_NAME, familyName.get());
        }
        if (sex.isPresent()) {
            cv.put(Contracts.Patients.SEX, Sex.nullableNameOf(sex.get()));
        }
        if (birthdate.isPresent()) {
            cv.put(Contracts.Patients.BIRTHDATE, birthdate.get().toString());
        }
        return cv;
    }

    @Override public String toString() {
        JSONObject jsonObject = new JSONObject();
        if (toJson(jsonObject)) {
            return jsonObject.toString();
        }
        return super.toString();
    }

    /**
     * Serializes the fields changed in the delta to a {@link JSONObject}.
     * @return whether serialization succeeded
     */
    public boolean toJson(JSONObject json) {
        // TODO: Use a JsonPatient instead of all these field name constants.
        try {
            if (id.isPresent()) {
                json.put("id", id.get());
            }
            if (givenName.isPresent()) {
                json.put("given_name", givenName.get());
            }
            if (familyName.isPresent()) {
                json.put("family_name", familyName.get());
            }
            if (sex.isPresent()) {
                json.put("sex", Sex.serialize(sex.get()));
            }
            if (birthdate.isPresent()) {
                json.put("birthdate", Utils.format(birthdate.get()));
            }
            return true;
        } catch (JSONException e) {
            LOG.w(e, "Unable to serialize a patient delta to JSON.");
            return false;
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models;

/** Chart section type identifiers, used in the ChartItems.SECTION_TYPE column. */
public enum ChartSectionType {
    CHART_DIVIDER,
    FIXED_ROW,
    TILE_ROW,
    GRID_SECTION
}

package org.projectbuendia.models;

import org.projectbuendia.client.App;
import org.projectbuendia.client.utils.Utils;

import javax.annotation.Nonnull;

import static org.projectbuendia.client.utils.Utils.eq;

public class Quantity {
    public static final Quantity ZERO = new Quantity(0, Unit.UNSPECIFIED);

    public final double mag;
    public final @Nonnull Unit unit;

    public Quantity(double mag, Unit unit, Unit defaultUnit) {
        this(mag, Utils.orDefault(unit, defaultUnit));
    }

    public Quantity(double mag, Unit unit) {
        this.mag = mag;
        this.unit = unit == null ? Unit.UNSPECIFIED : unit;
    }

    public Quantity(double mag) {
        this(mag, Unit.UNSPECIFIED);
    }

    public boolean equals(Object other) {
        return other instanceof Quantity
            && eq(mag, ((Quantity) other).mag)
            && eq(unit, ((Quantity) other).unit);
    }

    public String toString() {
        return format(6);
    }

    public String format(int maxPrec) {
        String abbr = App.localize(unit.abbr);
        String suffix = abbr.startsWith("\b") ? abbr.substring(1) : " " + abbr;
        return Utils.format(mag, maxPrec) + suffix;
    }

    public String formatLong(int maxPrec) {
        String suffix = App.localize(mag == 1.0 ? unit.singular : unit.plural);
        return Utils.format(mag, maxPrec) + " " + suffix;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models;

import org.projectbuendia.client.App;
import org.projectbuendia.models.tasks.TaskFactory;
import org.projectbuendia.models.tasks.TaskModule;

import javax.inject.Singleton;

import dagger.Module;
import dagger.Provides;

/** A Dagger module that provides bindings for the {@link AppModel}. */
@Module(includes = {TaskModule.class}, complete = false, library = true)
public class AppModelModule {
    @Provides @Singleton AppModel provideAppModel(TaskFactory taskFactory) {
        return new AppModel(App.getResolver(), taskFactory);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models;

import org.joda.time.Instant;
import org.joda.time.LocalDate;
import org.joda.time.ReadableInstant;
import org.json.JSONException;
import org.json.JSONObject;
import org.projectbuendia.client.utils.Utils;

import java.util.Arrays;
import java.util.Objects;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

/** The value of an observation, represented as a union of all the possible data types. */
public final class ObsValue implements Comparable<ObsValue> {
    /** The observed value as a concept UUID, if the observation is for a coded concept. */
    public final @Nullable String uuid;

    /** The observed numeric value, if the observation is for a numeric concept. */
    public final @Nullable Double number;

    /** The observed string value, if the observation is for a text concept. */
    public final @Nullable String text;

    /** The observed value as a LocalDate, if the observation is for a calendar date. */
    public final @Nullable LocalDate date;

    /** The observed value as an Instant, if the observation is for an instant in time. */
    public final @Nullable Instant instant;

    /**
     * The localized name of the observed value concept (specified in the 'uuid' field).
     * This is initially null, not used for comparison, and filled in only as needed for display.
     */
    public @Nullable String name;

    public static final ObsValue MIN_VALUE = ObsValue.newCoded(false);
    public static final ObsValue MAX_VALUE = ObsValue.newTime(Long.MAX_VALUE);
    public static final ObsValue MIN_DATE = ObsValue.newDate(Utils.MIN_DATE);
    public static final ObsValue MAX_DATE = ObsValue.newDate(Utils.MAX_DATE);
    public static final ObsValue MIN_TIME = ObsValue.newTime(Utils.MIN_TIME);
    public static final ObsValue MAX_TIME = ObsValue.newTime(Utils.MAX_TIME);
    public static final ObsValue ZERO = ObsValue.newNumber(0);
    public static final ObsValue FALSE = ObsValue.newCoded(false);
    public static final ObsValue TRUE = ObsValue.newCoded(true);

    // All constructors must honour the invariant that exactly one field is non-null.

    public static ObsValue newCoded(boolean bool) {
        return newCoded(ConceptUuids.toUuid(bool));
    }

    public static ObsValue newCoded(@Nonnull String uuid) {
        return new ObsValue(uuid, null, null, null, null);
    }

    public static ObsValue newCoded(@Nonnull String uuid, String name) {
        ObsValue ov = ObsValue.newCoded(uuid);
        ov.name = name;
        return ov;
    }

    public static ObsValue newNumber(double number) {
        return new ObsValue(null, number, null, null, null);
    }

    public static ObsValue newText(@Nonnull String text) {
        return new ObsValue(null, null, text, null, null);
    }

    public static ObsValue newDate(@Nonnull LocalDate date) {
        return new ObsValue(null, null, null, date, null);
    }

    public static ObsValue newTime(@Nonnull ReadableInstant instant) {
        return new ObsValue(null, null, null, null, instant);
    }

    public static ObsValue newTime(long millis) {
        return new ObsValue(null, null, null, null, new Instant(millis));
    }

    public boolean asBoolean() {
        if (uuid != null) {
            return !(
                uuid.equals(ConceptUuids.NO_UUID) ||
                uuid.equals(ConceptUuids.NONE_UUID) ||
                uuid.equals(ConceptUuids.NORMAL_UUID) ||
                uuid.equals(ConceptUuids.UNKNOWN_UUID)
            );
        } else if (number != null) {
            return number != 0;
        } else if (text != null) {
            return !text.isEmpty();
        } else if (date != null) {
            return true;
        } else if (instant != null) {
            return true;
        }
        return false;
    }

    @Override public String toString() {
        if (uuid != null) {
            return "ObsValue(uuid=" + uuid + ", name=" + name + ")";
        } else if (number != null) {
            return "ObsValue(number=" + number + ")";
        } else if (text != null) {
            return "ObsValue(text=" + text + ")";
        } else if (date != null) {
            return "ObsValue(date=" + date + ")";
        } else if (instant != null) {
            return "ObsValue(instant=" + instant + ")";
        } else {
            throw new IllegalStateException();  // this should never happen
        }
    }

    public JSONObject toJson() throws JSONException {
        JSONObject jo = new JSONObject();
        if (uuid != null) {
            jo.put("uuid", uuid);
        } else if (number != null) {
            jo.put("number", number);
        } else if (text != null) {
            jo.put("text", text);
        } else if (date != null) {
            jo.put("date", date.toString());  // LocalDate gives a string in yyyy-mm-dd format
        } else if (instant != null) {
            jo.put("instant", instant.getMillis());
        }
        return jo;
    }

    @Override public boolean equals(Object other) {
        if (!(other instanceof ObsValue)) return false;
        ObsValue o = (ObsValue) other;
        return Objects.equals(uuid, o.uuid)  // compare only the final fields
            && Objects.equals(number, o.number)
            && Objects.equals(text, o.text)
            && Objects.equals(date, o.date)
            && Objects.equals(instant, o.instant);
    }

    @Override public int hashCode() {
        return Arrays.hashCode(new Object[] {
            number, text, uuid, date, instant  // hash only the final fields
        });
    }

    // TODO(ping): This should subsume Obs.compareTo().  Boolean "true" should
    // be greater than all values, and date values should be sorted among
    // instant values.
    /**
     * Compares ObsValue instances according to a total ordering such that:
     * - All non-null values are greater than null.
     * - The lowest value is the "false" Boolean value (encoded as the coded concept for "No").
     * - Next are all coded values, ordered from least severe to most severe (if they can
     *   be interpreted as having a severity); or from first to last (if they can
     *   be interpreted as having a typical temporal sequence).
     * - Next is the "true" Boolean value (encoded as the coded concept for "Yes").
     * - Next are all numeric values, ordered from least to greatest.
     * - Next are all text values, ordered lexicographically from A to Z.
     * - Next are all date values, ordered from least to greatest.
     * - Next are all instant values, ordered from least to greatest.
     * @param other The other Value to compare to.
     * @return
     */
    @Override public int compareTo(@Nullable ObsValue other) {
        if (other == null) return 1;
        int result = 0;
        result = Integer.compare(getTypeOrdering(), other.getTypeOrdering());
        if (result != 0) return result;
        if (uuid != null) {
            result = ConceptUuids.compareUuids(uuid, other.uuid);
        } else if (number != null) {
            result = Double.compare(number, other.number);
        } else if (text != null) {
            result = text.compareTo(other.text);
        } else if (date != null) {
            result = date.compareTo(other.date);
        } else if (instant != null) {
            result = instant.compareTo(other.instant);
        }
        return result;
    }

    /** This constructor is private so that we can ensure exactly one field is non-null. */
    private ObsValue(@Nullable String uuid, @Nullable Double number, @Nullable String text,
                     @Nullable LocalDate date, @Nullable ReadableInstant instant) {
        this.uuid = uuid;
        this.number = number;
        this.text = text;
        this.date = date;
        this.instant = instant != null ? new Instant(instant) : null;
    }

    /** Gets a number specifying the ordering of ObsValues of different types. */
    private int getTypeOrdering() {
        return uuid != null ? 1
            : number != null ? 2
            : text != null ? 3
            : date != null ? 4
            : instant != null ? 5
            : 0;  // this 0 case should never happen
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models;

import java.util.ArrayList;
import java.util.List;

/** A chart definition. */
public class Chart {
    // TODO(ping): Support multiple charts stored in multiple forms.  Right now,
    // there is no UUID field because there is only ever a single chart form.

    public final String name;
    public final List<ChartSection> fixedGroups;
    public final List<ChartSection> tileGroups;
    public final List<ChartSection> rowGroups;

    public Chart(String name) {
        this.name = name;
        this.fixedGroups = new ArrayList<>();
        this.tileGroups = new ArrayList<>();
        this.rowGroups = new ArrayList<>();
    }
}

package org.projectbuendia.models;

import org.projectbuendia.models.Catalog.Category;
import org.projectbuendia.models.Catalog.Drug;
import org.projectbuendia.models.Catalog.Format;
import org.projectbuendia.models.Catalog.Route;

import java.util.HashMap;
import java.util.Map;

import static org.projectbuendia.client.utils.Utils.eq;

public class CatalogIndex {
    Category[] categories = {};
    Map<String, Drug> drugs = new HashMap<>();
    Map<String, Format> formats = new HashMap<>();
    Route[] routes = {};
    Unit[] dosageUnits = {};
    Unit[] durationUnits = {};

    public CatalogIndex(Category... categories) {
        this.categories = categories;
        for (Category category : categories) {
            for (Drug drug : category.drugs) {
                drugs.put(drug.code, drug);
                for (Format format : drug.formats) {
                    formats.put(format.code, format);
                }
            }
        }
    }

    public CatalogIndex withRoutes(Route... routes) {
        this.routes = routes;
        return this;
    }

    public CatalogIndex withDosageUnits(Unit... units) {
        this.dosageUnits = units;
        return this;
    }

    public CatalogIndex withDurationUnits(Unit... units) {
        this.durationUnits = units;
        return this;
    }

    public Category[] getCategories() {
        return categories;
    }

    public Drug getDrug(String code) {
        if (code.length() > 8) code = code.substring(0, 8);
        if (drugs.containsKey(code)) {
            return drugs.get(code);
        }
        return Drug.UNSPECIFIED;
    }

    public Format getFormat(String code) {
        code = code.replaceAll("-*$", "");
        if (formats.containsKey(code)) {
            return formats.get(code);
        }
        return Format.UNSPECIFIED;
    }

    public Route getRoute(String code) {
        for (Route route : routes) {
            if (eq(code, route.code)) return route;
        }
        return Route.UNSPECIFIED;
    }

    public Unit[] getDosageUnits() {
        return dosageUnits;
    }

    public Unit[] getDurationUnits() {
        return durationUnits;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models;

import android.os.Parcel;
import android.os.Parcelable;
import android.support.annotation.NonNull;

import org.joda.time.DateTime;
import org.json.JSONException;
import org.json.JSONObject;
import org.projectbuendia.client.json.Datatype;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.io.Serializable;
import java.util.Arrays;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import static com.google.common.base.Preconditions.checkNotNull;
import static org.projectbuendia.client.utils.Utils.eq;

// TODO(ping): Here's the data model we want to get to.
//
// Obs obs {  // a sourced data point (where did it come from), ordered by time
//     String uuid;
//     String providerUuid;
//     String encounterUuid;
//     String patientUuid;
//     String conceptUuid;
//     String orderUuid;
//     ObsPoint point {  // a timed value (when was it recorded), ordered by time
//         DateTime time;
//         ObsValue value {  // a polymorphic union, ordered by magnitude
//             Datatype type;
//             String serializedValue;
//         }
//     }
//

/** A simple bean class representing an observation with localized names and values. */
// TODO: Make ObsPoint a member of Obs; change the structure of Obs to be simply:
// { final @Nonnull String uuid; String name; final @Nonnull ObsPoint point; } then delete
// getObsPoint(), getObsValue(), compareTo(), getTypeOrdering(), getCodedValueOrdering().
public final class Obs extends Model implements Comparable<Obs>, Parcelable, Serializable {
    private static Logger LOG = Logger.create();

    /** The encounter during which this observation was taken. */
    public final @Nullable String encounterUuid;

    /** The patient for which this observation was taken (null if yet to be created). */
    public final @Nullable String patientUuid;

    /** The provider that recorded this observation. */
    public final @Nullable String providerUuid;

    /** The UUID of the concept that was observed. */
    public final @Nonnull String conceptUuid;

    /** The data type of the value that was observed. */
    public final @Nonnull Datatype type;

    /** The time at which this observation was taken. */
    public final @Nonnull DateTime time;

    /** The UUID of the order, if there is a related order. */
    public final @Nullable String orderUuid;

    /** The observed value (a string, number as a string, or answer concept UUID). */
    public final @Nullable String value;

    /** The name of the answer concept, if the value is an answer concept. */
    public final @Nullable String valueName;

    public Obs(
        @Nullable String uuid,
        @Nullable String encounterUuid,
        @Nullable String patientUuid,
        @Nullable String providerUuid,
        @Nonnull String conceptUuid,
        @Nonnull Datatype type,
        @Nonnull DateTime time,
        @Nullable String orderUuid,
        @Nullable String value,
        @Nullable String valueName) {
        super(uuid);
        this.encounterUuid = encounterUuid;
        this.patientUuid = patientUuid;
        this.providerUuid = providerUuid;
        this.conceptUuid = checkNotNull(conceptUuid);
        this.type = type;
        this.time = time;
        this.orderUuid = orderUuid;
        this.value = value;
        this.valueName = valueName;
    }

    /** Returns the time and value of this observation as an ObsPoint. */
    public @Nullable ObsPoint getObsPoint() {
        ObsValue ov = getObsValue();
        return ov != null ? new ObsPoint(time, ov) : null;
    }

    /** Returns the value of this observation as an ObsValue. */
    public @Nullable ObsValue getObsValue() {
        if (value == null || type == null) return null;
        switch (type) {
            case CODED:
                return ObsValue.newCoded(value, valueName);
            case NUMERIC:
                return ObsValue.newNumber(Double.valueOf(value));
            case TEXT:
                return ObsValue.newText(value);
            case BOOLEAN:
                return ObsValue.newCoded(ConceptUuids.isYes(value));
            case DATE:
                return ObsValue.newDate(Utils.toLocalDate(value));
            case DATETIME:
                return ObsValue.newTime(Long.valueOf(value));
        }
        return null;
    }

    @Override public String toString() {
        return "Obs(uuid=" + uuid
            + ", patientUuid=" + patientUuid
            + ", time=" + time
            + ", conceptUuid=" + conceptUuid
            + ", type=" + type
            + ", value=" + value
            + ", valueName=" + valueName + ")";
    }

    @Override public boolean equals(Object other) {
        // This compares all fields because ChartRenderer relies on this
        // equals() method to decide whether to re-render the chart grid.
        if (other instanceof Obs) {
            Obs o = (Obs) other;
            return eq(uuid, o.uuid)
                && eq(patientUuid, o.patientUuid)
                && eq(time, o.time)
                && eq(conceptUuid, o.conceptUuid)
                && eq(type, o.type)
                && eq(value, o.value)
                && eq(valueName, o.valueName);
        } else {
            return false;
        }
    }

    @Override public int hashCode() {
        return Arrays.hashCode(new Object[] {
            time, conceptUuid, type, value, valueName
        });
    }

    // TODO(ping): This should be the comparison operator on ObsValue, not Obs.
    // The natural comparison order for Obs should be chronological.
    /**
     * Compares value instances according to a total ordering such that:
     * - The empty value (present == false) is ordered before all others.
     * - The Boolean value false is ordered before all other values and types.
     * - Numeric values are ordered from least to greatest magnitude.
     * - Text values are ordered lexicographically from A to Z.
     * - Coded values are ordered from least severe to most severe (if they can
     * be interpreted as having a severity); or from first to last (if they can
     * be interpreted as having a typical temporal sequence).
     * - The Boolean value true is ordered after all other values and types.
     * @param other The other Value to compare to.
     * @return
     */
    @Override public int compareTo(@NonNull Obs other) {
        if (value == null || other.value == null) {
            return value == other.value ? 0 : value != null ? 1 : -1;
        }
        if (type != other.type) {
            return Integer.compare(getTypeOrdering(), other.getTypeOrdering());
        }
        if (type == Datatype.NUMERIC) {
            return Double.valueOf(value).compareTo(Double.valueOf(other.value));
        }
        if (type == Datatype.CODED || type == Datatype.BOOLEAN) {
            return ConceptUuids.compareUuids(value, other.value);
        }
        return value.compareTo(other.value);
    }

    /** Gets a number defining the ordering of Values of different types. */
    public int getTypeOrdering() {
        switch (type) {
            case BOOLEAN:
                return ConceptUuids.isYes(value) ? 5 : 1;
            case NUMERIC:
                return 2;
            case TEXT:
                return 3;
            case CODED:
                return 4;
        }
        return 0;
    }

    public JSONObject toJson() throws JSONException {
        JSONObject json = new JSONObject();
        if (Utils.hasChars(uuid)) json.put("uuid", uuid);
        json.put("encounter_uuid", encounterUuid);
        json.put("patient_uuid", patientUuid);
        json.put("provider_uuid", providerUuid);
        json.put("concept_uuid", conceptUuid);
        json.put("type", Datatype.serialize(type));
        json.put("time", Utils.formatUtc8601(time));
        json.put("order_uuid", orderUuid);
        if (value != null) {
            if (type == Datatype.BOOLEAN || type == Datatype.CODED) {
                json.put("value_coded", value);
            } else if (type == Datatype.NUMERIC) {
                json.put("value_numeric", Double.valueOf(value));
            } else if (type == Datatype.TEXT) {
                json.put("value_text", value);
            } else if (type == Datatype.DATE) {
                json.put("value_date", value);
            } else if (type == Datatype.DATETIME) {
                // Obs stores DATETIME in millis, but we want ISO8601 for JSON.
                json.put("value_datetime", Utils.formatUtc8601(new DateTime(Long.valueOf(value))));
            } else {
                LOG.w("Ignoring Obs with unknown type: %s", this);
            }
        }
        return json;
    }

    // ==== Parcelable protocol ====

    public static final Parcelable.Creator<Obs> CREATOR = new Parcelable.Creator<Obs>() {
        public Obs createFromParcel(Parcel src) {
            return new Obs(
                src.readString(),
                src.readString(),
                src.readString(),
                src.readString(),
                src.readString(),
                Datatype.deserialize(src.readString()),
                new DateTime(src.readLong()),
                src.readString(),
                src.readString(),
                src.readString()
            );
        }

        public Obs[] newArray(int size) {
            return new Obs[size];
        }
    };

    public int describeContents() {
        return 0;
    }

    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(uuid);
        dest.writeString(encounterUuid);
        dest.writeString(patientUuid);
        dest.writeString(providerUuid);
        dest.writeString(conceptUuid);
        dest.writeString(type != null ? type.name() : null);
        dest.writeLong(time.getMillis());
        dest.writeString(orderUuid);
        dest.writeString(value);
        dest.writeString(valueName);
    }
}

package org.projectbuendia.models;

import android.content.ContentResolver;
import android.database.ContentObserver;
import android.database.Cursor;
import android.net.Uri;
import android.os.Handler;

import org.projectbuendia.client.providers.Contracts;
import org.projectbuendia.client.utils.Utils;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import javax.annotation.Nonnull;

import static org.projectbuendia.client.utils.Utils.eq;

public class LocationForestProvider {
    private LocationForest currentForest = null;
    private Locale currentLocale = null;
    private Runnable onForestReplacedListener = null;

    private final ContentResolver resolver;
    private final ContentObserver locationChangeObserver = new ContentObserver(new Handler()) {
        public void onChange(boolean selfChange) {
            currentForest = null;
            if (onForestReplacedListener != null) {
                onForestReplacedListener.run();
            }
        }
    };
    private final ContentObserver patientChangeObserver = new ContentObserver(new Handler()) {
        public void onChange(boolean selfChange) {
            if (currentForest != null) {
                currentForest.updatePatientCounts(getPatientCountsByLocationUuid());
            }
        }
    };

    public LocationForestProvider(ContentResolver resolver) {
        this.resolver = resolver;
        resolver.registerContentObserver(
            Contracts.Locations.URI, true, locationChangeObserver);
        resolver.registerContentObserver(
            Contracts.Patients.URI, true, patientChangeObserver);
    }

    public void dispose() {
        resolver.unregisterContentObserver(locationChangeObserver);
        resolver.unregisterContentObserver(patientChangeObserver);
    }

    public @Nonnull LocationForest getForest(Locale locale) {
        if (currentForest != null && eq(currentLocale, locale)) {
            return currentForest;
        }
        currentForest = loadForest(locale);
        currentLocale = locale;
        return currentForest;
    }

    public void setOnForestReplacedListener(Runnable listener) {
        onForestReplacedListener = listener;
    }

    private LocationForest loadForest(Locale locale) {
        List<LocationForest.Record> records = new ArrayList<>();
        Uri uri = Contracts.Locations.URI;
        Map<String, Integer> countsByUuid = getPatientCountsByLocationUuid();
        try (Cursor cursor = resolver.query(uri, null, null, null, null)) {
            while (cursor.moveToNext()) {
                String uuid = Utils.getString(cursor, Contracts.Locations.UUID, "");
                String name = Utils.getString(cursor, Contracts.Locations.NAME, "?");
                String parentUuid = Utils.getString(cursor, Contracts.Locations.PARENT_UUID);
                records.add(new LocationForest.Record(
                    uuid, parentUuid, name, Utils.getOrDefault(countsByUuid, uuid, 0)
                ));
            }
        }
        return new LocationForest(records, locale);
    }

    private Map<String, Integer> getPatientCountsByLocationUuid() {
        Uri uri = Contracts.PatientCounts.URI;
        Map<String, Integer> countsByLocationUuid = new HashMap<>();
        try (Cursor cursor = resolver.query(uri, null, null, null, null)) {
            while (cursor.moveToNext()) {
                String locationUuid = Utils.getString(cursor, Contracts.PatientCounts.LOCATION_UUID);
                Integer count = Utils.getInt(cursor, Contracts.PatientCounts.PATIENT_COUNT);
                countsByLocationUuid.put(locationUuid, count);
            }
        }
        return countsByLocationUuid;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models;

import com.google.common.base.Joiner;

import org.projectbuendia.client.ui.chart.ObsFormat;
import org.projectbuendia.client.utils.Utils;

import java.text.Format;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

/** A tile or a grid row in a chart (i.e. a formatted unit). */
public class ChartItem {
    public final @Nonnull String label;
    public final @Nonnull String type;
    public final boolean required;
    public final @Nonnull String[] conceptIds;
    public final @Nonnull String[] conceptUuids;
    public final @Nonnull String conceptUuidsList;
    public final @Nullable Format format;
    public final @Nullable Format captionFormat;
    public final @Nullable Format cssClass;
    public final @Nonnull String cssStyle;
    public final @Nonnull String script;

    public ChartItem(@Nullable String label, @Nullable String type, boolean required,
                     @Nullable String[] conceptUuids, @Nullable String format,
                     @Nullable String captionFormat, @Nullable String cssClass,
                     @Nullable String cssStyle, @Nullable String script) {
        this(label, type, required, conceptUuids,
            ObsFormat.fromPattern(format), ObsFormat.fromPattern(captionFormat),
            ObsFormat.fromPattern(cssClass), cssStyle, script);
    }

    public ChartItem(@Nullable String label, @Nullable String type, boolean required,
                     @Nullable String[] conceptUuids, @Nullable Format format,
                     @Nullable Format captionFormat, @Nullable Format cssClass,
                     @Nullable String cssStyle, @Nullable String script) {
        this.label = Utils.toNonnull(label);
        this.type = Utils.toNonnull(type);
        this.required = required;
        this.conceptUuids = Utils.orDefault(conceptUuids, new String[0]);
        this.format = format;
        this.captionFormat = captionFormat;
        this.cssClass = cssClass;
        this.cssStyle = cssStyle;
        this.script = Utils.toNonnull(script);
        this.conceptUuidsList = Joiner.on(",").join(this.conceptUuids);
        this.conceptIds = new String[this.conceptUuids.length];
        for (int i = 0; i < this.conceptIds.length; i++) {
            this.conceptIds[i] = "" + Utils.compressUuid(this.conceptUuids[i]);
        }
    }

    public ChartItem withDefaults(@Nullable ChartItem defaults) {
        Format format = this.format;
        Format captionFormat = this.captionFormat;
        Format cssClass = this.cssClass;
        String cssStyle = this.cssStyle;
        String script = this.script;
        if (defaults != null) {
            format = Utils.orDefault(format, defaults.format);
            captionFormat = Utils.orDefault(captionFormat, defaults.captionFormat);
            cssClass = Utils.orDefault(cssClass, defaults.cssClass);
            cssStyle = Utils.orDefault(cssStyle, defaults.cssStyle);
            script = Utils.isEmpty(script) ? defaults.script : script;
        }
        return new ChartItem(label, type, required, conceptUuids,
            format, captionFormat, cssClass, cssStyle, script);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models;

import android.content.ContentValues;
import android.database.Cursor;

import org.joda.time.DateTime;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.projectbuendia.client.json.Datatype;
import org.projectbuendia.client.json.JsonEncounter;
import org.projectbuendia.client.json.JsonObservation;
import org.projectbuendia.client.providers.Contracts.Observations;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.util.ArrayList;
import java.util.List;

import javax.annotation.Nullable;
import javax.annotation.concurrent.Immutable;

/**
 * An encounter in the app model. Encounters contain one or more observations taken at a particular
 * timestamp. For more information on encounters and observations, see the official OpenMRS
 * documentation here:
 * <a href="https://wiki.openmrs.org/display/docs/Encounters+and+observations">
 * https://wiki.openmrs.org/display/docs/Encounters+and+observations"
 * </a>
 * <p/>
 * <p>NOTE: Because of lack of typing info from the server, {@link Encounter} attempts to
 * determine the most appropriate type, but this typing is not guaranteed to succeed; also,
 * currently only <code>DATE</code> and <code>UUID</code> (coded) types are supported.
 */
@Immutable
public class Encounter extends Model {
    private static final Logger LOG = Logger.create();

    public final String patientUuid;
    public final String providerUuid;
    public final DateTime time;
    public final Obs[] observations;

    public Encounter(@Nullable String uuid, String patientUuid, String providerUuid,
                     DateTime time, Obs[] observations) {
        super(uuid);
        this.patientUuid = patientUuid;
        this.providerUuid = providerUuid;
        this.time = time;
        this.observations = Utils.orDefault(observations, new Obs[0]);
    }

    public static Encounter fromJson(JsonEncounter encounter) {
        List<Obs> observations = new ArrayList<>();
        if (encounter.observations != null) {
            for (JsonObservation obs : encounter.observations) {
                observations.add(new Obs(
                    obs.uuid, encounter.uuid, encounter.patient_uuid, encounter.provider_uuid,
                    obs.concept_uuid, obs.type, obs.time, obs.order_uuid, obs.getValueAsString(), null
                ));
            }
        }
        return new Encounter(encounter.uuid, encounter.patient_uuid, encounter.provider_uuid,
            encounter.time, observations.toArray(new Obs[0]));
    }

    /** Serializes this into a {@link JSONObject}. */
    public JSONObject toJson() throws JSONException {
        JSONObject json = new JSONObject();
        json.put("patient_uuid", patientUuid);
        json.put("time", Utils.formatUtc8601(time));
        if (observations.length > 0) {
            JSONArray jsonObsArray = new JSONArray();
            for (Obs obs : observations) {
                jsonObsArray.put(obs.toJson());
            }
            json.put("observations", jsonObsArray);
        }
        return json;
    }

    /**
     * Converts this Encounter to an array of ContentValues objects for
     * insertion into a database or content provider.
     */
    public ContentValues[] toContentValuesArray() {
        ContentValues[] cvs = new ContentValues[observations.length];
        int i = 0;
        for (Obs obs : observations) {
            ContentValues cv = new ContentValues();
            cv.put(Observations.UUID, obs.uuid);
            cv.put(Observations.ENCOUNTER_UUID, uuid);
            cv.put(Observations.PATIENT_UUID, patientUuid);
            cv.put(Observations.PROVIDER_UUID, providerUuid);
            cv.put(Observations.CONCEPT_UUID, obs.conceptUuid);
            cv.put(Observations.TYPE, obs.type.name());
            cv.put(Observations.MILLIS, time.getMillis());
            cv.put(Observations.ORDER_UUID, obs.orderUuid);
            cv.put(Observations.VALUE, obs.value);
            cvs[i++] = cv;
        }
        return cvs;
    }

    /**
     * A CursorLoader that loads Encounters.  Expects the Cursor to contain only
     * a single encounter, represented by multiple observations, with one observation per row.
     */
    public static Encounter load(Cursor cursor) {
        String encounterUuid = null;
        String patientUuid = null;
        String providerUuid = null;
        DateTime time = null;
        List<Obs> observations = new ArrayList<>();
        do { // cursor is already at the first matching observation
            String uuid = Utils.getString(cursor, Observations.UUID);
            encounterUuid = Utils.getString(cursor, Observations.ENCOUNTER_UUID);
            patientUuid = Utils.getString(cursor, Observations.PATIENT_UUID);
            providerUuid = Utils.getString(cursor, Observations.PROVIDER_UUID);
            String conceptUuid = Utils.getString(cursor, Observations.CONCEPT_UUID);
            Datatype type = Datatype.valueOf(Utils.getString(cursor, Observations.TYPE));
            time = Utils.getDateTime(cursor, Observations.MILLIS);
            String orderUuid = Utils.getString(cursor, Observations.ORDER_UUID);
            String value = Utils.getString(cursor, Observations.VALUE);
            observations.add(new Obs(
                uuid, encounterUuid, patientUuid, providerUuid,
                conceptUuid, type, time, orderUuid, value, null
            ));
        } while (cursor.moveToNext());
        if (encounterUuid != null && patientUuid != null && time != null) {
            return new Encounter(encounterUuid, patientUuid, providerUuid,
                time, observations.toArray(new Obs[observations.size()]));
        }
        return null; // PATIENT_UUID should never be null, so this should never happen
    }

    /** For developer use only, to help fabricate a response from a nonexistent server. */
    public Encounter withUuid(String uuid) {
        return new Encounter(uuid, patientUuid, providerUuid, time, observations);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models;

import android.database.Cursor;

/**
 * A {@link Cursor}-like object that returns items of a specific type.
 * Implementations are most likely NOT thread-safe.
 */
public interface TypedCursor<T> extends Iterable<T> {
    /** Returns the number of items available. */
    int getCount();

    /** Returns the item at a given index, or null if the index is out of range. */
    T get(int index);

    /** Releases any held resources. */
    void close();
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models;

import android.content.Context;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;

/** A {@link BaseAdapter} backed by a {@link TypedCursor}. */
public abstract class TypedCursorAdapter<T extends Model> extends BaseAdapter {

    private final Context mContext;
    private TypedCursor<T> mTypedCursor;

    public TypedCursorAdapter(Context context, TypedCursor<T> typedCursor) {
        mContext = context;
        mTypedCursor = typedCursor;
    }

    @Override public int getCount() {
        return mTypedCursor != null ? mTypedCursor.getCount() : 0;
    }

    @Override public long getItemId(int position) {
        if (mTypedCursor == null) {
            return 0;
        }
        T item = mTypedCursor.get(position);
        return item != null ? item.hashCode() : 0;
    }

    @Override public boolean hasStableIds() {
        return true;
    }

    @Override public View getView(int position, View convertView, ViewGroup parent) {
        if (mTypedCursor == null) {
            throw new IllegalStateException(
                "Cannot get a view when no backing lazy array has been set.");
        }

        View view =
            convertView == null
                ? newView(mContext, mTypedCursor.get(position), parent)
                : convertView;
        bindView(mContext, view, getItem(position));

        return view;
    }

    protected abstract View newView(Context context, T item, ViewGroup parent);

    protected abstract void bindView(Context context, View view, T item);

    // TODO: Provide a mechanism to filter, similar to Cursor.

    @Override public T getItem(int position) {
        return mTypedCursor == null ? null : mTypedCursor.get(position);
    }

    /**
     * Changes the attached {@link TypedCursor} to the specified value, closing the currently
     * attached {@link TypedCursor} if it exists.
     */
    public void changeTypedCursor(TypedCursor<T> newTypedCursor) {
        if (mTypedCursor == newTypedCursor) return;

        if (mTypedCursor != null) {
            mTypedCursor.close();
        }

        mTypedCursor = newTypedCursor;
        if (mTypedCursor == null) {
            notifyDataSetInvalidated();
        } else {
            notifyDataSetChanged();
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models;

import org.projectbuendia.client.utils.Utils;

import javax.annotation.Nonnull;
import javax.annotation.concurrent.Immutable;

/** The app model for a location, including its localized name. */
public final @Immutable class Location extends Model {
    public @Nonnull String name;

    /** Creates an instance of {@link Location}. */
    public Location(@Nonnull String uuid, String name) {
        super(uuid);
        this.name = Utils.toNonnull(name);
    }

    @Override public String toString() {
        return Utils.format("<Location %s [%s]>", Utils.repr(name), uuid);
    }
}

package org.projectbuendia.models;

public interface MsfCatalog extends Catalog {
    Route UNSPECIFIED = new Route("", "", "");
    Route PO = new Route("PO", "oral [fr:orale]", "PO");
    Route IV = new Route("IV", "intravenous [fr:intraveineuse]", "IV");
    Route SC = new Route("SC", "subcutaneous [fr:sous-cutane", "SC");
    Route IM = new Route("IM", "intramuscular [fr:intramusculaire]", "IM");
    Route IO = new Route("IO", "intraosseous [fr:intraosseux]", "IO");
    Route OC = new Route("OC", "ocular [fr:oculaire]", "OC");

    // ==== BEGIN GENERATED OUTPUT ====
    // Produced by executing: get_meds -s 2 -e 3 -f 4 -E 7 -F 8 mml-buendia.xlsx

    Category ORAL = new Category("DORA", "oral", false, PO).withDrugs(
        new Drug("DORAABCV", "ABACAVIR sulfate (ABC) [fr:ABACAVIR sulfate (ABC)]").withFormats(
            new Format("DORAABCV3T", "eq. 300 mg base, tab. [fr:q. 300 mg base, comp.]", Unit.TABLET),
            new Format("DORAABCV6TD", "60 mg, disp. tab. [fr:60 mg, comp. disp.]", Unit.TABLET)
        ),
        new Drug("DORAABLA", "ABC / 3TC [fr:ABC / 3TC]").withFormats(
            new Format("DORAABLA1TD", "60 mg / 30 mg, disp. tab. [fr:60 mg / 30 mg, comp. disp.]", Unit.TABLET),
            new Format("DORAABLA2T3", "600 mg / 300 mg, tab. [fr:600 mg / 300 mg, comp.]", Unit.TABLET),
            new Format("DORAABLA3TD", "120 mg / 60 mg, disp. tab. [fr:120 mg / 60 mg, comp. disp.]", Unit.TABLET)
        ),
        new Drug("DORAABLZ", "ABC / 3TC / AZT [fr:ABC / 3TC / AZT]").withFormats(
            new Format("DORAABLZ1T", "60 mg / 30 mg / 60 mg, tab. [fr:60 mg / 30 mg / 60 mg, comp.]", Unit.TABLET),
            new Format("DORAABLZ2T", "300 mg / 150 mg / 300 mg, tab. [fr:300 mg / 150 mg / 300 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAACEN", "ACENOCOUMAROL [fr:ACENOCOUMAROL]").withFormats(
            new Format("DORAACEN4T", "4 mg, tab. [fr:4 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAACET", "ACETAZOLAMIDE [fr:ACETAZOLAMIDE]").withFormats(
            new Format("DORAACET2T", "250 mg, tab. [fr:250 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAACIV", "ACICLOVIR [fr:ACICLOVIR]").withFormats(
            new Format("DORAACIV2T", "200 mg, tab. [fr:200 mg, comp.]", Unit.TABLET),
            new Format("DORAACIV4T", "400 mg, tab. [fr:400 mg, comp.]", Unit.TABLET),
            new Format("DORAACIV8T", "800 mg, tab. [fr:800 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAACSA", "ACETYLSALICYLIC acid (aspirin) [fr:Acide ACETYLSALICYLIQUE (aspirine)]").withFormats(
            new Format("DORAACSA3T", "300 mg, tab. [fr:300 mg, comp.]", Unit.TABLET),
            new Format("DORAACSA3TD", "300 mg, disp. tab. [fr:300 mg, comp. disp.]", Unit.TABLET),
            new Format("DORAACSA5T", "500 mg, tab. [fr:500 mg, comp.]", Unit.TABLET),
            new Format("DORAACSA7TG", "75 mg, gastro-resistant tab. [fr:75 mg, comp. gastrors.]", Unit.TABLET)
        ),
        new Drug("DORAALBE", "ALBENDAZOLE [fr:ALBENDAZOLE]").withFormats(
            new Format("DORAALBE1S", "200 mg / 5 ml, oral susp., 10 ml, bot. [fr:200 mg / 5 ml, susp. orale, 10 ml, fl.]", Unit.ML),
            new Format("DORAALBE2T", "200 mg, tab. [fr:200 mg, comp.]", Unit.TABLET),
            new Format("DORAALBE4T", "400 mg, tab. [fr:400 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAALLO", "ALLOPURINOL [fr:ALLOPURINOL]").withFormats(
            new Format("DORAALLO1T", "100 mg, tab. [fr:100 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAALUM", "ALUMINIUM hydroxide / MAGNESIUM hydroxide [fr:ALUMINIUM hydroxyde / MAGNESIUM hydroxyde]").withFormats(
            new Format("DORAALUM44TC", "400 mg / 400 mg, chew. tab. [fr:400 mg / 400 mg, cp.  mcher]", Unit.TABLET)
        ),
        new Drug("DORAAMIO", "AMIODARONE hydrochloride [fr:AMIODARONE chlorhydrate]").withFormats(
            new Format("DORAAMIO2T", "200 mg, tab. [fr:200 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAAMIT", "AMITRIPTYLINE hydrochloride [fr:AMITRIPTYLINE chlorhydrate]").withFormats(
            new Format("DORAAMIT2T", "25 mg, tab. [fr:25 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAAMLO", "AMLODIPINE [fr:AMLODIPINE]").withFormats(
            new Format("DORAAMLO5T", "5 mg, tab. [fr:5 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAAMOC", "AMOXICILLIN / CLAVULANIC acid [fr:AMOXICILLINE / acide CLAVULANIQUE]").withFormats(
            new Format("DORAAMOC1S6", "500 mg / 62.5 mg / 5 ml, powder oral susp 60 ml [fr:500 mg / CLAVULANIQUE62.5 mg / 5 ml, poudre susp. orale 60 ml]", Unit.ML),
            new Format("DORAAMOC22TD", "200 mg / 28.5 mg, disp. tab. [fr:200 mg / 28.5 mg, comp. disp.]", Unit.TABLET),
            new Format("DORAAMOC4S5", "400 mg / 57 mg / 5 ml, powd. oral susp. 70 ml [fr:400 mg / 57 mg / 5 ml, poudre susp. orale 70 ml]", Unit.ML),
            new Format("DORAAMOC56T", "500 mg / 62.5 mg, tab. [fr:500 mg / ac. 62.5 mg, comp.]", Unit.TABLET),
            new Format("DORAAMOC81T", "875 mg / 125 mg, tab. [fr:875 mg / ac. 125 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAAMOX", "AMOXICILLIN [fr:AMOXICILLINE]").withFormats(
            new Format("DORAAMOX1S1", "125 mg / 5 ml, powder oral susp., 100 ml, bot. [fr:125 mg / 5 ml, poudre susp. orale, 100 ml, fl]", Unit.ML),
            new Format("DORAAMOX1S6", "125 mg / 5 ml, powder oral susp., 60 ml, bot. [fr:125 mg / 5 ml, poudre susp. orale, 60 ml, fl]", Unit.ML),
            new Format("DORAAMOX2C", "250 mg, caps. [fr:250 mg, gl.]", Unit.CAPSULE),
            new Format("DORAAMOX2T", "250 mg, tab. [fr:250 mg, comp.]", Unit.TABLET),
            new Format("DORAAMOX2TDB", "250 mg, disp. and breakable tab. [fr:250 mg, comp. disp et scable]", Unit.TABLET),
            new Format("DORAAMOX5C", "500 mg, caps. [fr:500 mg, gl.]", Unit.CAPSULE),
            new Format("DORAAMOX5T", "500 mg, tab. [fr:500 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAARLU", "AL (ARTEMETHER / LUMEFANTRINE) [fr:AL (ARTEMETHER / LUMEFANTRINE)]").withFormats(
            new Format("DORAARLU1TD1", "20/120 mg, blister of 6 disp. tab., 5-14 kg [fr:20/120 mg, blister de 6 comp. disp., 5-14 kg]", Unit.TABLET),
            new Format("DORAARLU2TD1", "20/120 mg, blister of 12 disp. tab., 15-24 kg [fr:20/120 mg, blister de 12 comp. disp., 15-24 kg]", Unit.TABLET),
            new Format("DORAARLU3T1", "20/120 mg, blister of 18 tab., 25-34 kg [fr:20/120 mg, blister de 18 comp., 25-34 kg]", Unit.TABLET),
            new Format("DORAARLU4T1", "20/120 mg, blister of 24 tab., >35 kg [fr:20/120 mg, blister de 24 comp., >35 kg]", Unit.TABLET),
            new Format("DORAARLU5T1", "80/480 mg, blister of 6 tab., >35 kg [fr:80/480 mg, blister de 6 comp., >35 kg]", Unit.TABLET)
        ),
        new Drug("DORAASAQ", "AS / AQ (ARTESUNATE / AMODIAQUINE) [fr:AS / AQ (ARTESUNATE / AMODIAQUINE)]").withFormats(
            new Format("DORAASAQ1T1", "25 mg / eq. 67.5 mg base, blister of 3 tab, 4.5-8 kg [fr:25 mg / q. 67.5 mg base, blister de 3 comp, 4.5-8 kg]", Unit.TABLET),
            new Format("DORAASAQ2T1", "50 mg / eq. 135 mg base, blister of 3 tab, 9-17 kg [fr:50 mg / q. 135 mg base, blister de 3 comp., 9-17 kg]", Unit.TABLET),
            new Format("DORAASAQ3T1", "100 mg / eq. 270 mg base, blister of 3 tab, 18-35 kg [fr:100 mg / q. 270 mg base, blister de 3 comp., 18-35kg]", Unit.TABLET),
            new Format("DORAASAQ4T1", "100 mg / eq. 270 mg base, blister of 6 tab., >36 kg [fr:100 mg / q. 270 mg base, blister de 6 comp., >36 kg]", Unit.TABLET)
        ),
        new Drug("DORAASCA", "ASCORBIC acid (vitamin C) [fr:Acide ASCORBIQUE (vitamine C)]").withFormats(
            new Format("DORAASCA05T", "50 mg, tab. [fr:50 mg, comp.]", Unit.TABLET),
            new Format("DORAASCA2T", "250 mg, tab. [fr:250 mg, comp.]", Unit.TABLET),
            new Format("DORAASCA5T", "500 mg, tab. [fr:500 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAASMQ", "AS / MQ (ARTESUNATE / MEFLOQUINE) [fr:AS / MQ (ARTESUNATE / MEFLOQUINE)]").withFormats(
            new Format("DORAASMQ1T1", "25 mg / eq. 50 mg base, blister of 3 tab., 5-8 kg [fr:25 mg / q. 50 mg base, blister de 3 comp., 5-8 kg]", Unit.TABLET),
            new Format("DORAASMQ2T1", "25 mg / eq. 50 mg base, blister of 6 tab., 9-17 kg [fr:25 mg / q. 50 mg base, blister of 6 comp., 9-17 kg]", Unit.TABLET),
            new Format("DORAASMQ3T1", "100 mg / eq. 200 mg base, blister of 3 tab., 18-29 kg [fr:100 mg / q. 200 mg base, blister de 3 comp., 18-29 kg]", Unit.TABLET),
            new Format("DORAASMQ4T1", "100 mg / eq. 200 mg base, blister of 6 tab., >30 kg [fr:100 mg / q. 200 mg base, blister de 6 comp., >30 kg]", Unit.TABLET)
        ),
        new Drug("DORAATAZ", "ATAZANAVIR sulfate (ATV) [fr:ATAZANAVIR sulfate (ATV)]").withFormats(
            new Format("DORAATAZ2C", "200 mg, caps. [fr:200 mg, gl.]", Unit.CAPSULE)
        ),
        new Drug("DORAATOP", "ATOVAQUONE / PROGUANIL HCl [fr:ATOVAQUONE / PROGUANIL HCl]").withFormats(
            new Format("DORAATOP1T1", "62.5 mg / 25 mg, tab., 11-40kg [fr:62.5 mg / 25 mg, comp, blister, 11-40kg]", Unit.TABLET),
            new Format("DORAATOP2T1", "250 mg / 100 mg, tab., >40 kg [fr:250 mg / 100 mg, comp, blister, >40 kg]", Unit.TABLET)
        ),
        new Drug("DORAATOR", "ATORVASTATIN calcium [fr:ATORVASTATINE calcique]").withFormats(
            new Format("DORAATOR1T", "eq. 10 mg base, tab. [fr:10 mg base, comp.]", Unit.TABLET),
            new Format("DORAATOR2T", "eq. 20 mg base, tab. [fr:eq. 20 mg base, comp.]", Unit.TABLET),
            new Format("DORAATOR4T", "eq. 40 mg base, tab. [fr:eq. 40 mg base, comp.]", Unit.TABLET)
        ),
        new Drug("DORAATVR", "ATV / r [fr:ATV / r]").withFormats(
            new Format("DORAATVR3T", "300 mg / 100 mg, tab. [fr:300 mg / 100 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAAZIT", "AZITHROMYCIN [fr:AZITHROMYCINE]").withFormats(
            new Format("DORAAZIT2T", "250 mg, tab. [fr:250 mg, comp.]", Unit.TABLET),
            new Format("DORAAZIT3S", "200 mg / 5 ml, powder oral susp., 30 ml, bot. [fr:200 mg / 5 ml, poudre susp. orale, 30 ml, fl.]", Unit.ML),
            new Format("DORAAZIT5T", "500 mg, tab [fr:500 mg, comp]", Unit.TABLET)
        ),
        new Drug("DORABECL", "BECLOMETASONE dipropionate [fr:BECLOMETASONE dipropionate]").withFormats(
            new Format("DORABECL1SF", "0.10 mg / puff, 200 puffs, aerosol [fr:0.10 mg / bouffe, 200 b., arosol]", Unit.PUFF),
            new Format("DORABECL2SF", "0.25 mg / puff, 200 puffs, aerosol [fr:0.25 mg / bouffe, 200 b., arosol]", Unit.PUFF),
            new Format("DORABECL5SF", "0.05 mg / puff, 200 puffs, aerosol [fr:0.05 mg / bouffe, 200 b., arosol]", Unit.PUFF)
        ),
        new Drug("DORABEDA", "BEDAQUILINE [fr:BEDAQUILINE]").withFormats(
            new Format("DORABEDA1T", "100 mg, tab. [fr:100 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORABEND", "BENZNIDAZOLE [fr:BENZNIDAZOLE]").withFormats(
            new Format("DORABEND1T", "100 mg, tab. [fr:100 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORABIPE", "BIPERIDEN hydrochloride [fr:BIPERIDENE chlorhydrate]").withFormats(
            new Format("DORABIPE2T", "2 mg, tab [fr:2 mg, comp]", Unit.TABLET)
        ),
        new Drug("DORABISA", "BISACODYL [fr:BISACODYL]").withFormats(
            new Format("DORABISA5T", "5 mg, tab. [fr:5 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORABISO", "BISOPROLOL fumarate [fr:BISOPROLOL fumarate]").withFormats(
            new Format("DORABISO1TB4", "10 mg, break. tab. in 1/4 [fr:10 mg, comp. quadriscable]", Unit.TABLET),
            new Format("DORABISO2TB", "2.5 mg, break. tab. [fr:2.5 mg, comp. sc.]", Unit.TABLET),
            new Format("DORABISO5T", "5 mg, tab. [fr:5 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORACABG", "CABERGOLINE [fr:CABERGOLINE]").withFormats(
            new Format("DORACABG5TB", "0.5 mg, break. tab. [fr:0.5 mg, comp. sc.]", Unit.TABLET)
        ),
        new Drug("DORACALC", "CALCIUM carbonate [fr:CALCIUM carbonate]").withFormats(
            new Format("DORACALC5TC", "eq. 500 mg Ca, chewable tab. [fr:q. 500 mg Ca, comp.  mcher]", Unit.TABLET),
            new Format("DORACALC6TC", "eq. 600 mg Ca, chewable tab. [fr:q. 600 mg Ca, comp.  mcher]", Unit.TABLET)
        ),
        new Drug("DORACALL", "CALCIUM lactate [fr:CALCIUM lactate]").withFormats(
            new Format("DORACALL3T", "300 mg, eq. to 39 mg Ca, tab. [fr:300 mg, q.  39 mg Ca, comp.]", Unit.TABLET)
        ),
        new Drug("DORACARB", "CARBAMAZEPINE [fr:CARBAMAZEPINE]").withFormats(
            new Format("DORACARB2T", "200 mg, tab. [fr:200 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORACARC", "CARBOCISTEINE [fr:CARBOCISTEINE]").withFormats(
            new Format("DORACARC1S", "250 mg / 5 ml, oral sol., 200 ml, bot. [fr:250 mg / 5 ml, sol. orale, 200 ml, fl.]", Unit.ML)
        ),
        new Drug("DORACARV", "CARVEDILOL [fr:CAREVEDILOL]").withFormats(
            new Format("DORACARV3TB", "3.125 mg, breakable tab. [fr:3.125 mg, comp. scable]", Unit.TABLET),
            new Format("DORACARV6TB", "6.25 mg, breakable tab. [fr:6.25 mg, comp. scable]", Unit.TABLET)
        ),
        new Drug("DORACARZ", "CARBIMAZOLE [fr:CARBIMAZOLE]").withFormats(
            new Format("DORACARZ2T", "20 mg, tab. [fr:20 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORACEFI", "CEFIXIME [fr:CEFIXIME]").withFormats(
            new Format("DORACEFI1S", "100 mg / 5 ml, powder for oral susp., 40 ml, bot. [fr:100 mg / 5 ml, poudre pour susp. orale, 40 ml, fl.]", Unit.ML),
            new Format("DORACEFI2S", "100 mg / 5 ml, powder for oral susp., 60 ml, bot. [fr:100 mg / 5 ml, poudre pour susp. orale, 60 ml, fl.]", Unit.ML),
            new Format("DORACEFI2T", "200 mg, tab. [fr:200 mg, comp.]", Unit.TABLET),
            new Format("DORACEFI4T", "400 mg, tab. [fr:400 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORACEFX", "CEFALEXIN [fr:CEFALEXINE]").withFormats(
            new Format("DORACEFX1S", "125 mg / 5 ml, granules oral susp., 100 ml, bot. [fr:125 mg / 5 ml, granules susp. orale, 100 ml, fl.]", Unit.ML),
            new Format("DORACEFX2C", "250 mg, caps. [fr:250 mg, gl.]", Unit.CAPSULE)
        ),
        new Drug("DORACETI", "CETIRIZINE [fr:CETIRIZINE]").withFormats(
            new Format("DORACETI1T", "10 mg, tab. [fr:10 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORACHAR", "CHARCOAL ACTIVATED [fr:CHARBON ACTIVE]").withFormats(
            new Format("DORACHAR5G", "granules for oral susp., 50 g, bot. [fr:granules pour susp. orale, 50 g, fl.]", Unit.MG)
        ),
        new Drug("DORACHLM", "CHLORPROMAZINE hydrochloride [fr:CHLORPROMAZINE chlorhydrate]").withFormats(
            new Format("DORACHLM1T", "eq. 100 mg base, tab. [fr:q. 100 mg base, comp.]", Unit.TABLET),
            new Format("DORACHLM2T", "eq. 25 mg base, tab. [fr:q. 25 mg base, comp.]", Unit.TABLET)
        ),
        new Drug("DORACHLO", "CHLORAMPHENICOL [fr:CHLORAMPHENICOL]").withFormats(
            new Format("DORACHLO2C", "250 mg, caps. [fr:250 mg, gl.]", Unit.CAPSULE)
        ),
        new Drug("DORACHLQ", "CHLOROQUINE [fr:CHLOROQUINE]").withFormats(
            new Format("DORACHLQ2S1", "eq. 25 mg base / 5 ml, syrup, 150 ml, bot. [fr:q. 25 mg base / 5 ml, sirop, 150 ml, fl.]", Unit.ML),
            new Format("DORACHLQ3T", "155 mg base, (250 mg phosphate), tab. [fr:155 mg base, (250 mg phosphate), comp.]", Unit.TABLET)
        ),
        new Drug("DORACIME", "CIMETIDINE [fr:CIMETIDINE]").withFormats(
            new Format("DORACIME2TE", "200 mg, effervescent tab. [fr:200 mg, comp. effervescent]", Unit.TABLET)
        ),
        new Drug("DORACIPR", "CIPROFLOXACIN [fr:CIPROFLOXACINE]").withFormats(
            new Format("DORACIPR1S", "250 mg / 5 ml, gran. + solvent oral susp [fr:250 mg / 5 ml, gran. + solvant susp. orale]", Unit.ML),
            new Format("DORACIPR2T", "hydrochloride, eq. 250 mg base, tab. [fr:chlorhydrate, q. 250 mg base, comp.]", Unit.TABLET),
            new Format("DORACIPR5T", "hydrochloride, eq. 500 mg base, tab. [fr:chlorhydrate, q. 500 mg base, comp.]", Unit.TABLET)
        ),
        new Drug("DORACLAR", "CLARITHROMYCIN [fr:CLARITHROMYCINE]").withFormats(
            new Format("DORACLAR1S", "250 mg / 5 ml, granules for oral susp., bot. [fr:250 mg / 5 ml, granules susp. buv., fl.]", Unit.ML),
            new Format("DORACLAR2T", "250 mg, tab. [fr:250 mg, comp.]", Unit.TABLET),
            new Format("DORACLAR5T", "500 mg, tab. [fr:500 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORACLIN", "CLINDAMYCIN hydrochloride [fr:CLINDAMYCINE chlorhydrate]").withFormats(
            new Format("DORACLIN1C", "eq. 150 mg base, caps. [fr:q. 150 mg base, gl.]", Unit.CAPSULE),
            new Format("DORACLIN3C", "eq. 300 mg base, caps. [fr:q. 300 mg base, gl.]", Unit.CAPSULE)
        ),
        new Drug("DORACLOF", "CLOFAZIMINE [fr:CLOFAZIMINE]").withFormats(
            new Format("DORACLOF1C", "100 mg, soft caps. [fr:100 mg, caps. molle]", Unit.CAPSULE),
            new Format("DORACLOF1T", "100 mg, tab. [fr:100 mg, comp.]", Unit.TABLET),
            new Format("DORACLOF5C", "50 mg, soft caps. [fr:50 mg, caps. molle]", Unit.CAPSULE),
            new Format("DORACLOF5T", "50 mg, tab. [fr:50 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORACLOP", "CLOPIDOGREL [fr:CLOPIDOGREL]").withFormats(
            new Format("DORACLOP7T", "75 mg, tab. [fr:75 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORACLOX", "CLOXACILLIN sodium [fr:CLOXACILLINE sodique]").withFormats(
            new Format("DORACLOX2C", "eq. 250 mg base, caps. [fr:q. 250 mg base, gl.]", Unit.CAPSULE),
            new Format("DORACLOX5C", "eq. 500 mg base, caps. [fr:q. 500 mg base, gl.]", Unit.CAPSULE)
        ),
        new Drug("DORACODE", "CODEINE phosphate [fr:CODEINE phosphate]").withFormats(
            new Format("DORACODE1S", "15 mg / 5 ml, syrup, 200 ml, bot. [fr:15 mg / 5 ml, sirop, 200 ml, fl.]", Unit.ML),
            new Format("DORACODE3T", "30 mg, tab. [fr:30 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORACOLC", "COLECALCIFEROL (vit. D3) [fr:COLECALCIFEROL (vit. D3)]").withFormats(
            new Format("DORACOLC1S1", "10.000 IU / ml, sol., 10 ml, bot. [fr:10000 UI / ml, sol., 10 ml, fl.]", Unit.ML)
        ),
        new Drug("DORACOLH", "COLCHICINE [fr:COLCHICINE]").withFormats(
            new Format("DORACOLH1T", "1 mg, tab. [fr:1 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORACOTR", "COTRIMOXAZOLE [fr:COTRIMOXAZOLE]").withFormats(
            new Format("DORACOTR1TD", "100 mg / 20 mg, disp. tab. [fr:100 mg / 20 mg, comp. disp.]", Unit.TABLET),
            new Format("DORACOTR2S1", "200 mg / 40 mg / 5 ml, oral susp, 100 ml, bot. [fr:200 mg / 40 mg / 5 ml, susp orale, 100 ml, fl.]", Unit.ML),
            new Format("DORACOTR4T", "400 mg / 80 mg, tab. [fr:400 mg / 80 mg, comp.]", Unit.TABLET),
            new Format("DORACOTR8T", "800 mg / 160 mg, tab. [fr:800 mg / 160 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORACYCL", "CYCLOSERINE [fr:CYCLOSERINE]").withFormats(
            new Format("DORACYCL1C1", "125 mg, caps. blister [fr:125 mg, gl. blister]", Unit.CAPSULE),
            new Format("DORACYCL2C1", "250 mg, caps. blister [fr:250 mg, gl. blister]", Unit.CAPSULE),
            new Format("DORACYCL2C3", "250 mg, caps. bulk [fr:250 mg, gl. vrac]", Unit.CAPSULE)
        ),
        new Drug("DORACYCS", "CYCLIZINE [fr:CYCLIZINE]").withFormats(
            new Format("DORACYCS5T", "50 mg, tabs. [fr:50 mg, tabs.]", Unit.MG)
        ),
        new Drug("DORADACL", "DACLATASVIR dihydrochloride (DCV) [fr:DACLATASVIR dichlorhydrate (DCV)]").withFormats(
            new Format("DORADACL3T", "eq. 30 mg base, tab. [fr:q. 30 mg base, comp.]", Unit.TABLET),
            new Format("DORADACL6T", "eq. 60 mg base, tab. [fr:q. 60 mg base, comp.]", Unit.TABLET)
        ),
        new Drug("DORADAPS", "DAPSONE [fr:DAPSONE]").withFormats(
            new Format("DORADAPS1TB", "100 mg, break. tab. [fr:100 mg, comp. scable]", Unit.TABLET),
            new Format("DORADAPS2T", "25 mg, tab. [fr:25 mg, comp.]", Unit.TABLET),
            new Format("DORADAPS5T", "50 mg, tab. [fr:50 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORADARU", "DARUNAVIR ethanolate (DRV) [fr:DARUNAVIR thanolate (DRV)]").withFormats(
            new Format("DORADARU1T", "eq. 150 mg base, tab. [fr:q. 150 mg base, comp.]", Unit.TABLET),
            new Format("DORADARU3T", "eq. 300 mg base, tab. [fr:q. 300 mg base, comp.]", Unit.TABLET),
            new Format("DORADARU4T", "eq. 400 mg base, tab. [fr:q. 400 mg base, comp.]", Unit.TABLET),
            new Format("DORADARU6T", "eq. 600 mg base, tab. [fr:q. 600 mg base, comp.]", Unit.TABLET),
            new Format("DORADARU7T", "eq. 75 mg base, tab. [fr:q. 75 mg base, comp.]", Unit.TABLET)
        ),
        new Drug("DORADEFP", "DEFERIPRONE [fr:DEFERIPRONE]").withFormats(
            new Format("DORADEFP2T", "250 mg, tab. [fr:250 mg, comp.]", Unit.TABLET),
            new Format("DORADEFP5T", "500 mg, tab. [fr:500 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORADEFS", "DEFERASIROX [fr:DEFERASIROX]").withFormats(
            new Format("DORADEFS1TD", "125 mg, disp. tab. [fr:125 mg, comp. disp.]", Unit.TABLET),
            new Format("DORADEFS2TD", "250 mg, disp. tab. [fr:250 mg, comp. disp.]", Unit.TABLET),
            new Format("DORADEFS5TD", "500 mg, disp. tab. [fr:500 mg, comp. disp.]", Unit.TABLET)
        ),
        new Drug("DORADELA", "DELAMANID [fr:DELAMANID]").withFormats(
            new Format("DORADELA5T1", "50 mg, tab., blister [fr:50 mg, comp., blister]", Unit.TABLET)
        ),
        new Drug("DORADESO", "DESOGESTREL [fr:DESOGESTREL]").withFormats(
            new Format("DORADESO7T1", "0.075 mg, blister of 28 tab. [fr:0.075 mg, blister de 28 comp.]", Unit.TABLET)
        ),
        new Drug("DORADHAP", "DHA / PPQ (DIHYDROARTEMISININ / PIPERAQUINE) [fr:DHA / PPQ (DIHYDROARTEMISININ / PIPERAQUINE)]").withFormats(
            new Format("DORADHAP1T1", "20 mg / 160 mg, blister de 3 tab., 5-12 kg [fr:20 mg / 160 mg, blister de 3 comp., 5-12 kg]", Unit.TABLET),
            new Format("DORADHAP2T1", "40 mg / 320 mg, blister of 3 tab., 13-23 kg [fr:40 mg / 320 mg, blister de 3 comp., 13-23 kg]", Unit.TABLET),
            new Format("DORADHAP3T1", "40 mg / 320 mg, blister of 6 tab., 24-34 kg [fr:40 mg / 320 mg, blister de 6 comp., 24-34 kg]", Unit.TABLET),
            new Format("DORADHAP4T1", "40 mg / 320 mg, blister of 9 tab., 35-74 kg [fr:40 mg / 320 mg, blister de 9 comp., 35-74 kg]", Unit.TABLET),
            new Format("DORADHAP5T1", "40 mg / 320 mg, blister de 12 tab., 75-100 kg [fr:40 mg / 320 mg, blister de 12 comp., 75-100 kg]", Unit.TABLET)
        ),
        new Drug("DORADIAC", "DIACETYLCYSTEINATE methyle [fr:DIACETYLCYSTEINE mthyl]").withFormats(
            new Format("DORADIAC2T", "200 mg, tab. [fr:200 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORADIAZ", "DIAZEPAM [fr:DIAZEPAM]").withFormats(
            new Format("DORADIAZ2T", "2 mg, tab. [fr:2 mg, comp.]", Unit.TABLET),
            new Format("DORADIAZ5T", "5 mg, tab. [fr:5 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORADICL", "DICLOFENAC sodium [fr:DICLOFENAC sodique]").withFormats(
            new Format("DORADICL2TG", "25 mg, gastro-resistant tab. [fr:25 mg, comp. gastro-rsistant]", Unit.TABLET)
        ),
        new Drug("DORADIET", "DIETHYLCARBAMAZINE citrate [fr:DIETHYLCARBAMAZINE citrate]").withFormats(
            new Format("DORADIET1TB", "eq. 100 mg base, break. tab. [fr:q. 100 mg base, comp. sc.]", Unit.TABLET)
        ),
        new Drug("DORADIGO", "DIGOXIN [fr:DIGOXINE]").withFormats(
            new Format("DORADIGO2T", "0.25 mg, tab. [fr:0.25 mg, comp.]", Unit.TABLET),
            new Format("DORADIGO6T", "0.0625 mg, tab. [fr:0.0625 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORADIPH", "DIPHENHYDRAMINE [fr:DIPHENHYDRAMINE]").withFormats(
            new Format("DORADIPH9T", "90 mg, tab. [fr:90 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORADOLU", "DOLUTEGRAVIR sodium (DTG) [fr:DOLUTEGRAVIR sodium (DTG)]").withFormats(
            new Format("DORADOLU5T", "eq. 50 mg base, tab. [fr:q. 50 mg base, comp.]", Unit.TABLET)
        ),
        new Drug("DORADOXY", "DOXYCYCLINE salt [fr:DOXYCYCLINE sel]").withFormats(
            new Format("DORADOXY1T", "eq. 100 mg base, tab. [fr:q. 100 mg base, comp.]", Unit.TABLET)
        ),
        new Drug("DORAEFAV", "EFAVIRENZ (EFV) [fr:EFAVIRENZ (EFV)]").withFormats(
            new Format("DORAEFAV2C", "200 mg, caps. [fr:200 mg, gl.]", Unit.CAPSULE),
            new Format("DORAEFAV2T", "200 mg, tab. [fr:200 mg, comp.]", Unit.TABLET),
            new Format("DORAEFAV2TB", "200 mg, break. tab. [fr:200 mg, comp. sc.]", Unit.TABLET),
            new Format("DORAEFAV6T", "600 mg, tab. [fr:600 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAEHRI", "E / H / R (ETHAMBUTOL / ISONIAZID / RIFAMPICIN) [fr:E / H / R (ETHAMBUTOL / ISONIAZID / RIFAMPICIN)]").withFormats(
            new Format("DORAEHRI1T1", "275 mg / 75 mg / 150 mg, tab., blister [fr:275 mg / 75 mg / 150 mg, comp., blister]", Unit.TABLET),
            new Format("DORAEHRI1T3", "275 mg / 75 mg / 150 mg, tab., bulk [fr:275 mg / 75 mg / 150 mg, comp., vrac]", Unit.TABLET)
        ),
        new Drug("DORAEHZR", "E / H / Z / R (ETHAMBUTOL / ISONIAZID / PYRAZINAMIDE / RIFAMPICIN) [fr:E / H / Z / R (ETHAMBUTOL / ISONIAZID / PYRAZINAMIDE / RIFAMPICIN)]").withFormats(
            new Format("DORAEHZR2T1", "275 mg / 75 mg / 400 mg / 150 mg, tab., blister [fr:275 mg / 75 mg / 400 mg / 150 mg, comp., blister]", Unit.TABLET),
            new Format("DORAEHZR2T3", "275 mg / 75 mg / 400 mg / 150 mg, tab., bulk [fr:275 mg / 75 mg / 400 mg / 150 mg, comp., vrac]", Unit.TABLET)
        ),
        new Drug("DORAENAL", "ENALAPRIL maleate [fr:ENALAPRIL malate]").withFormats(
            new Format("DORAENAL2T", "20 mg, tab. [fr:20 mg, comp.]", Unit.TABLET),
            new Format("DORAENAL5T", "5 mg, tab. [fr:5 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAERYT", "ERYTHROMYCIN [fr:ERYTHROMYCINE]").withFormats(
            new Format("DORAERYT1G", "ethylsucc. 125 mg, gran. for oral susp., sachet [fr:ethylsucc, 125 mg, gran. pour susp. orale, sachet]", Unit.MG),
            new Format("DORAERYT1S1", "ethylsucc. 125 mg / 5 ml, powder oral susp. 100 ml, bot [fr:ethylsucc, 125 mg / 5 ml, poudre susp. orale, 100 ml, fl]", Unit.ML),
            new Format("DORAERYT2T", "stearate, eq. 250 mg base, tab. [fr:starate, eq. 250 mg base, comp.]", Unit.TABLET),
            new Format("DORAERYT5T", "stearate, eq. 500 mg base, tab. [fr:starate, eq. 500 mg base, comp.]", Unit.TABLET)
        ),
        new Drug("DORAETHA", "ETHAMBUTOL hydrochloride (E) [fr:ETHAMBUTOL chlorhydrate (E)]").withFormats(
            new Format("DORAETHA1T1", "eq. 100 mg base, tab. blister [fr:q. 100 mg base, comp. blister]", Unit.TABLET),
            new Format("DORAETHA1T3", "eq. 100 mg base, tab. bulk [fr:q. 100 mg base, comp. vrac]", Unit.TABLET),
            new Format("DORAETHA4T1", "eq. 400 mg base, tab. blister [fr:q. 400 mg base, comp. blister]", Unit.TABLET),
            new Format("DORAETHA4T3", "eq. 400 mg base, tab. bulk [fr:q. 400 mg base, comp. vrac]", Unit.TABLET)
        ),
        new Drug("DORAETHL", "ETHINYLESTRADIOL / LEVONORGESTREL [fr:ETHINYLESTRADIOL / LEVONORGESTREL]").withFormats(
            new Format("DORAETHL31T", "0.03 mg / 0.15 mg, blister 28tab [fr:0.03 mg / 0.15 mg, plaq. 28 comp.]", Unit.MG)
        ),
        new Drug("DORAETHN", "ETHIONAMIDE [fr:ETHIONAMIDE]").withFormats(
            new Format("DORAETHN1T1", "125 mg, tab., blister [fr:125 mg, comp., blister]", Unit.TABLET),
            new Format("DORAETHN1TD1", "125 mg, dispersible tab., blister [fr:125 mg, comp. dispersible, blister]", Unit.TABLET),
            new Format("DORAETHN2T1", "250 mg, tab., blister [fr:250 mg, comp., blister]", Unit.TABLET)
        ),
        new Drug("DORAETRA", "ETRAVIRINE (ETV) [fr:ETRAVIRINE (ETV)]").withFormats(
            new Format("DORAETRA1T", "100 mg, tab. [fr:100 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAFENO", "FENOFIBRATE [fr:FENOFIBRATE]").withFormats(
            new Format("DORAFENO2C", "200 mg, caps. [fr:200 mg, gl.]", Unit.CAPSULE)
        ),
        new Drug("DORAFERF", "FERROUS salt / FOLIC acid (FEFOL) [fr:sel de FER / acide FOLIQUE (FEFOL)]").withFormats(
            new Format("DORAFERF14T", "eq. 60 mg iron / 0.4 mg, tab [fr:q. 60 mg fer / 0.4 mg, comp.]", Unit.TABLET),
            new Format("DORAFERF24T", "eq. 65 mg iron / 0.4 mg, tab [fr:q. 65 mg fer / 0.4 mg, comp.]", Unit.TABLET),
            new Format("DORAFERF45CP", "eq. 47 mg iron / 0.5 mg, prol. rel. caps. [fr:q. 47 mg fer / 0.5 mg, gl. lib. prol.]", Unit.CAPSULE)
        ),
        new Drug("DORAFERS", "FERROUS salt [fr:sel de FER]").withFormats(
            new Format("DORAFERS2S", "eq. iron 45 mg / 5 ml, syrup, 200 ml, bot. [fr:q. 45 mg / 5 ml fer, sirop, 200 ml, fl.]", Unit.ML),
            new Format("DORAFERS2T", "eq. + / - 65 mg iron, tab. [fr:q. + / - 65 mg de fer, comp.]", Unit.TABLET),
            new Format("DORAFERS3S", "eq. iron 45 mg / 5 ml, syrup, 300 ml, bot. [fr:q. 45 mg / 5 ml fer, sirop, 300 ml, fl.]", Unit.ML),
            new Format("DORAFERS4S", "sodium FEREDETATE, eq. 34 mg / 5 ml iron, 125 ml, bot. [fr:FEREDETATE sodium, eq. 34 mg / 5 ml fer, 125 ml, fl.]", Unit.ML)
        ),
        new Drug("DORAFEXI", "FEXINIDAZOLE [fr:FEXINIDAZOLE]").withFormats(
            new Format("DORAFEXI6T1A", "600 mg, wallet of 24 tabs., >34 kg [fr:600 mg, wallet of 24 tabs., >34 kg]", Unit.MG),
            new Format("DORAFEXI6T1P", "600 mg, wallet of 14 tabs., 20-34 kg [fr:600 mg, wallet of 14 tabs., 20-34 kg]", Unit.MG)
        ),
        new Drug("DORAFLUC", "FLUCONAZOLE [fr:FLUCONAZOLE]").withFormats(
            new Format("DORAFLUC1C", "100 mg, caps. [fr:100 mg, gl.]", Unit.CAPSULE),
            new Format("DORAFLUC1S", "50 mg / 5 ml, powder oral susp., bot. [fr:50 mg / 5 ml, poudre susp. orale, fl.]", Unit.ML),
            new Format("DORAFLUC2C", "200 mg, caps. [fr:200 mg, gl.]", Unit.CAPSULE),
            new Format("DORAFLUC2T", "200 mg, tab. [fr:200 mg, comp.]", Unit.TABLET),
            new Format("DORAFLUC5C", "50 mg, caps. [fr:50 mg, gl.]", Unit.CAPSULE)
        ),
        new Drug("DORAFLUS", "FLUTICASONE / SALMETEROL [fr:FLUTICASONE / SALMETEROL]").withFormats(
            new Format("DORAFLUS12SF", "125 g / 25 g / puff, aerosol [fr:125 g / 25 g / bouffe, arosol]", Unit.PUFF)
        ),
        new Drug("DORAFLUT", "FLUTICASONE propionate [fr:FLUTICASONE propionate]").withFormats(
            new Format("DORAFLUT5SF", "50 g / puff, aerosol, 120 doses [fr:50 g / bouffe, arosol, 120 doses]", Unit.PUFF)
        ),
        new Drug("DORAFLUX", "FLUOXETINE hydrochloride [fr:FLUOXETINE chlorhydrate]").withFormats(
            new Format("DORAFLUX2C", "eq. 20 mg base, caps. [fr:q. 20 mg base, gl.]", Unit.CAPSULE)
        ),
        new Drug("DORAFLUY", "FLUCYTOSINE [fr:FLUCYTOSINE]").withFormats(
            new Format("DORAFLUY5T", "500 mg, tab. [fr:500 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAFOLA", "FOLIC acid [fr:Acide FOLIQUE]").withFormats(
            new Format("DORAFOLA5T", "5 mg, tab. [fr:5 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAFOLC", "CALCIUM FOLINATE [fr:FOLINATE de CALCIUM]").withFormats(
            new Format("DORAFOLC1T", "eq. 15 mg, folinic acid, tab. [fr:q. 15 mg, acide folinique, comp.]", Unit.TABLET),
            new Format("DORAFOLC2C", "eq. 25 mg folinic acid, caps. [fr:q. 25 mg acide folinique, gl.]", Unit.CAPSULE)
        ),
        new Drug("DORAFOSF", "FOSFOMYCIN trometamol [fr:FOSFOMYCINE tromtamol]").withFormats(
            new Format("DORAFOSF3S", "eq. 3 g base, sachet [fr:q. 3 g base, sachet]", Unit.MG)
        ),
        new Drug("DORAFURO", "FUROSEMIDE [fr:FUROSEMIDE]").withFormats(
            new Format("DORAFURO2T", "20 mg, tab. [fr:20 mg, comp.]", Unit.TABLET),
            new Format("DORAFURO4T", "40 mg, tab. [fr:40 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAGABA", "GABAPENTIN [fr:GABAPENTINE]").withFormats(
            new Format("DORAGABA1C", "100 mg caps. [fr:100 mg gl.]", Unit.CAPSULE),
            new Format("DORAGABA3C", "300 mg caps. [fr:300 mg gl.]", Unit.CAPSULE),
            new Format("DORAGABA4C", "400 mg, caps. [fr:400 mg, gl.]", Unit.CAPSULE)
        ),
        new Drug("DORAGLIB", "GLIBENCLAMIDE [fr:GLIBENCLAMIDE]").withFormats(
            new Format("DORAGLIB5TB", "5 mg, breakable tab. [fr:5 mg, comp. scable]", Unit.TABLET)
        ),
        new Drug("DORAGLIC", "GLICLAZIDE [fr:GLICLAZIDE]").withFormats(
            new Format("DORAGLIC8TB", "80 mg, breakable tab. [fr:80 mg, comp. scable]", Unit.TABLET)
        ),
        new Drug("DORAGLIM", "GLIBENCLAMIDE / METFORMIN [fr:GLIBENCLAMIDE / METFORMINE]").withFormats(
            new Format("DORAGLIM55T", "5 mg / hydrochloride, 500 mg, tab. [fr:5 mg / chlorhydrate, 500 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAGLYT", "GLYCERYL TRINITRATE [fr:GLYCERYLE TRINITRATE]").withFormats(
            new Format("DORAGLYT5T", "0.5 mg, sublingual tab. [fr:0.5 mg, comp. sublingual]", Unit.TABLET)
        ),
        new Drug("DORAGRIS", "GRISEOFULVIN [fr:GRISEOFULVINE]").withFormats(
            new Format("DORAGRIS1T", "125 mg, tab. [fr:125 mg, comp.]", Unit.TABLET),
            new Format("DORAGRIS5T", "500 mg, tab. [fr:500 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAHALO", "HALOTHANE [fr:HALOTHANE]").withFormats(
            new Format("DORAHALO1A2", "250 ml, bot. [fr:250 ml, fl.]", Unit.ML)
        ),
        new Drug("DORAHALP", "HALOPERIDOL [fr:HALOPERIDOL]").withFormats(
            new Format("DORAHALP05C", "0.5 mg, caps. [fr:0.5 mg, gl.]", Unit.CAPSULE),
            new Format("DORAHALP05T", "0.5 mg, tab. [fr:0.5 mg, comp.]", Unit.TABLET),
            new Format("DORAHALP1S2", "2 mg / ml, oral sol., 100 ml, bot. with pipette [fr:2 mg / ml, sol. orale, 100 ml, fl. avec pipette]", Unit.ML),
            new Format("DORAHALP1T", "1 mg, tab. [fr:1 mg, comp.]", Unit.TABLET),
            new Format("DORAHALP3D", "2 mg / ml / 20 drops, 30 ml, bot. [fr:2 mg / ml / 20 gouttes, 30 ml, fl.]", Unit.ML),
            new Format("DORAHALP5T", "5 mg, tab. [fr:5 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAHPST", "INH / PYRIDOXINE / SMX / TMP [fr:INH / PYRIDOXINE / SMX / TMP]").withFormats(
            new Format("DORAHPST32T", "300 mg / 25 mg / 800 mg / 160 mg, tab. [fr:300 mg / 25 mg / 800 mg / 160 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAHRIF", "H / R (ISONIAZID / RIFAMPICIN) [fr:H / R (ISONIAZID / RIFAMPICIN)]").withFormats(
            new Format("DORAHRIF5TD1", "50 mg / 75 mg, disp. tab., blister [fr:50 mg / 75 mg, comp. disp., blister]", Unit.TABLET),
            new Format("DORAHRIF6TD1", "60 mg / 60 mg, disp. tab., blister [fr:60 mg / 60 mg, comp. disp., blister]", Unit.TABLET),
            new Format("DORAHRIF6TD3", "60 mg / 60 mg, disp. tab., bulk [fr:60 mg / 60 mg, comp. disp., vrac]", Unit.TABLET),
            new Format("DORAHRIF7T1", "75 mg / 150 mg, tab., blister [fr:75 mg / 150 mg, comp., blister]", Unit.TABLET),
            new Format("DORAHRIF7T3", "75 mg / 150 mg, tab., bulk [fr:75 mg / 150 mg, comp., vrac]", Unit.TABLET)
        ),
        new Drug("DORAHYDC", "HYDROXYCARBAMIDE [fr:HYDROXYCARBAMIDE]").withFormats(
            new Format("DORAHYDC1T", "100 mg, tab. [fr:100 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAHYDO", "HYDROCHLOROTHIAZIDE [fr:HYDROCHLOROTHIAZIDE]").withFormats(
            new Format("DORAHYDO1T", "12.5 mg, tab. [fr:12.5 mg, comp.]", Unit.TABLET),
            new Format("DORAHYDO2T", "25 mg, tab. [fr:25 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAHYDX", "HYDROXYZINE dihydrochloride [fr:HYDROXYZINE dichlorhydrate]").withFormats(
            new Format("DORAHYDX2T", "25 mg, tab. [fr:25 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAHYOS", "HYOSCINE BUTYLBROMIDE (scopolamine butylbromide) [fr:BUTYLBROMURE HYOSCINE (butylbromure scopolamine)]").withFormats(
            new Format("DORAHYOS1T", "10 mg, tab [fr:10 mg, cp]", Unit.TABLET)
        ),
        new Drug("DORAHZRI", "H / Z / R (ISONIAZID / PYRAZINAMIDE / RIFAMPICIN) [fr:H / Z / R (ISONIAZID / PYRAZINAMIDE / RIFAMPICIN)]").withFormats(
            new Format("DORAHZRI5TD1", "50 mg / 150 mg / 75 mg, disp. tab., blister [fr:50 mg / 150 mg / 75 mg, comp. disp., blister]", Unit.TABLET)
        ),
        new Drug("DORAIBUP", "IBUPROFEN [fr:IBUPROFENE]").withFormats(
            new Format("DORAIBUP2S", "100 mg / 5 ml, oral susp., 150 ml, bot. [fr:100 mg / 5 ml, susp. orale, 150 ml, fl.]", Unit.ML),
            new Format("DORAIBUP2T", "200 mg, tab. [fr:200 mg, comp.]", Unit.TABLET),
            new Format("DORAIBUP3S", "100 mg / 5 ml, oral susp., 200 ml, bot. [fr:100 mg / 5 ml, susp. orale, 200 ml, fl.]", Unit.ML),
            new Format("DORAIBUP4T", "400 mg, tab. [fr:400 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAIODO", "IODIZED OIL [fr:HUILE IODEE]").withFormats(
            new Format("DORAIODO1C", "190 mg, caps. [fr:190 mg, gl.]", Unit.CAPSULE)
        ),
        new Drug("DORAIPRA", "IPRATROPIUM bromide [fr:IPRATROPIUM bromure]").withFormats(
            new Format("DORAIPRA2N", "0.250 mg / ml, 1 ml, sol. for nebuliser [fr:0.250 mg / ml, 1 ml, sol. pour nbuliseur]", Unit.ML),
            new Format("DORAIPRA2N2", "0.125 mg / ml, 2 ml, sol. for nebuliser [fr:0.125 mg / ml, 2 ml, sol. pour nbuliseur]", Unit.ML),
            new Format("DORAIPRA2SF", "20 g / puff, 200 puffs, aerosol [fr:20 g / bouffe, 200 bouffes, aerosol]", Unit.PUFF),
            new Format("DORAIPRA5N", "0.250 mg / ml, 2 ml, sol. for nebuliser [fr:0.250 mg / ml, 2 ml, sol. pour nbuliseur]", Unit.ML)
        ),
        new Drug("DORAISOB", "ISOSORBIDE DINITRATE [fr:ISOSORBIDE DINITRATE]").withFormats(
            new Format("DORAISOB1T", "10 mg, tab [fr:10 mg, comp]", Unit.TABLET),
            new Format("DORAISOB5T", "5 mg, sublingual tab. [fr:5 mg, comp. sublingual]", Unit.TABLET)
        ),
        new Drug("DORAISOF", "ISOFLURANE [fr:ISOFLURANE]").withFormats(
            new Format("DORAISOF2L", "liquid, 250 ml, bot. [fr:liquide, 250 ml, fl.]", Unit.ML)
        ),
        new Drug("DORAISON", "ISONIAZID (H) [fr:ISONIAZIDE (H)]").withFormats(
            new Format("DORAISON1T1", "100 mg, breakable tab., blister [fr:100 mg, comp. scable, blister]", Unit.TABLET),
            new Format("DORAISON1T3", "100 mg, breakable tab., bulk [fr:100 mg, comp. scable, vrac]", Unit.TABLET),
            new Format("DORAISON3T1", "300 mg, tab., blister [fr:300 mg, comp., blister]", Unit.TABLET),
            new Format("DORAISON3T3", "300 mg, tab., bulk [fr:300 mg, comp., vrac]", Unit.TABLET),
            new Format("DORAISON5S", "50 mg / 5 ml, oral sol., 500 ml, bot. [fr:50 mg / 5 ml, sol. orale, 500 ml, fl.]", Unit.ML)
        ),
        new Drug("DORAISOS", "ISOSORBIDE DINITRATE (prolonged) [fr:ISOSORBIDE DINITRATE (prolong)]").withFormats(
            new Format("DORAISOS2T", "20 mg, prol. release, tab. [fr:20 mg, libr. prol., comp.]", Unit.TABLET)
        ),
        new Drug("DORAITRA", "ITRACONAZOLE [fr:ITRACONAZOLE]").withFormats(
            new Format("DORAITRA1C", "100 mg, caps. [fr:100 mg, gl.]", Unit.CAPSULE)
        ),
        new Drug("DORAIVER", "IVERMECTIN [fr:IVERMECTINE]").withFormats(
            new Format("DORAIVER3T", "(onchocerciasis, mass distribution), 3 mg, tab. [fr:(onchocercose, distribution de masse), 3 mg, comp]", Unit.TABLET),
            new Format("DORAIVER3T4", "(onchocerciasis), 3 mg, tab. [fr:(onchocercose), 3 mg, comp.]", Unit.TABLET),
            new Format("DORAIVER3TS", "(scabies + other indic. ), 3 mg, tab. [fr:(gale + autres indic. ), 3 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORALABE", "LABETALOL hydrochloride [fr:LABETALOL chlorhydrate]").withFormats(
            new Format("DORALABE1T", "100 mg, tab. [fr:100 mg, comp.]", Unit.TABLET),
            new Format("DORALABE2T", "200 mg, tab. [fr:200 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORALACT", "LACTULOSE [fr:LACTULOSE]").withFormats(
            new Format("DORALACT1S", "min. 3.1 g / 5 ml, oral sol., bot. [fr:min. 3.1 g / 5 ml, sol. orale, fl.]", Unit.ML),
            new Format("DORALACT3S", "10 g / 15 ml, oral sol., sachet [fr:10 g / 15 ml, sol. orale, sachet]", Unit.ML)
        ),
        new Drug("DORALAMI", "LAMIVUDINE (3TC) [fr:LAMIVUDINE (3TC)]").withFormats(
            new Format("DORALAMI1S", "50 mg / 5 ml, oral sol., 100 ml, bot. [fr:50 mg / 5 ml, sol. orale, 100 ml, fl.]", Unit.ML),
            new Format("DORALAMI1T", "150 mg, tab. [fr:150 mg, comp.]", Unit.TABLET),
            new Format("DORALAMI2S", "50 mg / 5 ml, oral sol., 240 ml, bot. [fr:50 mg / 5 ml, sol. orale, 240 ml, fl.]", Unit.ML)
        ),
        new Drug("DORALEFX", "LEVOFLOXACIN [fr:LEVOFLOXACINE]").withFormats(
            new Format("DORALEFX1TD1", "100 mg, dispersible tab., blister [fr:100 mg, comp. dispersible, blister]", Unit.TABLET),
            new Format("DORALEFX2T", "250 mg, tab., blister [fr:250 mg, comp., blister]", Unit.TABLET),
            new Format("DORALEFX5T", "500 mg, tab., blister [fr:500 mg, comp., blister]", Unit.TABLET)
        ),
        new Drug("DORALESO", "LEDIPASVIR [fr:LEDIPASVIR]").withFormats(
            new Format("DORALESO94T", "90 mg / SOFOSBUVIR 400 mg, tab. [fr:90 mg / SOFOSBUVIR 400 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORALEVC", "LEVODOPA [fr:LEVODOPA]").withFormats(
            new Format("DORALEVC2T", "250 mg / CARBIDOPA 25 mg, tab. [fr:250 mg / CARBIDOPA 25 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORALEVE", "LEVETIRACETAM [fr:LEVETIRACETAM]").withFormats(
            new Format("DORALEVE1S3", "500 mg / 5 ml, oral sol., 300 ml bot. [fr:500 mg / 5 ml, sol. orale, 300 ml fl.]", Unit.ML)
        ),
        new Drug("DORALEVN", "LEVONORGESTREL [fr:LEVONORGESTREL]").withFormats(
            new Format("DORALEVN1T", "1.5 mg, tab. [fr:1.5 mg, comp.]", Unit.TABLET),
            new Format("DORALEVN3T1", "0.03 mg, blister of 35 tab. [fr:0.03 mg, blister de 35 comp.]", Unit.TABLET)
        ),
        new Drug("DORALEVO", "LEVOTHYROXINE sodium [fr:LEVOTHYROXINE sodique]").withFormats(
            new Format("DORALEVO1T", "0.1 mg, tab. [fr:0.1 mg, cp]", Unit.TABLET),
            new Format("DORALEVO2T", "0.025 mg, tab. [fr:0.025 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORALINE", "LINEZOLID [fr:LINEZOLIDE]").withFormats(
            new Format("DORALINE1S", "100 mg / 5 ml, granules for oral susp., 150 ml, bot. [fr:100 mg / 5 ml, granules susp. orale, 150 ml, fl.]", Unit.ML),
            new Format("DORALINE6T", "600 mg, tab. [fr:600 mg, comp.]", Unit.TABLET),
            new Format("DORALINE6TB1", "600 mg, breakable tab., blister [fr:600 mg, comp. scable, blister]", Unit.TABLET)
        ),
        new Drug("DORALOPE", "LOPERAMIDE hydrochloride [fr:LOPERAMIDE chlorhydrate]").withFormats(
            new Format("DORALOPE2C", "2 mg, caps. [fr:2 mg, gl.]", Unit.CAPSULE),
            new Format("DORALOPE2T", "2 mg, tab. [fr:2 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORALORA", "LORATADINE [fr:LORATADINE]").withFormats(
            new Format("DORALORA1S", "5 mg / 5 ml, oral sol., 100 ml, bot. [fr:5 mg / 5 ml, sol. orale, 100 ml, fl.]", Unit.ML),
            new Format("DORALORA1T", "10 mg, tab. [fr:10 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORALOSA", "LOSARTAN potassium [fr:LOSARTAN potassium]").withFormats(
            new Format("DORALOSA5T", "50 mg, tab. [fr:50 mg, comp.]", Unit.TABLET),
            new Format("DORALOSA5TB", "50 mg, breakable tab. [fr:50 mg, comp. scable]", Unit.TABLET)
        ),
        new Drug("DORALPVR", "LPV / r [fr:LPV / r]").withFormats(
            new Format("DORALPVR1G", "40 mg / 10 mg, granules, sachet [fr:40 mg / 10 mg, granules, sachet]", Unit.MG),
            new Format("DORALPVR1P", "40 mg / 10 mg, pellets-in-a-capsule [fr:40 mg / 10 mg, granules dans glule]", Unit.MG),
            new Format("DORALPVR2S", "/ 400/100 mg / 5 ml, oral sol., 60 ml, bot. [fr:/ 400/100 mg / 5 ml, sol. orale, 60 ml, fl.]", Unit.ML),
            new Format("DORALPVR3S", "/ 400/100 mg / 5 ml, oral sol., 160 ml, bot. [fr:/ 400/100 mg / 5 ml, sol. orale, 160 ml, fl.]", Unit.ML),
            new Format("DORALPVR4T", "100 mg / 25 mg, tab. [fr:100 mg / 25 mg, comp.]", Unit.TABLET),
            new Format("DORALPVR5T", "200 mg / 50 mg, tab. [fr:200 mg / 50 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAMAGN", "MAGNESIUM oxide [fr:Oxyde de MAGNESIUM]").withFormats(
            new Format("DORAMAGN1TE", "270 mg, eq. to 150 mg Mg, efferv. tab. [fr:270 mg, q. 150 mg Mg, comp. efferv.]", Unit.TABLET),
            new Format("DORAMAGN3T", "eq. to 300 mg Mg, tab. [fr:q.  300 mg Mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAMAGP", "MAGNESIUM lactate / PYRIDOXINE HCl [fr:MAGNESIUM lactate / PYRIDOXINE HCl]").withFormats(
            new Format("DORAMAGP55T", "eq. 48 mg Mg / 5 mg, tab. [fr:q. 48 mg Mg / 5 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAMEBE", "MEBENDAZOLE [fr:MEBENDAZOLE]").withFormats(
            new Format("DORAMEBE1T", "100 mg, tab. [fr:100 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAMEDR", "MEDROXYPROGESTERONE acetate [fr:MEDROXYPROGESTERONE actate]").withFormats(
            new Format("DORAMEDR1T", "10 mg, tab. [fr:10 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAMEFL", "MEFLOQUINE hydrochloride [fr:MEFLOQUINE chlorhydrate]").withFormats(
            new Format("DORAMEFL2T", "eq. 250 mg base, tab. [fr:q. 250 mg base, comp.]", Unit.TABLET)
        ),
        new Drug("DORAMETF", "METFORMIN hydrochloride [fr:METFORMINE chlorhydrate]").withFormats(
            new Format("DORAMETF1T", "1000 mg, tab. [fr:1000 mg, comp.]", Unit.TABLET),
            new Format("DORAMETF5T", "500 mg, tab. [fr:500 mg, comp.]", Unit.TABLET),
            new Format("DORAMETF8T", "850 mg, tab. [fr:850 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAMETN", "METRONIDAZOLE [fr:METRONIDAZOLE]").withFormats(
            new Format("DORAMETN2S", "benzoate, eq. 200 mg / 5 ml base, oral susp., 100 ml [fr:benzoate, q. 200 mg / 5 ml base, susp. orale, 100 ml]", Unit.ML),
            new Format("DORAMETN2T", "250 mg, tab. [fr:250 mg, comp.]", Unit.TABLET),
            new Format("DORAMETN5T", "500 mg, tab. [fr:500 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAMETO", "METOCLOPRAMIDE hydrochloride anhydrous [fr:METOCLOPRAMIDE chlorhydrate anhydre]").withFormats(
            new Format("DORAMETO1T", "10 mg, tab. [fr:10 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAMETY", "METHYLDOPA [fr:METHYLDOPA]").withFormats(
            new Format("DORAMETY2T", "250 mg, tab. [fr:250 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAMICO", "MICONAZOLE [fr:MICONAZOLE]").withFormats(
            new Format("DORAMICO2J1", "nitrate, 2%, oral gel, 15 g, tube [fr:nitrate, 2%, gel oral, 15 g, tube]", Unit.ML),
            new Format("DORAMICO2J4", "2%, oral gel, 40 g, tube [fr:2%, gel oral, 40 g, tube]", Unit.ML),
            new Format("DORAMICO2J8", "2%, oral gel, 80 g, tube [fr:2%, gel oral, 80 g, tube]", Unit.ML)
        ),
        new Drug("DORAMIFP", "MIFEPRISTONE [fr:MIFEPRISTONE]").withFormats(
            new Format("DORAMIFP2T", "200 mg, tab. [fr:200 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAMILT", "MILTEFOSINE [fr:MILTEFOSINE]").withFormats(
            new Format("DORAMILT1C", "10 mg, caps. [fr:10 mg, gl.]", Unit.CAPSULE),
            new Format("DORAMILT5C", "50 mg, caps. [fr:50 mg, gl.]", Unit.CAPSULE)
        ),
        new Drug("DORAMISP", "MISOPROSTOL [fr:MISOPROSTOL]").withFormats(
            new Format("DORAMISP25T", "25 g, tab. [fr:25 g, comp.]", Unit.TABLET),
            new Format("DORAMISP2T", "200 g, tab. [fr:200 g, comp.]", Unit.TABLET)
        ),
        new Drug("DORAMMNS", "MULTIPLE MICRONUTRIENTS SUPPLEMENTS [fr:MICRONUTRIMENTS MULTIPLES, SUPPLEMENTS]").withFormats(
            new Format("DORAMMNS1T", "tab. [fr:S ^, comp.]", Unit.TABLET)
        ),
        new Drug("DORAMONT", "MONTELUKAST [fr:MONTELUKAST]").withFormats(
            new Format("DORAMONT5TC", "5 mg, chewing tab. [fr:5 mg, tab.  macher]", Unit.TABLET)
        ),
        new Drug("DORAMORP", "MORPHINE sulfate [fr:MORPHINE sulfate]").withFormats(
            new Format("DORAMORP1CS", "10 mg, prolonged-release caps. [fr:10 mg, gl. libration prolonge]", Unit.CAPSULE),
            new Format("DORAMORP1S", "10 mg / 5 ml, oral sol., 100 ml, bot. [fr:10 mg / 5 ml, sol. orale, 100 ml, fl.]", Unit.ML),
            new Format("DORAMORP1T", "10 mg, immediate release breakable tab. [fr:10 mg, comp. scable libration immdiate]", Unit.TABLET),
            new Format("DORAMORP1TS", "10 mg, prolonged-release tab. [fr:10 mg, comp. libration prolonge]", Unit.TABLET),
            new Format("DORAMORP3CS", "30 mg, prolonged-release caps. [fr:30 mg, gl. libration prolonge]", Unit.CAPSULE),
            new Format("DORAMORP3TS", "30 mg, prolonged-release, tab. [fr:30 mg, comp. libration prolonge]", Unit.TABLET)
        ),
        new Drug("DORAMOXI", "MOXIFLOXACIN hydrochloride [fr:MOXIFLOXACINE chlorhydrate]").withFormats(
            new Format("DORAMOXI1TD", "eq. 100 mg base, disp. tab. [fr:q. 100 mg base, comp. disp.]", Unit.TABLET),
            new Format("DORAMOXI4T1", "eq 400 mg base, tab. blister [fr:q 400 mg base, comp. blister]", Unit.TABLET)
        ),
        new Drug("DORAMULT", "MULTIVITAMINS [fr:MULTIVITAMINES]").withFormats(
            new Format("DORAMULT1T", "tab. [fr:comp.]", Unit.TABLET)
        ),
        new Drug("DORANEVI", "NEVIRAPINE (NVP) [fr:NEVIRAPINE (NVP)]").withFormats(
            new Format("DORANEVI1S1", "50 mg / 5 ml, oral susp., 100 ml, bot. [fr:50 mg / 5 ml, susp. orale, 100 ml, fl.]", Unit.ML),
            new Format("DORANEVI1S2", "50 mg / 5 ml, oral susp., 240 ml, bot. [fr:50 mg / 5 ml, susp. orale, 240 ml, fl.]", Unit.ML),
            new Format("DORANEVI2T", "200 mg, tab. [fr:200 mg, comp.]", Unit.TABLET),
            new Format("DORANEVI5TD", "50 mg, disp. tab. [fr:50 mg, comp. disp.]", Unit.TABLET)
        ),
        new Drug("DORANICA", "NICARDIPINE hydrochloride [fr:NICARDIPINE chlorhydrate]").withFormats(
            new Format("DORANICA2TB", "20 mg, breakable tab. [fr:20 mg, comp. scable]", Unit.TABLET)
        ),
        new Drug("DORANICO", "NICOTINAMIDE (vitamin PP) [fr:NICOTINAMIDE (vitamine PP)]").withFormats(
            new Format("DORANICO1T", "100 mg, tab. [fr:100 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORANIFE", "NIFEDIPINE [fr:NIFEDIPINE]").withFormats(
            new Format("DORANIFE1C", "10 mg, immediate release soft caps. [fr:10 mg, caps. molle lib. immdiate]", Unit.CAPSULE),
            new Format("DORANIFE1TI", "10 mg, immediate release tab. [fr:10 mg, comp. lib. immdiate]", Unit.TABLET)
        ),
        new Drug("DORANIFU", "NIFURTIMOX [fr:NIFURTIMOX]").withFormats(
            new Format("DORANIFU1T", "120 mg, tab. [fr:120 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORANYST", "NYSTATIN [fr:NYSTATINE]").withFormats(
            new Format("DORANYST1S", "100.000 IU / ml, oral susp. [fr:100.000 UI / ml, susp. orale]", Unit.MG)
        ),
        new Drug("DORAOLAN", "OLANZAPINE [fr:OLANZAPINE]").withFormats(
            new Format("DORAOLAN2T", "2.5 mg, tab. [fr:2.5 mg, comp.]", Unit.TABLET),
            new Format("DORAOLAN5T", "5 mg, tab. [fr:5 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAOMEP", "OMEPRAZOLE [fr:OMEPRAZOLE]").withFormats(
            new Format("DORAOMEP1TDG", "10 mg, disp. gastro-resistant tab. [fr:10 mg, comp. disp. gastro-rsistant]", Unit.TABLET),
            new Format("DORAOMEP2CG", "20 mg, gastro-resistant caps. [fr:20 mg, gl. gastrorsistante]", Unit.CAPSULE)
        ),
        new Drug("DORAONDA", "ONDANSETRON [fr:ONDANSETRON]").withFormats(
            new Format("DORAONDA1S", "HCl, eq. 4 mg / 5 ml base, oral sol., 50 ml, bot. [fr:HCl, q. 4 mg / 5 ml base, sol. orale, 50 ml, fl.]", Unit.ML),
            new Format("DORAONDA4T", "hydrochloride, eq. 4 mg base, tab. [fr:chlorhydrate, q. 4 mg base, comp.]", Unit.TABLET),
            new Format("DORAONDA8T", "hydrochloride, eq. 8 mg base, tab. [fr:chlorhydrate, q. 8 mg base, comp]", Unit.TABLET)
        ),
        new Drug("DORAORMA", "RESOMAL [fr:RESOMAL]").withFormats(
            new Format("DORAORMA2S8", "rehydration acute complic. malnut., sach. 84 g / 2 l [fr:rhydratation malnut. aigu compliq, sach. 84 g / 2 l]", Unit.ML)
        ),
        new Drug("DORAORSA", "ORAL REHYDRATION SALTS (ORS) low osmol. [fr:SELS REHYDRATATION ORALE (SRO) basse osmol.]").withFormats(
            new Format("DORAORSA2S", "sachet 20.5 g / 1 l [fr:sachet 20.5 g / 1 l]", Unit.ML)
        ),
        new Drug("DORAOSEL", "OSELTAMIVIR phosphate [fr:OSELTAMIVIR phosphate]").withFormats(
            new Format("DORAOSEL7C", "eq. 75 mg base, caps. [fr:q. 75 mg base, gl.]", Unit.CAPSULE)
        ),
        new Drug("DORAPARA", "PARACETAMOL (acetaminophen) [fr:PARACETAMOL (actaminophne)]").withFormats(
            new Format("DORAPARA1S2", "120 mg / 5 ml, oral susp., 100 ml bot. [fr:120 mg / 5 ml, susp. orale, 100 ml fl.]", Unit.ML),
            new Format("DORAPARA1T", "100 mg, tab. [fr:100 mg, comp.]", Unit.TABLET),
            new Format("DORAPARA5T", "500 mg, tab. [fr:500 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAPARX", "PAROXETINE [fr:PAROXETINE]").withFormats(
            new Format("DORAPARX2TB", "20 mg, breakable tab. [fr:20 mg, comp. scable]", Unit.TABLET)
        ),
        new Drug("DORAPASA", "PARA-AMINOSALICYLIC acid (PAS) [fr:Acide PARA-AMINOSALICYLIQUE (PAS), gran. lib.]").withFormats(
            new Format("DORAPASA4S", "delayed rel. gran, 4 g, sach. [fr:. ret., 4 g, sach.]", Unit.MG),
            new Format("DORAPASA4S2", "del. rel. gran, 4 g, sach. (25C) [fr:. ret, 4 g, sach(25C)]", Unit.MG)
        ),
        new Drug("DORAPASS", "PARA-AMINOSALICYLATE sodium [fr:PARA-AMINOSALICYLATE sodique]").withFormats(
            new Format("DORAPASS1", "del. rel. gran 60% w / w, 100 g jar [fr:gran. lib. prol 60% w / w, 100 g pot]", Unit.ML),
            new Format("DORAPASS5S", "5.52 g, powder oral sol., sach. [fr:5.52 g, poudre sol. orale, sach]", Unit.MG),
            new Format("DORAPASS9S", "del. rel. gran 60% w / w, 9.2 g sach. [fr:gran. lib. prol 60% w / w, 9.2 g sach]", Unit.ML)
        ),
        new Drug("DORAPEGL", "POLYETHYLENE GLYCOL [fr:POLYETHYLENE GLYCOL]").withFormats(
            new Format("DORAPEGL1P", "powder, sachet [fr:poudre, sachet]", Unit.MG)
        ),
        new Drug("DORAPENV", "PHENOXYMETHYLPENICILLIN [fr:PHENOXYMETHYLPENICILLINE]").withFormats(
            new Format("DORAPENV1S1", "125 mg / 5 ml, powd. oral sol, 100 ml, bot [fr:125 mg / 5 ml, poudre sol. orale, 100 ml, fl]", Unit.ML),
            new Format("DORAPENV2T", "250 mg, tab. [fr:250 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAPHEN", "PHENOBARBITAL [fr:PHENOBARBITAL]").withFormats(
            new Format("DORAPHEN1T", "15 mg, tab. [fr:15 mg, comp.]", Unit.TABLET),
            new Format("DORAPHEN3T", "30 mg, tab. [fr:30 mg, comp.]", Unit.TABLET),
            new Format("DORAPHEN5T", "50 mg, tab. [fr:50 mg, comp.]", Unit.TABLET),
            new Format("DORAPHEN6T", "60 mg, tab. [fr:60 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAPHEY", "PHENYTOIN [fr:PHENYTOINE]").withFormats(
            new Format("DORAPHEY1S", "30 mg / 5 ml, oral susp., 500 ml, bot. [fr:30 mg / 5 ml, susp. orale, 500 ml, fl.]", Unit.ML),
            new Format("DORAPHEY1T", "sodium, 100 mg, tab. [fr:sodique, 100 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAPHLO", "PHLOROGLUCINOL [fr:PHLOROGLUCINOL]").withFormats(
            new Format("DORAPHLO8TOD", "80 mg, orodisp. tab. [fr:80 mg, comp. orodisp.]", Unit.TABLET)
        ),
        new Drug("DORAPHYT", "PHYTOMENADIONE (vitamin K1) [fr:PHYTOMENADIONE (vitamine K1)]").withFormats(
            new Format("DORAPHYT1A1", "10 mg / ml, 1 ml, amp. [fr:10 mg / ml, 1 ml, amp.]", Unit.ML)
        ),
        new Drug("DORAPOTC", "POTASSIUM chloride [fr:POTASSIUM chlorure]").withFormats(
            new Format("DORAPOTC6TP", "600 mg (8mEq), prolonged-release tab. [fr:600 mg (8mEq), comp. libration prolonge]", Unit.TABLET),
            new Format("DORAPOTC7S", "7.5% w / v, 1mmol K / ml, oral sol., 500 ml, bot [fr:7.5% p / v, 1mmol K / ml, sol. orale, 500 ml, fl]", Unit.ML)
        ),
        new Drug("DORAPRAZ", "PRAZIQUANTEL [fr:PRAZIQUANTEL]").withFormats(
            new Format("DORAPRAZ6TB", "600 mg, break. tab. [fr:600 mg, comp. sc.]", Unit.TABLET)
        ),
        new Drug("DORAPRED", "PREDNISOLONE [fr:PREDNISOLONE]").withFormats(
            new Format("DORAPRED2TOD", "20 mg, orodisp. tablet [fr:20 mg, comp. orodisp.]", Unit.MG),
            new Format("DORAPRED5T", "5 mg, tab. [fr:5 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAPRIM", "PRIMAQUINE diphosphate [fr:PRIMAQUINE diphosphate]").withFormats(
            new Format("DORAPRIM1T", "eq. 15 mg base, tab. [fr:q. 15 mg base, comp.]", Unit.TABLET),
            new Format("DORAPRIM7T", "eq. 7.5 mg base, tab. [fr:q. 7.5 mg base, comp.]", Unit.TABLET)
        ),
        new Drug("DORAPRIS", "PRISTINAMYCIN [fr:PRISTINAMYCINE]").withFormats(
            new Format("DORAPRIS5TB", "500 mg, break. tab. [fr:500 mg, comp. sc.]", Unit.TABLET)
        ),
        new Drug("DORAPROM", "PROMETHAZINE [fr:PROMETHAZINE]").withFormats(
            new Format("DORAPROM2T", "hydrochloride, eq. 25 mg base, tab. [fr:chlorhydrate, q. 25 mg base, comp.]", Unit.TABLET),
            new Format("DORAPROM5S", "5 mg / 5 ml, syrup, 150 ml, bot. [fr:5 mg / 5 ml, sirop, 150 ml, fl.]", Unit.ML),
            new Format("DORAPROM5S1", "5 mg / 5 ml, oral solution, 100 ml, bot [fr:5 mg / 5 ml, sol. orale, 100 ml, fl.]", Unit.ML)
        ),
        new Drug("DORAPRON", "PROTHIONAMIDE [fr:PROTHIONAMIDE]").withFormats(
            new Format("DORAPRON2T1", "250 mg, tab., blister [fr:250 mg, comp., blister]", Unit.TABLET)
        ),
        new Drug("DORAPYRA", "PYRANTEL [fr:PYRANTEL]").withFormats(
            new Format("DORAPYRA1S", "250 mg / 5 ml, oral susp., 15 ml, bot. [fr:250 mg / 5 ml, susp. orale, 15 ml, fl.]", Unit.ML)
        ),
        new Drug("DORAPYRI", "PYRIDOXINE hydrochloride (vitamin B6) [fr:PYRIDOXINE chlorhydrate (vitamine B6)]").withFormats(
            new Format("DORAPYRI1T", "10 mg, tab. [fr:10 mg, comp.]", Unit.TABLET),
            new Format("DORAPYRI5T", "50 mg, tab. [fr:50 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAPYRM", "PYRIMETHAMINE [fr:PYRIMETHAMINE]").withFormats(
            new Format("DORAPYRM2T", "25 mg, tab. [fr:25 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAPYRZ", "PYRAZINAMIDE (Z) [fr:PYRAZINAMIDE (Z)]").withFormats(
            new Format("DORAPYRZ1T1", "150 mg, disp. tab., blister [fr:150 mg, comp. disp., blister]", Unit.TABLET),
            new Format("DORAPYRZ1T3", "150 mg, disp. tab., bulk [fr:150 mg, comp. disp., vrac]", Unit.TABLET),
            new Format("DORAPYRZ4T1", "400 mg, tab., blister [fr:400 mg, comp., blister]", Unit.TABLET),
            new Format("DORAPYRZ4T3", "400 mg, tab., bulk [fr:400 mg, comp., vrac]", Unit.TABLET)
        ),
        new Drug("DORAQUIN", "QUININE sulfate [fr:QUININE sulfate]").withFormats(
            new Format("DORAQUIN3T", "300 mg, tab. [fr:300 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORARALT", "RALTEGRAVIR potassium (RAL) [fr:RALTEGRAVIR potassique (RAL)]").withFormats(
            new Format("DORARALT1TC", "eq. 100 mg base, chew. tab. [fr:q. 100 mg base, comp.  macher]", Unit.TABLET),
            new Format("DORARALT2TC", "eq. 25 mg base, chew. tab. [fr:q. 25 mg base, comp.  mcher]", Unit.TABLET),
            new Format("DORARALT4T", "eq. 400 mg base, tab. [fr:q. 400 mg base, comp.]", Unit.TABLET)
        ),
        new Drug("DORARAMI", "RAMIPRIL [fr:RAMIPRIL]").withFormats(
            new Format("DORARAMI1T", "10 mg, tab. [fr:10 mg, comp.]", Unit.TABLET),
            new Format("DORARAMI2T", "2.5 mg, tab. [fr:2.5 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORARANI", "RANITIDINE [fr:RANITIDINE]").withFormats(
            new Format("DORARANI1T", "150 mg, tab. [fr:150 mg, comp.]", Unit.TABLET),
            new Format("DORARANI1TE", "150 mg, effervescent tab. [fr:150 mg, comp. effervescent]", Unit.TABLET)
        ),
        new Drug("DORARETI", "RETINOL (vitamin A) stabil. [fr:RETINOL (vitamine A) stabilis]").withFormats(
            new Format("DORARETI2C", "200.000 IU, soft gelat. caps. [fr:200.000 UI, caps. molle]", Unit.CAPSULE)
        ),
        new Drug("DORARIBA", "RIBAVIRIN [fr:RIBAVIRINE]").withFormats(
            new Format("DORARIBA1S", "200 mg / 5 ml, oral sol., 100 ml, bot. [fr:200 mg / 5 ml, sol. orale, 100 ml, fl.]", Unit.ML),
            new Format("DORARIBA2C", "200 mg, caps. [fr:200 mg, gl.]", Unit.CAPSULE),
            new Format("DORARIBA2T", "200 mg, tab. [fr:200 mg, comp.]", Unit.TABLET),
            new Format("DORARIBA4T", "400 mg, tab. [fr:400 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORARIFA", "RIFAMPICIN (R) [fr:RIFAMPICINE (R)]").withFormats(
            new Format("DORARIFA1C1", "150 mg, caps. blister [fr:150 mg, gl. blister]", Unit.CAPSULE),
            new Format("DORARIFA1C3", "150 mg, caps. bulk [fr:150 mg, gl. vrac]", Unit.CAPSULE),
            new Format("DORARIFA1T1", "150 mg, tab., blister [fr:150 mg, comp., blister]", Unit.TABLET),
            new Format("DORARIFA1T3", "150 mg, tab., bulk [fr:150 mg, comp., vrac]", Unit.TABLET),
            new Format("DORARIFA3C1", "300 mg, caps. blister [fr:300 mg, gl. blister]", Unit.CAPSULE),
            new Format("DORARIFA3C3", "300 mg, caps. bulk [fr:300 mg, gl. vrac]", Unit.CAPSULE)
        ),
        new Drug("DORARIFB", "RIFABUTIN [fr:RIFABUTINE]").withFormats(
            new Format("DORARIFB1C", "150 mg, caps. [fr:150 mg, gl.]", Unit.CAPSULE)
        ),
        new Drug("DORARIFP", "RIFAPENTINE [fr:RIFAPENTINE]").withFormats(
            new Format("DORARIFP1T1", "150 mg, tab., blister [fr:150 mg, comp., blister]", Unit.TABLET)
        ),
        new Drug("DORARISP", "RISPERIDONE [fr:RISPERIDONE]").withFormats(
            new Format("DORARISP1T", "1 mg, tab. [fr:1 mg, comp.]", Unit.TABLET),
            new Format("DORARISP2T", "2 mg, tab. [fr:2 mg, comp.]", Unit.TABLET),
            new Format("DORARISP4T", "4 mg, tab. [fr:4 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORARITO", "RITONAVIR (r) [fr:RITONAVIR (r)]").withFormats(
            new Format("DORARITO1T2", "100 mg, tab. [fr:100 mg, comp.]", Unit.TABLET),
            new Format("DORARITO2T", "25 mg, tab. [fr:25 mg, comp.]", Unit.TABLET),
            new Format("DORARITO8S", "400 mg / 5 ml, oral sol., 90 ml, bot. [fr:400 mg / 5 ml, sol. orale, 90 ml, fl.]", Unit.ML)
        ),
        new Drug("DORASALB", "SALBUTAMOL [fr:SALBUTAMOL]").withFormats(
            new Format("DORASALB1N", "solution for nebulizer, 2 mg / ml, 2.5 ml monodose [fr:solution pour nbuliseur, 2 mg / ml, 2.5 ml unidose]", Unit.ML),
            new Format("DORASALB2SF", "sulfate, eq. 0.1 mg base / puff, 200 puffs, aerosol [fr:sulfate, q. 0.1 mg base / bouffe, 200 bouff. arosol]", Unit.PUFF)
        ),
        new Drug("DORASALM", "SALMETEROL [fr:SALMETEROL]").withFormats(
            new Format("DORASALM2SF", "25 g / puff, 120 puffs, aerosol [fr:25 g / bouffe, 120 bouffes, aerosol]", Unit.PUFF)
        ),
        new Drug("DORASERT", "SERTRALINE hydrochloride [fr:SERTRALINE chlorhydrate]").withFormats(
            new Format("DORASERT1T", "eq. 100 mg base, tab. [fr:q. 100 mg base, comp.]", Unit.TABLET),
            new Format("DORASERT5T", "eq. 50 mg base, tab. [fr:q. 50 mg base, comp.]", Unit.TABLET)
        ),
        new Drug("DORASODC", "SODIUM chloride [fr:SODIUM chlorure]").withFormats(
            new Format("DORASODC6V", "6%, for nebulizer, 4 ml, vial [fr:6%, pour nbulisation, 4 ml, fl.]", Unit.ML)
        ),
        new Drug("DORASOFO", "SOFOSBUVIR [fr:SOFOSBUVIR]").withFormats(
            new Format("DORASOFO4T", "400 mg, tab. [fr:400 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORASOVE", "SOF / VEL (SOFOSBUVIR / VELPATASVIR) [fr:SOF / VEL (SOFOSBUVIR / VELPATASVIR)]").withFormats(
            new Format("DORASOVE41T", "() 400 mg / () 100 mg, tab. [fr:() 400 mg / () 100 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORASOVV", "SOF / VEL / VOX (SOFOSBUVIR / VELPATASVIR / VOXILAPREVIR) [fr:SOF / VEL / VOX (SOFOSBUVIR / VELPATASVIR / VOXILAPREVIR)]").withFormats(
            new Format("DORASOVV411T", "400 mg / 100 mg / 100 mg, tab. [fr:400 mg / 100 mg / 100 mg, comp]", Unit.TABLET)
        ),
        new Drug("DORASPAQ", "SP + AQ (SULFADOXINE / PYRIMETHAMINE + AMODIAQUINE) [fr:SP + AQ (SULFADOXINE / PYRIMETHAMINE + AMODIAQUINE)]").withFormats(
            new Format("DORASPAQ1TD2", "1 x 250/12.5 mg+ 3xeq. 75-76.5 mg base, cobl. disp. tab, 4.5-8kg [fr:1 x 250/12.5 mg+ 3 x eq. 75-76.5 mg base, cobl. comp. disp., 4.5-8kg]", Unit.TABLET),
            new Format("DORASPAQ2TD2", "1 x 500/25 mg + 3 x eq. 150-153 mg base, cobl. disp. tab, 9-17kg [fr:1 x 500/25 mg+ 3 x q. 150-153 mg base, cobl. comp. disp, 9-17kg]", Unit.TABLET)
        ),
        new Drug("DORASPIR", "SPIRONOLACTONE [fr:SPIRONOLACTONE]").withFormats(
            new Format("DORASPIR2T", "25 mg, tab. [fr:25 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORASUCC", "SUCCIMER [fr:SUCCIMER]").withFormats(
            new Format("DORASUCC2C", "200 mg, caps. [fr:200 mg, gl.]", Unit.CAPSULE)
        ),
        new Drug("DORASUDI", "SULFADIAZINE [fr:SULFADIAZINE]").withFormats(
            new Format("DORASUDI5T", "500 mg, tab. [fr:500 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORASULP", "SULFADOXINE / PYRIMETHAMINE [fr:SULFADOXINE / PYRIMETHAMINE]").withFormats(
            new Format("DORASULP5T", "500 mg / 25 mg, tab. [fr:500 mg / 25 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORATEEF", "TDF / FTC / EFV [fr:TDF / FTC / EFV]").withFormats(
            new Format("DORATEEF1T", "300 mg / 200 mg / 600 mg, tab. [fr:300 mg / 200 mg / 600 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORATEEM", "TDF / FTC [fr:TDF / FTC]").withFormats(
            new Format("DORATEEM1T", "300 mg / 200 mg, tab. [fr:300 mg / 200 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORATELA", "TDF / 3TC [fr:TDF / 3TC]").withFormats(
            new Format("DORATELA1T", "300 mg / 300 mg, tab. [fr:300 mg / 300 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORATELD", "TDF / 3TC / DTG [fr:TDF / 3TC / DTG]").withFormats(
            new Format("DORATELD1T", "300 mg / 300 mg / 50 mg, tab. [fr:300 mg / 300 mg / 50 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORATELE", "TDF / 3TC / EFV [fr:TDF / 3TC / EFV]").withFormats(
            new Format("DORATELE1T", "300 mg / 300 mg / 600 mg, tab. [fr:300 mg / 300 mg / 600 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORATENO", "TENOFOVIR DISOPROXIL [fr:TENOFOVIR DISOPROXIL]").withFormats(
            new Format("DORATENO2T", "FUMARATE, eq. 163 mg base, tab. [fr:FUMARATE, q. 163 mg base, comp.]", Unit.TABLET),
            new Format("DORATENO3T", "fumarate 300 mg, eq. 245 mg base, tab. [fr:fumarate 300 mg, q. 245 mg base, comp]", Unit.TABLET)
        ),
        new Drug("DORATHIA", "THIAMINE hydrochloride (vitamin B1) [fr:THIAMINE chlorhydrate (vitamine B1)]").withFormats(
            new Format("DORATHIA2T", "250 mg, tab. [fr:250 mg, comp.]", Unit.TABLET),
            new Format("DORATHIA5T", "50 mg, tab. [fr:50 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORATINI", "TINIDAZOLE [fr:TINIDAZOLE]").withFormats(
            new Format("DORATINI5T", "500 mg, tab. [fr:500 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORATRAM", "TRAMADOL hydrochloride [fr:TRAMADOL chlorhydrate]").withFormats(
            new Format("DORATRAM1S", "100 mg / ml / 40 drops, 10 ml, bot. [fr:100 mg / ml / 40 gouttes, 10 ml, fl.]", Unit.ML),
            new Format("DORATRAM5C", "50 mg, caps. [fr:50 mg, gl.]", Unit.CAPSULE)
        ),
        new Drug("DORATRAN", "TRANEXAMIC ACID [fr:ACIDE TRANEXAMIQUE]").withFormats(
            new Format("DORATRAN5T", "500 mg tab [fr:500 mg comp]", Unit.TABLET)
        ),
        new Drug("DORATRIB", "TRICLABENDAZOLE [fr:TRICLABENDAZOLE]").withFormats(
            new Format("DORATRIB2T", "250 mg, tab. [fr:250 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORATRIH", "TRIHEXYPHENIDYL hydrochloride [fr:TRIHEXYPHENIDYLE chlorhydrate]").withFormats(
            new Format("DORATRIH2T", "2 mg, tab. [fr:2 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAULIP", "ULIPRISTAL acetate [fr:ULIPRISTAL actate]").withFormats(
            new Format("DORAULIP3T", "30 mg, tab. [fr:30 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAVALG", "VALGANCICLOVIR hydrochloride [fr:VALGANCICLOVIR chlorhydrate]").withFormats(
            new Format("DORAVALG4T", "eq. 450 mg base, tab. [fr:q. 450 mg base, comp.]", Unit.TABLET)
        ),
        new Drug("DORAVALP", "VALPROATE SODIUM [fr:VALPROATE de SODIUM]").withFormats(
            new Format("DORAVALP1S", "200 mg / ml, 40 ml, bot. + syringe [fr:200 mg / ml, 40 ml, fl. + seringue]", Unit.ML),
            new Format("DORAVALP2S", "200 mg / 5 ml, 300 ml, bot. [fr:200 mg / 5 ml, 300 ml, fl.]", Unit.ML),
            new Format("DORAVALP2TG", "200 mg, gastro-resistant tab. [fr:200 mg, comp. gastro-rsistant]", Unit.TABLET),
            new Format("DORAVALP5TG", "500 mg, gastro-resistant tab. [fr:500 mg, comp. gastro-rsistant]", Unit.TABLET)
        ),
        new Drug("DORAVERA", "VERAPAMIL hydrochloride [fr:VERAPAMIL chlorhydrate]").withFormats(
            new Format("DORAVERA4T", "40 mg, tab. [fr:40 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAVITB", "VITAMINE B COMPLEX [fr:VITAMINE B COMPLEX]").withFormats(
            new Format("DORAVITB1T", "tab. [fr:comp.]", Unit.TABLET)
        ),
        new Drug("DORAWARF", "WARFARIN [fr:WARFARINE]").withFormats(
            new Format("DORAWARF1T", "1 mg, tab. [fr:1 mg, comp.]", Unit.TABLET),
            new Format("DORAWARF5T", "5 mg, tab. [fr:5 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAYIDO", "ZIDOVUDINE (AZT) [fr:ZIDOVUDINE (AZT)]").withFormats(
            new Format("DORAYIDO1S", "50 mg / 5 ml, oral sol., 100 ml bot. [fr:50 mg / 5 ml, sol. orale, 100 ml, fl.]", Unit.ML),
            new Format("DORAYIDO2S", "50 mg / 5 ml, oral sol., 200 ml, bot. [fr:50 mg / 5 ml, sol. orale, 200 ml, fl.]", Unit.ML),
            new Format("DORAYIDO3S", "50 mg / 5 ml, oral sol., 240 ml, bot. [fr:50 mg / 5 ml, sol. orale, 240 ml, fl.]", Unit.ML),
            new Format("DORAYIDO3T", "300 mg, tab. [fr:300 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAYILA", "AZT / 3TC [fr:AZT / 3TC]").withFormats(
            new Format("DORAYILA1T", "60 mg / 30 mg, tab. [fr:60 mg / 30 mg, comp.]", Unit.TABLET),
            new Format("DORAYILA1TD", "60 mg / 30 mg, disp. tab. [fr:60 mg / 30 mg, comp. disp.]", Unit.TABLET),
            new Format("DORAYILA2T", "300 mg / 150 mg, tab. [fr:300 mg / 150 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAYILE", "AZT / 3TC + EFV [fr:AZT / 3TC + EFV]").withFormats(
            new Format("DORAYILE1T2", "300 mg / 150 mg x 2 + 600 mg x 1, coblister of tab [fr:300 mg / 150 mg x 2 + 600 mg x 1, coblister comp]", Unit.TABLET),
            new Format("DORAYILE1T4", "300 mg / 150 mg x 60 + 600 mg x 30, co-pack of tab. [fr:300 mg / 150 mg x 60 + 600 mg x 30, co-pack comp.]", Unit.TABLET)
        ),
        new Drug("DORAYILN", "AZT / 3TC / NVP [fr:AZT / 3TC / NVP]").withFormats(
            new Format("DORAYILN1TD", "60 mg / 30 mg / 50 mg, dispersible tab. [fr:60 mg / 30 mg / 50 mg, comp. dispersible]", Unit.TABLET),
            new Format("DORAYILN2T", "300 mg / 150 mg / 200 mg, tab. [fr:300 mg / 150 mg / 200 mg, comp.]", Unit.TABLET)
        ),
        new Drug("DORAYINS", "ZINC sulfate [fr:ZINC sulfate]").withFormats(
            new Format("DORAYINS2T", "eq. to 20 mg zinc mineral, dispersible tab. [fr:q.  20 mg de zinc minral, comp. dispers.]", Unit.TABLET)
        ),
        new Drug("DORADEXT", "DEXTROSE (GLUCOSE) [fr:GLUCOSE]").withFormats(
            new Format("DORADEXTXX5", "5%, oral (nonstandard) [fr:5%, orale (non standard)]", Unit.ML),
            new Format("DORADEXTXX10", "10%, oral (nonstandard) [fr:10%, orale (non standard)]", Unit.ML)
        )
    );

    Category INJECTABLE = new Category("DINJ", "injectable", false, IV, SC, IM, IO).withDrugs(
        new Drug("DINJACCY", "ACETYLCYSTEINE [fr:ACETYLCYSTEINE]").withFormats(
            new Format("DINJACCY2A", "200 mg / ml, 10 ml, amp. [fr:200 mg / ml, 10 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJACIV", "ACICLOVIR sodium [fr:ACICLOVIR sodique]").withFormats(
            new Format("DINJACIV2V", "eq. 250 mg base, powder, vial [fr:q. 250 mg base, poudre, fl]", Unit.MG),
            new Format("DINJACIV2V1", "eq. 25 mg / ml base, 10 ml, vial [fr:q. 25 mg / ml base, 10 ml, fl.]", Unit.ML)
        ),
        new Drug("DINJADEN", "ADENOSINE [fr:ADENOSINE]").withFormats(
            new Format("DINJADEN6V", "3 mg / ml, 2 ml, vial [fr:3 mg / ml, 2 ml, fl.]", Unit.ML)
        ),
        new Drug("DINJAMBC", "AMPHOTERICIN B conventional [fr:AMPHOTERICINE B conventionnelle]").withFormats(
            new Format("DINJAMBC5V", "50 mg, powder, vial [fr:50 mg, poudre, fl.]", Unit.MG)
        ),
        new Drug("DINJAMBL", "AMPHOTERICIN B liposomal complex [fr:AMPHOTERICINE B complexe liposomal]").withFormats(
            new Format("DINJAMBL5V", "50 mg, powder, vial [fr:50 mg, poudre, fl.]", Unit.MG)
        ),
        new Drug("DINJAMIK", "AMIKACIN sulfate [fr:AMIKACINE sulfate]").withFormats(
            new Format("DINJAMIK5A", "eq. 250 mg / ml base, 2 ml, amp. [fr:q. 250 mg / ml base, 2 ml, amp.]", Unit.ML),
            new Format("DINJAMIK5V1", "eq. 250 mg / ml base, 2 ml, vial [fr:q. 250 mg / ml base, 2 ml, fl.]", Unit.ML)
        ),
        new Drug("DINJAMIO", "AMIODARONE hydrochloride [fr:AMIODARONE chlorhydrate]").withFormats(
            new Format("DINJAMIO1A", "50 mg / ml, 3 ml, amp. [fr:50 mg / ml, 3 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJAMOC", "AMOXICILLIN / CLAVULANIC acid [fr:AMOXICILLINE / acide CLAVULANIQUE]").withFormats(
            new Format("DINJAMOC1V2", "1 g / 200 mg, powder [fr:1 g / 200 mg, poudre]", Unit.MG)
        ),
        new Drug("DINJAMPI", "AMPICILLIN [fr:AMPICILLINE]").withFormats(
            new Format("DINJAMPI1V", "1 g, powder, vial [fr:1 g, poudre, fl.]", Unit.MG),
            new Format("DINJAMPI5V", "500 mg, powder, vial [fr:500 mg, poudre, fl.]", Unit.MG)
        ),
        new Drug("DINJAREP", "ARTICAINE / EPINEPHRINE [fr:ARTICAINE / EPINEPHRINE]").withFormats(
            new Format("DINJAREP4C1", "4% / 1/100000, 1.7 ml, dent. cartr. [fr:4% / 1/100000, 1.7 ml carp. dent.]", Unit.ML)
        ),
        new Drug("DINJARTS", "ARTESUNATE [fr:ARTESUNATE]").withFormats(
            new Format("DINJARTS6V", "60 mg, powder, vial +NaHCO3 5% 1 ml +NaCl 0.9% 5 ml [fr:60 mg, poudre, fl +NaHCO3 5% 1 ml +NaCl 0.9% 5 ml]", Unit.MG)
        ),
        new Drug("DINJATRB", "ATRACURIUM besilate [fr:besilate d'ATRACURIUM]").withFormats(
            new Format("DINJATRB2A", "10 mg / ml, 2.5 ml, amp. [fr:10 mg / ml, 2.5 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJATRO", "ATROPINE sulfate [fr:ATROPINE sulfate]").withFormats(
            new Format("DINJATRO1A", "1 mg / ml, 1 ml, amp. [fr:1 mg / ml, 1 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJBLEO", "BLEOMYCIN sulfate [fr:BLEOMYCINE sulfate]").withFormats(
            new Format("DINJBLEO1V", "eq 15.000 IU base, powder, vial [fr:q. 15.000 UI base, poudre, fl.]", Unit.MG)
        ),
        new Drug("DINJBUPI", "BUPIVACAINE HCl, hyperbaric / spinal [fr:BUPIVACAINE HCl, hyperbare / rachi]").withFormats(
            new Format("DINJBUPI2A", "l, eq. 5 mg / ml base, 4 ml, amp [fr:i, q. 5 mg / ml base, 4 ml, amp]", Unit.ML)
        ),
        new Drug("DINJCAFC", "CAFFEINE CITRATE [fr:CAFEINE CITRATE]").withFormats(
            new Format("DINJCAFC1A", "10 mg / ml, eq. 5 mg caffeine base, 1 ml, amp. [fr:10 mg / ml, q. 5 mg cafine base, 1 ml, amp.]", Unit.ML),
            new Format("DINJCAFC2A", "20 mg / ml eq. 10 mg caffeine base, 1 ml, amp. [fr:20 mg / ml, q. 10 mg cafine base, 1 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJCALG", "CALCIUM GLUCONATE [fr:CALCIUM GLUCONATE]").withFormats(
            new Format("DINJCALG1A", "100 mg / ml, 10 ml, amp. [fr:100 mg / ml, 10 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJCAPR", "CAPREOMYCIN sulfate [fr:CAPREOMYCINE sulfate]").withFormats(
            new Format("DINJCAPR1V", "eq. 1 g base, powder, vial [fr:q. 1 g base, poudre, fl.]", Unit.MG)
        ),
        new Drug("DINJCEFA", "CEFAZOLIN [fr:CEFAZOLINE]").withFormats(
            new Format("DINJCEFA1V", "1 g, (IV), powder, vial [fr:1 g, (IV), poudre, fl.]", Unit.MG)
        ),
        new Drug("DINJCEFL", "CEFTRIAXONE sodium + lidocaine IM [fr:CEFTRIAXONE sodique + lidocaine IM]").withFormats(
            new Format("DINJCEFL1V", "eq. 1 g base, powder, vial [fr:q. 1 g base, poudre, fl.]", Unit.MG),
            new Format("DINJCEFL2V", "eq. 250 mg base, powd, vial [fr:q. 250 mg base, poudre, fl.]", Unit.MG)
        ),
        new Drug("DINJCEFO", "CEFOTAXIME sodium [fr:CEFOTAXIME sodique]").withFormats(
            new Format("DINJCEFO2V", "eq. 250 mg base, vial [fr:q. 250 mg base, fl.]", Unit.MG),
            new Format("DINJCEFO5V", "eq. 500 mg base, vial [fr:q. 500 mg base, fl.]", Unit.MG)
        ),
        new Drug("DINJCEFT", "CEFTRIAXONE sodium [fr:CEFTRIAXONE sodique]").withFormats(
            new Format("DINJCEFT1V", "eq. 1 g base, powder, vial [fr:q. 1 g base, poudre, fl.]", Unit.MG),
            new Format("DINJCEFT2V", "eq. 250 mg base, powder, vial [fr:q. 250 mg base, poudre, fl.]", Unit.MG)
        ),
        new Drug("DINJCEFZ", "CEFTAZIDIME [fr:CEFTAZIDIME]").withFormats(
            new Format("DINJCEFZ1V", "1 g, powder, vial [fr:1 g, poudre, fl.]", Unit.MG),
            new Format("DINJCEFZ2V", "2 g, powder, vial [fr:2 g, poudre, fl.]", Unit.MG)
        ),
        new Drug("DINJCHLO", "CHLORAMPHENICOL [fr:CHLORAMPHENICOL]").withFormats(
            new Format("DINJCHLO1V", "1 g powder, vial [fr:1 g, poudre, fl.]", Unit.MG)
        ),
        new Drug("DINJCIPR", "CIPROFLOXACIN salt [fr:sel de CIPROFLOXACINE]").withFormats(
            new Format("DINJCIPR2FBF", "eq. 2 mg / ml base, 100 ml, flex. bag PVC free [fr:q. 2 mg / ml base, 100 ml, poche sple ssPVC]", Unit.ML),
            new Format("DINJCIPR2SRF", "eq. 2 mg / ml base, 100 ml, semi-r. bot PVCfree [fr:q. 2 mg / ml base, 100 ml, fl. semi-r. ssPVC]", Unit.ML)
        ),
        new Drug("DINJCLIN", "CLINDAMYCIN phosphate [fr:CLINDAMYCINE phosphate]").withFormats(
            new Format("DINJCLIN3A", "eq. 150 mg base / ml, 2 ml, amp. [fr:q. 150 mg base / ml, 2 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJCLON", "CLONIDINE [fr:CLONIDINE]").withFormats(
            new Format("DINJCLON1A", "0.15 mg / ml, 1 ml, amp. [fr:0.15 mg / ml, 1 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJCLOX", "CLOXACILLIN sodium [fr:CLOXACILLINE sodique]").withFormats(
            new Format("DINJCLOX5VV", "eq. 500 mg base, powder, vial IV [fr:q. 500 mg base, poudre, fl. IV]", Unit.MG)
        ),
        new Drug("DINJCOLI", "COLISTIMETHATE sodium [fr:COLISTIMETHATE sodique]").withFormats(
            new Format("DINJCOLI1V", "1 MIU, powder, vial [fr:1 MUI, poudre, fl.]", Unit.MG),
            new Format("DINJCOLI2V", "2 M IU, powder, vial, for infusion [fr:2 M UI, poudre, flacon, pour perf.]", Unit.MG)
        ),
        new Drug("DINJCOTR", "COTRIMOXAZOLE [fr:COTRIMOXAZOLE]").withFormats(
            new Format("DINJCOTR4A", "80 mg / 16 mg / ml, 5 ml for infusion, amp. [fr:80 mg / 16 mg / ml, 5 ml pour perfusion, amp.]", Unit.ML)
        ),
        new Drug("DINJDEFE", "DEFEROXAMINE (desferrioxamine) mesilate [fr:DEFEROXAMINE (desferrioxamine) mesilate]").withFormats(
            new Format("DINJDEFE5V", "500 mg, powder, vial [fr:500 mg, poudre, fl.]", Unit.MG)
        ),
        new Drug("DINJDEXA", "DEXAMETHASONE phosphate [fr:DEXAMETHASONE phosphate]").withFormats(
            new Format("DINJDEXA4A", "4 mg / ml, 1 ml, amp. [fr:4 mg / ml, 1 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJDIAZ", "DIAZEPAM [fr:DIAZEPAM]").withFormats(
            new Format("DINJDIAZ1A", "5 mg / ml, 2 ml, amp. [fr:5 mg / ml, 2 ml, amp.]", Unit.ML),
            new Format("DINJDIAZ1AE", "5 mg / ml, 2 ml, emulsion, amp. [fr:5 mg / ml, 2 ml, mulsion, amp.]", Unit.ML)
        ),
        new Drug("DINJDICL", "DICLOFENAC sodium [fr:DICLOFENAC sodique]").withFormats(
            new Format("DINJDICL7A", "25 mg / ml, 3 ml, amp. [fr:25 mg / ml, 3 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJDIGO", "DIGOXIN [fr:DIGOXINE]").withFormats(
            new Format("DINJDIGO5A", "0.25 mg / ml, 2 ml, amp. [fr:0.25 mg / ml, 2 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJDILT", "DILTIAZEM hydrochloride [fr:DILTIAZEM chlorhydrate]").withFormats(
            new Format("DINJDILT2V", "25 mg, powder, vial [fr:25 mg, poudre, fl.]", Unit.MG)
        ),
        new Drug("DINJDOBU", "DOBUTAMINE HCl. [fr:DOBUTAMINE HCl.]").withFormats(
            new Format("DINJDOBU2A", "eq. 12.5 mg / ml base, 20 ml, sol for infusion [fr:q. 12.5 mg / ml base, 20 ml, sol pour perfusion]", Unit.ML)
        ),
        new Drug("DINJDOPA", "DOPAMINE hydrochloride [fr:DOPAMINE chlorhydrate]").withFormats(
            new Format("DINJDOPA2A", "40 mg / ml, 5 ml, amp. [fr:40 mg / ml, 5 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJDOPL", "DOXORUBICIN HCl, pegylated liposomal [fr:DOXORUBICINE HCl, pgyle liposomale]").withFormats(
            new Format("DINJDOPL2V", "l, 2 mg / ml, 10 ml vial [fr:e, 2 mg / ml, 10 ml fl.]", Unit.ML),
            new Format("DINJDOPL5V", "l, 2 mg / ml, 25 ml vial [fr:e, 2 mg / ml, 25 ml fl.]", Unit.ML)
        ),
        new Drug("DINJDOXO", "DOXORUBICIN hydrochloride [fr:DOXORUBICINE chlorhydrate]").withFormats(
            new Format("DINJDOXO1V", "10 mg, powder, vial [fr:10 mg, poudre, fl.]", Unit.MG),
            new Format("DINJDOXO1V5", "2 mg / ml, 5 ml, vial [fr:2 mg / ml, 5 ml, fl.]", Unit.ML)
        ),
        new Drug("DINJEFLO", "EFLORNITHINE hydrochloride [fr:EFLORNITHINE chlorhydrate]").withFormats(
            new Format("DINJEFLO2V", "eq. 200 mg / ml base, 100 ml, vial [fr:q. 200 mg / ml base, 100 ml, fl.]", Unit.ML)
        ),
        new Drug("DINJENOX", "ENOXAPARIN sodium [fr:ENOXAPARINE sodique]").withFormats(
            new Format("DINJENOX10S", "10.000 IU / 1 ml, syringe [fr:10000 UI / 1 ml, seringue]", Unit.ML),
            new Format("DINJENOX20S", "2.000 IU / 0.2 ml, syringe [fr:2000 UI / 0.2 ml, seringue]", Unit.ML),
            new Format("DINJENOX40S", "4.000 IU / 0.4 ml, syringe [fr:4000 UI / 0.4 ml, seringue]", Unit.ML),
            new Format("DINJENOX60S", "6.000 IU / 0.6 ml, syringe [fr:6000 UI / 0.6 ml, seringue]", Unit.ML)
        ),
        new Drug("DINJEPHE", "EPHEDRINE hydrochloride [fr:EPHEDRINE chlorhydrate]").withFormats(
            new Format("DINJEPHE3A", "30 mg / ml, 1 ml, amp. [fr:30 mg / ml, 1 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJEPIN", "EPINEPHRINE (adrenaline) tartrate [fr:EPINEPHRINE (adrenaline) tartrate]").withFormats(
            new Format("DINJEPIN1AM", "eq. 1 mg / ml base, 1 ml amp IM [fr:q. 1 mg / ml base, 1 ml amp IM]", Unit.ML),
            new Format("DINJEPIN1AV", "eq. 1 mg / ml base, 1 ml amp IV [fr:q. 1 mg / ml base, 1 ml amp IV]", Unit.ML)
        ),
        new Drug("DINJEPOA", "EPOETIN ALFA [fr:EPOETINE ALFA]").withFormats(
            new Format("DINJEPOA1S", "10000 IU / ml, 1 ml, graduated syringe [fr:10000 UI / ml, 1 ml, seringue gradue]", Unit.ML)
        ),
        new Drug("DINJERYT", "ERYTHROMYCIN lactobionate [fr:ERYTHROMYCINE lactobionate]").withFormats(
            new Format("DINJERYT1V", "eq. to 1 g base, pdr, vial [fr:q.  1 g base, pdr, fl.]", Unit.MG)
        ),
        new Drug("DINJETAM", "ETAMSYLATE [fr:ETAMSYLATE]").withFormats(
            new Format("DINJETAM2A", "125 mg / ml, 2 ml, amp. [fr:125 mg / ml, 2 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJETON", "ETONOGESTREL implant [fr:ETONOGESTREL implant]").withFormats(
            new Format("DINJETON6I", "1 x 68 mg, with applicator s. u. [fr:1 x 68 mg, avec applicateur u. u.]", Unit.MG)
        ),
        new Drug("DINJFENT", "FENTANYL citrate [fr:FENTANYL citrate]").withFormats(
            new Format("DINJFENT1A", "eq. 0.05 mg / ml base, 2 ml, amp. [fr:q. 0.05 mg / ml base, 2 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJFERC", "FERRIC carboxymaltose [fr:carboxymaltose FERRIQUE]").withFormats(
            new Format("DINJFERC1A", "eq. 50 mg / ml iron, 2 ml, amp. [fr:eq. 50 mg / ml fer, 2 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJFLUC", "FLUCONAZOLE [fr:FLUCONAZOLE]").withFormats(
            new Format("DINJFLUC2FBF", "2 mg / ml, 100 ml, flexible bag PVC free [fr:2 mg / ml, 100 ml, poche souple sans PVC]", Unit.ML),
            new Format("DINJFLUC2SRF", "2 mg / ml, 100 ml, semi-rigid bot. PVC free [fr:2 mg / ml, 100 ml, fl. semi-rigide sans PVC]", Unit.ML)
        ),
        new Drug("DINJFLUM", "FLUMAZENIL [fr:FLUMAZENIL]").withFormats(
            new Format("DINJFLUM1A", "0.1 mg / ml, 10 ml, amp. [fr:0.1 mg / 1 ml, 10 ml, amp.]", Unit.ML),
            new Format("DINJFLUM5A", "0.1 mg / ml, 5 ml, amp. [fr:0.1 mg / ml, 5 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJFURO", "FUROSEMIDE [fr:FUROSEMIDE]").withFormats(
            new Format("DINJFURO2A", "10 mg / ml, 2 ml, amp. [fr:10 mg / ml, 2 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJGANC", "GANCICLOVIR sodium [fr:GANCICLOVIR sodique]").withFormats(
            new Format("DINJGANC5V", "eq. 500 mg base, powder, vial fr infusion [fr:q. 500 mg base, poudre, flacon perfusion]", Unit.MG)
        ),
        new Drug("DINJGENT", "GENTAMICIN sulfate [fr:GENTAMICINE sulfate]").withFormats(
            new Format("DINJGENT2A", "eq. 10 mg / ml base, 2 ml, amp. [fr:q. 10 mg / ml base, 2 ml, amp.]", Unit.ML),
            new Format("DINJGENT2V", "eq. 10 mg / ml base, 2 ml, vial [fr:q. 10 mg / ml base, 2 ml, fl.]", Unit.ML),
            new Format("DINJGENT8A", "eq. 40 mg / ml base, 2 ml, amp. [fr:eq. 40 mg / ml base, 2 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJGLUC", "GLUCOSE [fr:GLUCOSE]").withFormats(
            new Format("DINJGLUC1A1", "hypertonic, 10%, 10 ml, amp [fr:hypertonique, 10%, 10 ml, amp]", Unit.ML),
            new Format("DINJGLUC3A2", "HYPER, 30%, 20 ml, amp. [fr:HYPERTONIQUE, 30%, 20 ml, amp.]", Unit.ML),
            new Format("DINJGLUC5V5", "hypertonic, 50%, 50 ml, vial [fr:hypertonique, 50%, 50 ml, fl.]", Unit.ML)
        ),
        new Drug("DINJGLYC", "GLYCOPYRRONIUM bromide [fr:GLYCOPYRRONIUM bromure]").withFormats(
            new Format("DINJGLYC2A", "0.2 mg / ml, 1 ml, amp. [fr:0.2 mg / ml, 1 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJHALP", "HALOPERIDOL [fr:HALOPERIDOL]").withFormats(
            new Format("DINJHALP5A", "5 mg / ml, 1 ml, amp. [fr:5 mg / ml, 1 ml, amp.]", Unit.ML),
            new Format("DINJHALP5AD", "decanoate, 50 mg / ml, 1 ml, amp. [fr:decanoate, 50 mg / ml, 1 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJHEPA", "HEPARIN SODIUM [fr:HEPARINE SODIQUE]").withFormats(
            new Format("DINJHEPA2A", "5000 IU / ml, 5 ml, amp. [fr:5000 UI / ml, 5 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJHYDA", "HYDRALAZINE hydrochloride [fr:HYDRALAZINE chlorhydrate]").withFormats(
            new Format("DINJHYDA2A", "20 mg, powder, amp. [fr:20 mg, poudre, amp.]", Unit.MG)
        ),
        new Drug("DINJHYDR", "HYDROCORTISONE sodium succinate [fr:HYDROCORTISONE succinate sodique]").withFormats(
            new Format("DINJHYDR1V", "eq. 100 mg base, powder, vial [fr:eq. 100 mg base, poudre, fl]", Unit.MG),
            new Format("DINJHYDR1VS", "eq. 100 mg base, powder, vial +solvent [fr:q. 100 mg base, fl. pdre + solvant]", Unit.MG)
        ),
        new Drug("DINJHYOS", "HYOSCINE BUTYLBROMIDE (scopolamine butylbrom) [fr:BUTYLBROMURE HYOSCINE (butylbrom. scopolamine)]").withFormats(
            new Format("DINJHYOS2A", "20 mg / 1 ml, amp [fr:20 mg / 1 ml, amp]", Unit.ML)
        ),
        new Drug("DINJIMCI", "IMIPENEM / CILASTATIN sodium [fr:IMIPENEME / CILASTATIN sodium]").withFormats(
            new Format("DINJIMCI55V", "500 mg / 500 mg, powder, vial [fr:500 mg / 500 mg, poudre, fl.]", Unit.MG)
        ),
        new Drug("DINJINSA", "INSULIN [fr:INSULINE]").withFormats(
            new Format("DINJINSAB3APL", "LISPRO, BIPHASIC 25-75 IU / ml, 3 ml, autoinj. pref. L [fr:LISPRO, BIPHASIQUE 25-75 UI / ml, 3 ml, stylo prr. L]", Unit.ML),
            new Format("DINJINSAB3APN", "ASPART, BIPHASIC 30-70 IU / ml, 3 ml, autoinj. pref. N [fr:ASPART, BIPHASIQUE 30-70 UI / ml, 3 ml, stylo prr. N]", Unit.ML),
            new Format("DINJINSAL1VS", "GLARGINE, LONG 100 IU / ml, 10 ml, vial S [fr:GLARGINE, LENTE 100 UI / ml, 10 ml, fl. S]", Unit.ML),
            new Format("DINJINSAL3APS", "GLARGINE, LONG, 100 IU / ml, 3 ml, autoinjector pref. S [fr:GLARGINE, LENTE, 100 UI / ml, 3 ml, stylo prrempli S]", Unit.ML),
            new Format("DINJINSAU3APL", "LISPRO, ULTRARAPID 100 UI / ml, 3 ml, autoinject. pref. L [fr:LISPRO, ULTRARAPIDE 100 UI / ml, 3 ml, stylo prr. L]", Unit.ML),
            new Format("DINJINSAU3APN", "ASPART, ULTRARAPID 100 UI / ml, 3 ml, autoinject. pref. N [fr:ASPART, ULTRARAPIDE 100 UI / ml, 3 ml, stylo prr. N]", Unit.ML)
        ),
        new Drug("DINJINSH", "INSULIN HUMAN [fr:INSULINE HUMAINE]").withFormats(
            new Format("DINJINSHB1VL", "BIPHASIC 30-70 IU / ml, 10 ml, vial L [fr:BIPHASIQUE 30-70 UI / ml, 10 ml, fl. L]", Unit.ML),
            new Format("DINJINSHB1VN", "BIPHASIC 30-70 IU / ml, 10 ml, vial N [fr:BIPHASIQUE 30-70 UI / ml, 10 ml, fl. N]", Unit.ML),
            new Format("DINJINSHB1VS", "BIPHASIC 30-70 IU / ml, 10 ml, vial S [fr:BIPHASIQUE 30-70 UI / ml, 10 ml, fl. S]", Unit.ML),
            new Format("DINJINSHI1VN", "ISOPHANE (NPH) 100 UI / ml, 10 ml, vial N [fr:ISOPHANE (NPH) 100 UI / ml, 10 ml, fl. N]", Unit.ML),
            new Format("DINJINSHI1VS", "ISOPHANE (NPH) 100 UI / ml, 10 ml, vial S [fr:ISOPHANE (NPH) 100 UI / ml, 10 ml, fl. S]", Unit.ML),
            new Format("DINJINSHI3APN", "ISOPHANE (NPH) 100 UI / ml, 3 ml, autoinj. pref. N [fr:ISOPHANE (NPH) 100 UI / ml, 3 ml, stylo prr. N]", Unit.ML),
            new Format("DINJINSHR1VN", "RAPID 100 IU / ml, 10 ml, vial N [fr:RAPIDE 100 UI / ml, 10 ml, fl. N]", Unit.ML),
            new Format("DINJINSHR1VS", "RAPID 100 IU / ml, 10 ml, vial S [fr:RAPIDE 100 UI / ml, 10 ml, fl. S]", Unit.ML)
        ),
        new Drug("DINJISOB", "ISOSORBIDE DINITRATE [fr:ISOSORBIDE DINITRATE]").withFormats(
            new Format("DINJISOB1A", "1 mg / ml, 10 ml, amp. [fr:1 mg / ml, 10 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJKANA", "KANAMYCIN sulfate [fr:KANAMYCINE sulfate]").withFormats(
            new Format("DINJKANA1A4", "eq. 0.250 g / ml base, 4 ml, amp. [fr:q. 0.250 g / ml base, 4 ml, amp.]", Unit.ML),
            new Format("DINJKANA1V", "eq. 1 g base, powder, vial [fr:q. 1 g base, poudre, fl.]", Unit.MG),
            new Format("DINJKANA5A2", "eq. 0.250 g / ml base, 2 ml, amp. [fr:q. 0.250 g / ml base, 2 ml, amp.]", Unit.ML),
            new Format("DINJKANA5V", "eq. 0.5 g base, powder, vial [fr:q. 0.5 g base, poudre, fl.]", Unit.MG)
        ),
        new Drug("DINJKETA", "KETAMINE hydrochloride [fr:KETAMINE chlorhydrate]").withFormats(
            new Format("DINJKETA2A", "eq. 50 mg / ml base, 5 ml, amp. [fr:q. 50 mg / ml base, 5 ml, amp.]", Unit.ML),
            new Format("DINJKETA5V", "eq. 50 mg / ml base, 10 ml, vial [fr:q. 50 mg / ml base, 10 ml, fl.]", Unit.ML)
        ),
        new Drug("DINJLABE", "LABETALOL hydrochloride [fr:LABETALOL chlorhydrate]").withFormats(
            new Format("DINJLABE1A", "5 mg / ml, 20 ml amp. [fr:5 mg / ml, 20 ml amp.]", Unit.ML)
        ),
        new Drug("DINJLEVB", "LEVOBUPIVACAINE hydrochloride [fr:LEVOBUPIVACAINE chlorhydrate]").withFormats(
            new Format("DINJLEVB2A", "eq. 2.5 mg / ml base, 10 ml, amp. [fr:q. 2.5 mg / ml base, 10 ml, amp.]", Unit.ML),
            new Format("DINJLEVB5A", "eq. 5 mg / ml base, 10 ml, amp [fr:q. 5 mg / ml base, 10 ml, amp]", Unit.ML)
        ),
        new Drug("DINJLEVE", "LEVETIRACETAM [fr:LEVETIRACETAM]").withFormats(
            new Format("DINJLEVE5V", "100 mg / ml, 5 ml, vial [fr:100 mg / ml, 5 ml, fl.]", Unit.ML)
        ),
        new Drug("DINJLEVN", "LEVONORGESTREL implant [fr:LEVONORGESTREL implant]").withFormats(
            new Format("DINJLEVN15I", "2 x 75 mg (Jadelle) + trocar [fr:2 x 75 mg (Jadelle) + trocart]", Unit.MG)
        ),
        new Drug("DINJLIDE", "LIDOCAINE / EPINEPHRINE [fr:LIDOCAINE / EPINEPHRINE]").withFormats(
            new Format("DINJLIDE1C2", "1% / 1/200.000, 20 ml, vial [fr:1% / 1/200000, 20 ml, fl.]", Unit.ML),
            new Format("DINJLIDE2C1", "2% / 1/80000, 1.8 ml, cart. [fr:2% / 1/80000, 1.8 ml, cart.]", Unit.ML)
        ),
        new Drug("DINJLIDO", "LIDOCAINE hydrochloride [fr:LIDOCAINE chlorhydrate]").withFormats(
            new Format("DINJLIDO1A1", "1%, preservative-free, 10 ml, amp [fr:1%, sans conservateur, 10 ml, amp]", Unit.ML),
            new Format("DINJLIDO1A5", "1%, preservative-free, 5 ml, plast. amp [fr:1%, sans conservateur, 5 ml, amp. plast]", Unit.ML),
            new Format("DINJLIDO1V2", "1%, preservative-free, 20 ml, vial [fr:1%, sans conservateur, 20 ml, fl.]", Unit.ML),
            new Format("DINJLIDO2V2", "2%, preservative-free, 20 ml, vial [fr:2%, sans conservateur, 20 ml, fl.]", Unit.ML)
        ),
        new Drug("DINJLIPE", "LIPID emulsion [fr:mulsion LIPIDIQUE]").withFormats(
            new Format("DINJLIPE2FBF2", "20%, 250 ml, flex. bag, PVC free [fr:20%, 250 ml bot., poche souple, sans PVC]", Unit.ML)
        ),
        new Drug("DINJMAGS", "MAGNESIUM sulfate [fr:MAGNESIUM sulfate]").withFormats(
            new Format("DINJMAGS5A", "0.5 g / ml, 10 ml, amp. [fr:0.5 g / ml, 10 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJMEDR", "MEDROXYPROGESTERONE acetate [fr:MEDROXYPROGESTERONE actate]").withFormats(
            new Format("DINJMEDR1S", "150 mg, 1 ml, syringe [fr:150 mg, 1 ml, seringue]", Unit.ML),
            new Format("DINJMEDR1V", "150 mg, 1 ml, vial [fr:150 mg, 1 ml, fl.]", Unit.ML),
            new Format("DINJMEDR6IP", "104 mg / 0.65 ml, injector prefilled [fr:104 mg / 0.65 ml, injecteur prrempl]", Unit.ML)
        ),
        new Drug("DINJMEGA", "MEGLUMINE ANTIMONIATE [fr:MEGLUMINE ANTIMONIATE]").withFormats(
            new Format("DINJMEGA4A", "pentaval. antimony 81 mg / ml, 5 ml, amp [fr:antimoine pentaval. 81 mg / ml, 5 ml, amp]", Unit.ML)
        ),
        new Drug("DINJMELA", "MELARSOPROL [fr:MELARSOPROL]").withFormats(
            new Format("DINJMELA3A5", "36 mg / ml, 5 ml, amp. [fr:36 mg / ml, 5 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJMERG", "METHYLERGOMETRINE maleate [fr:METHYLERGOMETRINE maleate]").withFormats(
            new Format("DINJMERG2A", "0.2 mg / ml, 1 ml, amp. [fr:0.2 mg / ml, 1 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJMERO", "MEROPENEM [fr:MEROPENEME]").withFormats(
            new Format("DINJMERO1V", "1 g, powder, vial [fr:1 g, poudre, fl]", Unit.MG),
            new Format("DINJMERO5V", "500 mg, powder, vial [fr:500 mg, poudre, fl.]", Unit.MG)
        ),
        new Drug("DINJMETN", "METRONIDAZOLE [fr:METRONIDAZOLE]").withFormats(
            new Format("DINJMETN5FBF", "5 mg / ml, 100 ml, flex. bag PVC free [fr:5 mg / ml, 100 ml, poche souple sans PVC]", Unit.ML),
            new Format("DINJMETN5SRF", "5 mg / ml, 100 ml, semi-rigid bot. PVC free [fr:5 mg / ml, 100 ml, fl. semi-rigide sans PVC]", Unit.ML)
        ),
        new Drug("DINJMETO", "METOCLOPRAMIDE hydrochloride [fr:METOCLOPRAMIDE chlorhydrate]").withFormats(
            new Format("DINJMETO1A", "5 mg / ml, 2 ml, amp. [fr:5 mg / ml, 2 ml, amp]", Unit.ML)
        ),
        new Drug("DINJMIDA", "MIDAZOLAM [fr:MIDAZOLAM]").withFormats(
            new Format("DINJMIDA5A", "1 mg / ml, 5 ml, amp [fr:1 mg / ml, 5 ml, amp]", Unit.ML)
        ),
        new Drug("DINJMORP", "MORPHINE hydrochloride [fr:MORPHINE chlorhydrate]").withFormats(
            new Format("DINJMORP1A", "10 mg / ml, 1 ml, amp. [fr:10 mg / ml, 1 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJNADR", "NADROPARIN calcium [fr:NADROPARINE calcique]").withFormats(
            new Format("DINJNADR2S", "1900 IU / 0.2 ml, syringe [fr:1900 UI / 0.2 ml, seringue]", Unit.ML),
            new Format("DINJNADR3S", "2850 IU / 0.3 ml, syringe [fr:2850 UI / 0.3 ml, seringue]", Unit.ML),
            new Format("DINJNADR4S", "3800 IU / 0.4 ml, syringe [fr:3800 UI / 0.4 ml, seringue]", Unit.ML),
            new Format("DINJNADR5S", "5700 UI / 0.6 ml, syringe [fr:5700 UI / 0.6 ml, seringue]", Unit.ML)
        ),
        new Drug("DINJNALO", "NALOXONE hydrochloride [fr:NALOXONE chlorhydrate]").withFormats(
            new Format("DINJNALO4A", "0.4 mg / ml, 1 ml, amp. [fr:0.4 mg / ml, 1 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJNEOS", "NEOSTIGMINE methylsulfate [fr:NEOSTIGMINE mthylsulfate]").withFormats(
            new Format("DINJNEOS2A", "2.5 mg / ml, 1 ml, amp. [fr:2.5 mg / ml, 1 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJNEPI", "NOREPINEPHRINE (noradrenaline) tartrate [fr:NOREPINEPHRINE (noradrnaline) tartrate]").withFormats(
            new Format("DINJNEPI4AV", "eq. 1 mg / ml base, 4 ml [fr:q. 1 mg / ml base, 4 ml]", Unit.ML)
        ),
        new Drug("DINJNICA", "NICARDIPINE hydrochloride [fr:NICARDIPINE chlorhydrate]").withFormats(
            new Format("DINJNICA1A", "1 mg / ml, 10 ml, amp. [fr:1 mg / ml, 10 ml, amp.]", Unit.ML),
            new Format("DINJNICA5A", "1 mg / 1 ml, 5 ml, amp. [fr:1 mg / 1 ml, 5 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJOMEP", "OMEPRAZOLE sodium [fr:OMEPRAZOLE sodique]").withFormats(
            new Format("DINJOMEP4V", "eq. 40 mg base, powder, vial, fr infusion [fr:q. 40 mg base, poudre, fl. pr perfusion]", Unit.MG)
        ),
        new Drug("DINJONDA", "ONDANSETRON hydrochloride [fr:ONDANSETRON chlorhydrate]").withFormats(
            new Format("DINJONDA4A", "eq. 2 mg / ml base, 2 ml, amp. [fr:q. 2 mg / ml base, 2 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJOXYT", "OXYTOCIN [fr:OXYTOCINE]").withFormats(
            new Format("DINJOXYT1A", "10 IU / ml, 1 ml, amp. [fr:10 UI / ml, 1 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJPACL", "PACLITAXEL [fr:PACLITAXEL]").withFormats(
            new Format("DINJPACL1V", "6 mg / ml sol. to be diluted, 16.7 ml, bot. [fr:6 mg / ml sol. a diluer, 16.7 ml, fl.]", Unit.ML)
        ),
        new Drug("DINJPARA", "PARACETAMOL (acetaminophen) [fr:PARACETAMOL (actaminophne)]").withFormats(
            new Format("DINJPARA1B", "10 mg / ml, 100 ml, bot. [fr:10 mg / ml, 100 ml, fl.]", Unit.ML),
            new Format("DINJPARA1FBF", "10 mg / ml, 100 ml, flex. bag PVC free [fr:10 mg / ml, 100 ml, poche s. ss PVC]", Unit.ML),
            new Format("DINJPARA5B", "10 mg / ml, 50 ml, bot. [fr:10 mg / ml, 50 ml, fl.]", Unit.ML),
            new Format("DINJPARA5FBF", "10 mg / ml, 50 ml, flex. bag PVC free [fr:10 mg / ml, 50 ml, poche s. ss PVC]", Unit.ML)
        ),
        new Drug("DINJPARO", "PAROMOMYCIN sulfate [fr:PAROMOMYCINE sulfate]").withFormats(
            new Format("DINJPARO1A", "eq. 375 mg / ml base, 2 ml, amp [fr:q. 375 mg / ml base, 2 ml, amp]", Unit.ML)
        ),
        new Drug("DINJPENB", "BENZATHINE BENZYLPENICILLIN [fr:BENZATHINE BENZYLPENICILLINE]").withFormats(
            new Format("DINJPENB1V", "1.2 M IU, powder, vial [fr:1.2 M UI, poudre, fl.]", Unit.MG),
            new Format("DINJPENB1VS", "1.2 M IU, powder, vial+ solvent [fr:1.2 M UI, poudre, fl. +solvant]", Unit.MG),
            new Format("DINJPENB2V", "2.4 M IU, powder, vial [fr:2.4 M UI, poudre, fl.]", Unit.MG),
            new Format("DINJPENB2VS", "2.4 M IU, powder, vial+ solvent [fr:2.4 M UI, poudre, fl. +solvant]", Unit.MG)
        ),
        new Drug("DINJPENG", "BENZYLPENICILLIN (peni G, crystal peni) [fr:BENZYLPENICILLINE (peni G, cristal peni)]").withFormats(
            new Format("DINJPENG1V", "), 1 MIU, powder, vial [fr:), 1 MUI, poudre, fl]", Unit.MG),
            new Format("DINJPENG5V", "), 5 MIU, powder, vial [fr:), 5 MUI, poudre, fl]", Unit.MG)
        ),
        new Drug("DINJPENT", "PENTAMIDINE isetionate [fr:PENTAMIDINE isetionate]").withFormats(
            new Format("DINJPENT3V", "300 mg, powder, vial [fr:300 mg, poudre, fl.]", Unit.MG)
        ),
        new Drug("DINJPHEE", "PHENYLEPHRINE hydrochloride [fr:PHENYLEPHRINE chlorhydrate]").withFormats(
            new Format("DINJPHEE5A", "eq. 50 g base / ml, 10 ml amp. [fr:q. 50 g base / ml, 10 ml amp.]", Unit.ML)
        ),
        new Drug("DINJPHEN", "PHENOBARBITAL sodium [fr:PHENOBARBITAL sodique]").withFormats(
            new Format("DINJPHEN2A1", "200 mg / ml, 1 ml, amp. [fr:200 mg / ml, 1 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJPHEY", "PHENYTOIN sodium [fr:PHENYTOINE sodique]").withFormats(
            new Format("DINJPHEY2A", "50 mg / ml, 5 ml, amp. [fr:50 mg / ml, 5 ml, amp.]", Unit.ML),
            new Format("DINJPHEY2V", "50 mg / ml, 5 ml, vial [fr:50 mg / ml, 5 ml, fl.]", Unit.ML)
        ),
        new Drug("DINJPHLT", "PHLOROGLUCINOL / TRIMETHYLPHLOROGLUCINOL [fr:PHLOROGLUCINOL / TRIMETHYLPHLOROGLUCINOL]").withFormats(
            new Format("DINJPHLT44A", "10 mg / ml / 10 g / ml, 4 ml, amp. [fr:10 mg / ml / 10 g / ml, 4 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJPHYT", "PHYTOMENADIONE (vitamin K1) [fr:PHYTOMENADIONE (vitamine K1)]").withFormats(
            new Format("DINJPHYT2AN", "10 mg / ml (2 mg / 0.2 ml), 0.2 ml amp. [fr:10 mg / ml (2 mg / 0.2 ml), 0.2 ml amp.]", Unit.ML)
        ),
        new Drug("DINJPITA", "PIPERACILLIN / TAZOBACTAM [fr:PIPERACILLINE / TAZOBACTAM]").withFormats(
            new Format("DINJPITA45V", "4 g / 500 mg, powder, vial for inf. [fr:4 g / 500 mg, poudre, fl. pour perf.]", Unit.MG)
        ),
        new Drug("DINJPOTC", "POTASSIUM chloride [fr:POTASSIUM chlorure]").withFormats(
            new Format("DINJPOTC1A", "100 mg / ml, 10 ml, amp. [fr:100 mg / ml, 10 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJPRAL", "PRALIDOXIME [fr:PRALIDOXIME]").withFormats(
            new Format("DINJPRAL2A1S", "2%, vial powder + amp. solvant, 10 ml. [fr:2% flacons poudre+ ampoules solvant, 10 ml.]", Unit.ML)
        ),
        new Drug("DINJPROM", "PROMETHAZINE hydrochloride [fr:PROMETHAZINE chlorhydrate]").withFormats(
            new Format("DINJPROM2A", "eq. 25 mg / ml base, 1 ml, amp. [fr:q. 25 mg / ml base, 1 ml, amp.]", Unit.ML),
            new Format("DINJPROM5A", "eq. 25 mg / ml base, 2 ml, amp. [fr:q. 25 mg / ml base, 2 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJPROP", "PROPOFOL [fr:PROPOFOL]").withFormats(
            new Format("DINJPROP2AE", "10 mg / ml, 20 ml, emulsion, amp. [fr:10 mg / ml, 20 ml, mulsion, amp.]", Unit.ML)
        ),
        new Drug("DINJPROT", "PROTAMINE sulfate [fr:PROTAMINE sulfate]").withFormats(
            new Format("DINJPROT5A", "10 mg / ml, 5 ml, amp. [fr:10 mg / ml, 5 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJRANI", "RANITIDINE [fr:RANITIDINE]").withFormats(
            new Format("DINJRANI5A", "25 mg / ml, 2 ml, amp. [fr:25 mg / ml, 2 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJRIBA", "RIBAVIRIN [fr:RIBAVIRINE]").withFormats(
            new Format("DINJRIBA1A", "100 mg / ml, 12 ml, amp. [fr:100 mg / ml, 12 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJRIFA", "RIFAMPICIN (R) [fr:RIFAMPICINE (R)]").withFormats(
            new Format("DINJRIFA6VS", "600 mg, powder, vial + solvent [fr:600 mg, poudre, fl. + solvant]", Unit.MG)
        ),
        new Drug("DINJSODB", "SODIUM BICARBONATE [fr:SODIUM BICARBONATE]").withFormats(
            new Format("DINJSODB8A1", "8.4%, 1 mEq / ml, 10 ml, amp. [fr:8.4%, 1 mEq / ml, 10 ml, amp.]", Unit.ML),
            new Format("DINJSODB8A2", "8.4%, 1 mEq / ml, 20 ml, amp. [fr:8.4%, 1 mEq / ml, 20 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJSODC", "SODIUM chloride [fr:SODIUM chlorure]").withFormats(
            new Format("DINJSODC1A1", "10%, 10 ml, amp. [fr:10%, 10 ml, amp.]", Unit.ML),
            new Format("DINJSODC2A1", "hypertonic, 20%, 10 ml, amp. [fr:hypertonique, 20%, 10 ml, amp.]", Unit.ML),
            new Format("DINJSODC9A1", "0.9%, 10 ml, amp. [fr:0.9%, 10 ml, amp.]", Unit.ML),
            new Format("DINJSODC9A5", "0.9%, 5 ml, plastic amp. [fr:0.9%, 5 ml, amp.]", Unit.ML),
            new Format("DINJSODC9AP1", "0.9%, 10 ml, plastic amp. [fr:0.9%, 10 ml, amp. plastique]", Unit.ML)
        ),
        new Drug("DINJSPEC", "SPECTINOMYCIN hydrochloride [fr:SPECTINOMYCINE chlorhydrate]").withFormats(
            new Format("DINJSPEC2V", "eq. 2 g base, powder, vial [fr:q. 2 g base, poudre, fl.]", Unit.MG),
            new Format("DINJSPEC2VS", "eq. 2 g base, powder, vial+SOLVENT [fr:q. 2 g base, poudre, fl. + SOLVANT]", Unit.MG)
        ),
        new Drug("DINJSSGL", "SODIUM STIBOGLUCONATE, pentaval. antimony [fr:SODIUM STIBOGLUCONATE, antimoine pentaval.]").withFormats(
            new Format("DINJSSGL1V1", "y 100 mg / ml 100 ml vial [fr:. 100 mg / ml 100 ml fl]", Unit.ML),
            new Format("DINJSSGL1V3", "y 100 mg / ml, 30 ml vial [fr:. 100 mg / ml, 30 ml fl]", Unit.ML)
        ),
        new Drug("DINJSTRE", "STREPTOMYCIN sulfate [fr:STREPTOMYCINE sulfate]").withFormats(
            new Format("DINJSTRE1V", "eq. 1 g base, powder, vial [fr:q. 1 g base, poudre, fl.]", Unit.MG)
        ),
        new Drug("DINJSTRK", "STREPTOKINASE [fr:STREPTOKINASE]").withFormats(
            new Format("DINJSTRK1V", "1.500.000 IU, powder, vial [fr:1.500.000 IU, poudre, fl.]", Unit.MG)
        ),
        new Drug("DINJSUXC", "SUXAMETHONIUM chloride [fr:SUXAMETHONIUM chlorure]").withFormats(
            new Format("DINJSUXC1A", "50 mg / ml, 2 ml, amp. [fr:50 mg / ml, 2 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJTHIA", "THIAMINE (vitamin B1) [fr:THIAMINE (vitamine B1)]").withFormats(
            new Format("DINJTHIA1A", "50 mg / ml, 2 ml, amp. [fr:50 mg / ml, 2 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJTHIO", "THIOPENTAL sodium [fr:THIOPENTAL sodique]").withFormats(
            new Format("DINJTHIO5V", "500 mg, powder, vial [fr:500 mg, poudre, fl.]", Unit.MG)
        ),
        new Drug("DINJTRAM", "TRAMADOL hydrochloride [fr:TRAMADOL chlorhydrate]").withFormats(
            new Format("DINJTRAM1A", "50 mg / ml, 2 ml, amp. [fr:50 mg / ml, 2 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJTRAN", "TRANEXAMIC ACID [fr:ACIDE TRANEXAMIQUE]").withFormats(
            new Format("DINJTRAN5A", "100 mg / ml, 5 ml amp. [fr:100 mg / ml, 5 ml amp.]", Unit.ML)
        ),
        new Drug("DINJUROK", "UROKINASE [fr:UROKINASE]").withFormats(
            new Format("DINJUROK1V", "100000 IU, powder, vial [fr:100000 UI, poudre, fl.]", Unit.MG)
        ),
        new Drug("DINJVALP", "VALPROATE SODIUM [fr:VALPROATE DE SODIUM]").withFormats(
            new Format("DINJVALP4A", "100 mg / ml, 4 ml amp. [fr:100 mg / ml, 4 ml amp.]", Unit.ML)
        ),
        new Drug("DINJVANC", "VANCOMYCIN hydrocloride [fr:VANCOMYCINE]").withFormats(
            new Format("DINJVANC1V", "eq. 1 g base, powder, vial [fr:chlorydrate, q. 1 g base, poudre, fl.]", Unit.MG),
            new Format("DINJVANC5V", "eq. 500 mg base, powder, vial [fr:chlorhydrate, q. 500 mg base, poudre, fl.]", Unit.MG)
        ),
        new Drug("DINJVECB", "VECURONIUM bromide [fr:VECURONIUM bromure]").withFormats(
            new Format("DINJVECB1V", "10 mg, powder, vial [fr:10 mg, poudre, fl.]", Unit.MG)
        ),
        new Drug("DINJVERA", "VERAPAMIL hydrochloride [fr:VERAPAMIL chlorhydrate]").withFormats(
            new Format("DINJVERA2A", "2.5 mg / ml, 2 ml, amp. [fr:2.5 mg / ml, 2 ml, amp.]", Unit.ML)
        ),
        new Drug("DINJVINC", "VINCRISTINE sulfate [fr:VINCRISTINE sulfate]").withFormats(
            new Format("DINJVINC1V", "1 mg / ml, 1 ml, vial [fr:1 mg / ml, 1 ml, fl.]", Unit.ML),
            new Format("DINJVINC2V", "1 mg / ml, 2 ml, vial [fr:1 mg / ml, 2 ml, fl.]", Unit.ML)
        ),
        new Drug("DINJWATE", "WATER for injection [fr:EAU pour injection]").withFormats(
            new Format("DINJWATE1A", "10 ml, plastic amp. [fr:10 ml, amp. plastique]", Unit.ML)
        )
    );

    Category PERFUSION = new Category("DINF", "perfusion", true).withDrugs(
        new Drug("DINFDERI", "DEXTROSE (GLUCOSE) / RINGER LACTATE [fr:GLUCOSE / RINGER LACTATE]").withFormats(
            new Format("DINFDERI5FBF5", "GLUCOSE 5% + RL, 500 ml, flex. bag, PVC free [fr:GLUCOSE 5% + RL, 500 ml, poche souple, sans PVC]", Unit.ML),
            new Format("DINFDERIXX10", "GLUCOSE 10% + RL, prepared by hand (nonstandard) [fr:GLUCOSE 10% + RL, prpar  la main (non standard)]", Unit.ML)
        ),
        new Drug("DINFDEXT", "DEXTROSE (GLUCOSE) [fr:GLUCOSE]").withFormats(
            new Format("DINFDEXT1FBF2", "10%, 250 ml, flex. bag, PVC free [fr:10%, 250 ml, poche souple, sans PVC]", Unit.ML),
            new Format("DINFDEXT1FBF5", "10%, 500 ml, flex. bag, PVC free [fr:10%, 500 ml, poche souple, sans PVC]", Unit.ML),
            new Format("DINFDEXT1FBP5", "10%, 500 ml, flex. bag, PVC [fr:10%, 500 ml, poche souple, PVC]", Unit.ML),
            new Format("DINFDEXT1SRF2", "10%, 250 ml, semi-rigid bot., PVC free [fr:10%, 250 ml, fl. semi-rigide, sans PVC]", Unit.ML),
            new Format("DINFDEXT1SRF5", "10%, 500 ml, semi-rigid bot., PVC free [fr:10%, 500 ml, fl. semi-rigide, sans PVC]", Unit.ML),
            new Format("DINFDEXT5FBF1", "5%, 1 l, flex. bag, PVC free [fr:5%, 1 l, poche souple, sans PVC]", Unit.ML),
            new Format("DINFDEXT5FBF2", "5%, 250 ml, flex. bag, PVC free [fr:5%, 250 ml, poche souple, sans PVC]", Unit.ML),
            new Format("DINFDEXT5FBF5", "5%, 500 ml, flex. bag, PVC free [fr:5%, 500 ml, poche souple, sans PVC]", Unit.ML),
            new Format("DINFDEXT5FBP1", "5%, 1 l, flex. bag, PVC [fr:5%, 1 l, poche souple, PVC]", Unit.ML),
            new Format("DINFDEXT5FBP5", "5%, 500 ml, flex. bag, PVC [fr:5%, 500 ml, poche souple, PVC]", Unit.ML),
            new Format("DINFDEXT5SRF1", "5%, 1 l, semi-rigid bot., PVC free [fr:5%, 1 l, fl. semi-rigide, sans PVC]", Unit.ML),
            new Format("DINFDEXT5SRF5", "5%, 500 ml, semi-rigid bot., PVC free [fr:5%, 500 ml, fl. semi-rigide, sans PVC]", Unit.ML)
        ),
        new Drug("DINFMANN", "MANNITOL [fr:MANNITOL]").withFormats(
            new Format("DINFMANN2B5", "20%, 500 ml, bot. [fr:20%, 500 ml, fl.]", Unit.ML),
            new Format("DINFMANN2FBF5", "20%, 500 ml, flex. bag, PVC free [fr:20%, 500 ml, poche souple, sans PVC]", Unit.ML)
        ),
        new Drug("DINFPLAS", "MODIFIED FLUID GELATIN / POLYGELIN [fr:PLASMA SUBSTITUT, glatine]").withFormats(
            new Format("DINFPLAS1FBF5", "500 ml, flex. bag, PVC free [fr:e, 500 ml, poche souple, ss PVC]", Unit.ML),
            new Format("DINFPLAS1FBP5", "500 ml, flex. bag, PVC [fr:e, 500 ml, poche souple, PVC]", Unit.ML),
            new Format("DINFPLAS1SRF5", "500 ml, semi-rigid bt, PVCfree [fr:e, 500 ml, fl. semi-rigide, ss PVC]", Unit.ML)
        ),
        new Drug("DINFBLDT", "BLOOD transfusion [fr:transfusion SANGUINE]").withFormats(
            new Format("DINFBLDTON", "group O [fr:groupe O]", Unit.ML),
            new Format("DINFBLDTOP", "group O+ [fr:groupe O+]", Unit.ML),
            new Format("DINFBLDTAN", "group A [fr:groupe A]", Unit.ML),
            new Format("DINFBLDTAP", "group A+ [fr:groupe A+]", Unit.ML),
            new Format("DINFBLDTBN", "group B [fr:groupe B]", Unit.ML),
            new Format("DINFBLDTBP", "group B+ [fr:groupe B+]", Unit.ML),
            new Format("DINFBLDTABN", "group AB [fr:groupe AB]", Unit.ML),
            new Format("DINFBLDTABP", "group AB+ [fr:groupe AB+]", Unit.ML)
        ),
        new Drug("DINFRINL", "RINGER lactate [fr:RINGER lactate]").withFormats(
            new Format("DINFRINL1FBF1", "1 l, flex. bag, PVC free [fr:1 l, poche souple, sans PVC]", Unit.ML),
            new Format("DINFRINL1FBF5", "500 ml, flex. bag, PVC free [fr:500 m l, poche souple, sans PVC]", Unit.ML),
            new Format("DINFRINL1FBP1", "1 l, flex. bag, PVC [fr:1 l, poche souple, PVC]", Unit.ML),
            new Format("DINFRINL1FBP5", "500 ml, flex. bag, PVC [fr:500 m l, poche souple, PVC]", Unit.ML),
            new Format("DINFRINL1SRF1", "1 l, semi-rigid bot., PVC free [fr:1 l, fl. semi-rigide, sans PVC]", Unit.ML),
            new Format("DINFRINL1SRF5", "500 ml, semi-rigid bot., PVC free [fr:500 ml, fl. semi-rigide, sans PVC]", Unit.ML)
        ),
        new Drug("DINFSODC", "SODIUM chloride (NaCl) [fr:SODIUM chlorure (NaCl)]").withFormats(
            new Format("DINFSODC9FBF0", "0.9%, 100 ml, flex. bag, PVC free [fr:0.9%, 100 ml, poche souple, sans PVC]", Unit.ML),
            new Format("DINFSODC9FBF1", "0.9%, 1 l, flex. bag, PVC free [fr:0.9%, 1 l, poche souple, sans PVC]", Unit.ML),
            new Format("DINFSODC9FBF2", "0.9%, 250 ml, flex. bag, PVC free [fr:0.9%, 250 ml, poche souple, sans PVC]", Unit.ML),
            new Format("DINFSODC9FBF5", "0.9%, 500 ml, flex. bag, PVC free [fr:0.9%, 500 ml, poche souple, sans PVC]", Unit.ML),
            new Format("DINFSODC9FBP0", "0.9%, 100 ml, flex. bag, PVC [fr:0.9%, 100 ml, poche souple, PVC]", Unit.ML),
            new Format("DINFSODC9FBP1", "0.9%, 1 l, flex. bag, PVC [fr:0.9%, 1 l, poche souple, PVC]", Unit.ML),
            new Format("DINFSODC9FBP2", "0.9%, 250 ml, flex. bag, PVC [fr:0.9%, 250 ml, poche souple, PVC]", Unit.ML),
            new Format("DINFSODC9FBP5", "0.9%, 500 ml, flex. bag, PVC [fr:0.9%, 500 ml, poche souple, PVC]", Unit.ML),
            new Format("DINFSODC9SRF0", "0.9%, 100 ml, semi-rigid bot., PVC free [fr:0.9%, 100 ml, fl. semi-rigide, sans PVC]", Unit.ML),
            new Format("DINFSODC9SRF1", "0.9%, 1 l, semi-rigid bot., PVC free [fr:0.9%, 1 l, fl. semi-rigide, sans PVC]", Unit.ML),
            new Format("DINFSODC9SRF2", "0.9%, 250 ml, semi-rigid bot., PVC free [fr:0.9%, 250 ml, fl. semi-rigide, sans PVC]", Unit.ML),
            new Format("DINFSODC9SRF5", "0.9%, 500 ml, semi-rigid bot., PVC free [fr:0.9%, 500 ml, fl. semi-rigide, sans PVC]", Unit.ML)
        ),
        new Drug("DINFWATE", "WATER FOR INJECTION [fr:EAU POUR PREPARATION INJECTABLE]").withFormats(
            new Format("DINFWATE1B1", "100 ml, bot. [fr:100 ml, fl.]", Unit.ML),
            new Format("DINFWATE1FB05", "50 ml, flex. bag, PVC free [fr:50 ml, poche souple, ss PVC]", Unit.ML),
            new Format("DINFWATE1FBF1", "100 ml, flex. bag, PVC free [fr:100 ml, poche souple, ss PVC]", Unit.ML),
            new Format("DINFWATE1FBF2", "250 ml, flex. bag, PVC free [fr:250 ml, poche souple, ss PVC]", Unit.ML),
            new Format("DINFWATE1FBP1", "100 ml, flex. bag, PVC [fr:100 ml, poche souple, PVC]", Unit.ML),
            new Format("DINFWATE1FBP2", "250 ml, flex. bag, PVC [fr:250 ml, poche souple, PVC]", Unit.ML),
            new Format("DINFWATE1SRF1", "100 ml, semi-rigid bot., PVC free [fr:100 ml, fl. semi-rigide, ss PVC]", Unit.ML),
            new Format("DINFWATE1SRF2", "250 ml, semi-rigid bot., PVC free [fr:250 ml, fl. semi-rigide, ss PVC]", Unit.ML)
        )
    );

    Category EXTERNAL = new Category("DEXT", "external", false, UNSPECIFIED, OC).withDrugs(
        new Drug("DEXOACIV", "ACICLOVIR ophth. [fr:ACICLOVIR ophth.]").withFormats(
            new Format("DEXOACIV3T4", "3%, eye ointment, sterile, 4.5 g, tube [fr:3%, pommade ophtalmique, strile, 4.5 g, tube]", Unit.ML)
        ),
        new Drug("DEXOATRO", "ATROPINE sulfate [fr:ATROPINE sulfate]").withFormats(
            new Format("DEXOATRO1D4", "1%, eye drops, ster, 0.4 ml, unidose, amp. [fr:1%, collyre, str, 0.4 ml, unidose, amp.]", Unit.ML)
        ),
        new Drug("DEXOCHLO", "CHLORAMPHENICOL [fr:CHLORAMPHENICOL]").withFormats(
            new Format("DEXOCHLO5D1", "0.5%, eye drops, sterile, 10 ml, bot. [fr:0.5%, collyre, strile, 10 ml, fl.]", Unit.ML)
        ),
        new Drug("DEXODENP", "DEXAMETHASONE / NEOMYCIN / POLYMYXIN B [fr:DEXAMETHASONE / NEOMYCINE / POLYMYXINE B]").withFormats(
            new Format("DEXODENP513D5", "DEXAMETHASONE5 mg / NEOMYCIN17500 IU / 30000 IU, eye drops, 5 ml [fr:DEXAMETHASONE5 mg / NEOMYCINE17500 UI / 30000 UI, collyre, 5 ml]", Unit.ML)
        ),
        new Drug("DEXODEXN", "DEXAMETHASONE / NEOMYCIN [fr:DEXAMETHASONE / NEOMYCINE]").withFormats(
            new Format("DEXODEXN5D5", "5 mg / 17500 IU, eye drops, 5 ml, bot [fr:5 mg / 17500 UI, collyre, 5 ml, fl.]", Unit.ML)
        ),
        new Drug("DEXODEXT", "DEXAMETHASONE / TOBRAMYCIN [fr:DEXAMETHASONE / TOBRAMYCINE]").withFormats(
            new Format("DEXODEXT51D", "5 mg / 15 mg, eye drops, 5 ml, bot [fr:5 mg / 15 mg, collyre, 5 ml, fl.]", Unit.ML)
        ),
        new Drug("DEXOFLUO", "FLUORESCEIN [fr:FLUORESCEINE]").withFormats(
            new Format("DEXOFLUO1D4", "0.5%, eye drops, ster, 0.4 ml, unidose, amp. [fr:0.5%, collyre, strile, 0.4 ml, unidose, amp.]", Unit.ML),
            new Format("DEXOFLUO2D5", "2%, eye drops, sterile, 0.5 ml, unidose, amp [fr:2%, collyre, strile, 0.5 ml, unidose, amp.]", Unit.ML)
        ),
        new Drug("DEXOGANC", "GANCICLOVIR [fr:GANCICLOVIR]").withFormats(
            new Format("DEXOGANC1G", "0.15%, eye gel, sterile [fr:0.15%, gel ophtalmique, strile]", Unit.ML)
        ),
        new Drug("DEXOOXYB", "OXYBUPROCAINE [fr:OXYBUPROCAINE]").withFormats(
            new Format("DEXOOXYB1", "0.4%, eye drops, ster, 0.5 ml, unidose, amp. [fr:0.4%, collyre, str, 0.5 ml, unidose, amp.]", Unit.ML)
        ),
        new Drug("DEXOPHEE", "PHENYLEPHRINE hydrochloride [fr:PHENYLEPHRINE chlorhydrate]").withFormats(
            new Format("DEXOPHEE5D", "5%, eye drops [fr:5%, collyre]", Unit.ML)
        ),
        new Drug("DEXOPILO", "PILOCARPINE hydrochloride [fr:PILOCARPINE chlorhydrate]").withFormats(
            new Format("DEXOPILO2D1", "2%, eye drops, sterile, 10 ml, bot [fr:2%, collyre, strile, 10 ml, fl.]", Unit.ML)
        ),
        new Drug("DEXORIFM", "RIFAMYCINE [fr:RIFAMYCINE]").withFormats(
            new Format("DEXORIFM1D1", "sodium, 1000.000lU / 100 ml, eye drops, 10 ml, bot. [fr:sodique, 1000000Ul / 100 ml, collyre, 10 ml, fl.]", Unit.ML),
            new Format("DEXORIFM1O5", "1000.000 UI / 100 g, eye ointment, sterile, 5 g, tube [fr:1000000 UI / 100 g, pom. ophtalm, strile, 5 g, tube]", Unit.MG)
        ),
        new Drug("DEXOSODC", "SODIUM CHLORIDE [fr:SERUM PHYSIOLOGIQUE]").withFormats(
            new Format("DEXOSODC9D5", "0.9%, eye drops, sterile, 5 ml [fr:chlorure de sodium 0.9%, strile, 5 ml]", Unit.ML)
        ),
        new Drug("DEXOTETR", "TETRACYCLINE hydrochloride [fr:TETRACYCLINE chlorhydrate]").withFormats(
            new Format("DEXOTETR1O5", "1%, eye ointment, ster, 5 g, tube [fr:1%, pommade opht., str, 5 g, tube]", null)
        ),
        new Drug("DEXOTROP", "TROPICAMIDE [fr:TROPICAMIDE]").withFormats(
            new Format("DEXOTROP1D0", "1% eye drops 0.5 ml, unidose, amp [fr:1% collyre 0.5 ml, unidose, amp.]", Unit.ML),
            new Format("DEXOTROP5D4", "0.5%, eye drops, sterile, 0.4 ml, unidose, amp. [fr:0.5%, collyre, strile, 0.4 ml, unidose, amp.]", Unit.ML)
        ),
        new Drug("DEXTACIV", "ACICLOVIR [fr:ACICLOVIR]").withFormats(
            new Format("DEXTACIV5C1", "5%, cream, 10 g, tube [fr:5%, crme, 10 g, tube]", Unit.ML)
        ),
        new Drug("DEXTALCD", "DENATURED ALCOHOL [fr:ALCOOL DENATURE]").withFormats(
            new Format("DEXTALCDB5", "500 ml, bot. [fr:500 ml, fl.]", Unit.ML)
        ),
        new Drug("DEXTALCO", "ALCOHOL-BASED HAND RUB [fr:HYDRO-ALCOOLIQUE]").withFormats(
            new Format("DEXTALCO1G", "gel, 100 ml, bot. [fr:gel, 100 ml, fl.]", Unit.ML),
            new Format("DEXTALCO3G", "gel, 30 ml, bot. [fr:gel, 30 ml, fl.]", Unit.ML),
            new Format("DEXTALCO5S", "solution, 500 ml, bot. [fr:solution, 500 ml, fl.]", Unit.ML)
        ),
        new Drug("DEXTANTH", "ANTIHAEMORROID [fr:ANTI HEMORROIDAIRE]").withFormats(
            new Format("DEXTANTH1C2", "cream, 25 g, tube [fr:crme, 25 g, tube]", Unit.MG),
            new Format("DEXTANTH1O2", "ointment, 25 g, tube [fr:pommade, 25 g, tube]", Unit.MG)
        ),
        new Drug("DEXTARTS", "ARTESUNATE [fr:ARTESUNATE]").withFormats(
            new Format("DEXTARTS1RC", "100 mg, rectal caps. [fr:100 mg, caps. rectale]", Unit.CAPSULE)
        ),
        new Drug("DEXTBENS", "BENZOIC ACID / SALICYLIC ACID [fr:ACIDE BENZOIQUE / ACIDE SALICYLIQUE]").withFormats(
            new Format("DEXTBENS6O4", "6% / 3%, ointment, 40 g, tube [fr:6% / 3%, pom., 40 g, tube]", Unit.ML)
        ),
        new Drug("DEXTBENZ", "BENZYL BENZOATE [fr:BENZOATE DE BENZYLE]").withFormats(
            new Format("DEXTBENZ2L1", "25%, lotion, 1 l, bot. [fr:25%, lotion, 1 l, fl.]", Unit.ML)
        ),
        new Drug("DEXTBETM", "BETAMETHASONE dipropionate [fr:BETAMETHASONE dipropionate]").withFormats(
            new Format("DEXTBETM5C3", "eq. 0.05% base, cream, 30 g, tube [fr:q. 0.05% base, crme, 30 g, tube]", Unit.ML)
        ),
        new Drug("DEXTCALA", "CALAMINE [fr:CALAMINE]").withFormats(
            new Format("DEXTCALA1L5", "15%, lotion, 500 ml, bot. [fr:15%, lotion, 500 ml, fl.]", Unit.ML)
        ),
        new Drug("DEXTCHLH", "CHLORHEXIDINE [fr:CHLORHEXIDINE]").withFormats(
            new Format("DEXTCHLH2AS", "digluconate 2%, aqueous solution, 100 ml, bot. [fr:gluconate 2%, solution aqueuse, 100 ml fl.]", Unit.ML),
            new Format("DEXTCHLH2S", "digluconate 0.2%, mouthwash, sol., 300 ml, bot. [fr:digluconate 0.2%, bain de bouche, sol., 300 ml, fl]", Unit.ML),
            new Format("DEXTCHLH2S5", "0.2%, aqueous solution, 5 ml, unidose [fr:0.2%, solution aqueuse, 5 ml, unidose]", Unit.ML),
            new Format("DEXTCHLH2SA2", "2%, alcohol solution, 250 ml, bot. [fr:2%, solution alcoolique, 250 ml, fl.]", Unit.ML),
            new Format("DEXTCHLH5S1", "digluconate 5%, solution, 1 l, bot. [fr:digluconate 5%, solution, 1 l, fl.]", Unit.ML),
            new Format("DEXTCHLH5S9", "digluc. 0.5 ml / 0.5 g / 100 ml, mouthwash, sol, 90 ml [fr:digluc. 0.5 ml / 0.5 g / 100 ml, bain d. bouche, sol, 90 ml]", Unit.ML),
            new Format("DEXTCHLH7G2", "digluconate 7.1%, gel, 20 g tube [fr:digluconate 7.1%, gel, 20 g tube]", Unit.ML),
            new Format("DEXTCHLH7G3", "digluconate 7.1%, gel, 3 g sachet [fr:digluconate 7.1%, gel, 3 g sachet]", Unit.ML),
            new Format("DEXTCHLHA2S2", "2%, 70% isopropyl alcohol, sol., 250 ml, bot. [fr:2%, 70% d'alcool isopropylique, sol., 250 ml, fl.]", Unit.ML),
            new Format("DEXTCHLHA2W", "2%, 70% isopropyl alcohol, WIPE [fr:2%, 70% d'alcool isopropylique, LINGETTE]", Unit.ML),
            new Format("DEXTCHLHSP4", "digluconate 4%, soap, 500 ml, bot. [fr:digluconate 4%, savon, 500 ml, fl.]", Unit.ML)
        ),
        new Drug("DEXTCIPR", "CIPROFLOXACIN [fr:CIPROFLOXACINE]").withFormats(
            new Format("DEXTCIPR1D", "0.3%, ear / eye drops, sterile, bot. [fr:0.3%, gttes auriculaires / collyre, strile, fl]", Unit.ML)
        ),
        new Drug("DEXTCLOT", "CLOTRIMAZOLE [fr:CLOTRIMAZOLE]").withFormats(
            new Format("DEXTCLOT1C2", "1%, cream, 20 g, tube [fr:1%, crme, 20 g, tube]", Unit.ML),
            new Format("DEXTCLOT5T", "500 mg, vaginal tab. + applicator [fr:500 mg, comp. vaginal + applicateur]", Unit.TABLET)
        ),
        new Drug("DEXTCOLD", "COLD CREAM [fr:COLD CREAM]").withFormats(
            new Format("DEXTCOLD1C", "cream, 1000 ml, jar [fr:crme, 1000 ml, pot]", Unit.ML)
        ),
        new Drug("DEXTDEET", "D. E. E. T. [fr:D. E. E. T.]").withFormats(
            new Format("DEXTDEET1C", "anti-mosquito repellent lotion, 30% [fr:lotion rpulsive anti-moustique, 30%]", Unit.ML)
        ),
        new Drug("DEXTDIAZ", "DIAZEPAM [fr:DIAZEPAM]").withFormats(
            new Format("DEXTDIAZ1RS", "4 mg / ml, rectal sol., 2.5 ml, tube [fr:4 mg / ml, sol. rectale, 2.5 ml, tube]", Unit.ML),
            new Format("DEXTDIAZ2RS", "2 mg / 1 ml, rectal sol., 1.25 ml, tube [fr:2 mg / 1 ml, sol. rectale, 1.25 ml, tube]", Unit.ML)
        ),
        new Drug("DEXTDICL", "DICLOFENAC [fr:DICLOFENAC]").withFormats(
            new Format("DEXTDICL1G5", "1%, gel, 50 g, tube [fr:1%, gel, 50 g, tube]", Unit.ML)
        ),
        new Drug("DEXTDINO", "DINOPROSTONE [fr:DINOPROSTONE]").withFormats(
            new Format("DEXTDINO1G", "1 mg, vaginal gel, sterile [fr:1 mg, gel vaginal strile]", Unit.MG)
        ),
        new Drug("DEXTENEM", "ENEMA [fr:LAVEMENT]").withFormats(
            new Format("DEXTENEM5RS", "rectal sol., 5 ml, tube [fr:sol. rectale, 5 ml, tube]", Unit.ML)
        ),
        new Drug("DEXTFENT", "FENTANYL [fr:FENTANYL]").withFormats(
            new Format("DEXTFENT2TP", "2.1 mg / 5.25cm2, 12 g / h, transdermal patch [fr:2.1 mg / 5.25cm2, 12 g / h, dispositif transdermique]", Unit.MG),
            new Format("DEXTFENT4TP", "4.2 mg, 25 g / h, transdermal patch [fr:4.2 mg, 25 g / h, dispositif transdermique]", Unit.MG)
        ),
        new Drug("DEXTFUSI", "FUSIDIC ACID [fr:ACIDE FUSIDIQUE]").withFormats(
            new Format("DEXTFUSI2C3", "2%, cream, 30 g, tube [fr:2%, crme, 30 g, tube]", Unit.ML)
        ),
        new Drug("DEXTGLYP", "GLYCEROL / PARAFFIN [fr:GLYCEROL / PARAFFINE]").withFormats(
            new Format("DEXTGLYP2C", "15% / 10%, cream, 250 g, tube [fr:15% / 10%, crme, 250 g, tube]", Unit.ML)
        ),
        new Drug("DEXTHYDR", "HYDROCORTISONE (acetate or base) [fr:HYDROCORTISONE (actate ou base)]").withFormats(
            new Format("DEXTHYDR1C1", "1%, cream, 15 g, tube [fr:1%, crme, 15 g, tube]", Unit.ML),
            new Format("DEXTHYDR1O1", "1%, ointment, 15 g, tube [fr:1%, pommade, 15 g, tube]", Unit.ML)
        ),
        new Drug("DEXTHYPE", "HYDROGEN PEROXIDE [fr:PEROXYDE D'HYDROGNE]").withFormats(
            new Format("DEXTHYPE3B2", "3%, sol., 250 ml, bot. [fr:3%, sol., 250 ml, fl.]", Unit.ML)
        ),
        new Drug("DEXTHYSU", "HYALURONATE sodium / SILVER SULFADIAZINE [fr:HYALURONATE de sodium / SULFADIAZINE argent]").withFormats(
            new Format("DEXTHYSU1C", "/ cream, 100 g, tube [fr:/ ., crme, 100 g, tube]", Unit.MG)
        ),
        new Drug("DEXTIODP", "POLYVIDONE IODINE [fr:POLYVIDONE IODEE]").withFormats(
            new Format("DEXTIODP1G3", "10%, gel, tube of 30 g [fr:10%, gel, tube de 30 g]", Unit.ML),
            new Format("DEXTIODP1S2", "10%, solution, 200 ml, dropper bot. [fr:10%, solution, 200 ml, fl. verseur]", Unit.ML),
            new Format("DEXTIODPS4", "surgical scrub, 4%, 125 ml, bot. [fr:savon germicide, 4%, 125 ml, fl.]", Unit.ML),
            new Format("DEXTIODPS75", "surgical scrub, 7.5%, 500 ml, bot. [fr:savon germicide, 7.5%, 500 ml, fl.]", Unit.ML)
        ),
        new Drug("DEXTIUDE", "INTRA UTERINE DEVICE [fr:DISPOSITIF INTRA UTERIN]").withFormats(
            new Format("DEXTIUDE1L", "LEVONORGESTREL, 52 mg (LNG-IUD 52) [fr:LEVONORGESTREL, 52 mg (LNG-DIU 52)]", Unit.MG)
        ),
        new Drug("DEXTLICH", "LIDOCAINE / CHLORHEX. [fr:LIDOCAINE / CHLORHEX.]").withFormats(
            new Format("DEXTLICH2J", "2% / . digluc. 0.25%, jelly, 11 ml, ster, syr. [fr:2% / . digluc. 0.25%, gel, 11 ml, str, ser.]", Unit.ML)
        ),
        new Drug("DEXTLIDO", "LIDOCAINE [fr:LIDOCAINE]").withFormats(
            new Format("DEXTLIDO2J3", "2%, jelly, sterile, tube [fr:2%, gel, strile, tube]", Unit.ML)
        ),
        new Drug("DEXTLIDP", "LIDOCAINE / PRILOCAINE [fr:LIDOCAINE / PRILOCAINE]").withFormats(
            new Format("DEXTLIDP2C5", "2.5% / 2.5%, cream, 5 g, tube [fr:2.5% / 2.5%, crme, 5 g, tube]", Unit.ML)
        ),
        new Drug("DEXTMAFE", "MAFENIDE acetate [fr:MAFENIDE acetate]").withFormats(
            new Format("DEXTMAFE4C", "cream, 453.6 g, jar [fr:crme, 453.6 g, pot]", Unit.MG)
        ),
        new Drug("DEXTMALA", "MALATHION [fr:MALATHION]").withFormats(
            new Format("DEXTMALA5L", "500 mg / 100 ml, lotion, bot. [fr:500 mg / 100 ml, lotion, fl.]", Unit.ML)
        ),
        new Drug("DEXTMICO", "MICONAZOLE nitrate [fr:MICONAZOLE nitrate]").withFormats(
            new Format("DEXTMICO2C3", "2%, cream, 30 g, tube [fr:2%, crme, 30 g, tube]", Unit.ML)
        ),
        new Drug("DEXTMOSQ", "ANTIPRURITIC CREAM [fr:CREME ANTIPRURIGINEUSE]").withFormats(
            new Format("DEXTMOSQ1C", "after mosquito bites, tube [fr:aprs piqres de moustiques, tube]", Unit.MG)
        ),
        new Drug("DEXTMUPI", "MUPIROCIN [fr:MUPIROCINE]").withFormats(
            new Format("DEXTMUPI2O1", "2%, ointment, 15 g, tube [fr:2%, pommade, 15 g, tube]", Unit.ML)
        ),
        new Drug("DEXTOFLO", "OFLOXACIN [fr:OFLOXACINE]").withFormats(
            new Format("DEXTOFLO1S5", "3 mg / ml, ear sol., 0.5 ml, monodose [fr:3 mg / ml, sol. auriculaire, 0.5 ml, unidose]", Unit.ML)
        ),
        new Drug("DEXTPARA", "PARACETAMOL (acetaminophen) [fr:PARACETAMOL (actaminophne)]").withFormats(
            new Format("DEXTPARA12SU", "120 mg, suppository [fr:120 mg, suppositoire]", Unit.MG),
            new Format("DEXTPARA12SU1", "125 mg, suppository [fr:125 mg, suppositoire]", Unit.MG),
            new Format("DEXTPARA2SU", "240 mg, suppository [fr:240 mg, suppositoire]", Unit.MG),
            new Format("DEXTPARA5SU", "500 mg, suppository [fr:500 mg, suppositoire]", Unit.MG)
        ),
        new Drug("DEXTPERM", "PERMETHRIN [fr:PERMETHRINE]").withFormats(
            new Format("DEXTPERM1L1", "1%, lotion, bot. [fr:1%, lotion, fl.]", Unit.ML),
            new Format("DEXTPERM5T", "5%, cream, tube [fr:5% crme, tube]", Unit.ML)
        ),
        new Drug("DEXTPHEL", "PHENASONE / LIDOCAINE HCl [fr:PHENASONE / LIDOCAINE HCl]").withFormats(
            new Format("DEXTPHEL41D1", "4% / 1%, ear drops, 15 ml, bot. [fr:4% / 1%, gttes auric, 15 ml, fl.]", Unit.ML)
        ),
        new Drug("DEXTPODO", "PODOPHYLLOTOXIN [fr:PODOPHYLLOTOXINE]").withFormats(
            new Format("DEXTPODO5S3", "0.5%, solution, 3.5 ml, + 30 applicator tips [fr:0.5%, solution, 3.5 ml, + 30 applicateurs]", Unit.ML)
        ),
        new Drug("DEXTSILN", "SILVER NITRATE [fr:NITRATE D'ARGENT]").withFormats(
            new Format("DEXTSILN1U", "40%, pencil [fr:40%, crayon]", Unit.ML)
        ),
        new Drug("DEXTSUCE", "SILVER SULFADIAZINE / CERIUM nitrate [fr:SULFADIAZINE ARGENTIQUE / CERIUM nitrate]").withFormats(
            new Format("DEXTSUCE51C", "5 g / 11 g, cream, 500 g, pot [fr:5 g / 11 g, crme, 500 g]", Unit.MG)
        ),
        new Drug("DEXTSULZ", "SULFADIAZINE SILVER [fr:SULFADIAZINE ARGENTIQUE]").withFormats(
            new Format("DEXTSULZ1C5", "1%, cream, sterile, 50 g, tube [fr:1%, crme, strile, 50 g, tube]", Unit.ML),
            new Format("DEXTSULZ1CJ", "1%, cream, sterile, 500 g, jar [fr:1%, crme, strile, 500 g, pot]", Unit.ML)
        ),
        new Drug("DEXTYINO", "ZINC OXIDE [fr:OXYDE DE ZINC]").withFormats(
            new Format("DEXTYINO15O1", "15%, ointment, 100 g, jar [fr:15%, pommade, 100 g, pot]", Unit.ML),
            new Format("DEXTYINO1O1", "10%, ointment, 100 g, tube [fr:10%, pommade, 100 g, tube]", Unit.ML)
        )
    );

    Category VACCINE = new Category("DVAC", "vaccines/immunoglobulins", false).withDrugs(
        new Drug("DVACDTUB", "TUBERCULIN [fr:TUBERCULINE]").withFormats(
            new Format("DVACDTUB5T", "5 TU / 0.1 ml, multidose, 1 dose, vial. [fr:5 UI / 0.1 ml, multidose, 1 dose, fl.]", Unit.ML)
        ),
        new Drug("DVACIMAS", "IMMUNOGLOBULIN AFRICAN SNAKE ANTIVENOM [fr:IMMUNOGLOBULINE ANTIVENIN SERPENTS AFRICAINS]").withFormats(
            new Format("DVACIMAS2V", "EchiTab-Plus, vial [fr:EchiTab-Plus, fl]", Unit.MG),
            new Format("DVACIMAS3A", "SAIMR, 10 ml amp. [fr:SAIMR, 10 ml amp]", Unit.ML)
        ),
        new Drug("DVACIMHB", "IMMUNOGLOBULIN HUMAN HEPATITIS B [fr:IMMUNOGLOBULINE HUMAINE HEPATITE B]").withFormats(
            new Format("DVACIMHB1V", "180 IU / ml, 1 ml, vial [fr:180 UI / ml, 1 ml, fl.]", Unit.ML)
        ),
        new Drug("DVACIMHD", "IMMUNOGLOBULIN HUMAN anti-D [fr:IMMUNOGLOBULINE HUMAINE anti-D]").withFormats(
            new Format("DVACIMHD1S", "300 g, syringe [fr:300 g, seringue]", Unit.MG),
            new Format("DVACIMHD1V", "300 g, powder + diluent, vial [fr:300 g, poudre + solvant, fl.]", Unit.MG)
        ),
        new Drug("DVACIMHR", "IMMUNOGLOBULIN HUMAN ANTIRABIES [fr:IMMUNOGLOBULINE HUM.]").withFormats(
            new Format("DVACIMHR3V", "150 UI / ml, 2 ml, vial [fr:ANTIRABIQUES, 150 UI / ml, 2 ml, fl.]", Unit.ML),
            new Format("DVACIMHR3V1", "300 IU / ml, 1 ml, vial [fr:ANTIRABIQUE, 300 UI / ml, 1 ml, fl.]", Unit.ML),
            new Format("DVACIMHR3V5", "300 IU / ml, 5 ml, vial [fr:ANTIRABIQUE, 300 UI / ml, 5 ml, fl.]", Unit.ML)
        ),
        new Drug("DVACIMPH", "IMMUNOGLOBULIN [fr:IMMUNOGLOBULINE]").withFormats(
            new Format("DVACIMPH1V", "polyvalent, human, 0.1 g / ml, 100 ml, vial [fr:polyvalent, humaine, 0.1 g / ml, 100 ml, fl.]", Unit.ML)
        ),
        new Drug("DVACIMTE", "IMMUNOGLOBULIN HUMAN ANTITETANUS [fr:IMMUNOGLOBULINE HUM. ANTITETANIQUE]").withFormats(
            new Format("DVACIMTE2S", "250 IU / ml, syr. [fr:250 UI / ml, sering.]", Unit.MG)
        ),
        new Drug("DVACVBCG", "VACCINE BCG [fr:VACCIN BCG]").withFormats(
            new Format("DVACVBCG3SD", "DILUENT, 1 dose, multidose vial [fr:SOLVANT, 1 dose, multidose fl.]", Unit.MG),
            new Format("DVACVBCG3VD", "1 dose, multidose vial, 0.05 ml / dose [fr:1 dose, fl. multidose, 0.05 ml / dose]", Unit.ML)
        ),
        new Drug("DVACVCHO", "VACCINE CHOLERA, ORAL, monodose [fr:VACCIN CHOLERA, ORAL, monodose]").withFormats(
            new Format("DVACVCHO1PT", "se, 1.5 ml, plastic tube [fr:se, 1.5 ml, tube plast.]", Unit.ML),
            new Format("DVACVCHO1V", "se, 1.5 ml, vial [fr:se, 1.5 ml, fl]", Unit.ML)
        ),
        new Drug("DVACVDHH", "VACCINE DPT / HEPATITIS B / Hib [fr:VACCIN DTC / HEPATITE B / Hib]").withFormats(
            new Format("DVACVDHH1VD", "1 dose, multidose vial [fr:1 dose, fl. multidose]", Unit.MG)
        ),
        new Drug("DVACVDTB", "VACCINE Td (tetanus / diphtheria booster) [fr:VACCIN Td (ttanos / diphtrie dose rappel)]").withFormats(
            new Format("DVACVDTB1VD", "1 dose, multidose vial [fr:1 dose, fl. multid.]", Unit.MG)
        ),
        new Drug("DVACVENC", "VACCINE JAPANESE ENCEPHALITIS [fr:VACCIN ENCEPHALITE JAPONAISE]").withFormats(
            new Format("DVACVENC1S", "monodose, syringe, 0.5 ml [fr:monodose, seringue, 0.5 ml]", Unit.ML)
        ),
        new Drug("DVACVHEA", "VACCINE HEPATITIS A [fr:VACCIN HEPATITE A]").withFormats(
            new Format("DVACVHEA1S", "1 dose, adult, monodose, syringe [fr:1 dose, adult, monodose, seringue]", Unit.MG)
        ),
        new Drug("DVACVHEB", "VACCINE HEPATITIS B [fr:VACCIN HEPATITE B]").withFormats(
            new Format("DVACVHEB1U", "1 adult dose, monodose, uniject [fr:1 dose adulte, monodose, uniject]", Unit.MG),
            new Format("DVACVHEB1VD", "1 adult dose, multidose vial [fr:1 dose adulte, fl. multidose]", Unit.MG),
            new Format("DVACVHEB2V", "1 adult dose, monodose, 1 ml, vial [fr:1 dose adulte, monodose, 1 ml, fl.]", Unit.ML),
            new Format("DVACVHEB3V", "1 child dose, monodose, 0.5 ml, vial [fr:1 dose enfant, monodose, 0.5 ml, fl.]", Unit.ML),
            new Format("DVACVHEB3VD", "1 child dose, multidose vial [fr:1 dose enfant, fl. multidose]", Unit.MG)
        ),
        new Drug("DVACVHIB", "VACCINE HAEMOPHILUS INFLUENZAE type b [fr:VACCIN HAEMOPHILUS INFLUENZAE type b]").withFormats(
            new Format("DVACVHIB1S", "monodose, 0.5 ml, syr. [fr:monodose, 0.5 ml, ser.]", Unit.ML)
        ),
        new Drug("DVACVHPV", "VACCINE HPV [fr:VACCIN HPV]").withFormats(
            new Format("DVACVHPV2V", "bivalent, monodose, 0.5 ml, vial [fr:bivalent, monodose, 0.5 ml, fl.]", Unit.ML),
            new Format("DVACVHPV4V", "quadrivalent, monodose, 0.5 ml, vial [fr:quadrivalent, monodose, 0.5 ml, fl.]", Unit.ML)
        ),
        new Drug("DVACVMEA", "VACCINE MEASLES [fr:VACCIN ROUGEOLE]").withFormats(
            new Format("DVACVMEA2SD", "DILUENT, 1 dose, multidose vial [fr:SOLVANT, 1 dose, fl. multidose]", Unit.MG),
            new Format("DVACVMEA2VD", "1 dose, multidose vial [fr:1 dose, fl. multidose]", Unit.MG)
        ),
        new Drug("DVACVMEN", "VACCINE MENINGITIS [fr:VACCIN MENINGITE]").withFormats(
            new Format("DVACVMEN1VWCJ", "MENINGITIS CJ A+C+W135+Y, monod. + dil. 0.5 ml (Menveo) [fr:MENINGITE CJ A+C+W135+Y, monod. + solv. 0.5 ml (Menveo)]", Unit.ML),
            new Format("DVACVMEN2VWCJ", "MENINGITIS CJ A+C+W135+Y, monod., vial (Menactra) [fr:MENINGITE CJ A+C+W135+Y, monod. fl. (Menactra)]", Unit.MG),
            new Format("DVACVMEN3VWCJ", "MENINGITIS CJ A+C+W135+Y, monod. +dil. 0.5 ml (Nimenrix) [fr:MENINGITE CJ A+C+W135+Y, monod. +solv. 0.5 ml (Nimenrix)]", Unit.ML),
            new Format("DVACVMENA1SD", "MENINGOCOCCAL A CONJUGATE, 1-29years) DILUENT 1 dose, multidose v. [fr:MENINGOCOQUE A CONJUGUE, 1-29 ans) SOLVANT 1 dose, fl. multidose]", Unit.MG),
            new Format("DVACVMENA1VD", "MENINGOCOCCAL A CONJUGATE, 1-29years, 1dose, multid. v [fr:MENINGOCOQUE A CONJUGUE, 1-29 ans, 1dose, fl. multid.]", Unit.MG),
            new Format("DVACVMENA2SD", "MENINGOCOCCAL A CONJUGATE, 3-24months) DILUENT, 1 dose, multidose [fr:MENINGOCOQUE A CONJUGUE, 3-24 mois) SOLVANT, 1 dose, multidose]", Unit.MG),
            new Format("DVACVMENA2VD", "MENINGOCOCCAL A CONJ. 3-24months, 1dose, multid. vial [fr:MENINGOCOQUE A CONJ. 3-24 mois, 1dose, fl. multid.]", Unit.MG)
        ),
        new Drug("DVACVMER", "MEASLES / RUBELLA VACCINE [fr:VACCIN ROUGEOLE /]").withFormats(
            new Format("DVACVMER1SD", "Diluent multidose, 1 dose, bottle [fr:ROUBEOLE, ) Solvant multidose, 1 dose, fl.]", Unit.MG),
            new Format("DVACVMER1VD", "multidose, 1 dose, vial [fr:RUBEOLE, multidose, 1 dose, fl.]", Unit.MG)
        ),
        new Drug("DVACVMMR", "VACCINE MMR (measles / mumps / rubella) [fr:VACCIN ROR (rougeole / oreillons / rubole)]").withFormats(
            new Format("DVACVMMR1SD", "DILUENT, 1 dose, multidose vial [fr:SOLVANT, 1 dose, fl. multidose]", Unit.MG),
            new Format("DVACVMMR1VD", "1 dose, multidose vial [fr:1dose, fl. multidose]", Unit.MG),
            new Format("DVACVMMR2S", "DILUENT, monodose, amp. [fr:SOLVANT, monod amp.]", Unit.MG),
            new Format("DVACVMMR2V", "monodose vial [fr:monodose, fl.]", Unit.MG)
        ),
        new Drug("DVACVPCV", "VACCINE PNEUMOCOCCAL CONJUGATE [fr:VACCIN PNEUMOCOQUES CONJUGUE]").withFormats(
            new Format("DVACVPCV13VD", "PCV13, 1 dose, vial, multidose [fr:PCV13, 1 dose, fl. multidose]", Unit.MG),
            new Format("DVACVPCV13VDN", "PCV13.1dose, multid. vl noGAVI [fr:PCV13, 1dose, fl. multid. nonGAVI]", Unit.MG),
            new Format("DVACVPCV13VDS", "PCV13, 1dose, multid. vial spec [fr:PCV13, 1dose, fl. multid. spc.]", Unit.MG),
            new Format("DVACVPCV2VD", "PCV10, 1 dose, vial, multidose [fr:PCV10, 1 dose, fl. multidose]", Unit.MG)
        ),
        new Drug("DVACVPOI", "VACCINE POLIOMYELITIS, INACTIVATED [fr:VACCIN POLIO]").withFormats(
            new Format("DVACVPOI1VD", "D, 1 dose, multidose vial [fr:INACTIVE, 1 dose, fl. multidose]", Unit.MG),
            new Format("DVACVPOI2S", "D, 0.5 ml, monodose syringe [fr:INACTIVE (IPV) inject, monodose, 0.5 ml, sering]", Unit.ML)
        ),
        new Drug("DVACVPOL", "VACCINE POLIOMYELITIS, BIVALENT ORAL [fr:VACCIN POLIO, BIVALENT ORAL]").withFormats(
            new Format("DVACVPOL13BD", "L, 1 dose, multidose vial [fr:L, 1 dose, fl. multidose]", Unit.MG),
            new Format("DVACVPOL13DR", "L, DROPPER [fr:L, COMPTE-GOUTTE]", Unit.MG)
        ),
        new Drug("DVACVPPV", "VACCINE PNEUMOCOCCAL polysaccharide [fr:VACCIN PNEUMOCOQUE polysaccharide]").withFormats(
            new Format("DVACVPPV23S", "23, monodose, 0.5 ml, syr. [fr:23, monodose, 0.5 ml, ser.]", Unit.ML)
        ),
        new Drug("DVACVRAB", "VACCINE RABIES, CCV, cell culture, monodose [fr:VACCIN ANTIRABIQUE, VCC, culture cellulaire, monodose]").withFormats(
            new Format("DVACVRAB1V", "ose, vial [fr:ose, fl.]", Unit.MG),
            new Format("DVACVRAB2S", "ose, syringe [fr:ose, ser.]", Unit.MG),
            new Format("DVACVRAB3V", "ose, vial [fr:ose, fl.]", Unit.MG)
        ),
        new Drug("DVACVROT", "VACCINE ROTAVIRUS [fr:VACCIN ROTAVIRUS]").withFormats(
            new Format("DVACVROT1T", "ORAL (Rotarix), monodose, 1.5 ml, tube [fr:ORAL (Rotarix), monodose, 1.5 ml, tube]", Unit.ML)
        ),
        new Drug("DVACVTET", "VACCINE TT (tetanus) [fr:VACCIN TT (ttanos)]").withFormats(
            new Format("DVACVTET1S", "monodose, 0.5 ml, syringe [fr:monodose, 0.5 ml, seringue]", Unit.ML),
            new Format("DVACVTET1VD", "1 dose, multidose vial [fr:1 dose, fl. multidose]", Unit.MG)
        ),
        new Drug("DVACVTYP", "VACCINE TYPHOID [fr:VACCIN TYPHOIDIQUE]").withFormats(
            new Format("DVACVTYP1S", "polysaccharide 25 g, monodosis, 0.5 ml, syringe [fr:polyosidique 25 g, monodose, 0.5 ml, seringue]", Unit.ML),
            new Format("DVACVTYP2VD", "Typhim Vi, 1 dose, multidose vial [fr:Typhim Vi, 1 dose, fl. multidose]", Unit.MG),
            new Format("DVACVTYPC1VD", "CONJUGATE, 1dose, multidose vial [fr:CONJUGUE, 1 dose, fl. multidose]", Unit.MG)
        ),
        new Drug("DVACVYEF", "VACCINE YELLOW FEVER [fr:VACCIN FIEVRE JAUNE]").withFormats(
            new Format("DVACVYEF1S", "monodose amp. + syr. solvent 0.5 ml [fr:monodose amp. + seringue solvant 0.5 ml]", Unit.ML),
            new Format("DVACVYEF2SD", "DILUENT, 1 dose, multidose vial [fr:SOLVANT, 1 dose, fl. multidose]", Unit.MG),
            new Format("DVACVYEF2VD", "1 dose, multidose vial [fr:1 dose, fl. multidose]", Unit.MG)
        )
    );

    // ==== END GENERATED OUTPUT ====

    CatalogIndex INDEX = new CatalogIndex(ORAL, INJECTABLE, PERFUSION, EXTERNAL, VACCINE)
        .withRoutes(UNSPECIFIED, PO, IV, SC, IM, IO, OC)
        .withDosageUnits(
            Unit.TABLET, Unit.CAPSULE,
            Unit.G, Unit.MG, Unit.MCG,
            Unit.L, Unit.ML,
            Unit.IU,
            Unit.DROP, Unit.PUFF,
            Unit.AMPOULE, Unit.SACHET,
            Unit.OVULE, Unit.SUPP)
        .withDurationUnits(
            Unit.HOUR,
            Unit.MINUTE,
            Unit.SECOND
        );

}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models;

import android.content.ContentResolver;
import android.database.Cursor;
import android.net.Uri;
import android.os.AsyncTask;

import org.joda.time.DateTime;
import org.projectbuendia.client.App;
import org.projectbuendia.client.events.CrudEventBus;
import org.projectbuendia.client.events.data.ItemCreatedEvent;
import org.projectbuendia.client.events.data.ItemLoadedEvent;
import org.projectbuendia.client.events.data.ItemUpdatedEvent;
import org.projectbuendia.client.events.data.TypedCursorLoadedEvent;
import org.projectbuendia.client.events.data.TypedCursorLoadedEventFactory;
import org.projectbuendia.client.filter.db.SimpleSelectionFilter;
import org.projectbuendia.client.filter.db.patient.UuidFilter;
import org.projectbuendia.client.json.Datatype;
import org.projectbuendia.client.json.JsonPatient;
import org.projectbuendia.models.tasks.TaskFactory;
import org.projectbuendia.client.net.Server;
import org.projectbuendia.client.providers.Contracts.Misc;
import org.projectbuendia.client.providers.Contracts.Patients;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

/**
 * A model that manages all data access within the application.
 * <p/>
 * <p>This model's {@code load} methods often provide {@link TypedCursor}s as results, which MUST
 * be closed when the consumer is done with them.
 * <p/>
 * <p>Updates done through this model are written through to a backing {@link Server}; callers do
 * not need to worry about the implementation details of this.
 */
public class AppModel {

    private static final Logger LOG = Logger.create();
    private final ContentResolver mContentResolver;
    private final TaskFactory mTaskFactory;

    private LocationForestProvider forestProvider = null;

    AppModel(ContentResolver contentResolver, TaskFactory taskFactory) {
        mContentResolver = contentResolver;
        mTaskFactory = taskFactory;
        forestProvider = new LocationForestProvider(mContentResolver);
    }

    /** Clears all in-memory model state. */
    public void reset() {
        forestProvider.dispose();
        forestProvider = new LocationForestProvider(mContentResolver);
    }

    public @Nonnull LocationForest getForest() {
        return forestProvider.getForest(App.getSettings().getLocale());
    }

    public @Nullable Location getDefaultLocation() {
        return getForest().getDefaultLocation();
    }

    public void setOnForestReplacedListener(Runnable listener) {
        forestProvider.setOnForestReplacedListener(listener);
    }

    /** Returns true if the model is ready for use. */
    public boolean isReady() {
        return getLastFullSyncTime() != null;
    }

    public DateTime getLastFullSyncTime() {
        // The FULL_SYNC_END_MILLIS field indicates a successful full sync.
        // It is set to non-null only when the end of a full sync is reached and the
        // database has not been cleared during the sync (see storeFullSyncEndTime).
        DateTime fullSyncEnd = null;
        try (Cursor cursor = mContentResolver.query(Misc.URI, null, null, null, null)) {
            if (cursor.moveToNext()) {
                fullSyncEnd = Utils.getDateTime(cursor, Misc.FULL_SYNC_END_MILLIS);
            }
        }
        return fullSyncEnd;
    }

    public void deleteObs(CrudEventBus bus, Obs obs) {
        mTaskFactory.newDeleteObsTask(bus, obs).execute();
    }

    /** Asynchronously downloads one patient from the server and saves it locally. */
    public void fetchPatient(CrudEventBus bus, String patientId) {
        mTaskFactory.newFetchPatientTask(patientId, bus).execute();
    }

    /**
     * Asynchronously loads patients, posting a {@link TypedCursorLoadedEvent} with
     * {@link Patient}s on the specified event bus when complete.
     */
    public void loadPatients(CrudEventBus bus, SimpleSelectionFilter filter, String constraint) {
        // NOTE: We need to keep the object creation separate from calling #execute() here, because
        // the type inference breaks on Java 8 otherwise, which throws
        // `java.lang.ClassCastException: java.lang.Object[] cannot be cast to java.lang.Void[]`.
        // See http://stackoverflow.com/questions/24136126/fatal-exception-asynctask and
        // https://github.com/projectbuendia/client/issues/7
        LoadTypedCursorAsyncTask<Patient> task = new LoadTypedCursorAsyncTask<>(
            Patients.URI,
            // The projection must contain an "_id" column for the ListAdapter as well as all
            // the columns used in Patient.Loader.fromCursor().
            null, //new String[] {"rowid as _id", Patients.UUID, Patients.ID, Patients.GIVEN_NAME,
                //Patients.FAMILY_NAME, Patients.BIRTHDATE, Patients.SEX, Patients.LOCATION_UUID},
            Patient.class, mContentResolver, filter, constraint, Patient::load, bus);
        task.execute();
    }

    /**
     * Asynchronously loads a single patient by UUID, posting a {@link ItemLoadedEvent}
     * with the {@link Patient} on the specified event bus when complete.
     */
    public void loadSinglePatient(CrudEventBus bus, String uuid) {
        mTaskFactory.newLoadItemTask(
            Patients.URI, null, new UuidFilter(), uuid, Patient::load, bus
        ).execute();
    }

    /**
     * Asynchronously adds a patient, posting a
     * {@link ItemCreatedEvent} with the newly-added patient on
     * the specified event bus when complete.
     */
    public void addPatient(CrudEventBus bus, JsonPatient patient) {
        mTaskFactory.newAddPatientTask(patient, bus).execute();
    }

    /**
     * Asynchronously updates a patient, posting a
     * {@link ItemUpdatedEvent} with the updated
     * {@link Patient} on the specified event bus when complete.
     */
    public void updatePatient(CrudEventBus bus, JsonPatient patient) {
        mTaskFactory.newUpdatePatientTask(patient, bus).execute();
    }

    /**
     * Asynchronously adds or updates an order (depending whether order.uuid is null), posting an
     * {@link ItemCreatedEvent} or {@link ItemUpdatedEvent} when complete.
     */
    public void addOrder(CrudEventBus bus, Order order) {
        mTaskFactory.newAddOrderTask(order, bus).execute();
    }

    /** Asynchronously deletes an order. */
    public void deleteOrder(CrudEventBus bus, String orderUuid) {
        mTaskFactory.newDeleteOrderTask(orderUuid, bus).execute();
    }

    /**
     * Asynchronously adds an encounter that records an order as executed, posting a
     * {@link ItemCreatedEvent} when complete.
     */
    public void addOrderExecutionEncounter(
        CrudEventBus bus, String patientUuid, String orderUuid, DateTime executionTime) {
        addObservationEncounter(bus, patientUuid, new Obs(
            null, null, patientUuid, Utils.getProviderUuid(), ConceptUuids.ORDER_EXECUTED_UUID,
            Datatype.NUMERIC, executionTime, orderUuid, "1", null));
    }

    /** Adds a single observation in an encounter, posting ItemCreatedEvent when complete. */
    public void addObservationEncounter(CrudEventBus bus, String patientUuid, Obs obs) {
        mTaskFactory.newAddEncounterTask(new Encounter(
            null, patientUuid, Utils.getProviderUuid(), DateTime.now(), new Obs[] {obs}
        ), bus).execute();
    }

    /**
     * Asynchronously adds an encounter to a patient, posting a
     * {@link ItemCreatedEvent} when complete.
     */
    public void addEncounter(CrudEventBus bus, Encounter encounter) {
        mTaskFactory.newAddEncounterTask(encounter, bus).execute();
    }

    /**
     * Updates the denormalized observation fields in a row in the patient table
     * with the latest unvoided values in the observations table.
     */
    public void denormalizeObservations(CrudEventBus bus, String patientUuid) {
        mTaskFactory.newDenormalizeObsTask(patientUuid, bus).execute();
    }

    private static class LoadTypedCursorAsyncTask<T extends Model>
        extends AsyncTask<Void, Void, TypedCursor<T>> {

        private final Uri mContentUri;
        private final String[] mProjection;
        private final Class<T> mClazz;
        private final ContentResolver mContentResolver;
        private final SimpleSelectionFilter mFilter;
        private final String mConstraint;
        private final CursorLoader<T> mLoader;
        private final CrudEventBus mBus;

        public LoadTypedCursorAsyncTask(
            Uri contentUri,
            String[] projection,
            Class<T> clazz,
            ContentResolver contentResolver,
            SimpleSelectionFilter<T> filter,
            String constraint,
            CursorLoader<T> loader,
            CrudEventBus bus) {
            mContentUri = contentUri;
            mProjection = projection;
            mClazz = clazz;
            mContentResolver = contentResolver;
            mFilter = filter;
            mConstraint = constraint;
            mLoader = loader;
            mBus = bus;
        }

        @Override protected TypedCursor<T> doInBackground(Void... voids) {
            Cursor cursor = null;
            try {
                cursor = mContentResolver.query(
                    mContentUri,
                    mProjection,
                    mFilter.getSelectionString(),
                    mFilter.getSelectionArgs(mConstraint),
                    null);

                return new TypedCursorWithLoader<>(cursor, mLoader);
            } catch (Exception e) {
                if (cursor != null) {
                    cursor.close();
                }

                throw e;
            }
        }

        @Override protected void onPostExecute(TypedCursor<T> result) {
            mBus.post(TypedCursorLoadedEventFactory.createEvent(mClazz, result));
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models;

import java.util.ArrayList;
import java.util.List;

/** A group of tiles (shown in one row) or a group of grid rows (with a heading) in a chart. */
public class ChartSection {
    public final String label;
    public final List<ChartItem> items;

    public ChartSection(String label) {
        this(label, new ArrayList<>());
    }

    public ChartSection(String label, List<ChartItem> items) {
        this.label = label;
        this.items = items;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models;

import android.database.Cursor;

/** An object that loads a model from a database cursor. */
public interface CursorLoader<T> {
    /** Constructs a model from the given {@link Cursor}'s current row of values. */
    T load(Cursor cursor);
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models;

import org.projectbuendia.client.utils.Utils;

import static org.projectbuendia.client.utils.Utils.eq;

/** An abstract base class for application models, which all have UUIDs. */
public abstract class Model {
    public final String uuid;

    protected Model(String uuid) {
        this.uuid = Utils.toNonnull(uuid);
    }

    public boolean equals(Object other) {
        return other instanceof Model && eq(uuid, ((Model) other).uuid);
    }

    public int hashCode() {
        return uuid != null ? uuid.hashCode() : 0;
    }

    public String toString() {
        return "<" + getClass().getSimpleName() + " " + uuid + ">";
    }
}

package org.projectbuendia.models;

import com.google.gson.annotations.SerializedName;

import org.projectbuendia.client.App;
import org.projectbuendia.client.R;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

public enum Sex {
    @SerializedName("F") FEMALE,
    @SerializedName("M") MALE,
    @SerializedName("O") OTHER;

    public static @Nullable Sex nullableValueOf(@Nullable String name) {
        return name != null ? Enum.valueOf(Sex.class, name) : null;
    }

    public static @Nullable String nullableNameOf(@Nullable Sex sex) {
        return sex != null ? sex.name() : null;
    }

    /** Converts a Sex value to a code for JSON communication with the server. */
    public static @Nullable String serialize(@Nullable Sex sex) {
        if (sex == null) return null;
        try {
            return Sex.class.getField(sex.name()).getAnnotation(SerializedName.class).value();
        } catch (NoSuchFieldException e) {
            return null;
        }
    }

    /** Gets the localized abbreviation for a Sex value. */
    public static @Nonnull String getAbbreviation(@Nullable Sex sex) {
        // Java switch is not safe to use because it stupidly crashes on null.
        if (sex == FEMALE) return App.str(R.string.sex_female_abbreviation);
        if (sex == MALE) return App.str(R.string.sex_male_abbreviation);
        if (sex == OTHER) return App.str(R.string.sex_other_abbreviation);
        return "";
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models;

import org.joda.time.Instant;
import org.joda.time.ReadableInstant;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.Objects;

import javax.annotation.Nonnull;

/** An observed value together with the time it was observed (like a point on a graph). */
public final class ObsPoint implements Comparable<ObsPoint> {
    /** The time that the value was observed. */
    public final @Nonnull Instant time;

    /** The observed value. */
    public final @Nonnull ObsValue value;

    public ObsPoint(@Nonnull ReadableInstant time, @Nonnull ObsValue value) {
        this.time = new Instant(time);
        this.value = value;
    }

    @Override public String toString() {
        return "ObsPoint(time=" + time + ", " + value + ")";
    }

    public JSONObject toJson() throws JSONException {
        JSONObject jo = value.toJson();
        jo.put("time", time.getMillis());
        return jo;
    }

    @Override public boolean equals(Object other) {
        if (!(other instanceof ObsPoint)) return false;
        ObsPoint o = (ObsPoint) other;
        return Objects.equals(time, o.time) && Objects.equals(value, o.value);
    }

    @Override public int hashCode() {
        return 31 * Objects.hashCode(time) + Objects.hashCode(value);
    }

    @Override public int compareTo(@Nonnull ObsPoint other) {
        return time.compareTo(other.time);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models;

import android.content.ContentValues;
import android.database.Cursor;

import org.joda.time.LocalDate;
import org.projectbuendia.client.json.JsonPatient;
import org.projectbuendia.client.providers.Contracts.Patients;
import org.projectbuendia.client.utils.Utils;

import java.io.Serializable;

import javax.annotation.concurrent.Immutable;

public final @Immutable class Patient extends Model implements Serializable {
    public final String id;
    public final String givenName;
    public final String familyName;
    public final Sex sex;
    public final LocalDate birthdate;

    // The fields below are denormalized from observations, not received
    // as part of the patient model.
    public final boolean pregnancy;
    public final String locationUuid;
    public final String bedNumber;

    /** Creates an instance of {@link Patient} from a network {@link JsonPatient} object. */
    public static Patient fromJson(JsonPatient patient) {
        return new Patient(
            patient.uuid, patient.id, patient.given_name, patient.family_name,
            patient.sex, patient.birthdate, false /* pregnancy */,
            "" /* locationUuid */, "" /* bedNumber */);
    }

    /** Puts this object's fields in a {@link ContentValues} object for insertion into a database. */
    public ContentValues toContentValues() {
        ContentValues cv = new ContentValues();
        cv.put(Patients.UUID, uuid);
        cv.put(Patients.ID, id);
        cv.put(Patients.GIVEN_NAME, givenName);
        cv.put(Patients.FAMILY_NAME, familyName);
        cv.put(Patients.SEX, Sex.nullableNameOf(sex));
        cv.put(Patients.BIRTHDATE, Utils.format(birthdate));
        // PREGNANCY is a denormalized column and is never written directly.
        // LOCATION_UUID is a denormalized column and is never written directly.
        // BED_NUMBER is a denormalized column and is never written directly.
        return cv;
    }

    public org.odk.collect.android.model.Patient toOdkPatient() {
        return new org.odk.collect.android.model.Patient(
            uuid, id, givenName, familyName);
    }

    public Patient(String uuid, String id, String givenName, String familyName,
                   Sex sex, LocalDate birthdate, boolean pregnancy,
                   String locationUuid, String bedNumber) {
        super(uuid);
        this.id = Utils.toNonnull(id);
        this.givenName = Utils.toNonnull(givenName);
        this.familyName = Utils.toNonnull(familyName);
        this.sex = sex;
        this.birthdate = birthdate;
        this.pregnancy = pregnancy;
        this.locationUuid = Utils.toNonnull(locationUuid);
        this.bedNumber = Utils.toNonnull(bedNumber);
    }

    public static Patient load(Cursor cursor) {
        return new Patient(
            Utils.getString(cursor, Patients.UUID),
            Utils.getString(cursor, Patients.ID),
            Utils.getString(cursor, Patients.GIVEN_NAME),
            Utils.getString(cursor, Patients.FAMILY_NAME),
            Sex.nullableValueOf(Utils.getString(cursor, Patients.SEX)),
            Utils.getLocalDate(cursor, Patients.BIRTHDATE),
            Utils.getBoolean(cursor, Patients.PREGNANCY, false),
            Utils.getString(cursor, Patients.LOCATION_UUID),
            Utils.getString(cursor, Patients.BED_NUMBER)
        );
    }
}

package org.projectbuendia.models;

import android.support.annotation.NonNull;
import android.view.View;

import org.projectbuendia.client.R;
import org.projectbuendia.client.utils.Intl;
import org.projectbuendia.client.utils.Utils;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

public class MsfSupplyCatalog {

    // ==== Style conventions for captions ====
    //
    // A caption describes a primary category of therapeutic action, in lowercase.
    //   - A good test for this part is that it should have a plural form.
    //   - Use a noun, not a verb phrase (e.g. "abortifacient", not "causes abortion")
    //   - Use a noun, not an adjective (e.g. "anticonvulsant", not "anticonvulsive")
    //   - Describe the drug, not the action (e.g. "laxative", not "laxation")
    //   - Describe the drug, not the disease (e.g. "antimalarial", not "malaria")
    //   - For multiple purposes, use a comma (e.g. "antiseptic, disinfectant")
    //   - If primarily for a specific disease, optionally append "for" and the
    //     disease name in parentheses (e.g. "insecticide (for scabies)")

    public static final Intl ABORTIFACIENT = new Intl("abortifacient [fr:abortif]");
    public static final Intl ADSORBENT = new Intl("adsorbent [fr:adsorbant]");
    public static final Intl ANAESTHETIC = new Intl("anaesthetic [fr:anesthsique]");
    public static final Intl ANALGESIC = new Intl("analgesic [fr:analgsique]");
    public static final Intl ANTACID = new Intl("antacid [fr:antiacide]");
    public static final Intl ANTHELMINTHIC = new Intl("anthelminthic [fr:anthelminthique]");
    public static final Intl ANTIANAEMIC = new Intl("antianaemic [fr:anti-anmique]");
    public static final Intl ANTIANAPHYLACTIC = new Intl("antianaphylactic [fr:anti-anaphylactique]");
    public static final Intl ANTIANGINAL = new Intl("antianginal [fr:anti-angineux]");
    public static final Intl ANTIBACTERIAL = new Intl("antibacterial [fr:antibactrien]");
    public static final Intl ANTICHOLINERGIC = new Intl("anticholinergic [fr:anticholinergique]");
    public static final Intl ANTICOAGULANT = new Intl("anticoagulant [fr:anticoagulant]");
    public static final Intl ANTICONVULSANT = new Intl("anticonvulsant [fr:anticonvulsivant]");
    public static final Intl ANTIDEPRESSANT = new Intl("antidepressant [fr:antidpresseur]");
    public static final Intl ANTIDIABETIC = new Intl("antidiabetic [fr:antidiabtique]");
    public static final Intl ANTIDIARRHOEAL = new Intl("antidiarrhoeal [fr:antidiarrhique]");
    public static final Intl ANTIEMETIC = new Intl("antiemetic [fr:antimtique]");
    public static final Intl ANTIEPILEPTIC = new Intl("antiepileptic [fr:antipileptique]");
    public static final Intl ANTIFIBRINOLYTIC = new Intl("antifibrinolytic [fr:antifibrinolytique]");
    public static final Intl ANTIFUNGAL = new Intl("antifungal [fr:antifongique]");
    public static final Intl ANTIHISTAMINE = new Intl("antihistamine [fr:antihistaminique]");
    public static final Intl ANTIHYPERTENSIVE = new Intl("antihypertensive [fr:antihypertenseur]");
    public static final Intl ANTILEPROTIC = new Intl("antileprotic [fr:antileprotique]");
    public static final Intl ANTIMALARIAL = new Intl("antimalarial [fr:antipaludique]");
    public static final Intl ANTIOXYTOCIC = new Intl("antioxytocic [fr:antioxytocique]");
    public static final Intl ANTIPARKINSONIAN = new Intl("antiparkinsonian [fr:antiparkinsonien]");
    public static final Intl ANTIPROTOZOAL = new Intl("antiprotozoal [fr:antiprotozoaire]");
    public static final Intl ANTIPROTOZOAL_FOR_SLEEPING_SICKNESS = new Intl("antiprotozoal (for sleeping sickness) [fr:antiprotozoaire (pour la maladie du sommeil)]");
    public static final Intl ANTIPRURITIC = new Intl("antipruritic [fr:antiprurigineux]");
    public static final Intl ANTIPSYCHOTIC = new Intl("antipsychotic [fr:antipsychotique]");
    public static final Intl ANTIPYRETIC = new Intl("antipyretic [fr:antipyrtique]");
    public static final Intl ANTIRETROVIRAL = new Intl("antiretroviral [fr:antirtroviral]");
    public static final Intl ANTISEPTIC = new Intl("antiseptic [fr:antiseptique]");
    public static final Intl ANTISPASMODIC = new Intl("antispasmodic [fr:antispasmodique]");
    public static final Intl ANTITUBERCULAR = new Intl("antitubercular [fr:antituberculeux]");
    public static final Intl ANTIVIRAL = new Intl("antiviral [fr:antiviral]");
    public static final Intl ANTIVIRAL_FOR_HPV = new Intl("antiviral (for HPV) [fr:antiviral (pour le VPH)]");
    public static final Intl BETA_BLOCKER = new Intl("beta blocker [fr:bta-bloquant]");
    public static final Intl BRONCHODILATOR = new Intl("bronchodilator [fr:bronchodilatateur]");
    public static final Intl CARDIOTONIC = new Intl("cardiotonic [fr:cardiotonique]");
    public static final Intl CONTRACEPTIVE = new Intl("contraceptive [fr:contraceptif]");
    public static final Intl CORTICOSTEROID = new Intl("corticosteroid [fr:corticostrode]");
    public static final Intl DIAGNOSTIC_STAINING_AGENT = new Intl("diagnostic staining agent [fr:agent de coloration diagnostique]");
    public static final Intl DISINFECTANT = new Intl("disinfectant [fr:dsinfectant]");
    public static final Intl DIURETIC = new Intl("diuretic [fr:diurtique]");
    public static final Intl EXPERIMENTAL_EBOLA_TREATMENT = new Intl("experimental Ebola treatment [fr:traitement exprimental contre Ebola]");
    public static final Intl EXPERIMENTAL_EBOLA_VACCINE = new Intl("experimental Ebola vaccine [fr:vaccin exprimental contre Ebola]");
    public static final Intl FLUID_REPLACER = new Intl("fluid replacer [fr:substitut fluide]");
    public static final Intl HEPARIN_ANTIDOTE = new Intl("heparin antidote [fr:antidote  l'hparine]");
    public static final Intl INSECTICIDE = new Intl("insecticide [fr:insecticide]");
    public static final Intl INSECTICIDE_FOR_LICE = new Intl("insecticide (for lice) [fr:insecticide (pour les poux)]");
    public static final Intl INSECTICIDE_FOR_SCABIES = new Intl("insecticide (for scabies) [fr:insecticide (pour la gale)]");
    public static final Intl LACTATION_INHIBITOR = new Intl("lactation inhibitor [fr:inhibiteur de la lactation]");
    public static final Intl LAXATIVE = new Intl("laxative [fr:laxatif]");
    public static final Intl MIOTIC = new Intl("miotic [fr:miotique]");
    public static final Intl OPIOID_ANALGESIC = new Intl("opioid analgesic [fr:analgsique opiode]");
    public static final Intl OPIOID_ANTAGONIST = new Intl("opioid antagonist [fr:antagoniste des opiodes]");
    public static final Intl OXYTOCIC = new Intl("oxytocic [fr:ocytocique]");
    public static final Intl PLASMA_SUBSTITUTE = new Intl("plasma substitute [fr:substitut de plasma]");
    public static final Intl SEDATIVE = new Intl("sedative [fr:sedatif]");
    public static final Intl SKIN_PROTECTOR = new Intl("skin protector [fr:protecteur de la peau]");
    public static final Intl SUPPLEMENT = new Intl("supplement [fr:supplment]");
    public static final Intl VACCINE = new Intl("vaccine [fr:vaccin]");


    // === Style conventions for medication names ====
    //
    // The medication name consists of a title-cased part followed optionally
    // by a comma and a lower-cased part.
    //   - A good test for the title-cased part is that it should fill the blank
    //     in the sentence: "The active ingredient in this drug is ______."
    //   - The title-cased part is the complete chemical name and should be a
    //     meaningful noun phrase on its own (e.g. "Ascorbic Acid", not
    //     "Ascorbic acid"; "Ferrous Salts", not "Ferrous salts")
    //   - When medications are combined, join them with a slash (e.g.
    //     "Artesunate/Amodiaquine", not "Artesunate + Amodiaquine")
    //   - Hyphenate the prefix "Co-" in names of combination medicines
    //     (e.g. "Co-amoxiclav", not "Coamoxiclav")
    //   - Do not capitalize immediately after a hyphen (e.g. "Co-artemether",
    //     not "Co-Artemether")
    //   - The lower-cased part describes the concentration, forumlation, or
    //     application (e.g. "Diazepam, solution", not "Diazepam Solution";
    //     "Morphine, immediate-release", not "Morphine Immediate-Release")
    //   - The concentration comes first, immediately after the comma (e.g.
    //     "Glucose, 50%" not "Glucose 50%"; "Permethrin, 1% lotion", not
    //     "Permethrin Lotion 1%" or "Permethrin 1%, lotion")

    public static List<Med> MEDS = deduplicate(

        // === MSF Essential Drugs, 2016 edition, by Sophie Pilon

        new Med("Abacavir", "ABC").caption(ANTIRETROVIRAL),
        // Oral drugs
        new Med("Abacavir", "ABC").caption(ANTIRETROVIRAL),
        new Med("Acetylsalicylic Acid", "Aspirin", "ASA").caption(ANALGESIC, ANTIPYRETIC),
        new Med("Aciclovir", "Acyclovir").caption(ANTIVIRAL),
        new Med("Activated Charcoal").caption(ADSORBENT),
        new Med("Albendazole").caption(ANTHELMINTHIC),
        new Med("Aluminium Hydroxide").caption(ANTACID),
        new Med("Amitriptyline").caption(ANTIDEPRESSANT),
        new Med("Amlodipine").caption(ANTIHYPERTENSIVE),
        // ! new Med("Amodiaquine").caption(AQ),
        new Med("Amoxicillin").caption(ANTIBACTERIAL),
        // ! new Med("Artesunate").caption(AS),
        new Med("Artesunate/Amodiaquine", "AS/AQ").caption(ANTIMALARIAL),
        new Med("Artesunate/Sulfadoxine/Pyrimethamine", "AS/SP").caption(ANTIMALARIAL),
        new Med("Ascorbic Acid", "Vitamin C").caption(SUPPLEMENT),
        new Med("Atazanavir", "ATV").caption(ANTIRETROVIRAL),
        new Med("Azithromycin").caption(ANTIBACTERIAL),
        new Med("Beclometasone, aerosol").caption(CORTICOSTEROID),
        new Med("Biperiden").caption(ANTICHOLINERGIC),
        new Med("Bisacodyl").caption(LAXATIVE),
        new Med("Bisoprolol").caption(BETA_BLOCKER),
        new Med("Cabergoline").caption(LACTATION_INHIBITOR),
        new Med("Calcium Folinate", "Folinic Acid").caption(),
        new Med("Carbamazepine").caption(ANTIEPILEPTIC),
        new Med("Cefalexin").caption(ANTIBACTERIAL),
        new Med("Cefixime").caption(ANTIBACTERIAL),
        new Med("Chloramphenicol").caption(ANTIBACTERIAL),
        new Med("Chloroquine Phosphate").caption(ANTIMALARIAL),
        new Med("Chloroquine Sulfate").caption(ANTIMALARIAL),
        new Med("Chlorphenamine", "Chlorpheniramine").caption(ANTIHISTAMINE),
        new Med("Chlorpromazine").caption(ANTIPSYCHOTIC),
        new Med("Cimetidine").caption(ANTACID),
        new Med("Ciprofloxacin").caption(ANTIBACTERIAL),
        new Med("Clindamycin").caption(ANTIBACTERIAL),
        new Med("Clomipramine").caption(ANTIDEPRESSANT),
        new Med("Cloxacillin").caption(ANTIBACTERIAL),
        new Med("Co-amoxiclav", "Amoxicillin/Clavulanic Acid").caption(ANTIBACTERIAL),
        new Med("Co-artemether", "Artemether/Lumefantrine").caption(ANTIMALARIAL),
        new Med("Codeine").caption(OPIOID_ANALGESIC),
        new Med("Colecalciferol", "Vitamin D3").caption(SUPPLEMENT),
        new Med("Co-trimoxazole", "Sulfamethoxazole/Trimethoprim", "SMX/TMP").caption(ANTIBACTERIAL),
        new Med("Dapsone").caption(ANTIBACTERIAL, ANTILEPROTIC),
        new Med("Darunavir", "DRV").caption(ANTIRETROVIRAL),
        new Med("Desogestrel").caption(CONTRACEPTIVE),
        new Med("Diazepam").caption(SEDATIVE, ANTICONVULSANT),
        new Med("Diethylcarbamazine").caption(ANTHELMINTHIC),
        new Med("Digoxin").caption(CARDIOTONIC),
        new Med("Dihydroartemisinin/Piperaquine", "DHA/PPQ").caption(ANTIMALARIAL),
        // ! new Med("Dipyrone"),
        new Med("Dolutegravir", "DTG").caption(ANTIRETROVIRAL),
        new Med("Doxycycline").caption(ANTIBACTERIAL),
        new Med("Efavirenz", "EFV", "EFZ").caption(ANTIRETROVIRAL),
        new Med("Enalapril").caption(ANTIHYPERTENSIVE),
        new Med("Ergocalciferol", "Vitamin D2").caption(SUPPLEMENT),
        new Med("Erythromycin").caption(ANTIBACTERIAL),
        new Med("Ethambutol",  "E").caption(ANTITUBERCULAR, ANTIBACTERIAL),
        new Med("Ethinylestradiol/Levonorgestrel").caption(CONTRACEPTIVE),
        new Med("Ferrous Salts").caption(ANTIANAEMIC),
        new Med("Ferrous Salts/Folic Acid"),
        new Med("Fluconazole").caption(ANTIFUNGAL),
        new Med("Flucytosine").caption(ANTIFUNGAL),
        new Med("Fluoxetine").caption(ANTIDEPRESSANT),
        new Med("Folic Acid", "Vitamin B9").caption(ANTIANAEMIC),
        new Med("Fosfomycin Trometamol").caption(ANTIBACTERIAL),
        new Med("Furosemide").caption(DIURETIC),
        new Med("Glibenclamide").caption(ANTIDIABETIC),
        new Med("Gliclazide").caption(ANTIDIABETIC),
        new Med("Glyceryl Trinitrate", "Nitroglycerin", "Trinitrin").caption(ANTIANGINAL),
        new Med("Griseofulvin").caption(ANTIFUNGAL),
        new Med("Haloperidol").caption(ANTIPSYCHOTIC),
        new Med("Hydrochlorothiazide").caption(DIURETIC),
        new Med("Hydroxyzine").caption(ANTIHISTAMINE),
        new Med("Hyoscine Butylbromide", "Butylscopolamine").caption(ANTISPASMODIC),
        new Med("Ibuprofen").caption(ANALGESIC, ANTIPYRETIC),
        new Med("Iodized Oil").caption(SUPPLEMENT),
        new Med("Ipratropium Bromide, nebuliser solution").caption(BRONCHODILATOR),
        new Med("Isoniazid", "H").caption(ANTITUBERCULAR),
        new Med("Isosorbide Dinitrate").caption(ANTIANGINAL),
        new Med("Itraconazole").caption(ANTIFUNGAL),
        new Med("Ivermectin").caption(ANTHELMINTHIC),
        new Med("Labetalol").caption(BETA_BLOCKER),
        new Med("Lactulose").caption(LAXATIVE),
        new Med("Lamivudine", "3TC").caption(ANTIRETROVIRAL),
        new Med("Levodopa/Carbidopa", "Co-careldopa").caption(ANTIPARKINSONIAN),
        new Med("Levonorgestrel").caption(CONTRACEPTIVE),
        new Med("Loperamide").caption(ANTIDIARRHOEAL),
        new Med("Lopinavir/Ritonavir", "LPV/R").caption(ANTIRETROVIRAL),
        new Med("Loratadine").caption(ANTIHISTAMINE),
        new Med("Mebendazole").caption(ANTHELMINTHIC),
        new Med("Mefloquine", "MQ").caption(ANTIMALARIAL),
        // ! new Med("Metamizole"),
        new Med("Metformin").caption(ANTIDIABETIC),
        new Med("Methyldopa").caption(ANTIHYPERTENSIVE),
        new Med("Metoclopramide").caption(ANTIEMETIC),
        new Med("Metronidazole").caption(ANTIBACTERIAL, ANTIPROTOZOAL),
        new Med("Miconazole").caption(ANTIFUNGAL),
        new Med("Mifepristone", "RU-486").caption(ABORTIFACIENT),
        new Med("Misoprostol").caption(OXYTOCIC),
        new Med("Morphine, immediate-release", "MIR").caption(OPIOID_ANALGESIC),
        new Med("Morphine, sustained-release", "MSR").caption(OPIOID_ANALGESIC),
        new Med("Multivitamins", "Vitamin B complex").caption(SUPPLEMENT),
        new Med("Nevirapine", "NVP").caption(ANTIRETROVIRAL),
        new Med("Niclosamide").caption(ANTHELMINTHIC),
        new Med("Nicotinamide", "Vitamin PP", "Vitamin B3").caption(SUPPLEMENT),
        new Med("Nifedipine").caption(ANTIHYPERTENSIVE, ANTIOXYTOCIC),
        new Med("Nitrofurantoin").caption(ANTIBACTERIAL),
        // ! new Med("Noramidopyrine"),
        new Med("Nystatin").caption(ANTIFUNGAL),
        new Med("Olanzapine").caption(ANTIPSYCHOTIC),
        new Med("Omeprazole").caption(ANTACID),
        new Med("Oral Rehydration Salts", "ORS").caption(FLUID_REPLACER),
        new Med("Paracetamol", "Acetaminophen").caption(ANALGESIC, ANTIPYRETIC),
        new Med("Paroxetine").caption(ANTIDEPRESSANT),
        new Med("Phenobarbital").caption(SEDATIVE, ANTICONVULSANT),
        new Med("Phenoxymethylpenicillin", "Penicillin V").caption(ANTIBACTERIAL),
        new Med("Phenytoin").caption(ANTICONVULSANT),
        new Med("Potassium Chloride, immediate-release").caption(SUPPLEMENT),
        new Med("Potassium Chloride, sustained-release").caption(SUPPLEMENT),
        new Med("Praziquantel").caption(ANTHELMINTHIC),
        new Med("Prednisolone").caption(CORTICOSTEROID),
        new Med("Prednisone").caption(CORTICOSTEROID),
        new Med("Promethazine").caption(ANTIHISTAMINE),
        new Med("Pyrantel").caption(ANTHELMINTHIC),
        new Med("Pyrazinamide", "Z").caption(ANTITUBERCULAR),
        new Med("Pyridoxine", "Vitamin B6").caption(SUPPLEMENT),
        new Med("Pyrimethamine").caption(ANTIPROTOZOAL),
        new Med("Quinine").caption(ANTIMALARIAL),
        new Med("Resomal", "Rehydration Solution for Malnutrition").caption(),
        new Med("Retinol", "Vitamin A").caption(SUPPLEMENT),
        new Med("Rifampicin", "R").caption(ANTITUBERCULAR),
        new Med("Risperidone").caption(ANTIPSYCHOTIC),
        new Med("Ritonavir", "RTV").caption(ANTIRETROVIRAL),
        // ! new Med("Salbutamol").caption(ALBUTEROL),
        new Med("Salbutamol, aerosol", "Albuterol").caption(BRONCHODILATOR),
        new Med("Salbutamol, nebuliser solution", "Albuterol").caption(BRONCHODILATOR),
        new Med("Sertraline").caption(ANTIDEPRESSANT),
        new Med("Spironolactone").caption(DIURETIC),
        new Med("Sulfadiazine").caption(ANTIBACTERIAL),
        new Med("Sulfadoxine/Pyrimethamine", "SP").caption(ANTIMALARIAL),
        new Med("Tenofovir Disoproxil Fumarate", "TDF").caption(ANTIRETROVIRAL),
        new Med("Thiamine", "Vitamin B1").caption(SUPPLEMENT),
        new Med("Tinidazole").caption(ANTIPROTOZOAL, ANTIBACTERIAL),
        new Med("Tramadol").caption(OPIOID_ANALGESIC),
        new Med("Tranexamic Acid").caption(ANTIFIBRINOLYTIC),
        new Med("Triclabendazole").caption(ANTHELMINTHIC),
        new Med("Trihexyphenidyl").caption(ANTIPARKINSONIAN),
        new Med("Ulipristal").caption(CONTRACEPTIVE),
        new Med("Valproic Acid", "Sodium Valproate").caption(ANTIEPILEPTIC),
        new Med("Vitamin B6").caption(SUPPLEMENT),
        new Med("Zidovudine", "AZT", "ZDV").caption(ANTIRETROVIRAL),
        new Med("Zidovudine/Lamivudine", "AZT/3TC").caption(ANTIRETROVIRAL),
        new Med("Zidovudine/Lamivudine/Nevirapine", "AZT/3TC/NVP").caption(ANTIRETROVIRAL),
        new Med("Zinc Sulfate").caption(SUPPLEMENT),

        // Injectable drugs
        new Med("Amphotericin B, conventional").caption(ANTIFUNGAL),
        new Med("Amphotericin B, liposomal").caption(ANTIFUNGAL),
        new Med("Ampicillin").caption(ANTIBACTERIAL),
        // ! new Med("Artemether"),
        new Med("Artesunate").caption(ANTIMALARIAL),
        new Med("Atropine").caption(ANTISPASMODIC),
        new Med("Benzathine Benzylpenicillin").caption(ANTIBACTERIAL),
        new Med("Benzylpenicillin", "Penicillin G").caption(ANTIBACTERIAL),
        new Med("Calcium Gluconate").caption(SUPPLEMENT),
        new Med("Cefotaxime").caption(ANTIBACTERIAL),
        new Med("Ceftriaxone").caption(ANTIBACTERIAL),
        new Med("Chloramphenicol").caption(ANTIBACTERIAL),
        // ! new Med("Long-Acting Oily Chloramphenicol"),
        new Med("Chlorpromazine").caption(ANTIPSYCHOTIC),
        new Med("Clindamycin").caption(ANTIBACTERIAL),
        new Med("Cloxacillin").caption(ANTIBACTERIAL),
        new Med("Co-amoxiclav", "Amoxicillin/Clavulanic Acid").caption(ANTIBACTERIAL),
        new Med("Dexamethasone").caption(CORTICOSTEROID),
        new Med("Diazepam, emulsion").caption(SEDATIVE, ANTICONVULSANT),
        new Med("Diazepam, solution").caption(SEDATIVE, ANTICONVULSANT),
        new Med("Diclofenac").caption(ANALGESIC, ANTIPYRETIC),
        new Med("Digoxin").caption(CARDIOTONIC),
        // ! new Med("Dipyrone"),
        new Med("Eflornithine").caption(ANTIPROTOZOAL_FOR_SLEEPING_SICKNESS),
        new Med("Epinephrine", "EPN", "Adrenaline").caption(ANTIANAPHYLACTIC),
        new Med("Etonogestrel, subdermal implant").caption(CONTRACEPTIVE),
        new Med("Fluconazole").caption(ANTIFUNGAL),
        new Med("Furosemide").caption(DIURETIC),
        new Med("Gentamicin").caption(ANTIBACTERIAL),
        new Med("Glucose, 50%", "Dextrose, 50%").caption(),
        new Med("Haloperidol").caption(ANTIPSYCHOTIC),
        new Med("Haloperidol Decanoate").caption(ANTIPSYCHOTIC),
        new Med("Heparin").caption(ANTICOAGULANT),
        new Med("Hydralazine").caption(ANTIHYPERTENSIVE),
        new Med("Hydrocortisone").caption(CORTICOSTEROID),
        new Med("Hyoscine Butylbromide", "Butylscopolamine").caption(ANTISPASMODIC),
        new Med("Insulin, biphasic"),
        new Med("Insulin, intermediate-acting"),
        new Med("Insulin, long-acting"),
        new Med("Insulin, short-acting"),
        new Med("Ketamine").caption(ANAESTHETIC),
        new Med("Labetalol").caption(BETA_BLOCKER),
        new Med("Levonorgestrel, subdermal implant").caption(CONTRACEPTIVE),
        new Med("Lidocaine", "Lignocaine").caption(ANAESTHETIC),
        new Med("Magnesium Sulfate", "MgSO4").caption(ANTICONVULSANT),
        new Med("Medroxyprogesterone").caption(CONTRACEPTIVE),
        new Med("Melarsoprol").caption(ANTIPROTOZOAL_FOR_SLEEPING_SICKNESS),
        // ! new Med("Metamizole"),
        new Med("Methylergometrine").caption(OXYTOCIC),
        new Med("Metoclopramide").caption(ANTIEMETIC),
        new Med("Metronidazole").caption(ANTIPROTOZOAL, ANTIBACTERIAL),
        new Med("Morphine").caption(OPIOID_ANALGESIC),
        new Med("Naloxone").caption(OPIOID_ANTAGONIST),
        // ! new Med("Noramidopyrine"),
        new Med("Omeprazole").caption(ANTACID),
        new Med("Ondansetron").caption(ANTIEMETIC),
        new Med("Oxytocin").caption(OXYTOCIC),
        new Med("Paracetamol", "Acetaminophen").caption(ANALGESIC, ANTIPYRETIC),
        new Med("Penicillin G").caption(ANTIBACTERIAL),
        new Med("Pentamidine").caption(ANTIPROTOZOAL),
        new Med("Phenobarbital").caption(ANTICONVULSANT),
        new Med("Phytomenadione", "Vitamin K1").caption(SUPPLEMENT),
        new Med("Potassium Chloride, 10%", "KCl, 10%").caption(),
        new Med("Promethazine").caption(ANTIHISTAMINE, ANTIEMETIC),
        new Med("Protamine").caption(HEPARIN_ANTIDOTE),
        new Med("Quinine").caption(ANTIMALARIAL),
        new Med("Salbutamol", "Albuterol").caption(BRONCHODILATOR),
        new Med("Sodium Bicarbonate, 8.4%"),
        new Med("Spectinomycin").caption(ANTIBACTERIAL),
        new Med("Streptomycin", "S").caption(ANTIBACTERIAL),
        new Med("Suramin").caption(ANTIPROTOZOAL_FOR_SLEEPING_SICKNESS),
        new Med("Thiamine", "Vitamin B1").caption(SUPPLEMENT),
        new Med("Tramadol").caption(OPIOID_ANALGESIC),
        new Med("Tranexamic Acid").caption(ANTIFIBRINOLYTIC),

        // Infusion fluids
        new Med("Glucose, 5%", "Dextrose, 5%").caption(),
        new Med("Glucose, 10%", "Dextrose, 10%").caption(),
        new Med("Modified Fluid Gelatin").caption(PLASMA_SUBSTITUTE),
        new Med("Polygeline").caption(PLASMA_SUBSTITUTE),
        new Med("Ringer Lactate").caption(FLUID_REPLACER),
        new Med("RLG 5% mix", "Ringer Lactate/Glucose, 5%").caption(FLUID_REPLACER),
        new Med("RLG 10% mix", "Ringer Lactate/Glucose, 10%").caption(FLUID_REPLACER),
        new Med("Sodium Chloride, 0.9%", "NaCl").caption(FLUID_REPLACER),

        // Vaccines, immunoglobulins, and antisera
        new Med("Oral Cholera Vaccine O1+O139").caption(VACCINE),
        new Med("Diphtheria/Tetanus/Pertussis Vaccine", "DTP").caption(VACCINE),
        new Med("Diphtheria/Tetanus/Pertussis/Hepatitis B Vaccine").caption(VACCINE),
        new Med("Diphtheria/Tetanus/Pertussis/Hepatitis B/Hib Vaccine").caption(VACCINE),
        new Med("Hepatitis B Vaccine").caption(VACCINE),
        new Med("Japanese Encephalitis Vaccine").caption(VACCINE),
        new Med("Measles Vaccine").caption(VACCINE),
        new Med("Meningococcal A Conjugate Vaccine").caption(VACCINE),
        new Med("Meningococcal A+C Vaccine").caption(VACCINE),
        new Med("Meningococcal A+C+W135 Vaccine").caption(VACCINE),
        new Med("Human Papillomavirus Vaccine", "HPV").caption(VACCINE),
        new Med("Pneumococcal Conjugate Vaccine", "PCV").caption(VACCINE),
        new Med("Inactivated Poliomyelitis Vaccine", "IPV").caption(VACCINE),
        new Med("Oral Poliomyelitis Vaccine", "OPV").caption(VACCINE),
        new Med("Human Rabies Immunoglobulin", "HRIG").caption(),
        new Med("Rabies Vaccine").caption(VACCINE),
        new Med("Oral Rotavirus Vaccine").caption(VACCINE),
        new Med("Human Tetanus Immunoglobulin", "HTIG").caption(),
        new Med("Tetanus Vaccine", "TT").caption(VACCINE),
        new Med("Tetanus-Diphtheria Vaccine", "Td").caption(VACCINE),
        // ! new Med("Tetanus Antitoxin, Equine"),
        new Med("Tuberculosis Vaccine", "BCG Vaccine").caption(VACCINE),
        new Med("Typhoid Conjugate Vaccine", "TCV").caption(VACCINE),
        new Med("Yellow Fever Vaccine").caption(VACCINE),

        // Drugs for external use, antiseptics, and disinfectants
        new Med("Aciclovir, eye ointment", "Acyclovir").caption(ANTIVIRAL),
        new Med("Alcohol-Based Hand Rub").caption(ANTISEPTIC),
        new Med("Artesunate, rectal").caption(ANTIMALARIAL),
        new Med("Benzoic Acid/Salicylic Acid ointment", "Whitfield's ointment").caption(ANTIFUNGAL),
        new Med("Benzyl Benzoate, lotion").caption(INSECTICIDE_FOR_SCABIES),
        new Med("Calamine, lotion").caption(ANTIPRURITIC),
        new Med("Chlorhexidine, 5% solution").caption(ANTISEPTIC),
        new Med("Chlorhexidine, 7.1% dermal gel").caption(ANTISEPTIC),
        new Med("Chlorhexidine, 0.2% mouthwash").caption(ANTISEPTIC),
        new Med("Ciprofloxacin, ear drops").caption(ANTIBACTERIAL),
        new Med("Clotrimazole, vaginal tablet").caption(ANTIFUNGAL),
        new Med("Dinoprostone, vaginal gel").caption(OXYTOCIC),
        new Med("Ethyl Alcohol", "Ethanol").caption(ANTISEPTIC, DISINFECTANT),
        new Med("Fluorescein, eye drops").caption(DIAGNOSTIC_STAINING_AGENT),
        new Med("Hydrocortisone, cream").caption(CORTICOSTEROID),
        new Med("Malathion, lotion").caption(INSECTICIDE_FOR_LICE),
        // ! new Med("Methylrosanilinium Chloride", "GV", "Crystal violet").caption(GENTIAN VIOLET),
        new Med("Miconazole, cream").caption(ANTIFUNGAL),
        new Med("Mupirocin, ointment").caption(ANTIBACTERIAL),
        new Med("Nystatin, vaginal tablet").caption(ANTIFUNGAL),
        new Med("Oxybuprocaine, eye drops").caption(ANAESTHETIC),
        new Med("Permethrin, 1% lotion").caption(INSECTICIDE_FOR_LICE),
        new Med("Permethrin, 5% lotion").caption(INSECTICIDE_FOR_SCABIES),
        new Med("Pilocarpine, eye drops").caption(MIOTIC),
        new Med("Podophyllotoxin, 0.5% solution").caption(ANTIVIRAL_FOR_HPV),
        new Med("Podophyllum Resin, solution").caption(ANTIVIRAL_FOR_HPV),
        new Med("Povidone Iodine, aqueous solution", "Polyvidone iodine", "PVI").caption(ANTISEPTIC, DISINFECTANT),
        new Med("Povidone Iodine, scrub solution", "Polyvidone iodine", "PVI").caption(ANTISEPTIC, DISINFECTANT),
        new Med("Silver Sulfadiazine, cream").caption(ANTIBACTERIAL),
        new Med("Sodium Dichloroisocyanurate", "NaDCC").caption(DISINFECTANT),
        new Med("Calcium Hypochlorite", "HTH").caption(DISINFECTANT),
        new Med("Sodium Hypochlorite, solution", "Bleach").caption(DISINFECTANT),
        new Med("Chlorinated Lime, powder").caption(DISINFECTANT),
        new Med("Tetracycline, eye ointment").caption(ANTIBACTERIAL),
        new Med("Zinc Oxide, ointment").caption(SKIN_PROTECTOR),

        // ==== Additional Ebola treatments and vaccines

        // Experimental Ebola treatments
        new Med("Amodiaquine").caption(EXPERIMENTAL_EBOLA_TREATMENT),
        new Med("Favipiravir").caption(EXPERIMENTAL_EBOLA_TREATMENT),
        new Med("Remdesivir").caption(EXPERIMENTAL_EBOLA_TREATMENT),
        new Med("ZMapp").caption(EXPERIMENTAL_EBOLA_TREATMENT),

        // Experimental Ebola vaccines
        new Med("cAd3-EBOZ").caption(EXPERIMENTAL_EBOLA_VACCINE),
        new Med("VSV-EBOV").caption(EXPERIMENTAL_EBOLA_VACCINE),
        new Med("Ad5-EBOV").caption(EXPERIMENTAL_EBOLA_VACCINE),
        new Med("Ad26-ZEBOV/MVA-BN").caption(EXPERIMENTAL_EBOLA_VACCINE),
        new Med("rVSV-ZEBOV").caption(EXPERIMENTAL_EBOLA_VACCINE)
    );

    public static List<Med> deduplicate(Med... meds) {
        List<Med> result = new ArrayList<>();
        Set<String> names = new HashSet<>();
        for (Med med : meds) {
            if (!names.contains(normalize(med.name))) {
                names.add(normalize(med.name));
                result.add(med);
            }
        }
        Collections.sort(result, (a, b) -> a.name.compareToIgnoreCase(b.name));
        return result;
    }

    public List<Med> suggestCompletions(CharSequence constraint) {
        String[] searchKeys = normalize(constraint).trim().split(" ");
        for (int i = 0; i < searchKeys.length; i++) {
            searchKeys[i] = " " + searchKeys[i];
        }

        List<Med> results = new ArrayList<>();
        for (Med med : MEDS) {
            // Look for words matching the words in the input as prefixes.
            int score = 0;
            for (String searchKey : searchKeys) {
                score += med.filterTarget.contains(searchKey) ? 1 : 0;
            }
            if (score == searchKeys.length) {
                results.add(med);
                continue;
            }

            if (searchKeys.length == 1) {
                // Look for words matching the letters in the input as initials.
                score = 0;
                char[] initials = searchKeys[0].trim().toCharArray();
                for (char ch : initials) {
                    score += med.filterTarget.contains(" " + ch) ? 1 : 0;
                }
                if (score == initials.length) {
                    results.add(med);
                }
            }
        }
        return results;
    }

    private static String normalize(CharSequence name) {
        return name.toString().toLowerCase().replaceAll("[^a-z0-9]+", " ");
    }

    public static class Med {
        String name;
        Intl[] captions;
        String[] aliases;
        String label;
        String filterTarget;

        public Med(String name, String... aliases) {
            this.name = name;
            this.captions = new Intl[0];
            this.aliases = aliases;
            label = name;
            filterTarget = " " + name.toLowerCase();
            for (String alias : aliases) {
                label += " (" + alias + ")";
                filterTarget += " " + alias;
            }
            String collapsed = filterTarget.replaceAll("[^a-z0-9]+", "");
            filterTarget = normalize(" " + filterTarget + " " + collapsed + " ");
        }

        public Med caption(Intl... captions) {
            this.captions = captions;
            return this;
        }

        public void showInView(View itemView) {
            Locale locale = Locale.getDefault();
            Utils.setText(itemView, R.id.label, label);
            String caption = "";
            for (Intl intl : captions) {
                if (!caption.isEmpty()) caption += ", ";
                caption += intl.loc(locale);
            }
            Utils.setText(itemView, R.id.caption, caption);
        }

        public @NonNull String getValue() {
            return name;
        }
    }

    public static class Inventory {
        Map<String, List<Med>> categories;  // oral, injectable, infusion, etc.
    }

    // Examples of combined medications:

    // name = "Amoxicillin/Clavulanic acid" (separated by slash without spaces)
    // aliases = {"Co-amoxiclav"}
    // code = "DORAAMOC4S5"
    // formulation = "400 mg/57 mg per 5 ml, powd. oral susp."
    // dosageUnit = "ml"

    // code = "DORAARLU2TD1"
    // name = "Artemether/Lumefantrine"
    // aliases = {"AL", "Co-artemether"}
    // formulation = "20 mg/120 mg, blister of 12 disp. tab."
    // dosageUnit = "tablet"


}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models;

import com.google.common.collect.ImmutableMap;

import org.projectbuendia.client.resolvables.ResStatus;
import org.projectbuendia.client.utils.Utils;

import java.util.Map;

/**
 * Defines hardcoded concept ids expected to exist on the OpenMRS server. Over time, values in this
 * file should be phased out and replaced with modular configuration, either on the server or the
 * client.
 */
public class ConceptUuids {
    // ==== UUIDs used for special treatment in the UI.

    private static String toUuid(int id) {
        return Utils.expandUuid(id);
    }

    // Date used for calculating "Day 1", "Day 2", etc. table headings.
    public static final String ADMISSION_DATETIME_UUID = toUuid(8001640);

    // Concepts whose values are prefilled in forms.
    public static final String PREGNANCY_UUID = toUuid(2005272);
    public static final String IV_UUID = toUuid(2900012);

    // Patient colour category.  Used to colour-code patient ID chips in patient lists.
    public static final String CATEGORY_UUID = toUuid(2900019);
    public static final String CATEGORY_GREEN_UUID = toUuid(4900041);
    public static final String CATEGORY_YELLOW_UUID = toUuid(4900042);
    public static final String CATEGORY_RED_UUID = toUuid(4900043);

    public static final String[] GENERAL_CONDITION_UUIDS = new String[] {
        CATEGORY_GREEN_UUID,
        CATEGORY_YELLOW_UUID,
        CATEGORY_RED_UUID
    };


    // ==== Concept UUIDs for observation-like events stored as observations.

    // This is a custom Buendia-specific concept to indicate that a treatment order
    // has been carried out (e.g. a prescribed medication has been administered).
    // The timestamp of an observation for this concept should be the time the order
    // was executed, and the value of the observation should be the UUID of the order.
    public static final String ORDER_EXECUTED_UUID = "buendia_concept_order_executed";

    // This is a custom Buendia-specific concept to indicate where a patient is
    // placed, as a string consisting of a Location UUID, a slash, and a bed number.
    public static final String PLACEMENT_UUID = "buendia_concept_placement";


    // ==== Pulse; used only for health checks and logging messages to the server.

    public static final String PULSE_UUID = toUuid(5087);


    // ==== UUIDs referenced only for sort ordering.

    public static final String NO_UUID = toUuid(1066);  // answer: no
    public static final String NONE_UUID = toUuid(1107);  // answer: none
    public static final String NORMAL_UUID = toUuid(1115);  // answer: normal
    public static final String SOLID_FOOD_UUID = toUuid(159597);  // answer: patient can eat solid food
    public static final String MILD_UUID = toUuid(1148);  // answer: mild (severity)
    public static final String MODERATE_UUID = toUuid(1499);  // answer: moderate (severity)
    public static final String SEVERE_UUID = toUuid(1500);  // answer: severe
    public static final String YES_UUID = toUuid(1065);  // answer: yes
    public static final String UNKNOWN_UUID = toUuid(1067);  // answer: answer is unknown

    /**
     * A number specifying the ordering of coded values.  These are arranged from least to
     * most severe, or earliest to latest in typical temporal sequence, so that the maximum value
     * in a list of values for a particular concept is the most severe value or latest value.
     */
    private static final Map<String, Integer> CODED_VALUE_ORDERING =
        new ImmutableMap.Builder<String, Integer>()
            .put(ConceptUuids.NO_UUID, -100)
            .put(ConceptUuids.NONE_UUID, -1)
            .put(ConceptUuids.NORMAL_UUID, -1)
            .put(ConceptUuids.SOLID_FOOD_UUID, -1)
            .put(ConceptUuids.MILD_UUID, 1)
            .put(ConceptUuids.MODERATE_UUID, 2)
            .put(ConceptUuids.SEVERE_UUID, 3)
            .put(ConceptUuids.YES_UUID, 100).build();

    public static final int compareUuids(String a, String b) {
        int result = Integer.compare(
            Utils.getOrDefault(CODED_VALUE_ORDERING, a, 0),
            Utils.getOrDefault(CODED_VALUE_ORDERING, b, 0));
        if (result != 0) return result;
        return a.compareTo(b);
    }


    // ==== Boolean interpretation of UUIDs.

    public static final String toUuid(boolean bool) {
        return bool ? YES_UUID : NO_UUID;
    }

    public static final boolean isYes(String uuid) {
        return YES_UUID.equals(uuid);
    }

    public static final boolean isYes(Obs obs) {
        return obs != null && YES_UUID.equals(obs.value);
    }

    public static boolean isNormal(String uuid) {
        return NORMAL_UUID.equals(uuid)
            || NONE_UUID.equals(uuid)
            || NO_UUID.equals(uuid)
            || SOLID_FOOD_UUID.equals(uuid);
    }


    // ==== Mapping of general condition values to ResStatus values.

    public static final Map<String, ResStatus> STATUS_BY_CONDITION_UUID = new ImmutableMap.Builder<String, ResStatus>()
        .put(CATEGORY_GREEN_UUID, ResStatus.WELL)
        .put(CATEGORY_YELLOW_UUID, ResStatus.UNWELL)
        .put(CATEGORY_RED_UUID, ResStatus.CRITICAL)
        .build();

    /** Returns the {@link ResStatus} for the specified condition UUID. */
    public static ResStatus getResStatus(String conditionUuid) {
        return Utils.getOrDefault(STATUS_BY_CONDITION_UUID, conditionUuid, ResStatus.UNKNOWN);
    }

    private ConceptUuids() {
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models.tasks;

import android.content.ContentResolver;

import org.projectbuendia.client.net.Server;

import javax.inject.Singleton;

import dagger.Module;
import dagger.Provides;

/** A Dagger module that provides bindings for a {@link TaskFactory}. */
@Module(complete = false, library = true)
public class TaskModule {
    @Provides
    @Singleton TaskFactory provideAppAsyncTaskFactory(
        Server server,
        ContentResolver contentResolver) {
        return new TaskFactory(server, contentResolver);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models.tasks;

import android.content.ContentResolver;
import android.net.Uri;
import android.os.AsyncTask;

import org.projectbuendia.client.events.CrudEventBus;
import org.projectbuendia.client.filter.db.SimpleSelectionFilter;
import org.projectbuendia.client.json.JsonPatient;
import org.projectbuendia.models.AppModel;
import org.projectbuendia.models.CursorLoader;
import org.projectbuendia.models.Encounter;
import org.projectbuendia.models.Model;
import org.projectbuendia.models.Obs;
import org.projectbuendia.models.Order;
import org.projectbuendia.client.net.Server;

/**
 * An assisted injection factory that creates {@link AsyncTask}s for performing {@link AppModel}
 * operations.
 */
public class TaskFactory {
    private final Server mServer;
    private final ContentResolver mContentResolver;

    public TaskFactory(Server server, ContentResolver contentResolver) {
        mServer = server;
        mContentResolver = contentResolver;
    }

    public AddPatientTask newAddPatientTask(JsonPatient patient, CrudEventBus bus) {
        return new AddPatientTask(this, mServer, mContentResolver, patient, bus);
    }

    public FetchPatientTask newFetchPatientTask(
        String patientId, CrudEventBus bus) {
        return new FetchPatientTask(
            this, mServer, mContentResolver, patientId, bus);
    }

    public DeleteObsTask newDeleteObsTask(CrudEventBus bus, Obs obs) {
        return new DeleteObsTask(this, mServer, mContentResolver, obs, bus);
    }

    public UpdatePatientTask newUpdatePatientTask(JsonPatient patient, CrudEventBus bus) {
        return new UpdatePatientTask(this, mServer, mContentResolver, patient, bus);
    }

    public AddEncounterTask newAddEncounterTask(Encounter encounter, CrudEventBus bus) {
        return new AddEncounterTask(this, mServer, mContentResolver, encounter, bus);
    }

    public AddOrderTask newAddOrderTask(Order order, CrudEventBus bus) {
        return new AddOrderTask(this, mServer, mContentResolver, order, bus);
    }

    public DeleteOrderTask newDeleteOrderTask(String orderUuid, CrudEventBus bus) {
        return new DeleteOrderTask(mServer, mContentResolver, orderUuid, bus);
    }

    public <T extends Model> LoadItemTask<T> newLoadItemTask(
        Uri contentUri,
        String[] projectionColumns,
        SimpleSelectionFilter filter,
        String constraint,
        CursorLoader<T> loader,
        CrudEventBus bus) {
        return new LoadItemTask<>(
            mContentResolver, contentUri, projectionColumns, filter, constraint, loader, bus);
    }

    public DenormalizeObsTask newDenormalizeObsTask(String patientUuid, CrudEventBus bus) {
        return new DenormalizeObsTask(this, mServer, mContentResolver, patientUuid, bus);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models.tasks;

import android.content.ContentResolver;
import android.content.ContentValues;
import android.database.Cursor;
import android.os.AsyncTask;

import com.google.common.collect.ImmutableSet;

import org.projectbuendia.client.events.CrudEventBus;
import org.projectbuendia.client.events.data.ItemLoadFailedEvent;
import org.projectbuendia.client.events.data.ItemLoadedEvent;
import org.projectbuendia.client.events.data.ItemUpdatedEvent;
import org.projectbuendia.client.events.data.PatientUpdateFailedEvent;
import org.projectbuendia.client.filter.db.patient.UuidFilter;
import org.projectbuendia.models.ConceptUuids;
import org.projectbuendia.models.Patient;
import org.projectbuendia.client.net.Server;
import org.projectbuendia.client.providers.Contracts.Observations;
import org.projectbuendia.client.providers.Contracts.Patients;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.util.Set;

public class DenormalizeObsTask extends AsyncTask<Void, Void, PatientUpdateFailedEvent> {
    private static final Logger LOG = Logger.create();
    private final TaskFactory mTaskFactory;
    private final Server mServer;
    private final ContentResolver mContentResolver;
    private final String mPatientUuid;
    private final CrudEventBus mBus;

    private static final String DENORMALIZE_QUERY = ""
        + "UPDATE patients SET %s = ("
        + "    SELECT obs.value"
        + "    FROM observations AS obs"
        + "    WHERE observations.voided IS NOT 1"
        + "        AND observations.patient_uuid = patients.patient_uuid"
        + "        AND observations.concept_uuid = ?"
        + "    ORDER BY observations.encounter_millis DESCENDING"
        + "    LIMIT 1"
        + ") where patients.patient_uuid = ?";

    private static final Set<String> DENORMALIZED_CONCEPTS = ImmutableSet.of(
        ConceptUuids.PREGNANCY_UUID,
        ConceptUuids.PLACEMENT_UUID
    );

    DenormalizeObsTask(
        TaskFactory taskFactory,
        Server server,
        ContentResolver contentResolver,
        String patientUuid,
        CrudEventBus bus) {
        mTaskFactory = taskFactory;
        mServer = server;
        mContentResolver = contentResolver;
        mPatientUuid = patientUuid;
        mBus = bus;
    }

    @Override protected PatientUpdateFailedEvent doInBackground(Void... params) {
        String pregnancyValue = getLatestValue(mPatientUuid, ConceptUuids.PREGNANCY_UUID);
        String placementValue = getLatestValue(mPatientUuid, ConceptUuids.PLACEMENT_UUID);

        LOG.i("Denormalizing observations for patient %s (%s, %s)", mPatientUuid, pregnancyValue, placementValue);
        ContentValues cv = new ContentValues();
        if (pregnancyValue != null) {
            cv.put(Patients.PREGNANCY, ConceptUuids.isYes(pregnancyValue));
        }
        if (placementValue != null) {
            String[] parts = Utils.splitFields(placementValue, "/", 2);
            cv.put(Patients.LOCATION_UUID, parts[0]);
            cv.put(Patients.BED_NUMBER, parts[1]);
        }
        if (cv.size() == 0) return null;  // no update needed

        int count = mContentResolver.update(
            Patients.URI, cv, Patients.UUID + " = ?", new String[] {mPatientUuid}
        );
        if (count == 1) return null;

        // If the patient doesn't exist, that's okay.  It's possible for observations
        // about a patient to arrive before a newly created patient arrives.
        return null;
    }

    private String getLatestValue(String patientUuid, String conceptUuid) {
        try (Cursor cursor = mContentResolver.query(
            Observations.URI, new String[] {Observations.VALUE},
            Observations.PATIENT_UUID + " = ?" +
                " AND " + Observations.CONCEPT_UUID + " = ?" +
                " AND " + Observations.VOIDED + " IS NOT 1",
            new String[] {patientUuid, conceptUuid},
            Observations.MILLIS + " DESC"
        )) {
            return cursor.moveToNext() ? cursor.getString(0) : null;
        }
    }

    @Override protected void onPostExecute(PatientUpdateFailedEvent event) {
        if (event != null) mBus.post(event);
        else {
            mBus.register(new EventSubscriber());
            mTaskFactory.newLoadItemTask(
                Patients.URI, null, new UuidFilter(), mPatientUuid, Patient::load, mBus
            ).execute();
        }
    }

    @SuppressWarnings("unused") // Called by reflection from EventBus.
    private final class EventSubscriber {
        public void onEventMainThread(ItemLoadedEvent<?> event) {
            if (event.item instanceof Patient) {
                mBus.post(new ItemUpdatedEvent<>(mPatientUuid, (Patient) event.item));
                mBus.unregister(this);
            }
        }

        public void onEventMainThread(ItemLoadFailedEvent event) {
            mBus.post(new PatientUpdateFailedEvent(
                PatientUpdateFailedEvent.REASON_CLIENT, new Exception(event.error)));
            mBus.unregister(this);
        }
    }

    public static boolean needsDenormalization(String conceptUuid) {
        return DENORMALIZED_CONCEPTS.contains(conceptUuid);
    }

    public static boolean needsDenormalization(ContentValues[] values) {
        for (ContentValues cv  : values) {
            if (DENORMALIZED_CONCEPTS.contains(
                cv.getAsString(Observations.CONCEPT_UUID))) return true;
        }
        return false;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models.tasks;

import android.content.ContentResolver;
import android.os.AsyncTask;

import com.android.volley.VolleyError;
import com.android.volley.toolbox.RequestFuture;

import org.projectbuendia.client.events.CrudEventBus;
import org.projectbuendia.client.events.data.ItemLoadFailedEvent;
import org.projectbuendia.client.events.data.ItemLoadedEvent;
import org.projectbuendia.client.events.data.ItemUpdatedEvent;
import org.projectbuendia.client.events.data.PatientUpdateFailedEvent;
import org.projectbuendia.client.filter.db.SimpleSelectionFilter;
import org.projectbuendia.client.filter.db.patient.UuidFilter;
import org.projectbuendia.client.json.JsonPatient;
import org.projectbuendia.models.Patient;
import org.projectbuendia.client.net.OpenMrsServer;
import org.projectbuendia.client.net.Server;
import org.projectbuendia.client.providers.Contracts.Patients;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * An {@link AsyncTask} that updates a patient on a server.
 * <p/>
 * <p>If the operation succeeds, a {@link ItemUpdatedEvent} is posted on the given
 * {@link CrudEventBus} with both the old and updated patient data. If the operation fails, a
 * {@link PatientUpdateFailedEvent} is posted instead.
 */
public class UpdatePatientTask extends AsyncTask<Void, Void, PatientUpdateFailedEvent> {
    private static final SimpleSelectionFilter FILTER = new UuidFilter();

    private final TaskFactory mTaskFactory;
    private final Server mServer;
    private final ContentResolver mContentResolver;
    private final JsonPatient mPatient;
    private final String mUuid;
    private final CrudEventBus mBus;

    UpdatePatientTask(
        TaskFactory taskFactory,
        Server server,
        ContentResolver contentResolver,
        JsonPatient patient,
        CrudEventBus bus) {
        mTaskFactory = taskFactory;
        mServer = server;
        mContentResolver = contentResolver;
        mPatient = patient;
        mUuid = patient.uuid;
        mBus = bus;
    }

    @Override protected PatientUpdateFailedEvent doInBackground(Void... params) {
        RequestFuture<JsonPatient> patientFuture = RequestFuture.newFuture();

        mServer.updatePatient(mPatient, patientFuture, patientFuture);
        try {
            patientFuture.get(OpenMrsServer.TIMEOUT_SECONDS, TimeUnit.SECONDS);
        } catch (TimeoutException e) {
            return new PatientUpdateFailedEvent(PatientUpdateFailedEvent.REASON_TIMEOUT, e);
        } catch (InterruptedException e) {
            return new PatientUpdateFailedEvent(PatientUpdateFailedEvent.REASON_INTERRUPTED, e);
        } catch (ExecutionException e) {
            // TODO: Parse the VolleyError to see exactly what kind of error was raised.
            return new PatientUpdateFailedEvent(
                PatientUpdateFailedEvent.REASON_NETWORK, (VolleyError) e.getCause());
        }

        int count = mContentResolver.update(
            Patients.URI,
            mPatient.toContentValues(),
            FILTER.getSelectionString(),
            FILTER.getSelectionArgs(mUuid));

        switch (count) {
            case 0:
                return new PatientUpdateFailedEvent(
                    PatientUpdateFailedEvent.REASON_NO_SUCH_PATIENT, null /*exception*/);
            case 1:
                return null;
            default:
                return new PatientUpdateFailedEvent(
                    PatientUpdateFailedEvent.REASON_SERVER, null /*exception*/);
        }
    }

    @Override protected void onPostExecute(PatientUpdateFailedEvent event) {
        // If an error occurred, post the error event.
        if (event != null) {
            mBus.post(event);
            return;
        }

        // Otherwise, start a fetch task to fetch the patient from the database.
        mBus.register(new UpdateEventSubscriber());
        LoadItemTask<Patient> task = mTaskFactory.newLoadItemTask(
            Patients.URI, null, new UuidFilter(), mUuid, Patient::load, mBus);
        task.execute();
    }

    // After updating a patient, we fetch the patient from the database. The result of the fetch
    // determines if updating a patient was truly successful and propagates a new event to report
    // success/failure.
    @SuppressWarnings("unused") // Called by reflection from EventBus.
    private final class UpdateEventSubscriber {
        public void onEventMainThread(ItemLoadedEvent<?> event) {
            if (event.item instanceof Patient) {
                mBus.post(new ItemUpdatedEvent<>(mUuid, (Patient) event.item));
                mBus.unregister(this);
            }
        }

        public void onEventMainThread(ItemLoadFailedEvent event) {
            mBus.post(new PatientUpdateFailedEvent(
                PatientUpdateFailedEvent.REASON_CLIENT, new Exception(event.error)));
            mBus.unregister(this);
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models.tasks;

import android.content.ContentResolver;
import android.database.Cursor;
import android.net.Uri;
import android.os.AsyncTask;

import com.android.volley.toolbox.RequestFuture;

import org.projectbuendia.client.events.CrudEventBus;
import org.projectbuendia.client.events.data.ItemLoadFailedEvent;
import org.projectbuendia.client.events.data.ItemLoadedEvent;
import org.projectbuendia.client.filter.db.patient.UuidFilter;
import org.projectbuendia.client.json.JsonPatient;
import org.projectbuendia.models.Patient;
import org.projectbuendia.client.net.OpenMrsServer;
import org.projectbuendia.client.net.Server;
import org.projectbuendia.client.providers.Contracts.Patients;
import org.projectbuendia.client.utils.Logger;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

import static java.util.concurrent.TimeUnit.SECONDS;

/**
 * An {@link AsyncTask} that downloads one specific patient from the server and
 * stores it locally (unlike sync, which ensures all patients are stored locally).
 * <p/>
 * <p>Posts an {@link ItemLoadedEvent} or an {@link ItemLoadFailedEvent} on
 * the given {@link CrudEventBus} to indicate success or failure.
 */
public class FetchPatientTask extends AsyncTask<Void, Void, ItemLoadFailedEvent> {

    private static final Logger LOG = Logger.create();

    private final TaskFactory mTaskFactory;
    private final Server mServer;
    private final ContentResolver mContentResolver;
    private final String mPatientId;
    private final CrudEventBus mBus;

    private String mUuid;

    /** Creates a new {@link FetchPatientTask}. */
    public FetchPatientTask(
        TaskFactory taskFactory,
        Server server,
        ContentResolver contentResolver,
        String patientId,
        CrudEventBus bus) {
        mTaskFactory = taskFactory;
        mServer = server;
        mContentResolver = contentResolver;
        mPatientId = patientId;
        mBus = bus;
    }

    @Override protected ItemLoadFailedEvent doInBackground(Void... params) {
        RequestFuture<JsonPatient> future = RequestFuture.newFuture();

        // Try to download the specified patient from the server.
        LOG.i("Downloading single patient %s from server", mPatientId);
        mServer.getPatient(mPatientId, future, future);
        JsonPatient json;
        try {
            json = future.get(OpenMrsServer.TIMEOUT_SECONDS, SECONDS);
        } catch (TimeoutException e) {
            return new ItemLoadFailedEvent("timeout", mPatientId, e);
        } catch (InterruptedException e) {
            return new ItemLoadFailedEvent("interrupted", mPatientId, e);
        } catch (ExecutionException e) {
            return new ItemLoadFailedEvent("network error", mPatientId, e);
        }
        if (json == null) {
            LOG.i("Patient ID %s not found on server", mPatientId);
            return new ItemLoadFailedEvent("not found", mPatientId);
        }

        // Update the patient in the local database.
        Patient patient = Patient.fromJson(json);
        Uri uri = null;
        try (Cursor c = mContentResolver.query(Patients.URI, null,
            Patients.ID + " = ?", new String[] {mPatientId}, null)) {
            if (c.moveToNext()) {
                uri = Patients.URI.buildUpon().appendPath(mPatientId).build();
                mContentResolver.update(uri, patient.toContentValues(),
                    Patients.ID + " = ?", new String[] {mPatientId});
                LOG.i("Updated local patient %s", mPatientId);
            } else {
                uri = mContentResolver.insert(Patients.URI, patient.toContentValues());
                LOG.i("Added new local patient %s", mPatientId);
            }
        }

        // Record the UUID to use for fetching the patient back from the local database.
        if (uri == null || uri.equals(Uri.EMPTY)) {
            LOG.i("Patient ID %s not found on server", mPatientId);
            return new ItemLoadFailedEvent("not found", mPatientId);
        }
        if (json.uuid == null) {
            return new ItemLoadFailedEvent("server error", mPatientId);
        }
        mUuid = json.uuid;
        return null;
    }

    @Override protected void onPostExecute(ItemLoadFailedEvent event) {
        // If an error occurred, post the error event.
        if (event != null) {
            mBus.post(event);
            return;
        }

        // After updating a patient, we fetch the patient from the database. The
        // result of the fetch determines if adding a patient was truly successful
        // and propagates a new event to report success/failure.
        mTaskFactory.newLoadItemTask(
            Patients.URI, null, new UuidFilter(), mUuid, Patient::load, mBus
        ).execute();
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models.tasks;

import android.content.ContentResolver;
import android.content.ContentValues;
import android.os.AsyncTask;

import com.android.volley.VolleyError;
import com.android.volley.toolbox.RequestFuture;

import org.projectbuendia.client.App;
import org.projectbuendia.client.events.CrudEventBus;
import org.projectbuendia.client.events.data.EncounterAddFailedEvent;
import org.projectbuendia.client.events.data.ItemCreatedEvent;
import org.projectbuendia.client.events.data.ItemLoadFailedEvent;
import org.projectbuendia.client.events.data.ItemLoadedEvent;
import org.projectbuendia.client.filter.db.encounter.EncounterUuidFilter;
import org.projectbuendia.client.json.JsonEncounter;
import org.projectbuendia.models.Encounter;
import org.projectbuendia.client.net.OpenMrsServer;
import org.projectbuendia.client.net.Server;
import org.projectbuendia.client.providers.Contracts.Observations;
import org.projectbuendia.client.utils.Logger;

import java.util.UUID;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

import static java.util.concurrent.TimeUnit.SECONDS;

/**
 * An {@link AsyncTask} that adds a patient encounter to the server.
 * <p/>
 * <p>If the operation succeeds, a {@link ItemCreatedEvent} is posted on the given
 * {@link CrudEventBus} with the added encounter. If the operation fails, a
 * {@link EncounterAddFailedEvent} is posted instead.
 */
public class AddEncounterTask extends AsyncTask<Void, Void, EncounterAddFailedEvent> {
    // TODO: Factor out common code between this class and AddPatientTask.
    private static final Logger LOG = Logger.create();

    private final TaskFactory mTaskFactory;
    private final Server mServer;
    private final ContentResolver mContentResolver;
    private final Encounter mEncounter;
    private final CrudEventBus mBus;

    private String mUuid;

    /** Creates a new {@link AddEncounterTask}. */
    public AddEncounterTask(
        TaskFactory taskFactory,
        Server server,
        ContentResolver contentResolver,
        Encounter encounter,
        CrudEventBus bus
    ) {
        mTaskFactory = taskFactory;
        mServer = server;
        mContentResolver = contentResolver;
        mEncounter = encounter;
        mBus = bus;
    }

    @Override protected EncounterAddFailedEvent doInBackground(Void... params) {
        RequestFuture<JsonEncounter> future = RequestFuture.newFuture();

        mServer.addEncounter(mEncounter, future, future);
        Encounter encounter;
        try {
            encounter = Encounter.fromJson(future.get(OpenMrsServer.TIMEOUT_SECONDS, SECONDS));
        } catch (InterruptedException e) {
            return new EncounterAddFailedEvent(EncounterAddFailedEvent.Reason.INTERRUPTED, e);
        } catch (TimeoutException e) {
            return new EncounterAddFailedEvent(EncounterAddFailedEvent.Reason.TIMEOUT, e);
        } catch (ExecutionException e) {
            LOG.e(e, "Server error while adding encounter");

            EncounterAddFailedEvent.Reason reason =
                EncounterAddFailedEvent.Reason.UNKNOWN_SERVER_ERROR;
            if (e.getCause() != null) {
                String errorMessage = e.getCause().getMessage();
                if (errorMessage.contains("failed to validate")) {
                    reason = EncounterAddFailedEvent.Reason.FAILED_TO_VALIDATE;
                } else if (errorMessage.contains("Privileges required")) {
                    reason = EncounterAddFailedEvent.Reason.FAILED_TO_AUTHENTICATE;
                }
            }
            LOG.e("Error response: %s", ((VolleyError) e.getCause()).networkResponse);

            if (App.getSettings().getServerResponsesFabricated()) {
                encounter = mEncounter.withUuid(UUID.randomUUID().toString());
            } else {
                return new EncounterAddFailedEvent(reason, (VolleyError) e.getCause());
            }
        }

        if (encounter.uuid == null) {
            LOG.e("Server returned an encounter with no UUID.");
            return new EncounterAddFailedEvent(
                EncounterAddFailedEvent.Reason.FAILED_TO_SAVE_ON_SERVER, null /*exception*/);
        }

        ContentValues[] cvs = encounter.toContentValuesArray();
        if (cvs.length > 0) {
            int inserted = mContentResolver.bulkInsert(Observations.URI, cvs);
            if (DenormalizeObsTask.needsDenormalization(cvs)) {
                App.getModel().denormalizeObservations(mBus, encounter.patientUuid);
            }
            if (inserted != cvs.length) {
                LOG.w("Inserted %d observations for encounter. Expected: %d",
                    inserted, encounter.observations.length);
                return new EncounterAddFailedEvent(
                    EncounterAddFailedEvent.Reason.INVALID_NUMBER_OF_OBSERVATIONS_SAVED,
                    null /*exception*/);
            }
        } else {
            LOG.w("Encounter was sent to the server but contained no observations.");
        }

        mUuid = encounter.uuid;
        return null;
    }

    @Override protected void onPostExecute(EncounterAddFailedEvent event) {
        // If an error occurred, post the error event.
        if (event != null) {
            mBus.post(event);
            return;
        }

        // Otherwise, start a fetch task to fetch the encounter from the database.
        mBus.register(new CreationEventSubscriber());
        LoadItemTask<Encounter> task = mTaskFactory.newLoadItemTask(
            Observations.URI, null, new EncounterUuidFilter(), mUuid, Encounter::load, mBus);
        task.execute();
    }

    // After updating an encounter, we fetch the encounter from the database. The result of the
    // fetch determines if adding a patient was truly successful and propagates a new event to
    // report success/failure.
    @SuppressWarnings("unused") // Called by reflection from EventBus.
    private final class CreationEventSubscriber {
        public void onEventMainThread(ItemLoadedEvent<?> event) {
            if (event.item instanceof Encounter) {
                mBus.post(new ItemCreatedEvent<>((Encounter) event.item));
                mBus.unregister(this);
            }
        }

        public void onEventMainThread(ItemLoadFailedEvent event) {
            mBus.post(new EncounterAddFailedEvent(
                EncounterAddFailedEvent.Reason.FAILED_TO_FETCH_SAVED_OBSERVATION,
                new Exception(event.error)));
            mBus.unregister(this);
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models.tasks;

import android.content.ContentResolver;
import android.content.ContentValues;
import android.net.Uri;
import android.os.AsyncTask;

import com.android.volley.VolleyError;
import com.android.volley.toolbox.RequestFuture;

import org.projectbuendia.client.App;
import org.projectbuendia.client.events.CrudEventBus;
import org.projectbuendia.client.events.data.ItemCreatedEvent;
import org.projectbuendia.client.events.data.ItemLoadFailedEvent;
import org.projectbuendia.client.events.data.ItemLoadedEvent;
import org.projectbuendia.client.events.data.PatientAddFailedEvent;
import org.projectbuendia.client.filter.db.patient.UuidFilter;
import org.projectbuendia.client.json.JsonObservation;
import org.projectbuendia.client.json.JsonPatient;
import org.projectbuendia.models.Patient;
import org.projectbuendia.client.net.OpenMrsServer;
import org.projectbuendia.client.net.Server;
import org.projectbuendia.client.providers.Contracts.Observations;
import org.projectbuendia.client.providers.Contracts.Patients;
import org.projectbuendia.client.sync.SyncManager;
import org.projectbuendia.client.utils.Logger;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

import javax.inject.Inject;

import static java.util.concurrent.TimeUnit.SECONDS;

/**
 * An {@link AsyncTask} that adds a patient to a server.
 * <p/>
 * <p>If the operation succeeds, a {@link ItemCreatedEvent} is posted on the given
 * {@link CrudEventBus} with the added patient. If the operation fails, a
 * {@link PatientAddFailedEvent} is posted instead.
 */
public class AddPatientTask extends AsyncTask<Void, Void, PatientAddFailedEvent> {

    private static final Logger LOG = Logger.create();

    private final TaskFactory mTaskFactory;
    private final Server mServer;
    private final ContentResolver mContentResolver;
    private final JsonPatient mPatient;
    private final CrudEventBus mBus;
    @Inject SyncManager mSyncManager;

    private String mUuid;

    /** Creates a new {@link AddPatientTask}. */
    public AddPatientTask(
        TaskFactory taskFactory,
        Server server,
        ContentResolver contentResolver,
        JsonPatient patient,
        CrudEventBus bus) {
        mTaskFactory = taskFactory;
        mServer = server;
        mContentResolver = contentResolver;
        mPatient = patient;
        mBus = bus;
        App.inject(this);
    }

    @Override protected PatientAddFailedEvent doInBackground(Void... params) {
        RequestFuture<JsonPatient> future = RequestFuture.newFuture();

        mServer.addPatient(mPatient, future, future);
        JsonPatient json;
        try {
            json = future.get(OpenMrsServer.TIMEOUT_SECONDS, SECONDS);
        } catch (TimeoutException e) {
            return new PatientAddFailedEvent(PatientAddFailedEvent.REASON_TIMEOUT, e);
        } catch (InterruptedException e) {
            return new PatientAddFailedEvent(PatientAddFailedEvent.REASON_INTERRUPTED, e);
        } catch (ExecutionException e) {
            int failureReason = PatientAddFailedEvent.REASON_NETWORK;
            if (e.getCause() != null && e.getCause() instanceof VolleyError) {
                String message = e.getCause().getMessage();
                if (message.contains("could not insert: [org.openmrs.PatientIdentifier]")) {
                    failureReason = PatientAddFailedEvent.REASON_INVALID_ID;
                } else if (message.contains("already has the ID")) {
                    failureReason = PatientAddFailedEvent.REASON_DUPLICATE_ID;
                } else if (isValidationErrorMessageForField(message, "names[0].givenName")) {
                    failureReason = PatientAddFailedEvent.REASON_INVALID_GIVEN_NAME;
                } else if (isValidationErrorMessageForField(message, "names[0].familyName")) {
                    failureReason = PatientAddFailedEvent.REASON_INVALID_FAMILY_NAME;
                }
            }
            return new PatientAddFailedEvent(failureReason, e);
        }

        if (json.uuid == null) {
            LOG.e("Server successfully added a new patient but returned no UUID");
            return new PatientAddFailedEvent(PatientAddFailedEvent.REASON_SERVER, null);
        }

        Patient patient = Patient.fromJson(json);
        Uri uri = mContentResolver.insert(Patients.URI, patient.toContentValues());
        if (uri == null || uri.equals(Uri.EMPTY)) {
            return new PatientAddFailedEvent(PatientAddFailedEvent.REASON_CLIENT, null);
        }
        mUuid = json.uuid;
        if (json.observations != null) {
            ContentValues[] cvs = new ContentValues[json.observations.size()];
            int i = 0;
            for (JsonObservation obs : json.observations) {
                cvs[i++] = obs.toContentValues();
            }
            mContentResolver.bulkInsert(Observations.URI, cvs);
            if (DenormalizeObsTask.needsDenormalization(cvs)) {
                App.getModel().denormalizeObservations(mBus, patient.uuid);
            }
        }
        return null;
    }

    private boolean isValidationErrorMessageForField(String message, String fieldName) {
        return message.contains("'Patient#null' failed to validate with reason: "
            + fieldName);
    }

    @Override protected void onPostExecute(PatientAddFailedEvent event) {
        // If an error occurred, post the error event.
        if (event != null) {
            mBus.post(event);
            return;
        }

        // Otherwise, start a fetch task to fetch the patient from the database.
        mBus.register(new CreationEventSubscriber());
        LoadItemTask<Patient> task = mTaskFactory.newLoadItemTask(
            Patients.URI, null, new UuidFilter(), mUuid, Patient::load, mBus);
        task.execute();
    }

    // After updating a patient, we fetch the patient from the database. The result of the fetch
    // determines if adding a patient was truly successful and propagates a new event to report
    // success/failure.
    @SuppressWarnings("unused") // Called by reflection from EventBus.
    private final class CreationEventSubscriber {
        public void onEventMainThread(ItemLoadedEvent<?> event) {
            if (event.item instanceof Patient) {
                mBus.post(new ItemCreatedEvent<>((Patient) event.item));
                mBus.unregister(this);
            }
        }

        public void onEventMainThread(ItemLoadFailedEvent event) {
            mBus.post(new PatientAddFailedEvent(
                PatientAddFailedEvent.REASON_CLIENT, new Exception(event.error)));
            mBus.unregister(this);
        }
    }
}

package org.projectbuendia.models.tasks;

import android.content.ContentResolver;
import android.content.ContentValues;
import android.os.AsyncTask;

import com.android.volley.VolleyError;
import com.android.volley.toolbox.RequestFuture;

import org.projectbuendia.client.App;
import org.projectbuendia.client.events.CrudEventBus;
import org.projectbuendia.client.events.data.ItemDeletedEvent;
import org.projectbuendia.client.events.data.ObsDeleteFailedEvent;
import org.projectbuendia.client.events.data.ObsDeleteFailedEvent.Reason;
import org.projectbuendia.models.Obs;
import org.projectbuendia.client.net.OpenMrsServer;
import org.projectbuendia.client.net.Server;
import org.projectbuendia.client.providers.Contracts.Observations;
import org.projectbuendia.client.utils.Logger;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

import static java.util.concurrent.TimeUnit.SECONDS;

public class DeleteObsTask extends AsyncTask<Void, Void, ObsDeleteFailedEvent> {

    private static final Logger LOG = Logger.create();

    private final TaskFactory mTaskFactory;
    private final Server mServer;
    private final ContentResolver mContentResolver;
    private final Obs mObs;
    private final CrudEventBus mBus;

    public DeleteObsTask(
        TaskFactory taskFactory,
        Server server,
        ContentResolver contentResolver,
        Obs obs,
        CrudEventBus bus) {
        mTaskFactory = taskFactory;
        mServer = server;
        mContentResolver = contentResolver;
        mObs = obs;
        mBus = bus;
    }

    @Override protected ObsDeleteFailedEvent doInBackground(Void... params) {
        RequestFuture future = RequestFuture.newFuture();
        mServer.deleteObservation(mObs.uuid, future, future);
        try {
            future.get(OpenMrsServer.TIMEOUT_SECONDS, SECONDS);
        } catch (TimeoutException e) {
            return new ObsDeleteFailedEvent(Reason.TIMEOUT, e);
        } catch (InterruptedException e) {
            return new ObsDeleteFailedEvent(Reason.INTERRUPTED, e);
        } catch (ExecutionException e) {
            return new ObsDeleteFailedEvent(Reason.UNKNOWN_SERVER_ERROR, (VolleyError) e.getCause());
        }
        ContentValues cv = new ContentValues();
        cv.put(Observations.VOIDED, 1);
        mContentResolver.update(
            Observations.URI, cv, Observations.UUID + " = ?", new String[] {mObs.uuid});
        if (DenormalizeObsTask.needsDenormalization(mObs.conceptUuid)) {
            App.getModel().denormalizeObservations(App.getCrudEventBus(), mObs.patientUuid);
        }
        return null;
    }

    @Override protected void onPostExecute(ObsDeleteFailedEvent event) {
        mBus.post(event != null ? event  // error
            : new ItemDeletedEvent(mObs.uuid)); // success
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models.tasks;

import android.content.ContentResolver;
import android.database.Cursor;
import android.net.Uri;
import android.os.AsyncTask;

import org.projectbuendia.client.events.CrudEventBus;
import org.projectbuendia.client.events.data.ItemLoadFailedEvent;
import org.projectbuendia.client.events.data.ItemLoadedEvent;
import org.projectbuendia.client.filter.db.SimpleSelectionFilter;
import org.projectbuendia.models.Model;
import org.projectbuendia.models.CursorLoader;

/**
 * An {@link AsyncTask} that loads a single item from the data store.
 * <p/>
 * <p>If the operation succeeds, a {@link ItemLoadedEvent} is posted on the given
 * {@link CrudEventBus} with the retrieved item. If the operation fails, a
 * {@link ItemLoadFailedEvent} is posted instead.
 */
public class LoadItemTask<T extends Model> extends AsyncTask<Void, Void, Object> {
    private final ContentResolver mContentResolver;
    private final Uri mContentUri;
    private final String[] mProjectionColumns;
    private final SimpleSelectionFilter<T> mFilter;
    private final String mConstraint;
    private final CursorLoader<T> mLoader;
    private final CrudEventBus mBus;

    LoadItemTask(
        ContentResolver contentResolver,
        Uri contentUri,
        String[] projectionColumns,
        SimpleSelectionFilter filter,
        String constraint,
        CursorLoader<T> loader,
        CrudEventBus bus) {
        mContentResolver = contentResolver;
        mContentUri = contentUri;
        mProjectionColumns = projectionColumns;
        mFilter = filter;
        mConstraint = constraint;
        mLoader = loader;
        mBus = bus;
    }

    @Override protected Object doInBackground(Void... params) {
        try (Cursor cursor = mContentResolver.query(
            mContentUri, mProjectionColumns,
            mFilter.getSelectionString(), mFilter.getSelectionArgs(mConstraint), null
        )) {
            if (cursor == null || !cursor.moveToFirst()) {
                return new ItemLoadFailedEvent("no results");
            }
            return new ItemLoadedEvent<>(mLoader.load(cursor));
        }
    }

    @Override protected void onPostExecute(Object result) {
        mBus.post(result);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models.tasks;

import android.content.ContentResolver;
import android.net.Uri;
import android.os.AsyncTask;

import com.android.volley.toolbox.RequestFuture;

import org.projectbuendia.client.events.CrudEventBus;
import org.projectbuendia.client.events.data.ItemCreatedEvent;
import org.projectbuendia.client.events.data.ItemLoadFailedEvent;
import org.projectbuendia.client.events.data.ItemLoadedEvent;
import org.projectbuendia.client.events.data.ItemUpdatedEvent;
import org.projectbuendia.client.events.data.OrderAddFailedEvent;
import org.projectbuendia.client.filter.db.patient.UuidFilter;
import org.projectbuendia.client.json.JsonOrder;
import org.projectbuendia.models.Order;
import org.projectbuendia.client.net.OpenMrsServer;
import org.projectbuendia.client.net.Server;
import org.projectbuendia.client.providers.Contracts.Orders;
import org.projectbuendia.client.utils.Logger;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

import static java.util.concurrent.TimeUnit.SECONDS;

/** A task that submits a new order to the server and then saves it locally. */
public class AddOrderTask extends AsyncTask<Void, Void, OrderAddFailedEvent> {

    private static final Logger LOG = Logger.create();

    private final TaskFactory mTaskFactory;
    private final Server mServer;
    private final ContentResolver mContentResolver;
    private final Order mOrder;
    private final CrudEventBus mBus;

    private String mUuid;

    public AddOrderTask(
        TaskFactory taskFactory,
        Server server,
        ContentResolver contentResolver,
        Order order,
        CrudEventBus bus) {
        mTaskFactory = taskFactory;
        mServer = server;
        mContentResolver = contentResolver;
        mOrder = order;
        mBus = bus;
    }

    @SuppressWarnings("unused") // called by reflection from EventBus
    public void onEventMainThread(ItemLoadedEvent<?> event) {
        if (event.item instanceof Order) {
            Order item = (Order) event.item;
            mBus.post(mOrder.uuid != null
                ? new ItemUpdatedEvent<>(mOrder.uuid, item)
                : new ItemCreatedEvent<>(item)
            );
            mBus.unregister(this);
        }
    }

    @SuppressWarnings("unused") // called by reflection from EventBus
    public void onEventMainThread(ItemLoadFailedEvent event) {
        mBus.post(new OrderAddFailedEvent(
            OrderAddFailedEvent.Reason.CLIENT_ERROR, new Exception(event.error)));
        mBus.unregister(this);
    }

    @Override protected OrderAddFailedEvent doInBackground(Void... params) {
        RequestFuture<JsonOrder> future = RequestFuture.newFuture();
        mServer.saveOrder(mOrder, future, future);
        JsonOrder json;
        try {
            json = future.get(OpenMrsServer.TIMEOUT_SECONDS, SECONDS);
        } catch (TimeoutException e) {
            return new OrderAddFailedEvent(OrderAddFailedEvent.Reason.TIMEOUT, e);
        } catch (InterruptedException e) {
            return new OrderAddFailedEvent(OrderAddFailedEvent.Reason.INTERRUPTED, e);
        } catch (ExecutionException e) {
            return new OrderAddFailedEvent(OrderAddFailedEvent.Reason.UNKNOWN_SERVER_ERROR, e);
        }

        // insert() is implemented as insert or replace, so we use it for both adding and updating.
        Uri uri = mContentResolver.insert(
            Orders.URI, Order.fromJson(json).toContentValues());
        if (uri == null || uri.equals(Uri.EMPTY)) {
            return new OrderAddFailedEvent(OrderAddFailedEvent.Reason.CLIENT_ERROR, null);
        }

        mUuid = json.uuid;
        return null;  // no error means success
    }

    @Override protected void onPostExecute(OrderAddFailedEvent event) {
        if (event != null) {  // an error occurred
            mBus.post(event);
            return;
        }

        // We use the fetch event to trigger UI updates, both for initial load and for this update.
        mBus.register(this);
        mTaskFactory.newLoadItemTask(
            Orders.URI, null, new UuidFilter(), mUuid, Order::load, mBus
        ).execute();
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.models.tasks;

import android.content.ContentResolver;
import android.os.AsyncTask;

import com.android.volley.toolbox.RequestFuture;

import org.projectbuendia.client.events.CrudEventBus;
import org.projectbuendia.client.events.data.ItemCreatedEvent;
import org.projectbuendia.client.events.data.ItemDeletedEvent;
import org.projectbuendia.client.events.data.OrderDeleteFailedEvent;
import org.projectbuendia.client.net.OpenMrsServer;
import org.projectbuendia.client.net.Server;
import org.projectbuendia.client.providers.Contracts;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

import static java.util.concurrent.TimeUnit.SECONDS;

/**
 * An {@link AsyncTask} that adds an order, both on the server and in the local store.
 * <p/>
 * <p>If the operation succeeds, a {@link ItemCreatedEvent} is posted on the
 * given {@link CrudEventBus} with the added order. If the operation fails, an
 * {@link OrderDeleteFailedEvent} is posted instead.
 */
public class DeleteOrderTask extends AsyncTask<Void, Void, OrderDeleteFailedEvent> {

    private final Server mServer;
    private final ContentResolver mContentResolver;
    private final String mOrderUuid;
    private final CrudEventBus mBus;

    /** Creates a new {@link DeleteOrderTask}. */
    public DeleteOrderTask(
            Server server,
            ContentResolver contentResolver,
            String orderUuid,
            CrudEventBus bus) {
        mServer = server;
        mContentResolver = contentResolver;
        mOrderUuid = orderUuid;
        mBus = bus;
    }

    @Override protected OrderDeleteFailedEvent doInBackground(Void... params) {
        RequestFuture<Void> future = RequestFuture.newFuture();

        mServer.deleteOrder(mOrderUuid, future, future);
        try {
            future.get(OpenMrsServer.TIMEOUT_SECONDS, SECONDS);
        } catch (TimeoutException e) {
            return new OrderDeleteFailedEvent(OrderDeleteFailedEvent.Reason.TIMEOUT, e);
        } catch (InterruptedException e) {
            return new OrderDeleteFailedEvent(OrderDeleteFailedEvent.Reason.INTERRUPTED, e);
        } catch (ExecutionException e) {
            return new OrderDeleteFailedEvent(OrderDeleteFailedEvent.Reason.UNKNOWN_SERVER_ERROR, e);
        }

        mContentResolver.delete(
            Contracts.Orders.URI,
            "uuid = ?",
            new String[] {mOrderUuid}
        );
        return null;
    }

    @Override protected void onPostExecute(OrderDeleteFailedEvent event) {
        mBus.post(event != null ? event  // error
            : new ItemDeletedEvent(mOrderUuid)); // success
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client;

import android.app.Application;
import android.content.ContentResolver;
import android.preference.PreferenceManager;

import org.projectbuendia.client.diagnostics.DiagnosticsModule;
import org.projectbuendia.client.events.EventsModule;
import org.projectbuendia.models.AppModelModule;
import org.projectbuendia.models.tasks.AddPatientTask;
import org.projectbuendia.client.net.NetModule;
import org.projectbuendia.client.sync.BuendiaSyncEngine;
import org.projectbuendia.client.sync.ChartDataHelper;
import org.projectbuendia.client.sync.SyncEngine;
import org.projectbuendia.client.sync.SyncManager;
import org.projectbuendia.client.sync.ThreadedSyncScheduler;
import org.projectbuendia.client.ui.AuthorizationActivity;
import org.projectbuendia.client.ui.BaseActivity;
import org.projectbuendia.client.ui.SettingsActivity;
import org.projectbuendia.client.ui.UpdateCheckController;
import org.projectbuendia.client.ui.chart.PatientChartActivity;
import org.projectbuendia.client.ui.dialogs.GoToPatientDialogFragment;
import org.projectbuendia.client.ui.dialogs.PatientDialogFragment;
import org.projectbuendia.client.ui.dialogs.PatientLocationDialogFragment;
import org.projectbuendia.client.ui.lists.FilteredPatientListActivity;
import org.projectbuendia.client.ui.lists.LocationListActivity;
import org.projectbuendia.client.ui.lists.LocationListFragment;
import org.projectbuendia.client.ui.lists.PatientListActivity;
import org.projectbuendia.client.ui.lists.PatientListController;
import org.projectbuendia.client.ui.lists.PatientListFragment;
import org.projectbuendia.client.ui.lists.SingleLocationActivity;
import org.projectbuendia.client.ui.login.LoginActivity;
import org.projectbuendia.client.ui.login.LoginFragment;
import org.projectbuendia.client.updater.UpdateModule;
import org.projectbuendia.client.user.UserManager;
import org.projectbuendia.client.user.UserModule;
import org.projectbuendia.client.utils.UtilsModule;

import javax.inject.Singleton;

import dagger.Module;
import dagger.Provides;

/** A Dagger module that provides the top-level bindings for the app. */
@Module(
    includes = {
        AppModelModule.class,
        DiagnosticsModule.class,
        EventsModule.class,
        NetModule.class,
        UpdateModule.class,
        UserModule.class,
        UtilsModule.class
    },
    injects = {
        App.class,
        AppSettings.class,
        UserManager.class,
        SyncManager.class,

        // TODO: Move these into activity-specific modules.
        // Activities
        BaseActivity.class,
        PatientChartActivity.class,
        FilteredPatientListActivity.class,
        PatientListController.class,
        GoToPatientDialogFragment.class,
        PatientDialogFragment.class,
        PatientLocationDialogFragment.class,
        LocationListFragment.class,
        PatientListActivity.class,
        SingleLocationActivity.class,
        LocationListActivity.class,
        PatientListFragment.class,
        UpdateCheckController.class,
        LoginActivity.class,
        LoginFragment.class,
        SettingsActivity.class,
        AuthorizationActivity.class,
        AddPatientTask.class
    })
public final class AppModule {

    private final App mApp;

    public AppModule(App app) {
        mApp = app;
    }

    @Provides @Singleton Application provideApplication() {
        return mApp;
    }

    @Provides @Singleton AppSettings provideAppSettings(Application app) {
        return new AppSettings(
            PreferenceManager.getDefaultSharedPreferences(app), app.getResources());
    }

    @Provides @Singleton ContentResolver provideContentResolver(Application app) {
        return app.getContentResolver();
    }

    @Provides @Singleton SyncManager provideSyncManager(AppSettings settings, SyncEngine engine) {
        return new SyncManager(new ThreadedSyncScheduler(engine));
    }

    @Provides @Singleton SyncEngine provideSyncEngine(Application app) {
        return new BuendiaSyncEngine(app.getApplicationContext());
    }

    @Provides @Singleton ChartDataHelper provideLocalizedChartHelper(ContentResolver contentResolver) {
        return new ChartDataHelper(contentResolver);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client;

import android.content.SharedPreferences;
import android.content.res.Resources;
import android.support.annotation.NonNull;

import org.projectbuendia.client.utils.Utils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

/** Type-safe access to application settings. */
public class AppSettings {
    // The locale in which this app guarantees a definition for every string.
    public static final Locale APP_DEFAULT_LOCALE = new Locale("en");

    // The system default locale at app startup time.
    public static final Locale ORIGINAL_DEFAULT_LOCALE = Locale.getDefault();

    // Locales to offer as options to the user.
    public static final Locale[] AVAILABLE_LOCALES = new Locale[] {
        new Locale("en"), new Locale("fr")
    };

    private SharedPreferences prefs;
    private Resources resources;

    public AppSettings(SharedPreferences prefs, Resources resources) {
        this.prefs = prefs;
        this.resources = resources;
    }

    /** Gets the server hostname for Buendia API requests. */
    public String getServer() {
        String server = prefs.getString("server", "").trim();
        return Utils.hasChars(server) ? server : resources.getString(R.string.server_default);
    }

    public void setServer(String server) {
        server = server.trim();
        prefs.edit()
            .putString("server", server)
            .putString("openmrs_root_url", "http://" + server + ":9000/openmrs")
            .putString("package_server_root_url", "http://" + server + ":9001")
            .commit();
    }

    /** Constructs the URL for a given URL path under the OpenMRS root URL. */
    public String getOpenmrsUrl(String urlPath) {
        return getOpenmrsUrl().replaceAll("/*$", "") + urlPath;
    }

    /** Gets the root URL of the OpenMRS server providing the Buendia API. */
    public String getOpenmrsUrl() {
        return prefs.getString("openmrs_root_url",
            resources.getString(R.string.openmrs_root_url_default));
    }

    /** Gets the OpenMRS username to use for API requests. */
    public String getOpenmrsUser() {
        return prefs.getString("openmrs_user",
            resources.getString(R.string.openmrs_user_default));
    }

    /** Gets the OpenMRS password to use for API requests. */
    public String getOpenmrsPassword() {
        String defaultPassword = "";
        try {
            // Usually, this resource isn't set; the app comes without a
            // password and the user has to enter one.  For demos, this can
            // be set in order to let the user skip the authorization activity.
            defaultPassword = resources.getString(R.string.openmrs_password_default);
        } catch (Resources.NotFoundException e) {
            defaultPassword = "";
        }
        return prefs.getString("openmrs_password", defaultPassword);
    }

    /**
     * The app can be in an "unauthorized" state (user must provide the correct
     * OpenMRS password before being allowed to do anything) or an "authorized"
     * state (the user provided the correct OpenMRS password and we don't need
     * to ask for it again).  The state is determined and defined by whether
     * the OpenMRS password pref is set to anything.
     */
    public boolean isAuthorized() {
        return Utils.hasChars(getOpenmrsPassword());
    }

    /**
     * Records an OpenMRS password entered by the user that has successfully
     * authorized at least one request.
     */
    public void authorize(String server, String username, String password) {
        setServer(server);
        prefs.edit()
            .putString("openmrs_user", username)
            .putString("openmrs_password", password)
            .commit();
    }

    /** Puts the app back in the "unauthorized" state where an OpenMRS password is required. */
    public void deauthorize() {
        prefs.edit().putString("openmrs_password", "").commit();
        App.reset(null);
    }

    /** Constructs the URL for a given URL path on the package server. */
    public String getPackageServerUrl(String urlPath) {
        return getPackageServerUrl().replaceAll("/*$", "") + urlPath;
    }

    /** Gets the root URL of the package server providing APK updates. */
    public String getPackageServerUrl() {
        return prefs.getString("package_server_root_url",
            resources.getString(R.string.package_server_root_url_default));
    }

    /** Gets the index of the preferred chart zoom level. */
    public int getChartZoomIndex() {
        return prefs.getInt("chart_zoom_index", 0);
    }

    /** Sets the preferred chart zoom level. */
    public void setChartZoomIndex(int zoom) {
        prefs.edit().putInt("chart_zoom_index", zoom).commit();
    }

    /**
     Gets the minimum period between checks for APK updates, in seconds.
     Repeated calls to UpdateManager.checkForUpdate() within this period
     will not check the package server for new updates.
     */
    public int getApkUpdateInterval() {
        return prefs.getInt("apk_check_interval",
            resources.getInteger(R.integer.apk_check_interval_default));
    }

    /** Returns true if the app should skip directly to a patient chart on startup. */
    public boolean shouldSkipToPatientChart() {
        return !getStartingPatientId().isEmpty();
    }

    /** Gets the patient ID of the chart to skip directly to on startup, or "". */
    public @NonNull String getStartingPatientId() {
        return prefs.getString("starting_patient_id",
            resources.getString(R.string.starting_patient_id_default)).trim();
    }

    /** Returns true if periodic sync has been disabled in the settings. */
    public boolean getPeriodicSyncDisabled() {
        return prefs.getBoolean("periodic_sync_disabled",
            resources.getBoolean(R.bool.periodic_sync_disabled_default));
    }

    /** Sets whether periodic sync is disabled in the settings. */
    public void setPeriodicSyncDisabled(boolean disabled) {
        prefs.edit().putBoolean("periodic_sync_disabled", disabled).commit();
    }

    /** Gets the setting for whether to retain filled-in forms after submission. */
    public boolean getFormInstancesRetainedLocally() {
        return prefs.getBoolean("form_instances_retained",
            resources.getBoolean(R.bool.form_instances_retained_default));
    }

    /** Gets the flag controlling whether to assume no wifi means no network. */
    public boolean getNonWifiAllowed() {
        return prefs.getBoolean("non_wifi_allowed",
            resources.getBoolean(R.bool.non_wifi_allowed_default));
    }

    /** Gets the currently selected locale. */
    public Locale getLocale() {
        String localeTag = Utils.toNonnull(prefs.getString("locale", ""));
        return !localeTag.isEmpty() ? new Locale(localeTag) : ORIGINAL_DEFAULT_LOCALE;
    }

    /** Sets the locale. */
    public void setLocale(String languageTag) {
        prefs.edit().putString("locale", languageTag).commit();
    }

    /** Gets the index of the currently selected locale in the getLocaleOptionValues() array. */
    public int getLocaleIndex() {
        String languageTag = Utils.toNonnull(prefs.getString("locale", ""));
        return Arrays.asList(getLocaleOptionValues()).indexOf(languageTag);
    }

    /** Gets the values for a menu of available locales. */
    public static String[] getLocaleOptionValues() {
        List<String> values = new ArrayList<>();
        for (Locale locale : AVAILABLE_LOCALES) {
            values.add(Utils.toLanguageTag(locale));
        }
        return values.toArray(new String[0]);
    }

    /** Gets the labels for a menu of available locales. */
    public static String[] getLocaleOptionLabels() {
        List<String> labels = new ArrayList<>();
        for (Locale locale : AVAILABLE_LOCALES) {
            labels.add(locale.getDisplayName(locale));
        }
        return labels.toArray(new String[0]);
    }

    /** Gets the interval for fast incremental syncs (patients, orders, observations). */
    // Syncs in this category should typically take less than 100 ms.
    public int getSmallSyncInterval() {
        return prefs.getInt("small_sync_interval",
            resources.getInteger(R.integer.small_sync_interval_default));
    }

    /** Gets the interval for syncs that are non-incremental but small (locations, users). */
    // This category is for syncs expected to take up to 500 ms, for data
    // that changes (on average) less than once an hour.
    public int getMediumSyncInterval() {
       return prefs.getInt("medium_sync_interval",
           resources.getInteger(R.integer.medium_sync_interval_default));
    }

    /** Gets the interval for syncs that are non-incremental and large (concepts, forms). */
    // This category is for syncs expected to take up to 2000 ms, for data
    // that changes (on average) less than once a day.
    public int getLargeSyncInterval() {
        return prefs.getInt("large_sync_interval",
            resources.getInteger(R.integer.large_sync_interval_default));
    }

    /** Gets the setting for whether to fabricate responses when the server fails. */
    public boolean getServerResponsesFabricated() {
        return prefs.getBoolean("server_responses_fabricated", false);
    }

    public String getLastIdPrefix() {
        return prefs.getString("last_id_prefix", "");
    }

    public void setLastIdPrefix(String prefix) {
        prefs.edit().putString("last_id_prefix", prefix).commit();
    }
}


// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client;

import android.app.Application;
import android.content.ContentResolver;
import android.content.Context;
import android.content.SharedPreferences;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.preference.PreferenceManager;

import com.android.volley.VolleyLog;
import com.facebook.stetho.Stetho;
import com.joanzapata.iconify.Iconify;
import com.joanzapata.iconify.fonts.FontAwesomeModule;

import org.odk.collect.android.application.Collect;
import org.projectbuendia.client.diagnostics.HealthMonitor;
import org.projectbuendia.client.diagnostics.Troubleshooter;
import org.projectbuendia.client.events.CrudEventBus;
import org.projectbuendia.models.AppModel;
import org.projectbuendia.client.net.OpenMrsConnectionDetails;
import org.projectbuendia.client.net.Server;
import org.projectbuendia.client.sync.ChartDataHelper;
import org.projectbuendia.client.sync.ConceptService;
import org.projectbuendia.client.sync.Database;
import org.projectbuendia.client.sync.SyncManager;
import org.projectbuendia.client.updater.UpdateManager;
import org.projectbuendia.client.user.UserManager;
import org.projectbuendia.client.utils.Intl;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.io.File;
import java.util.Locale;

import javax.inject.Inject;

import dagger.ObjectGraph;
import de.greenrobot.event.EventBus;

/** An {@link Application} the represents the Android Client. */
public class App extends Application {
    private static final Logger LOG = Logger.create();

    // Global instances of all our singletons.
    private static App sInstance;
    private static Resources sResources;
    private static AppModel sModel;
    private static AppSettings sSettings;
    private static ChartDataHelper sChartDataHelper;
    private static CrudEventBus sCrudEventBus;
    private static EventBus sHealthEventBus;
    private static HealthMonitor sHealthMonitor;
    private static Troubleshooter sTroubleshooter;
    private static SyncManager sSyncManager;
    private static UpdateManager sUpdateManager;
    private static UserManager sUserManager;
    private static OpenMrsConnectionDetails sConnectionDetails;
    private static Server sServer;
    private static ConceptService sConceptService;

    private ObjectGraph mObjectGraph;
    @Inject AppModel mModel;
    @Inject AppSettings mSettings;
    @Inject ChartDataHelper mChartDataHelper;
    @Inject CrudEventBus mCrudEventBus;
    @Inject EventBus mHealthEventBus;
    @Inject HealthMonitor mHealthMonitor;
    @Inject Troubleshooter mTroubleshooter;
    @Inject SyncManager mSyncManager;
    @Inject UpdateManager mUpdateManager;
    @Inject UserManager mUserManager;
    @Inject OpenMrsConnectionDetails mOpenMrsConnectionDetails;
    @Inject Server mServer;

    public static App getInstance() {
        return sInstance;
    }

    public static Context getContext() {
        return sInstance.getApplicationContext();
    }

    /** This should be called in every Activity's attachBaseContext method. */
    public static Context applyLocaleSetting(Context base) {
        Locale locale = getSettings().getLocale();
        Locale.setDefault(locale);
        Resources resources = base.getResources();
        Configuration config = resources.getConfiguration();
        config.setLocale(locale);
        config.setLayoutDirection(locale);
        Context context = base.createConfigurationContext(config);
        sResources = context.getResources();
        return context;
    }

    public static String str(int id, Object... args) {
        return sResources.getString(id, args);
    }

    public static String localize(String packed) {
        return localize(new Intl(packed));
    }

    public static String localize(Intl packed) {
        return packed.loc(getSettings().getLocale());
    }

    public static void inject(Object obj) {
        sInstance.mObjectGraph.inject(obj);
    }

    public static synchronized ContentResolver getResolver() {
        return sInstance.getContentResolver();
    }

    public static synchronized SharedPreferences getPrefs() {
        return PreferenceManager.getDefaultSharedPreferences(getContext());
    }

    public static synchronized AppModel getModel() {
        return sModel;
    }

    public static synchronized AppSettings getSettings() {
        return sSettings;
    }

    public static synchronized ChartDataHelper getChartDataHelper() {
        return sChartDataHelper;
    }

    public static synchronized CrudEventBus getCrudEventBus() {
        return sCrudEventBus;
    }

    public static synchronized EventBus getHealthEventBus() {
        return sHealthEventBus;
    }

    public static synchronized HealthMonitor getHealthMonitor() {
        return sHealthMonitor;
    }

    public static synchronized Troubleshooter getTroubleshooter() {
        return sTroubleshooter;
    }

    public static synchronized SyncManager getSyncManager() {
        return sSyncManager;
    }

    public static synchronized UpdateManager getUpdateManager() {
        return sUpdateManager;
    }

    public static synchronized UserManager getUserManager() {
        return sUserManager;
    }

    public static synchronized OpenMrsConnectionDetails getConnectionDetails() {
        return sConnectionDetails;
    }

    public static synchronized Server getServer() {
        return sServer;
    }

    public static synchronized ConceptService getConceptService() {
        return sConceptService;
    }

    @Override public void onCreate() {
        sInstance = this;
        sResources = this.getResources();
        Collect.onCreate(this);
        super.onCreate();

        // Distinguish our Volley log messages from other apps that might use Volley
        VolleyLog.setTag("buendia/Volley");

        // Enable FontAwesome Icons
        Iconify.with(new FontAwesomeModule());

        // Enable Stetho, which lets you inspect the app's database, UI, and network activity
        // just by opening chrome://inspect in Chrome on a computer connected to the tablet.
        Stetho.initializeWithDefaults(this);

        mObjectGraph = ObjectGraph.create(Modules.list(this));
        mObjectGraph.inject(this);
        mObjectGraph.injectStatics();

        // Ensure all unset preferences get initialized with default values.
        PreferenceManager.setDefaultValues(this, R.xml.pref_general, false);

        synchronized (App.class) {
            sModel = mModel;
            sSettings = mSettings;
            sChartDataHelper = mChartDataHelper;
            sCrudEventBus = mCrudEventBus;
            sHealthEventBus = mHealthEventBus;
            sHealthMonitor = mHealthMonitor;
            sTroubleshooter = mTroubleshooter;
            sSyncManager = mSyncManager;
            sUpdateManager = mUpdateManager;
            sUserManager = mUserManager;
            sConnectionDetails = mOpenMrsConnectionDetails;
            sServer = mServer;
            sConceptService = new ConceptService(getContentResolver());
            mHealthMonitor.start();
        }
    }

    public static synchronized void reset(Runnable callback) {
        sSyncManager.setNewSyncsSuppressed(true);
        LOG.i("reset(): Waiting for syncs to stop...");
        sSyncManager.stopSyncing(() -> {
            try {
                clearDatabase();
                clearMemoryState();
                clearOdkFiles();
                LOG.i("reset(): Completed");
                if (callback != null) callback.run();
            } finally {
                sSyncManager.setNewSyncsSuppressed(false);
            }
        });
    }

    private static void clearDatabase() {
        LOG.i("Clearing local database");
        try {
            Database db = new Database(getContext());
            db.clear();
            db.close();
        } catch (Throwable t) {
            LOG.e(t, "Failed to clear database");
        }
    }

    private static synchronized void clearMemoryState() {
        LOG.i("Clearing memory state");
        try {
            sUserManager.reset();
            sModel.reset();
        } catch (Throwable t) {
            LOG.e(t, "Failed to clear memory state");
        }
    }

    private static void clearOdkFiles() {
        LOG.i("Clearing ODK files");
        try {
            File filesDir = getContext().getFilesDir();
            File odkDir = new File(filesDir, "odk");
            File odkTempDir = new File(filesDir, "odk-deleted." + System.currentTimeMillis());
            odkDir.renameTo(odkTempDir);
            Utils.recursivelyDelete(odkTempDir);
        } catch (Throwable t) {
            LOG.e(t, "Failed to clear ODK state");
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.support.v4.app.Fragment;
import android.util.Log;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.LinearLayout;
import android.widget.ProgressBar;
import android.widget.RelativeLayout;
import android.widget.TextView;

import com.android.volley.Response;
import com.android.volley.VolleyError;
import com.google.common.base.Charsets;

import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.client.utils.Logger;

import java.util.ArrayList;
import java.util.List;

/** A Fragment that shows a spinner or progress bar when content is not ready. */
public abstract class ProgressFragment extends Fragment implements Response.ErrorListener {

    private static final Logger LOG = Logger.create();
    protected int mContentLayout;
    protected View mContent;
    protected RelativeLayout mFrame;
    protected TextView mErrorTextView;

    protected View mProgressBarLayout;
    protected ProgressBar mProgressBar;
    protected TextView mProgressBarLabel;
    protected ProgressBar mIndeterminateProgressBar;

    protected int mShortAnimationDuration;
    private ReadyState mState = ReadyState.LOADING;
    private List<ReadyStateSubscriber> mSubscribers = new ArrayList<>();

    public interface ReadyStateSubscriber {
        public void onChangeState(ReadyState state);
    }

    public ProgressFragment() {
    }

    @Override public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mShortAnimationDuration = getResources().getInteger(
            android.R.integer.config_shortAnimTime);
    }

    @Override public void onErrorResponse(VolleyError error) {
        setErrorState(error.toString());
        Log.e("server", new String(error.networkResponse.data, Charsets.UTF_8));
    }

    public void setErrorState(String message) {
        mErrorTextView.setText(message);
        setReadyState(ReadyState.ERROR);
    }

    /** Changes the state of this fragment, hiding or showing the spinner as necessary. */
    public void setReadyState(ReadyState state) {
        if (state == mState) return;
        LOG.w("setReadyState %s", state);

        mState = state;
        mProgressBarLayout.setVisibility(state == ReadyState.SYNCING ? View.VISIBLE : View.GONE);
        mIndeterminateProgressBar.setVisibility(state == ReadyState.LOADING ? View.VISIBLE : View.GONE);
        mContent.setVisibility(state == ReadyState.READY ? View.VISIBLE : View.GONE);
        mErrorTextView.setVisibility(state == ReadyState.ERROR ? View.VISIBLE : View.GONE);
        for (ReadyStateSubscriber subscriber : mSubscribers) {
            subscriber.onChangeState(mState);
        }
    }

    @Override public void onDestroy() {
        super.onDestroy();
        App.getServer().cancelPendingRequests();
    }

    @Override public View onCreateView(
        LayoutInflater inflater,
        @Nullable ViewGroup container,
        @Nullable Bundle savedInstanceState) {
        super.onCreateView(inflater, container, savedInstanceState);

        mFrame = new RelativeLayout(getActivity());
        RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(
            RelativeLayout.LayoutParams.MATCH_PARENT,
            RelativeLayout.LayoutParams.MATCH_PARENT);
        mFrame.setLayoutParams(layoutParams);

        RelativeLayout.LayoutParams centeredLayout = new RelativeLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT);
        centeredLayout.addRule(RelativeLayout.CENTER_IN_PARENT, RelativeLayout.TRUE);
        mIndeterminateProgressBar = new ProgressBar(getActivity());
        mIndeterminateProgressBar.setLayoutParams(centeredLayout);

        mProgressBarLayout =
            inflater.inflate(R.layout.labelled_progress_bar, null);
        mProgressBarLayout.setLayoutParams(centeredLayout);
        mProgressBar =
            mProgressBarLayout.findViewById(R.id.progress_fragment_progress_bar);
        mProgressBarLabel = mProgressBarLayout.findViewById(R.id.progress_fragment_label);
        mProgressBarLabel.setText(R.string.sync_in_progress);

        RelativeLayout.LayoutParams fullLayout = new RelativeLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.MATCH_PARENT);
        fullLayout.addRule(RelativeLayout.CENTER_IN_PARENT, RelativeLayout.TRUE);
        mErrorTextView = new TextView(getActivity());
        mErrorTextView.setLayoutParams(fullLayout);
        mErrorTextView.setGravity(Gravity.CENTER);

        mFrame.setLayoutParams(fullLayout);

        mContent = LayoutInflater.from(getActivity()).inflate(mContentLayout, mFrame, false);
        mContent.setVisibility(View.GONE);

        mIndeterminateProgressBar.setVisibility(View.VISIBLE);
        mProgressBarLayout.setVisibility(View.GONE);
        mErrorTextView.setVisibility(View.GONE);

        mFrame.addView(mIndeterminateProgressBar);
        mFrame.addView(mProgressBarLayout);
        mFrame.addView(mContent);
        mFrame.addView(mErrorTextView);
        return mFrame;
    }

    @Override public void onDestroyView() {
        super.onDestroyView();
        if (mFrame != null) {
            mFrame.removeAllViewsInLayout();
        }
    }

    public void registerSubscriber(ReadyStateSubscriber subscriber) {
        mSubscribers.add(subscriber);
    }

    public void unregisterSubscriber(ReadyStateSubscriber subscriber) {
        mSubscribers.remove(subscriber);
    }

    public ReadyState getState() {
        return mState;
    }

    protected void setContentLayout(int layout) {
        mContentLayout = layout;
    }

    protected void setProgress(int numerator, int denominator) {
        if (denominator > 0) mProgressBar.setMax(denominator);
        mProgressBar.setProgress(numerator);
    }

    protected void setProgressMessage(int messageId) {
        mProgressBarLabel.setText(messageId);
    }

    private void crossfade(View inView, final View outView) {

        // Set the content view to 0% opacity but visible, so that it is visible
        // (but fully transparent) during the animation.
        inView.setAlpha(0f);
        inView.setVisibility(View.VISIBLE);

        // Animate the content view to 100% opacity, and clear any animation
        // listener set on the view.
        inView.animate()
            .alpha(1f)
            .setDuration(mShortAnimationDuration)
            .setListener(null);

        // Animate the loading view to 0% opacity. After the animation ends,
        // set its visibility to GONE as an optimization step (it won't
        // participate in layout passes, etc.)
        if (outView != null) {
            outView.animate()
                .alpha(0f)
                .setDuration(mShortAnimationDuration)
                .setListener(new AnimatorListenerAdapter() {
                    @Override public void onAnimationEnd(Animator animation) {
                        outView.setVisibility(View.GONE);
                    }
                });
        }
    }

}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui;

import android.os.Handler;

import org.projectbuendia.client.App;
import org.projectbuendia.client.events.UpdateAvailableEvent;
import org.projectbuendia.client.events.UpdateReadyToInstallEvent;
import org.projectbuendia.client.updater.AvailableUpdateInfo;
import org.projectbuendia.client.updater.DownloadedUpdateInfo;

import de.greenrobot.event.EventBus;

/**
 * A controller for software update notification behaviour.  Activities that
 * want this behaviour should instantiate this controller and call its init()
 * and suspend() methods, in addition to other controllers they may have.
 */
public class UpdateCheckController {
    Ui mUi;
    AvailableUpdateInfo mAvailableUpdateInfo;
    DownloadedUpdateInfo mDownloadedUpdateInfo;
    boolean isRunning = false;
    Handler handler;

    public interface Ui {

        void showUpdateAvailableForDownload(AvailableUpdateInfo updateInfo);

        void showUpdateReadyToInstall(DownloadedUpdateInfo updateInfo);

        void hideSoftwareUpdateNotifications();
    }

    public UpdateCheckController(Ui ui) {
        mUi = ui;
        handler = new Handler();
    }

    /** Activate the controller.  Called whenever user enters a new activity. */
    public void init() {
        EventBus.getDefault().register(this);
        isRunning = true;
        handler.post(this::doNextCheck);
    }

    private void doNextCheck() {
        if (isRunning) {
            App.getUpdateManager().checkForUpdate();
            updateAvailabilityNotifications();
            handler.postDelayed(
                this::doNextCheck,
                App.getSettings().getApkUpdateInterval() * 1000);
        }
    }

    /**
     * Shows or hides software update notifications in the UI according to the
     * currently posted sticky events (posted by the UpdateManager).
     */
    protected void updateAvailabilityNotifications() {
        EventBus bus = EventBus.getDefault();
        UpdateReadyToInstallEvent readyEvent =
            bus.getStickyEvent(UpdateReadyToInstallEvent.class);
        UpdateAvailableEvent availableEvent =
            bus.getStickyEvent(UpdateAvailableEvent.class);
        if (readyEvent != null) {
            mDownloadedUpdateInfo = readyEvent.updateInfo;
            mUi.showUpdateReadyToInstall(mDownloadedUpdateInfo);
        } else if (availableEvent != null) {
            mDownloadedUpdateInfo = null;
            mAvailableUpdateInfo = availableEvent.updateInfo;
            mUi.showUpdateAvailableForDownload(mAvailableUpdateInfo);
        } else {
            mDownloadedUpdateInfo = null;
            mAvailableUpdateInfo = null;
            mUi.hideSoftwareUpdateNotifications();
        }
    }

    public void suspend() {
        isRunning = false;
        EventBus.getDefault().unregister(this);
    }

    /** Updates the UI in response to updated knowledge of available .apks. */
    public void onEventMainThread(UpdateAvailableEvent event) {
        updateAvailabilityNotifications();
    }

    /** Updates the UI in response to completion of an .apk download. */
    public void onEventMainThread(UpdateReadyToInstallEvent event) {
        updateAvailabilityNotifications();
    }

    /** Starts a download of the last known available update. */
    public void onEventMainThread(BaseActivity.DownloadRequestedEvent event) {
        if (mAvailableUpdateInfo != null) {
            App.getUpdateManager().startDownload(mAvailableUpdateInfo);
        }
    }

    /** Installs the last downloaded update. */
    public void onEventMainThread(BaseActivity.InstallationRequestedEvent event) {
        if (mDownloadedUpdateInfo != null) {
            App.getUpdateManager().installUpdate(mDownloadedUpdateInfo);
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui;

import android.annotation.SuppressLint;
import android.app.AlertDialog;
import android.content.Intent;
import android.graphics.drawable.BitmapDrawable;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.PopupWindow;
import android.widget.TextView;

import com.joanzapata.iconify.fonts.FontAwesomeIcons;

import org.joda.time.Duration;
import org.projectbuendia.client.App;
import org.projectbuendia.client.AppSettings;
import org.projectbuendia.client.R;
import org.projectbuendia.client.events.actions.PatientChartRequestedEvent;
import org.projectbuendia.client.events.user.ActiveUserUnsetEvent;
import org.projectbuendia.client.json.JsonUser;
import org.projectbuendia.client.ui.chart.PatientChartActivity;
import org.projectbuendia.client.ui.dialogs.GoToPatientDialogFragment;
import org.projectbuendia.client.ui.login.LoginActivity;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import butterknife.ButterKnife;
import butterknife.InjectView;
import butterknife.OnClick;

import static org.projectbuendia.client.utils.Utils.eq;

/** A {@link BaseActivity} that requires that there currently be a logged-in user. */
public abstract class LoggedInActivity extends BaseActivity {
    private static final Logger LOG = Logger.create();
    private static final Duration UNDOCKED_AUTOLOGOUT_IDLE_DURATION = Duration.standardMinutes(10);
    private static final Duration DOCKED_AUTOLOGOUT_IDLE_DURATION = Duration.standardSeconds(30);

    private JsonUser mLastActiveUser;
    private Menu mMenu;
    private UserMenuPopup mUserMenu;

    private ReadyState mReadyState = ReadyState.READY;

    @Override protected boolean onCreateImpl(Bundle state) {
        if (!super.onCreateImpl(state)) return false;
        if (App.getUserManager().getActiveUser() == null) {
            Utils.jumpToActivity(this, LoginActivity.class);
            return false;
        }

        // Turn the action bar icon into a "back" arrow that goes back in the activity stack.
        getActionBar().setIcon(R.drawable.ic_back_36dp);
        getActionBar().setDisplayHomeAsUpEnabled(true);
        return true;
    }

    @Override public final boolean onCreateOptionsMenu(Menu menu) {
        if (!mIsCreated) return true;

        mMenu = menu;
        onExtendOptionsMenu(menu);

        getMenuInflater().inflate(R.menu.base, menu);

        MenuItem searchByIdItem = menu.findItem(R.id.action_go_to);
        setMenuBarIcon(searchByIdItem, FontAwesomeIcons.fa_search);

        searchByIdItem.setOnMenuItemClickListener(menuItem -> {
            Utils.logUserAction("go_to_patient_pressed");
            openDialog(new GoToPatientDialogFragment());
            return true;
        });

        mUserMenu = new UserMenuPopup();

        final View userView = mMenu.getItem(mMenu.size() - 1).getActionView();
        userView.setOnClickListener(view -> mUserMenu.showAsDropDown(userView));

        updateActiveUser();

        return true;
    }

    public void onExtendOptionsMenu(Menu menu) {
    }

    @Override public boolean onOptionsItemSelected(MenuItem item) {
        int id = item.getItemId();
        if (id == android.R.id.home) {
            // Go back rather than reloading the activity, so that the patient list retains its
            // filter state.
            onBackPressed();
            return true;
        }
        return super.onOptionsItemSelected(item);
    }

    private void updateActiveUser() {
        JsonUser user = App.getUserManager().getActiveUser();
        if (!eq(mLastActiveUser, user)) {
            LOG.w("User has switched from %s to %s", mLastActiveUser, user);
        }
        mLastActiveUser = user;

        TextView initials = mMenu
            .getItem(mMenu.size() - 1)
            .getActionView()
            .findViewById(R.id.user_initials);
        initials.setBackgroundColor(App.getUserManager().getColor(user));
        initials.setText(user.getLocalizedInitials());
    }

    public void onEvent(ActiveUserUnsetEvent event) {
        // TODO: Implement this in one way or another!
    }

    public void onEventMainThread(PatientChartRequestedEvent event) {
        PatientChartActivity.start(this, event.uuid);
    }

    @Override protected final void onStart() {
        if (!mIsCreated) {
            super.onStart();
            return;
        }

        onStartImpl();
    }

    protected void onStartImpl() {
        super.onStart();
    }

    @Override protected final void onResume() {
        if (!mIsCreated) {
            super.onResume();
            return;
        }
        onResumeImpl();
    }

    protected void onResumeImpl() {
        super.onResume();
    }

    @Override protected final void onPause() {
        if (!mIsCreated) {
            super.onPause();
            return;
        }
        onPauseImpl();
    }

    protected void onPauseImpl() {
        if (mUserMenu != null) {
            mUserMenu.dismiss();
        }

        super.onPause();
    }

    @Override protected final void onStop() {
        if (!mIsCreated) {
            super.onStop();
            return;
        }

        onStopImpl();
    }

    protected void onStopImpl() {
        super.onStop();
    }

    protected void onTick() {
        Duration idle = getIdleDuration();
        Duration docked = batteryWatcher.getDockedDuration();
        Duration idleLimit = batteryWatcher.isDocked() ?
            DOCKED_AUTOLOGOUT_IDLE_DURATION :
            UNDOCKED_AUTOLOGOUT_IDLE_DURATION;
        if (idle.isLongerThan(idleLimit)) {
            LOG.i("Auto logout (idle for %s, docked for %s)", idle, docked);
            BigToast.show(R.string.idle_signed_out);
            Utils.jumpToActivity(this, LoginActivity.class);
        }
    }

    protected ReadyState getReadyState() {
        return mReadyState;
    }

    /** Changes the activity's ready state and updates the set of available buttons. */
    protected void setReadyState(ReadyState state) {
        if (mReadyState != state) {
            mReadyState = state;
            invalidateOptionsMenu();
        }
    }

    class UserMenuPopup extends PopupWindow {

        private final LinearLayout mLayout;

        @InjectView(R.id.user_name) TextView mUserName;
        @InjectView(R.id.language) TextView mLanguage;
        @InjectView(R.id.button_settings) ImageButton mSettingsButton;
        @InjectView(R.id.button_log_out) ImageButton mLogOutButton;

        @SuppressLint("InflateParams")
        public UserMenuPopup() {
            super();

            mLayout = (LinearLayout) getLayoutInflater()
                .inflate(R.layout.user_menu_popup, null);
            setContentView(mLayout);

            ButterKnife.inject(this, mLayout);

            setWindowLayoutMode(
                ViewGroup.LayoutParams.WRAP_CONTENT,
                ViewGroup.LayoutParams.WRAP_CONTENT);
            setFocusable(true);
            setOutsideTouchable(true);
            setBackgroundDrawable(new BitmapDrawable());
        }

        @Override public void showAsDropDown(View anchor) {
            super.showAsDropDown(anchor);
            JsonUser user = App.getUserManager().getActiveUser();
            mUserName.setText(user != null ? user.getLocalizedName() : "?");
        }

        @OnClick(R.id.language)
        public void onLanguageClick() {
            Utils.logUserAction("user_menu_language_pressed");
            String[] languageTags = AppSettings.getLocaleOptionValues();
            new AlertDialog.Builder(LoggedInActivity.this)
                .setTitle(R.string.pref_title_language)
                .setSingleChoiceItems(
                    AppSettings.getLocaleOptionLabels(),
                    App.getSettings().getLocaleIndex(),
                    (view, index) -> {
                        App.getSettings().setLocale(languageTags[index]);
                        Utils.restartActivity(LoggedInActivity.this);
                    }
                ).show();
        }

        @OnClick(R.id.button_settings)
        public void onSettingsClick() {
            Utils.logUserAction("user_menu_settings_pressed");
            SettingsActivity.start(LoggedInActivity.this);
        }

        @OnClick(R.id.button_log_out)
        public void onLogOutClick() {
            Utils.logUserAction("user_menu_logout_pressed");
            App.getUserManager().setActiveUser(null);

            Intent intent = new Intent(LoggedInActivity.this, LoginActivity.class);
            intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);
            startActivity(intent);
        }
    }
}


// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui;

import android.app.Activity;
import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.net.Uri;

import com.android.volley.Response;
import com.android.volley.TimeoutError;
import com.android.volley.VolleyError;
import com.google.common.base.Charsets;
import com.google.common.base.Joiner;

import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.instance.TreeElement;
import org.javarosa.xform.parse.XFormParser;
import org.joda.time.DateTime;
import org.joda.time.format.ISODateTimeFormat;
import org.json.JSONObject;
import org.odk.collect.android.activities.FormEntryActivity;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.model.Preset;
import org.odk.collect.android.provider.FormsProviderAPI;
import org.odk.collect.android.tasks.DeleteInstancesTask;
import org.odk.collect.android.utilities.FileUtils;
import org.projectbuendia.client.App;
import org.projectbuendia.client.AppSettings;
import org.projectbuendia.client.events.FetchXformFailedEvent;
import org.projectbuendia.client.events.SubmitXformFailedEvent;
import org.projectbuendia.client.events.SubmitXformSucceededEvent;
import org.projectbuendia.client.exception.ValidationException;
import org.projectbuendia.client.json.JsonUser;
import org.projectbuendia.models.tasks.DenormalizeObsTask;
import org.projectbuendia.client.net.OdkDatabase;
import org.projectbuendia.client.net.OdkXformSyncTask;
import org.projectbuendia.client.net.OpenMrsXformIndexEntry;
import org.projectbuendia.client.net.OpenMrsXformsConnection;
import org.projectbuendia.client.providers.Contracts;
import org.projectbuendia.client.providers.Contracts.Observations;
import org.projectbuendia.client.sync.ConceptService;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.net.HttpURLConnection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.Nullable;

import de.greenrobot.event.EventBus;

import static android.provider.BaseColumns._ID;
import static java.lang.String.format;
import static org.odk.collect.android.provider.InstanceProviderAPI.InstanceColumns.CONTENT_ITEM_TYPE;
import static org.odk.collect.android.provider.InstanceProviderAPI.InstanceColumns.INSTANCE_FILE_PATH;

/** Convenience class for launching ODK to display an Xform. */
public class OdkActivityLauncher {

    private static final Logger LOG = Logger.create();

    /**
     * Fetches all xforms from the server and caches them. If any error occurs during fetching,
     * a failed event is triggered.
     */
    public static void fetchAndCacheAllXforms() {
        LOG.i("Listing all forms from server (in order to cache them)");
        new OpenMrsXformsConnection(App.getConnectionDetails()).listXforms(
            response -> {
                if (App.getSyncManager().getNewSyncsSuppressed()) {
                    LOG.w("Skipping form sync: New syncs are currently suppressed.");
                    return;
                }
                for (OpenMrsXformIndexEntry formEntry : response) {
                    fetchAndCacheXForm(formEntry);
                }
            }, OdkActivityLauncher::handleFetchError
        );
    }

    /**
     * Fetches the xform specified by the form uuid.
     *
     * @param formEntry the {@link OpenMrsXformIndexEntry} object containing the uuid form
     */
    public static void fetchAndCacheXForm(OpenMrsXformIndexEntry formEntry) {
        new OdkXformSyncTask(null).fetchAndAddXFormToDb(
            formEntry.uuid, formEntry.getPathForForm());
    }

    /**
     * Opens an XForm in the ODK form activity.  First, attempts to load the
     * form from a cache file; if the file is missing or out of date, the form
     * is fetched from the server.
     *
     * CONTRACT: If the form successfully opens, syncs will be stopped and
     * suppressed.  It is the caller's responsibility to re-enable syncs when
     * the form activity closes and returns its result to onActivityResult().
     */
    public static void fetchAndShowXform(
        final Activity callingActivity,
        final String formUuid,
        final int requestCode,  // will be passed to onActivityResult()
        @Nullable final org.odk.collect.android.model.Patient patient,
        @Nullable final Preset fields) {
        LOG.i("Trying to load cached file for form %s", formUuid);
        if (loadXformFromCache(callingActivity, formUuid, requestCode, patient, fields)) {
            return;
        }

        LOG.i("Form %s not found in cache; getting form list from server.", formUuid);
        new OpenMrsXformsConnection(App.getConnectionDetails()).listXforms(
            response -> {
                if (response.isEmpty()) {
                    LOG.i("Server returned an empty list of forms.");
                    EventBus.getDefault().post(new FetchXformFailedEvent(
                        FetchXformFailedEvent.Reason.NO_FORMS_FOUND));
                    return;
                }
                showForm(callingActivity, requestCode, patient, fields, findUuid(response,
                    formUuid));
            }, error -> {
                LOG.e(error, "Failed to fetch list of forms from server.");
                handleFetchError(error);
            });
    }

    /**
     * Shows the form with the given id in ODK collect.
     * @param callingActivity the {@link Activity} requesting the xform; when ODK closes, the user
     *                        will be returned to this activity
     * @param requestCode     if >= 0, this code will be returned in onActivityResult() when the
     *                        activity exits
     * @param formId          the id of the form to fetch
     * @param patient         the {@link org.odk.collect.android.model.Patient} that this form entry will
     *                        correspond to
     * @param preset          a {@link Preset} object with any form fields that should be
     *                        pre-populated
     */
    public static void showOdkCollect(
        Activity callingActivity,
        int requestCode,
        long formId,
        @Nullable org.odk.collect.android.model.Patient patient,
        @Nullable Preset preset) {
        FormEntryActivity.locale = App.getSettings().getLocale();
        LOG.i("Launching FormEntryActivity with formId = %d, locale = %s", formId, FormEntryActivity.locale);
        Intent intent = new Intent(callingActivity, FormEntryActivity.class);
        Uri formUri = ContentUris.withAppendedId(FormsProviderAPI.FormsColumns.CONTENT_URI, formId);
        intent.setData(formUri);
        intent.setAction(Intent.ACTION_PICK);
        if (patient != null) {
            intent.putExtra("patient", patient);
        }
        if (preset != null) {
            intent.putExtra("fields", preset);
        }
        callingActivity.startActivityForResult(intent, requestCode);
    }

    /**
     * Loads the xform from the cache and launches ODK using it. Return true if the cache is
     * available.
     * @param callingActivity the {@link Activity} requesting the xform; when ODK closes, the user
     *                        will be returned to this activity
     * @param uuidToShow      UUID of the form to show
     * @param requestCode     if >= 0, this code will be returned in onActivityResult() when the
     *                        activity exits
     * @param patient         the {@link org.odk.collect.android.model.Patient} that this form entry will
     *                        correspond to
     * @param fields          a {@link Preset} object with any form fields that should be
     *                        pre-populated
     */
    private static boolean loadXformFromCache(final Activity callingActivity,
                                              final String uuidToShow,
                                              final int requestCode,
                                              @Nullable final org.odk.collect.android.model.Patient patient,
                                              @Nullable final Preset fields) {
        List<OpenMrsXformIndexEntry> entries = getLocalFormEntries();
        OpenMrsXformIndexEntry formToShow = findUuid(entries, uuidToShow);
        File path = formToShow.getPathForForm();
        boolean exists = path.exists();
        LOG.i("Checking for form at %s: %s", path, exists ? "file exists" : "no such file");
        if (!exists) return false;

        LOG.i(format("Using form %s from local cache.", uuidToShow));
        showForm(callingActivity, requestCode, patient, fields, formToShow);
        return true;
    }

    private static List<OpenMrsXformIndexEntry> getLocalFormEntries() {
        List<OpenMrsXformIndexEntry> entries = new ArrayList<>();

        final ContentResolver resolver = App.getResolver();
        try (Cursor c = resolver.query(Contracts.Forms.URI, new String[] {
            Contracts.Forms.UUID, Contracts.Forms.NAME
        }, null, null, null)) {
            while (c.moveToNext()) {
                String uuid = Utils.getString(c, Contracts.Forms.UUID);
                String name = Utils.getString(c, Contracts.Forms.NAME);
                long date = 0; // date is not important here
                entries.add(new OpenMrsXformIndexEntry(uuid, name, date));
            }
        }
        return entries;
    }

    /**
     * Launches ODK using the requested form.
     * @param callingActivity the {@link Activity} requesting the xform; when ODK closes, the user
     *                        will be returned to this activity
     * @param requestCode     if >= 0, this code will be returned in onActivityResult() when the
     *                        activity exits
     * @param patient         the {@link org.odk.collect.android.model.Patient} that this form entry will
     *                        correspond to
     * @param fields          a {@link Preset} object with any form fields that should be
     *                        pre-populated
     * @param formToShow    a {@link OpenMrsXformIndexEntry} object representing the form that
     *                       should be opened
     */
    private static void showForm(final Activity callingActivity,
                                 final int requestCode,
                                 @Nullable final org.odk.collect.android.model.Patient patient,
                                 @Nullable final Preset fields,
                                 final OpenMrsXformIndexEntry formToShow) {
        new OdkXformSyncTask((path, uuid) -> {
            LOG.i("Wrote form %s; now suppressing syncs", path);
            App.getSyncManager().setNewSyncsSuppressed(true);
            App.getSyncManager().stopSyncing(() -> showOdkCollect(
                callingActivity, requestCode,
                OdkDatabase.getFormIdForPath(path), patient, fields)
            );
        }).execute(formToShow);
    }

    // Out of a list of OpenMRS Xform entries, find the form that matches the given uuid, or
    // return null if no xform is found.
    private static OpenMrsXformIndexEntry findUuid(
        List<OpenMrsXformIndexEntry> allEntries, String uuid) {
        for (OpenMrsXformIndexEntry entry : allEntries) {
            if (entry.uuid.equals(uuid)) {
                return entry;
            }
        }
        return null;
    }

    /**
     * Convenient shared code for handling an ODK activity result.
     * @param context           the application context
     * @param settings          the application settings
     * @param patientUuid       the patient to add an observation to, or null to create a new patient
     * @param resultCode        the result code sent from Android activity transition
     * @param data              the incoming intent
     */
    public static void sendOdkResultToServer(
        final Context context,
        final AppSettings settings,
        @Nullable final String patientUuid,
        int resultCode,
        Intent data) {

        if (isActivityCanceled(resultCode, data)) return;

        try {
            final Uri uri = data.getData();
            if(!validateContentUriType(context, uri, CONTENT_ITEM_TYPE)) {
                throw new ValidationException("Tried to load a content URI of the wrong type: "
                    + uri);
            }

            final String filePath = getFormFilePath(context, uri);
            if(!validateFilePath(filePath, uri)) {
                throw new ValidationException("No file path for form instance: " + uri);
            }

            final Long formIdToDelete = getIdToDeleteAfterUpload(context, uri);
            if(!validateIdToDeleteAfterUpload(formIdToDelete, uri)) {
                throw new ValidationException("No id to delete for after upload: " + uri);
            }

            // Temporary code for messing about with xform instance, reading values.
            byte[] fileBytes = FileUtils.getFileAsBytes(new File(filePath));

            // get the root of the saved and template instances
            final TreeElement savedRoot = XFormParser.restoreDataModel(fileBytes, null).getRoot();

            final String xml = readFromPath(filePath);
            if(!validateXml(xml)) {
                throw new ValidationException("Xml form is not valid for uri: " + uri);
            }

            sendFormToServer(patientUuid, xml,
                response -> {
                    LOG.i("Created new encounter successfully on server" + response.toString());
                    // Only locally cache new observations, not new patients.
                    if (patientUuid != null) {
                        updateObservationCache(patientUuid, savedRoot, context.getContentResolver());
                    }
                    if (!settings.getFormInstancesRetainedLocally()) {
                        deleteLocalFormInstances(formIdToDelete);
                    }
                    EventBus.getDefault().post(new SubmitXformSucceededEvent());
                }, error -> {
                    LOG.e(error, "Error submitting form to server");
                    handleSubmitError(error);
                });
        } catch(ValidationException ve) {
            LOG.e(ve.getMessage());
            EventBus.getDefault().post(
                new SubmitXformFailedEvent(SubmitXformFailedEvent.Reason.CLIENT_ERROR));
        }
    }

    /**
     * Checks if the file path is valid. If so, it returns {@code true}. Otherwise returns
     * {@code false}
     * @param filePath               the file path to be validated
     * @param uri                    the form uri
     */
    private static boolean validateFilePath(String filePath, Uri uri) {
        return filePath != null;
    }

    /** Checks if the URI has a valid type. If so, returns {@code true}. Otherwise,  returns {@code false}
     * @param context           the application context
     * @param uri               the URI to be checked
     * @param validType         the accepted type for URI
     */
    private static boolean validateContentUriType(final Context context, final Uri uri,
                                                  final String validType) {
        return context.getContentResolver().getType(uri).equals(validType);
    }

    /**
     * Validates the id to be deleted after the form upload. If id is valid, it returns
     * {@code true}. Otherwise, returns {@code false}.
     * @param id           the id to be deleted
     * @param uri               the URI containing the id to be deleted
     */
    private static boolean validateIdToDeleteAfterUpload(final Long id, Uri uri) {
        return id != null;
    }

    /**
     * Validates the xml. Returns {@code true} if it is valid. Otherwise, returns {@code false}
     */
    private static boolean validateXml(String xml) {
        return xml != null;
    }

    private static void deleteLocalFormInstances(Long formIdToDelete) {
        //Code largely copied from InstanceUploaderTask to delete on upload
        DeleteInstancesTask dit = new DeleteInstancesTask();
        dit.setContentResolver(
            Collect.getInstance().getApplication()
                .getContentResolver());
        dit.execute(formIdToDelete);
    }

    /**
     * Returns the form file path queried from the given {@link Uri}. If no file path was found,
     * it returns <code>null</code>.
     * @param context           the application context
     * @param uri               the URI containing the form file path
     */
    private static String getFormFilePath(final Context context, final Uri uri) {
        try (Cursor instanceCursor = getCursorAtRightPosition(context, uri)) {
            if (instanceCursor == null) return null;
            return instanceCursor.getString(instanceCursor.getColumnIndex(INSTANCE_FILE_PATH));
        }
    }

    /**
     * Returns the id to be deleted after the form upload, which was queried from the given
     * {@link Uri}. If no id was found, it returns <code>null</code>.
     * @param context           the application context
     * @param uri               the URI containing the id to be deleted
     */
    private static Long getIdToDeleteAfterUpload(final Context context, final Uri uri) {
        try (Cursor instanceCursor = getCursorAtRightPosition(context, uri)) {
            if (instanceCursor == null) return null;

            int columnIndex = instanceCursor.getColumnIndex(_ID);
            if (columnIndex == -1) return null;

            return instanceCursor.getLong(columnIndex);
        }
    }

    /**
     * Returns the form {@link Cursor} ready to be used. If no form was found, it triggers a
     * {@link SubmitXformFailedEvent} event and returns <code>null</code>.
     * @param context           the application context
     * @param uri               the URI to be queried
     */
    private static Cursor getCursorAtRightPosition(final Context context, final Uri uri) {
        Cursor instanceCursor = context.getContentResolver().query(uri, null, null, null, null);
        if (instanceCursor.getCount() != 1) {
            LOG.e("The form that we tried to load did not exist: " + uri);
            EventBus.getDefault().post(
                new SubmitXformFailedEvent(SubmitXformFailedEvent.Reason.CLIENT_ERROR));
            return null;
        }
        instanceCursor.moveToFirst();

        return instanceCursor;
    }

    /**
     * Returns true if the activity was canceled
     * @param resultCode        the result code sent from Android activity transition
     * @param data              the incoming intent
     */
    private static boolean isActivityCanceled(int resultCode, Intent data) {
        if (resultCode == Activity.RESULT_CANCELED) return true;
        if (data == null || data.getData() == null) {
            LOG.i("No data for form result, probably cancelled.");
            return true;
        }
        return false;
    }

    private static void sendFormToServer(String patientUuid, String xml,
                                         Response.Listener<JSONObject> successListener,
                                         Response.ErrorListener errorListener) {
        OpenMrsXformsConnection connection =
            new OpenMrsXformsConnection(App.getConnectionDetails());
        JsonUser activeUser = App.getUserManager().getActiveUser();
        LOG.i("Submitting form instance to server");
        connection.postXformInstance(
                patientUuid, activeUser.getUuid(), xml, successListener, errorListener);
    }

    private static void handleSubmitError(VolleyError error) {
        SubmitXformFailedEvent.Reason reason =  SubmitXformFailedEvent.Reason.UNKNOWN;

        if (error instanceof TimeoutError) {
            reason = SubmitXformFailedEvent.Reason.SERVER_TIMEOUT;
        } else if (error.networkResponse != null) {
            switch (error.networkResponse.statusCode) {
                case HttpURLConnection.HTTP_UNAUTHORIZED:
                case HttpURLConnection.HTTP_FORBIDDEN:
                    reason = SubmitXformFailedEvent.Reason.SERVER_AUTH;
                    break;
                case HttpURLConnection.HTTP_NOT_FOUND:
                    reason = SubmitXformFailedEvent.Reason.SERVER_BAD_ENDPOINT;
                    break;
                case HttpURLConnection.HTTP_INTERNAL_ERROR:
                    if (error.networkResponse.data == null) {
                        LOG.e("Server error, but no internal error stack trace available.");
                    } else {
                        LOG.e(new String(error.networkResponse.data, Charsets.UTF_8));
                        LOG.e("Server error. Internal error stack trace:\n");
                    }
                    reason = SubmitXformFailedEvent.Reason.SERVER_ERROR;
                    break;
                default:
                    reason = SubmitXformFailedEvent.Reason.SERVER_ERROR;
                    break;
            }
        }

        EventBus.getDefault().post(new SubmitXformFailedEvent(reason, error));
    }

    private static void handleFetchError(VolleyError error) {
        FetchXformFailedEvent.Reason reason =
            FetchXformFailedEvent.Reason.SERVER_UNKNOWN;
        if (error.networkResponse != null) {
            switch (error.networkResponse.statusCode) {
                case HttpURLConnection.HTTP_FORBIDDEN:
                case HttpURLConnection.HTTP_UNAUTHORIZED:
                    reason = FetchXformFailedEvent.Reason.SERVER_AUTH;
                    break;
                case HttpURLConnection.HTTP_NOT_FOUND:
                    reason = FetchXformFailedEvent.Reason.SERVER_BAD_ENDPOINT;
                    break;
                case HttpURLConnection.HTTP_INTERNAL_ERROR:
                default:
                    reason = FetchXformFailedEvent.Reason.SERVER_UNKNOWN;
            }
        }
        EventBus.getDefault().post(new FetchXformFailedEvent(reason, error));
    }

    /**
     * Returns the xml form as a String from the path. If for any reason, the file couldn't be read,
     * it returns <code>null</code>
     * @param path      the path to be read
     */
    private static String readFromPath(String path) {
        try {
            StringBuilder sb = new StringBuilder();
            BufferedReader reader = new BufferedReader(new FileReader(path));
            String line;
            while ((line = reader.readLine()) != null) {
                sb.append(line).append("\n");
            }
            return sb.toString();
        } catch (IOException e) {
            LOG.e(e, format("Failed to read XML form at: %s", path));
            return null;
        }
    }

    /**
     * Caches the observation changes locally for a given patient.
     */
    private static void updateObservationCache(String patientUuid, TreeElement savedRoot,
                                               ContentResolver resolver) {
        ContentValues common = new ContentValues();
        // It's critical that UUID is {@code null} for temporary observations, so we make it
        // explicit here. See {@link Contracts.Observations.UUID} for details.
        common.put(Observations.UUID, (String) null);
        common.put(Observations.PATIENT_UUID, patientUuid);
        common.put(Observations.PROVIDER_UUID, Utils.getProviderUuid());

        final DateTime encounterTime = getEncounterAnswerDateTime(savedRoot);
        if (encounterTime == null) return;
        common.put(Observations.MILLIS, encounterTime.getMillis());

        Set<Integer> xformConceptIds = new HashSet<>();
        List<ContentValues> toInsert = getAnsweredObservations(common, savedRoot, xformConceptIds);
        Map<String, String> xformIdToUuid = mapFormConceptIdToUuid(xformConceptIds, resolver);
        ConceptService concepts = App.getConceptService();

        // Remap concept ids to uuids, skipping anything we can't remap.
        for (Iterator<ContentValues> i = toInsert.iterator(); i.hasNext(); ) {
            ContentValues values = i.next();
            String conceptUuid = mapIdToUuid(xformIdToUuid, values, Observations.CONCEPT_UUID);
            if (conceptUuid == null) {
                i.remove();
            } else {
                values.put(Observations.TYPE, concepts.getType(conceptUuid).name());
                mapIdToUuid(xformIdToUuid, values, Observations.VALUE);
            }
        }

        ContentValues[] values = toInsert.toArray(new ContentValues[toInsert.size()]);
        resolver.bulkInsert(Observations.URI, values);
        if (DenormalizeObsTask.needsDenormalization(values)) {
            App.getModel().denormalizeObservations(App.getCrudEventBus(), patientUuid);
        }
    }

    /** Get a map from XForm ids to UUIDs from our local concept database. */
    private static Map<String, String> mapFormConceptIdToUuid(Set<Integer> xformConceptIds,
                                                              ContentResolver resolver) {
        String inClause = Joiner.on(",").join(xformConceptIds);
        HashMap<String, String> xformIdToUuid = new HashMap<>();

        try (Cursor cursor = resolver.query(
            Contracts.Concepts.URI,
            new String[] {Contracts.Concepts.UUID, Contracts.Concepts.XFORM_ID},
            Contracts.Concepts.XFORM_ID + " IN (" + inClause + ")",
            null, null
        )) {
            while (cursor.moveToNext()) {
                xformIdToUuid.put(Utils.getString(cursor, Contracts.Concepts.XFORM_ID),
                    Utils.getString(cursor, Contracts.Concepts.UUID));
            }
        }

        return xformIdToUuid;
    }

    /**
     * Returns a {@link ContentValues} list containing the id concept and the answer valeu from
     * all answered observations. Returns a empty {@link List} if no observation was answered.
     *
     * @param common                        the current content values.
     * @param savedRoot                     the root forest form element
     * @param xformConceptIdsAccumulator    the set to store the form concept ids found
     */
    private static List<ContentValues> getAnsweredObservations(
        ContentValues common, TreeElement savedRoot, Set<Integer> xformConceptIdsAccumulator) {
        List<ContentValues> answeredObservations = new ArrayList<>();
        for (int i = 0; i < savedRoot.getNumChildren(); i++) {
            TreeElement group = savedRoot.getChildAt(i);
            if (group.getNumChildren() == 0) continue;
            for (int j = 0; j < group.getNumChildren(); j++) {
                TreeElement question = group.getChildAt(j);
                TreeElement openmrsConcept = question.getAttribute(null, "openmrs_concept");
                TreeElement openmrsDatatype = question.getAttribute(null, "openmrs_datatype");
                if (openmrsConcept == null || openmrsDatatype == null) continue;

                // Get the concept for the question.
                // eg "5088^Temperature (C)^99DCT"
                String encodedConcept = (String) openmrsConcept.getValue().getValue();
                Integer id = getConceptId(xformConceptIdsAccumulator, encodedConcept);
                if (id == null) continue;

                // Also get for the answer if a coded question
                TreeElement valueChild = question.getChild("value", 0);
                IAnswerData answer = valueChild.getValue();
                if (answer == null || answer.getValue() == null) continue;

                Object answerObject = answer.getValue();
                String value;
                Object typeCode = openmrsDatatype.getValue().getValue();
                if ("CWE".equals(typeCode)) {
                    value = getConceptId(xformConceptIdsAccumulator, answerObject.toString()).toString();
                } else if ("TS".equals(typeCode)) {
                    value = "" + DateTime.parse(answerObject.toString()).getMillis();
                } else {
                    value = answerObject.toString();
                }

                ContentValues observation = new ContentValues(common);
                // Set to the id for now, we'll replace with uuid later
                observation.put(Observations.CONCEPT_UUID, id.toString());
                observation.put(Observations.VALUE, value);

                answeredObservations.add(observation);
            }
        }
        return answeredObservations;
    }

    /**
     * Returns the encounter's answer date time. Returns <code>null</code> if it cannot be retrieved.
     */
    private static DateTime getEncounterAnswerDateTime(TreeElement root) {
        TreeElement encounter = root.getChild("encounter", 0);
        if (encounter == null) {
            LOG.e("No encounter found in instance");
            return null;
        }

        TreeElement encounterDatetime =
            encounter.getChild("encounter.encounter_datetime", 0);
        if (encounterDatetime == null) {
            LOG.e("No encounter date time found in instance");
            return null;
        }

        IAnswerData dateTimeValue = encounterDatetime.getValue();
        try {
         return  ISODateTimeFormat.dateTime().parseDateTime((String) dateTimeValue.getValue());
        } catch (IllegalArgumentException e) {
            LOG.e("Could not parse datetime: %s", dateTimeValue.getValue());
            return null;
        }
    }

    private static Integer getConceptId(Set<Integer> accumulator, String encodedConcept) {
        Integer id = getConceptId(encodedConcept);
        if (id != null) {
            accumulator.add(id);
        }
        return id;
    }

    private static String mapIdToUuid(
        Map<String, String> idToUuid, ContentValues values, String key) {
        String id = (String) values.get(key);
        String uuid = idToUuid.get(id);
        if (uuid != null) values.put(key, uuid);
        return uuid;
    }

    private static Integer getConceptId(String encodedConcept) {
        int idEnd = encodedConcept.indexOf('^');
        if (idEnd == -1) {
            return null;
        }
        String idString = encodedConcept.substring(0, idEnd);
        try {
            return Integer.parseInt(idString);
        } catch (NumberFormatException ex) {
            LOG.w("Strangely formatted id String " + idString);
            return null;
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui;

import android.content.Context;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;

import org.projectbuendia.client.App;
import org.projectbuendia.client.R;

import java.util.Locale;

/** A {@link Toast} with a large text size. */
public final class BigToast {
    /** Displays a toast with the given message. */
    private static void pop(String message, int length) {
        Context context = App.getContext();
        Toast toast = Toast.makeText(context, message, length);
        LinearLayout layout = (LinearLayout) toast.getView();
        TextView view = (TextView) layout.getChildAt(0);
        view.setTextAppearance(context, R.style.text_large_white);
        toast.show();
    }

    public static void show(String message) {
        pop(message, Toast.LENGTH_LONG);
    }

    /**  Displays a toast with the given formatted string resource. */
    public static void show(int messageId, Object... args) {
        pop(format(App.str(messageId), args), Toast.LENGTH_LONG);
    }

    /** Displays a toast with the given formatted string. */
    public static void show(String message, Object... args) {
        pop(format(message, args), Toast.LENGTH_LONG);
    }

    public static void brief(String message) {
        pop(message, Toast.LENGTH_SHORT);
    }

    public static void brief(int messageId, Object... args) {
        pop(format(App.str(messageId), args), Toast.LENGTH_SHORT);
    }

    public static void brief(String message, Object... args) {
        pop(format(message, args), Toast.LENGTH_SHORT);
    }

    private static String format(String message, Object... args) {
        Context context = App.getContext();
        Locale locale = context.getResources().getConfiguration().locale;
        return String.format(locale, message, args);
    }

    private BigToast() {
        // Prevent instantiation.
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui;

import android.content.Context;
import android.graphics.PorterDuff;
import android.os.AsyncTask;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseExpandableListAdapter;
import android.widget.ExpandableListView;
import android.widget.ImageView;
import android.widget.TextView;

import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.models.ConceptUuids;
import org.projectbuendia.models.Location;
import org.projectbuendia.models.LocationForest;
import org.projectbuendia.models.Obs;
import org.projectbuendia.models.Patient;
import org.projectbuendia.models.TypedCursor;
import org.projectbuendia.client.resolvables.ResStatus;
import org.projectbuendia.client.sync.ChartDataHelper;
import org.projectbuendia.client.utils.ContextUtils;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;
import org.projectbuendia.client.widgets.ShrinkFitTextView;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import butterknife.ButterKnife;
import butterknife.InjectView;

import static org.projectbuendia.client.utils.ContextUtils.FormatStyle.NONE;
import static org.projectbuendia.client.utils.ContextUtils.FormatStyle.SHORT;
import static org.projectbuendia.client.utils.Utils.eq;

/**
 * A ListAdapter that displays Patients from a TypedCursor, grouped by location
 * and filtered by an optional SimpleSelectionFilter.
 */
public class PatientListAdapter extends BaseExpandableListAdapter {
    protected final ContextUtils u;
    private final HashMap<Location, List<Patient>> mPatientsByLocation;
    private final ChartDataHelper mChartDataHelper;

    private static final Logger LOG = Logger.create();

    private Location[] mLocations;
    private Map<String, Obs> mConditionObs = new HashMap<>();
    private boolean mGroupsVisible = true;

    public PatientListAdapter(Context context) {
        u = ContextUtils.from(context);
        mPatientsByLocation = new HashMap<>();
        mChartDataHelper = App.getChartDataHelper();
    }

    @Override public int getGroupCount() {
        return mPatientsByLocation != null ? mPatientsByLocation.size() : 0;
    }

    @Override public long getGroupId(int groupIndex) {
        return groupIndex;
    }

    @Override public long getChildId(int groupIndex, int childIndex) {
        return childIndex;
    }

    @Override public boolean hasStableIds() {
        return false;
    }

    @Override public View getGroupView(
        int groupIndex, boolean isExpanded, View view, ViewGroup parent) {
        if (!mGroupsVisible) {
            return u.inflate(R.layout.patient_list_empty_heading, parent);
        }

        Location location = getGroup(groupIndex);
        view = u.reuseOrInflate(view, R.layout.patient_list_group_heading, parent);

        ((ExpandableListView) parent).expandGroup(groupIndex);
        TextView item = view.findViewById(R.id.heading);
        item.setText(u.formatLocationHeading(
            location.uuid, getChildrenCount(groupIndex)));
        return view;
    }

    @Override public Location getGroup(int groupIndex) {
        if (mLocations == null) {
            LOG.e("getGroup: mLocations is null! (see issue #352)");
            return null;
        }
        return mLocations[groupIndex];
    }

    @Override public int getChildrenCount(int groupIndex) {
        LOG.d("getChildrenCount: mLocations = %s (%d), groupIndex = %d", mLocations, mLocations != null ? mLocations.length : -1, groupIndex);
        Location location = getGroup(groupIndex);
        if (mPatientsByLocation == null || location == null) {
            return 0;
        }

        return mPatientsByLocation.get(location).size();
    }

    @Override public View getChildView(int groupIndex, int childIndex,
        boolean isLastChild, View view, ViewGroup parent) {
        Patient patient = (Patient) getChild(groupIndex, childIndex);
        view = u.reuseOrInflate(view, R.layout.patient_list_item, parent);

        // Show condition, if the data for this has been loaded.
        Obs obs = mConditionObs.get(patient.uuid);
        String condition = obs != null ? obs.value : null;
        ResStatus.Resolved status =
            ConceptUuids.getResStatus(condition).resolve(u.getResources());

        u.setContainer(view);
        u.setText(R.id.name, u.formatPatientName(patient));
        u.setText(R.id.bed_number, patient.bedNumber);
        u.show(R.id.bed_bar, !Utils.isEmpty(patient.bedNumber));
        ShrinkFitTextView idView = u.findView(R.id.id);
        idView.setTextAndResize(patient.id.replace('/', ' '));
        idView.setTextColor(status.getForegroundColor());
        idView.getBackground().setColorFilter(status.getBackgroundColor(), PorterDuff.Mode.SRC_ATOP);
        u.setText(R.id.sex, u.formatPatientDetails(patient, SHORT, SHORT, NONE));
        u.setText(R.id.age, u.formatPatientDetails(patient, NONE, NONE, SHORT));

        ((ExpandableListView) parent).expandGroup(groupIndex);
        return view;
    }

    @Override public Object getChild(int groupIndex, int childIndex) {
        return mPatientsByLocation.get(getGroup(groupIndex)).get(childIndex);
    }

    @Override public boolean isChildSelectable(int groupIndex, int childIndex) {
        return true;
    }

    /**
     * Updates the adapter to show all patients from the given cursor.  (Does not
     * take ownership; the original owner remains responsible for closing it.)
     */
    public void setPatients(TypedCursor<Patient> cursor, LocationForest forest, boolean showGroups) {
        mPatientsByLocation.clear();
        mGroupsVisible = showGroups;

        // Add all patients from cursor.
        int count = cursor.getCount();
        for (int i = 0; i < count; i++) {
            addPatient(cursor.get(i), forest);
        }

        // Produce a sorted list of all the locations that have patients.
        mLocations = new Location[mPatientsByLocation.size()];
        mPatientsByLocation.keySet().toArray(mLocations);
        forest.sort(mLocations);

        // Sort the patient lists within each location by bed number, then ID.
        for (List<Patient> patients : mPatientsByLocation.values()) {
            Collections.sort(patients, (a, b) ->
                !eq(a.bedNumber, b.bedNumber) ?
                    Utils.ALPHANUMERIC_COMPARATOR.compare(a.bedNumber, b.bedNumber) :
                    Utils.ALPHANUMERIC_COMPARATOR.compare(a.id, b.id)
            );
        }

        new FetchObservationsTask().execute();
        notifyDataSetChanged();
    }

    // Add a single patient to relevant data structures.
    private void addPatient(Patient patient, LocationForest forest) {
        Location location = forest.get(patient.locationUuid);
        if (location != null) {  // shouldn't be null, but better to be safe
            if (!mPatientsByLocation.containsKey(location)) {
                mPatientsByLocation.put(location, new ArrayList<>());
            }
            mPatientsByLocation.get(location).add(patient);
        }
    }

    private class FetchObservationsTask extends AsyncTask<String, Void, Void> {
        @Override protected Void doInBackground(String... params) {
            Locale locale = App.getSettings().getLocale();
            mConditionObs = mChartDataHelper.getLatestObservationsForConcept(ConceptUuids.CATEGORY_UUID);
            return null;
        }

        @Override protected void onPostExecute(Void result) {
            notifyDataSetChanged();
        }
    }

    static class ViewHolder {
        @InjectView(R.id.name) TextView mName;
        @InjectView(R.id.bed_number) TextView mBedNumber;
        @InjectView(R.id.id) TextView mId;
        @InjectView(R.id.sex) ImageView mSex;
        @InjectView(R.id.age) TextView mAge;

        public ViewHolder(View view) {
            ButterKnife.inject(this, view);
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;

import java.util.List;

/**
 * An {@link ArrayAdapter} that uses null values to indicate 'section' boundaries. Section
 * boundaries are represented by an arbitrary resource (such as a horizontal divider) and are not
 * clickable.
 */
public class SectionedSpinnerAdapter<T> extends ArrayAdapter<T> {
    private final List<T> mItems;
    private final int mSectionBorderResource;
    private final LayoutInflater mInflater;

    /**
     * Instantiates a {@link SectionedSpinnerAdapter} with the given resources and contents.
     * @param context               the Application or Activity context
     * @param collapsedResource     the {@link android.graphics.drawable.Drawable} used to display the
     *                              selected adapter item when the list is collapsed
     * @param dropDownResource      the {@link android.graphics.drawable.Drawable} used to display an
     *                              adapter item when the list is expanded
     * @param sectionBorderResource the {@link android.graphics.drawable.Drawable} used to display
     *                              section dividers (null items)
     * @param items                 the contents of the list
     */
    public SectionedSpinnerAdapter(
        Context context, int collapsedResource, int dropDownResource,
        int sectionBorderResource, List<T> items) {
        super(context, collapsedResource, items);
        mItems = items;
        mSectionBorderResource = sectionBorderResource;
        setDropDownViewResource(dropDownResource);

        mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);

    }

    @Override public View getDropDownView(int position, View convertView, ViewGroup parent) {
        if (isSectionBorder(position)) {
            return getSectionBorder(convertView, parent);
        }

        resetClickable(convertView);
        if (convertView != null && convertView.getTag() != ViewType.LIST_ITEM) {
            convertView = null;
        }

        View view = super.getDropDownView(position, convertView, parent);
        // Manually manage the different types of views, since Spinners don't
        // ordinarily support multiple view types and ignore getViewTypeCount().
        view.setTag(ViewType.LIST_ITEM);
        return view;
    }

    private boolean isSectionBorder(int position) {
        return position < mItems.size() && mItems.get(position) == null;
    }

    private View getSectionBorder(View convertView, ViewGroup parent) {
        if (convertView == null || convertView.getTag() != ViewType.SECTION_BORDER) {
            convertView = mInflater.inflate(mSectionBorderResource, parent, false);
        }
        convertView.setClickable(true);

        // Manually manage the different types of views, since Spinners don't
        // ordinarily support multiple view types and ignore getViewTypeCount().
        convertView.setTag(ViewType.SECTION_BORDER);

        return convertView;
    }

    private void resetClickable(View convertView) {
        if (convertView != null) {
            convertView.setClickable(false);
        }
    }

    @Override public View getView(int position, View convertView, ViewGroup parent) {
        if (isSectionBorder(position)) {
            return getSectionBorder(convertView, parent);
        }

        resetClickable(convertView);
        if (convertView != null && convertView.getTag() != ViewType.LIST_ITEM) {
            convertView = null;
        }

        View view = super.getView(position, convertView, parent);
        // Manually manage the different types of views, since Spinners don't
        // ordinarily support multiple view types and ignore getViewTypeCount().
        view.setTag(ViewType.LIST_ITEM);
        return view;
    }

    @Override public int getViewTypeCount() {
        // For targetSdkVersion >= LOLLIPOP (21), this is required to return 1.
        return 1;
    }

    /**
     * Returns the type for the view at the given position, where valid types are ordinal values of
     * the {@link ViewType} enum.
     * @param position the position of the view in the adapter
     */
    public int getItemViewType(int position) {
        return isSectionBorder(position)
            ? ViewType.SECTION_BORDER.ordinal()
            : ViewType.LIST_ITEM.ordinal();
    }

    private enum ViewType {
        SECTION_BORDER, LIST_ITEM
    }
}

package org.projectbuendia.client.ui;

import android.content.Context;
import android.support.annotation.NonNull;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.Filter;

import java.util.ArrayList;
import java.util.List;

public class AutocompleteAdapter<T> extends ArrayAdapter<T> {
    private final LayoutInflater inflater;
    private final int resourceId;
    private final Filter filter;
    private final CompletionAdapter<T> adapter;

    public AutocompleteAdapter(Context context, int resourceId, CompletionAdapter<T> adapter) {
        super(context, resourceId, 0, new ArrayList<>());
        this.inflater = LayoutInflater.from(context);
        this.resourceId = resourceId;
        this.adapter = adapter;
        this.filter = new Filter() {
            @Override protected FilterResults performFiltering(CharSequence constraint) {
                FilterResults results = new FilterResults();
                if (constraint != null) {
                    List<T> completions = adapter.suggestCompletions(constraint);
                    results.values = completions;
                    results.count = completions.size();
                }
                return results;
            }

            @Override public CharSequence convertResultToString(Object result) {
                return adapter.getCompletedText((T) result);
            }

            @Override protected void publishResults(CharSequence constraint, FilterResults results) {
                if (results != null && results.count > 0) {
                    clear();
                    addAll((List<T>) results.values);
                }
            }
        };
    }

    @Override public @NonNull View getView(int position, View reusableView, @NonNull ViewGroup parent) {
        View view = reusableView;
        if (view == null) {
            view = inflater.inflate(resourceId, parent, false);
        }
        adapter.showInView(view, getItem(position));
        return view;
    }

    @Override public long getItemId(int position) {
        return position;
    }

    @Override public @NonNull Filter getFilter() {
        return filter;
    }

    public interface CompletionAdapter<T> {
        List<T> suggestCompletions(CharSequence constraint);
        void showInView(View itemView, T item);
        @NonNull String getCompletedText(T item);
    }
}

package org.projectbuendia.client.ui;

import android.support.annotation.NonNull;
import android.view.View;

import org.projectbuendia.client.R;
import org.projectbuendia.client.utils.Intl;
import org.projectbuendia.client.utils.Utils;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Set;

public class MedCompleter {

    // ==== Style conventions for captions ====
    //
    // A caption describes a primary category of therapeutic action, in lowercase.
    //   - A good test for this part is that it should have a plural form.
    //   - Use a noun, not a verb phrase (e.g. "abortifacient", not "causes abortion")
    //   - Use a noun, not an adjective (e.g. "anticonvulsant", not "anticonvulsive")
    //   - Describe the drug, not the action (e.g. "laxative", not "laxation")
    //   - Describe the drug, not the disease (e.g. "antimalarial", not "malaria")
    //   - For multiple purposes, use a comma (e.g. "antiseptic, disinfectant")
    //   - If primarily for a specific disease, optionally append "for" and the
    //     disease name in parentheses (e.g. "insecticide (for scabies)")

    public static final Intl ABORTIFACIENT = new Intl("abortifacient [fr:abortif]");
    public static final Intl ADSORBENT = new Intl("adsorbent [fr:adsorbant]");
    public static final Intl ANAESTHETIC = new Intl("anaesthetic [fr:anesthsique]");
    public static final Intl ANALGESIC = new Intl("analgesic [fr:analgsique]");
    public static final Intl ANTACID = new Intl("antacid [fr:antiacide]");
    public static final Intl ANTHELMINTHIC = new Intl("anthelminthic [fr:anthelminthique]");
    public static final Intl ANTIANAEMIC = new Intl("antianaemic [fr:anti-anmique]");
    public static final Intl ANTIANAPHYLACTIC = new Intl("antianaphylactic [fr:anti-anaphylactique]");
    public static final Intl ANTIANGINAL = new Intl("antianginal [fr:anti-angineux]");
    public static final Intl ANTIBACTERIAL = new Intl("antibacterial [fr:antibactrien]");
    public static final Intl ANTICHOLINERGIC = new Intl("anticholinergic [fr:anticholinergique]");
    public static final Intl ANTICOAGULANT = new Intl("anticoagulant [fr:anticoagulant]");
    public static final Intl ANTICONVULSANT = new Intl("anticonvulsant [fr:anticonvulsivant]");
    public static final Intl ANTIDEPRESSANT = new Intl("antidepressant [fr:antidpresseur]");
    public static final Intl ANTIDIABETIC = new Intl("antidiabetic [fr:antidiabtique]");
    public static final Intl ANTIDIARRHOEAL = new Intl("antidiarrhoeal [fr:antidiarrhique]");
    public static final Intl ANTIEMETIC = new Intl("antiemetic [fr:antimtique]");
    public static final Intl ANTIEPILEPTIC = new Intl("antiepileptic [fr:antipileptique]");
    public static final Intl ANTIFIBRINOLYTIC = new Intl("antifibrinolytic [fr:antifibrinolytique]");
    public static final Intl ANTIFUNGAL = new Intl("antifungal [fr:antifongique]");
    public static final Intl ANTIHISTAMINE = new Intl("antihistamine [fr:antihistaminique]");
    public static final Intl ANTIHYPERTENSIVE = new Intl("antihypertensive [fr:antihypertenseur]");
    public static final Intl ANTILEPROTIC = new Intl("antileprotic [fr:antileprotique]");
    public static final Intl ANTIMALARIAL = new Intl("antimalarial [fr:antipaludique]");
    public static final Intl ANTIOXYTOCIC = new Intl("antioxytocic [fr:antioxytocique]");
    public static final Intl ANTIPARKINSONIAN = new Intl("antiparkinsonian [fr:antiparkinsonien]");
    public static final Intl ANTIPROTOZOAL = new Intl("antiprotozoal [fr:antiprotozoaire]");
    public static final Intl ANTIPROTOZOAL_FOR_SLEEPING_SICKNESS = new Intl("antiprotozoal (for sleeping sickness) [fr:antiprotozoaire (pour la maladie du sommeil)]");
    public static final Intl ANTIPRURITIC = new Intl("antipruritic [fr:antiprurigineux]");
    public static final Intl ANTIPSYCHOTIC = new Intl("antipsychotic [fr:antipsychotique]");
    public static final Intl ANTIPYRETIC = new Intl("antipyretic [fr:antipyrtique]");
    public static final Intl ANTIRETROVIRAL = new Intl("antiretroviral [fr:antirtroviral]");
    public static final Intl ANTISEPTIC = new Intl("antiseptic [fr:antiseptique]");
    public static final Intl ANTISPASMODIC = new Intl("antispasmodic [fr:antispasmodique]");
    public static final Intl ANTITUBERCULAR = new Intl("antitubercular [fr:antituberculeux]");
    public static final Intl ANTIVIRAL = new Intl("antiviral [fr:antiviral]");
    public static final Intl ANTIVIRAL_FOR_HPV = new Intl("antiviral (for HPV) [fr:antiviral (pour le VPH)]");
    public static final Intl BETA_BLOCKER = new Intl("beta blocker [fr:bta-bloquant]");
    public static final Intl BRONCHODILATOR = new Intl("bronchodilator [fr:bronchodilatateur]");
    public static final Intl CARDIOTONIC = new Intl("cardiotonic [fr:cardiotonique]");
    public static final Intl CONTRACEPTIVE = new Intl("contraceptive [fr:contraceptif]");
    public static final Intl CORTICOSTEROID = new Intl("corticosteroid [fr:corticostrode]");
    public static final Intl DIAGNOSTIC_STAINING_AGENT = new Intl("diagnostic staining agent [fr:agent de coloration diagnostique]");
    public static final Intl DISINFECTANT = new Intl("disinfectant [fr:dsinfectant]");
    public static final Intl DIURETIC = new Intl("diuretic [fr:diurtique]");
    public static final Intl EXPERIMENTAL_EBOLA_TREATMENT = new Intl("experimental Ebola treatment [fr:traitement exprimental contre Ebola]");
    public static final Intl EXPERIMENTAL_EBOLA_VACCINE = new Intl("experimental Ebola vaccine [fr:vaccin exprimental contre Ebola]");
    public static final Intl FLUID_REPLACER = new Intl("fluid replacer [fr:substitut fluide]");
    public static final Intl HEPARIN_ANTIDOTE = new Intl("heparin antidote [fr:antidote  l'hparine]");
    public static final Intl INSECTICIDE = new Intl("insecticide [fr:insecticide]");
    public static final Intl INSECTICIDE_FOR_LICE = new Intl("insecticide (for lice) [fr:insecticide (pour les poux)]");
    public static final Intl INSECTICIDE_FOR_SCABIES = new Intl("insecticide (for scabies) [fr:insecticide (pour la gale)]");
    public static final Intl LACTATION_INHIBITOR = new Intl("lactation inhibitor [fr:inhibiteur de la lactation]");
    public static final Intl LAXATIVE = new Intl("laxative [fr:laxatif]");
    public static final Intl MIOTIC = new Intl("miotic [fr:miotique]");
    public static final Intl OPIOID_ANALGESIC = new Intl("opioid analgesic [fr:analgsique opiode]");
    public static final Intl OPIOID_ANTAGONIST = new Intl("opioid antagonist [fr:antagoniste des opiodes]");
    public static final Intl OXYTOCIC = new Intl("oxytocic [fr:ocytocique]");
    public static final Intl PLASMA_SUBSTITUTE = new Intl("plasma substitute [fr:substitut de plasma]");
    public static final Intl SEDATIVE = new Intl("sedative [fr:sedatif]");
    public static final Intl SKIN_PROTECTOR = new Intl("skin protector [fr:protecteur de la peau]");
    public static final Intl SUPPLEMENT = new Intl("supplement [fr:supplment]");
    public static final Intl VACCINE = new Intl("vaccine [fr:vaccin]");


    // === Style conventions for medication names ====
    //
    // The medication name consists of a title-cased part followed optionally
    // by a comma and a lower-cased part.
    //   - A good test for the title-cased part is that it should fill the blank
    //     in the sentence: "The active ingredient in this drug is ______."
    //   - The title-cased part is the complete chemical name and should be a
    //     meaningful noun phrase on its own (e.g. "Ascorbic Acid", not
    //     "Ascorbic acid"; "Ferrous Salts", not "Ferrous salts")
    //   - When medications are combined, join them with a slash (e.g.
    //     "Artesunate/Amodiaquine", not "Artesunate + Amodiaquine")
    //   - Hyphenate the prefix "Co-" in names of combination medicines
    //     (e.g. "Co-amoxiclav", not "Coamoxiclav")
    //   - Do not capitalize immediately after a hyphen (e.g. "Co-artemether",
    //     not "Co-Artemether")
    //   - The lower-cased part describes the concentration, forumlation, or
    //     application (e.g. "Diazepam, solution", not "Diazepam Solution";
    //     "Morphine, immediate-release", not "Morphine Immediate-Release")
    //   - The concentration comes first, immediately after the comma (e.g.
    //     "Glucose, 50%" not "Glucose 50%"; "Permethrin, 1% lotion", not
    //     "Permethrin Lotion 1%" or "Permethrin 1%, lotion")

    public static List<Med> MEDS = deduplicate(

        // === MSF Essential Drugs, 2016 edition, by Sophie Pilon

        new Med("Abacavir", "ABC").caption(ANTIRETROVIRAL),
        // Oral drugs
        new Med("Abacavir", "ABC").caption(ANTIRETROVIRAL),
        new Med("Acetylsalicylic Acid", "Aspirin", "ASA").caption(ANALGESIC, ANTIPYRETIC),
        new Med("Aciclovir", "Acyclovir").caption(ANTIVIRAL),
        new Med("Activated Charcoal").caption(ADSORBENT),
        new Med("Albendazole").caption(ANTHELMINTHIC),
        new Med("Aluminium Hydroxide").caption(ANTACID),
        new Med("Amitriptyline").caption(ANTIDEPRESSANT),
        new Med("Amlodipine").caption(ANTIHYPERTENSIVE),
        // ! new Med("Amodiaquine").caption(AQ),
        new Med("Amoxicillin").caption(ANTIBACTERIAL),
        // ! new Med("Artesunate").caption(AS),
        new Med("Artesunate/Amodiaquine", "AS/AQ").caption(ANTIMALARIAL),
        new Med("Artesunate/Sulfadoxine/Pyrimethamine", "AS/SP").caption(ANTIMALARIAL),
        new Med("Ascorbic Acid", "Vitamin C").caption(SUPPLEMENT),
        new Med("Atazanavir", "ATV").caption(ANTIRETROVIRAL),
        new Med("Azithromycin").caption(ANTIBACTERIAL),
        new Med("Beclometasone, aerosol").caption(CORTICOSTEROID),
        new Med("Biperiden").caption(ANTICHOLINERGIC),
        new Med("Bisacodyl").caption(LAXATIVE),
        new Med("Bisoprolol").caption(BETA_BLOCKER),
        new Med("Cabergoline").caption(LACTATION_INHIBITOR),
        new Med("Calcium Folinate", "Folinic Acid").caption(),
        new Med("Carbamazepine").caption(ANTIEPILEPTIC),
        new Med("Cefalexin").caption(ANTIBACTERIAL),
        new Med("Cefixime").caption(ANTIBACTERIAL),
        new Med("Chloramphenicol").caption(ANTIBACTERIAL),
        new Med("Chloroquine Phosphate").caption(ANTIMALARIAL),
        new Med("Chloroquine Sulfate").caption(ANTIMALARIAL),
        new Med("Chlorphenamine", "Chlorpheniramine").caption(ANTIHISTAMINE),
        new Med("Chlorpromazine").caption(ANTIPSYCHOTIC),
        new Med("Cimetidine").caption(ANTACID),
        new Med("Ciprofloxacin").caption(ANTIBACTERIAL),
        new Med("Clindamycin").caption(ANTIBACTERIAL),
        new Med("Clomipramine").caption(ANTIDEPRESSANT),
        new Med("Cloxacillin").caption(ANTIBACTERIAL),
        new Med("Co-amoxiclav", "Amoxicillin/Clavulanic Acid").caption(ANTIBACTERIAL),
        new Med("Co-artemether", "Artemether/Lumefantrine").caption(ANTIMALARIAL),
        new Med("Codeine").caption(OPIOID_ANALGESIC),
        new Med("Colecalciferol", "Vitamin D3").caption(SUPPLEMENT),
        new Med("Co-trimoxazole", "Sulfamethoxazole/Trimethoprim", "SMX/TMP").caption(ANTIBACTERIAL),
        new Med("Dapsone").caption(ANTIBACTERIAL, ANTILEPROTIC),
        new Med("Darunavir", "DRV").caption(ANTIRETROVIRAL),
        new Med("Desogestrel").caption(CONTRACEPTIVE),
        new Med("Diazepam").caption(SEDATIVE, ANTICONVULSANT),
        new Med("Diethylcarbamazine").caption(ANTHELMINTHIC),
        new Med("Digoxin").caption(CARDIOTONIC),
        new Med("Dihydroartemisinin/Piperaquine", "DHA/PPQ").caption(ANTIMALARIAL),
        // ! new Med("Dipyrone"),
        new Med("Dolutegravir", "DTG").caption(ANTIRETROVIRAL),
        new Med("Doxycycline").caption(ANTIBACTERIAL),
        new Med("Efavirenz", "EFV", "EFZ").caption(ANTIRETROVIRAL),
        new Med("Enalapril").caption(ANTIHYPERTENSIVE),
        new Med("Ergocalciferol", "Vitamin D2").caption(SUPPLEMENT),
        new Med("Erythromycin").caption(ANTIBACTERIAL),
        new Med("Ethambutol",  "E").caption(ANTITUBERCULAR, ANTIBACTERIAL),
        new Med("Ethinylestradiol/Levonorgestrel").caption(CONTRACEPTIVE),
        new Med("Ferrous Salts").caption(ANTIANAEMIC),
        new Med("Ferrous Salts/Folic Acid"),
        new Med("Fluconazole").caption(ANTIFUNGAL),
        new Med("Flucytosine").caption(ANTIFUNGAL),
        new Med("Fluoxetine").caption(ANTIDEPRESSANT),
        new Med("Folic Acid", "Vitamin B9").caption(ANTIANAEMIC),
        new Med("Fosfomycin Trometamol").caption(ANTIBACTERIAL),
        new Med("Furosemide").caption(DIURETIC),
        new Med("Glibenclamide").caption(ANTIDIABETIC),
        new Med("Gliclazide").caption(ANTIDIABETIC),
        new Med("Glyceryl Trinitrate", "Nitroglycerin", "Trinitrin").caption(ANTIANGINAL),
        new Med("Griseofulvin").caption(ANTIFUNGAL),
        new Med("Haloperidol").caption(ANTIPSYCHOTIC),
        new Med("Hydrochlorothiazide").caption(DIURETIC),
        new Med("Hydroxyzine").caption(ANTIHISTAMINE),
        new Med("Hyoscine Butylbromide", "Butylscopolamine").caption(ANTISPASMODIC),
        new Med("Ibuprofen").caption(ANALGESIC, ANTIPYRETIC),
        new Med("Iodized Oil").caption(SUPPLEMENT),
        new Med("Ipratropium Bromide, nebuliser solution").caption(BRONCHODILATOR),
        new Med("Isoniazid", "H").caption(ANTITUBERCULAR),
        new Med("Isosorbide Dinitrate").caption(ANTIANGINAL),
        new Med("Itraconazole").caption(ANTIFUNGAL),
        new Med("Ivermectin").caption(ANTHELMINTHIC),
        new Med("Labetalol").caption(BETA_BLOCKER),
        new Med("Lactulose").caption(LAXATIVE),
        new Med("Lamivudine", "3TC").caption(ANTIRETROVIRAL),
        new Med("Levodopa/Carbidopa", "Co-careldopa").caption(ANTIPARKINSONIAN),
        new Med("Levonorgestrel").caption(CONTRACEPTIVE),
        new Med("Loperamide").caption(ANTIDIARRHOEAL),
        new Med("Lopinavir/Ritonavir", "LPV/R").caption(ANTIRETROVIRAL),
        new Med("Loratadine").caption(ANTIHISTAMINE),
        new Med("Mebendazole").caption(ANTHELMINTHIC),
        new Med("Mefloquine", "MQ").caption(ANTIMALARIAL),
        // ! new Med("Metamizole"),
        new Med("Metformin").caption(ANTIDIABETIC),
        new Med("Methyldopa").caption(ANTIHYPERTENSIVE),
        new Med("Metoclopramide").caption(ANTIEMETIC),
        new Med("Metronidazole").caption(ANTIBACTERIAL, ANTIPROTOZOAL),
        new Med("Miconazole").caption(ANTIFUNGAL),
        new Med("Mifepristone", "RU-486").caption(ABORTIFACIENT),
        new Med("Misoprostol").caption(OXYTOCIC),
        new Med("Morphine, immediate-release", "MIR").caption(OPIOID_ANALGESIC),
        new Med("Morphine, sustained-release", "MSR").caption(OPIOID_ANALGESIC),
        new Med("Multivitamins", "Vitamin B complex").caption(SUPPLEMENT),
        new Med("Nevirapine", "NVP").caption(ANTIRETROVIRAL),
        new Med("Niclosamide").caption(ANTHELMINTHIC),
        new Med("Nicotinamide", "Vitamin PP", "Vitamin B3").caption(SUPPLEMENT),
        new Med("Nifedipine").caption(ANTIHYPERTENSIVE, ANTIOXYTOCIC),
        new Med("Nitrofurantoin").caption(ANTIBACTERIAL),
        // ! new Med("Noramidopyrine"),
        new Med("Nystatin").caption(ANTIFUNGAL),
        new Med("Olanzapine").caption(ANTIPSYCHOTIC),
        new Med("Omeprazole").caption(ANTACID),
        new Med("Oral Rehydration Salts", "ORS").caption(FLUID_REPLACER),
        new Med("Paracetamol", "Acetaminophen").caption(ANALGESIC, ANTIPYRETIC),
        new Med("Paroxetine").caption(ANTIDEPRESSANT),
        new Med("Phenobarbital").caption(SEDATIVE, ANTICONVULSANT),
        new Med("Phenoxymethylpenicillin", "Penicillin V").caption(ANTIBACTERIAL),
        new Med("Phenytoin").caption(ANTICONVULSANT),
        new Med("Potassium Chloride, immediate-release").caption(SUPPLEMENT),
        new Med("Potassium Chloride, sustained-release").caption(SUPPLEMENT),
        new Med("Praziquantel").caption(ANTHELMINTHIC),
        new Med("Prednisolone").caption(CORTICOSTEROID),
        new Med("Prednisone").caption(CORTICOSTEROID),
        new Med("Promethazine").caption(ANTIHISTAMINE),
        new Med("Pyrantel").caption(ANTHELMINTHIC),
        new Med("Pyrazinamide", "Z").caption(ANTITUBERCULAR),
        new Med("Pyridoxine", "Vitamin B6").caption(SUPPLEMENT),
        new Med("Pyrimethamine").caption(ANTIPROTOZOAL),
        new Med("Quinine").caption(ANTIMALARIAL),
        new Med("Resomal", "Rehydration Solution for Malnutrition").caption(),
        new Med("Retinol", "Vitamin A").caption(SUPPLEMENT),
        new Med("Rifampicin", "R").caption(ANTITUBERCULAR),
        new Med("Risperidone").caption(ANTIPSYCHOTIC),
        new Med("Ritonavir", "RTV").caption(ANTIRETROVIRAL),
        // ! new Med("Salbutamol").caption(ALBUTEROL),
        new Med("Salbutamol, aerosol", "Albuterol").caption(BRONCHODILATOR),
        new Med("Salbutamol, nebuliser solution", "Albuterol").caption(BRONCHODILATOR),
        new Med("Sertraline").caption(ANTIDEPRESSANT),
        new Med("Spironolactone").caption(DIURETIC),
        new Med("Sulfadiazine").caption(ANTIBACTERIAL),
        new Med("Sulfadoxine/Pyrimethamine", "SP").caption(ANTIMALARIAL),
        new Med("Tenofovir Disoproxil Fumarate", "TDF").caption(ANTIRETROVIRAL),
        new Med("Thiamine", "Vitamin B1").caption(SUPPLEMENT),
        new Med("Tinidazole").caption(ANTIPROTOZOAL, ANTIBACTERIAL),
        new Med("Tramadol").caption(OPIOID_ANALGESIC),
        new Med("Tranexamic Acid").caption(ANTIFIBRINOLYTIC),
        new Med("Triclabendazole").caption(ANTHELMINTHIC),
        new Med("Trihexyphenidyl").caption(ANTIPARKINSONIAN),
        new Med("Ulipristal").caption(CONTRACEPTIVE),
        new Med("Valproic Acid", "Sodium Valproate").caption(ANTIEPILEPTIC),
        new Med("Vitamin B6").caption(SUPPLEMENT),
        new Med("Zidovudine", "AZT", "ZDV").caption(ANTIRETROVIRAL),
        new Med("Zidovudine/Lamivudine", "AZT/3TC").caption(ANTIRETROVIRAL),
        new Med("Zidovudine/Lamivudine/Nevirapine", "AZT/3TC/NVP").caption(ANTIRETROVIRAL),
        new Med("Zinc Sulfate").caption(SUPPLEMENT),

        // Injectable drugs
        new Med("Amphotericin B, conventional").caption(ANTIFUNGAL),
        new Med("Amphotericin B, liposomal").caption(ANTIFUNGAL),
        new Med("Ampicillin").caption(ANTIBACTERIAL),
        // ! new Med("Artemether"),
        new Med("Artesunate").caption(ANTIMALARIAL),
        new Med("Atropine").caption(ANTISPASMODIC),
        new Med("Benzathine Benzylpenicillin").caption(ANTIBACTERIAL),
        new Med("Benzylpenicillin", "Penicillin G").caption(ANTIBACTERIAL),
        new Med("Calcium Gluconate").caption(SUPPLEMENT),
        new Med("Cefotaxime").caption(ANTIBACTERIAL),
        new Med("Ceftriaxone").caption(ANTIBACTERIAL),
        new Med("Chloramphenicol").caption(ANTIBACTERIAL),
        // ! new Med("Long-Acting Oily Chloramphenicol"),
        new Med("Chlorpromazine").caption(ANTIPSYCHOTIC),
        new Med("Clindamycin").caption(ANTIBACTERIAL),
        new Med("Cloxacillin").caption(ANTIBACTERIAL),
        new Med("Co-amoxiclav", "Amoxicillin/Clavulanic Acid").caption(ANTIBACTERIAL),
        new Med("Dexamethasone").caption(CORTICOSTEROID),
        new Med("Diazepam, emulsion").caption(SEDATIVE, ANTICONVULSANT),
        new Med("Diazepam, solution").caption(SEDATIVE, ANTICONVULSANT),
        new Med("Diclofenac").caption(ANALGESIC, ANTIPYRETIC),
        new Med("Digoxin").caption(CARDIOTONIC),
        // ! new Med("Dipyrone"),
        new Med("Eflornithine").caption(ANTIPROTOZOAL_FOR_SLEEPING_SICKNESS),
        new Med("Epinephrine", "EPN", "Adrenaline").caption(ANTIANAPHYLACTIC),
        new Med("Etonogestrel, subdermal implant").caption(CONTRACEPTIVE),
        new Med("Fluconazole").caption(ANTIFUNGAL),
        new Med("Furosemide").caption(DIURETIC),
        new Med("Gentamicin").caption(ANTIBACTERIAL),
        new Med("Glucose, 50%", "Dextrose, 50%").caption(),
        new Med("Haloperidol").caption(ANTIPSYCHOTIC),
        new Med("Haloperidol Decanoate").caption(ANTIPSYCHOTIC),
        new Med("Heparin").caption(ANTICOAGULANT),
        new Med("Hydralazine").caption(ANTIHYPERTENSIVE),
        new Med("Hydrocortisone").caption(CORTICOSTEROID),
        new Med("Hyoscine Butylbromide", "Butylscopolamine").caption(ANTISPASMODIC),
        new Med("Insulin, biphasic"),
        new Med("Insulin, intermediate-acting"),
        new Med("Insulin, long-acting"),
        new Med("Insulin, short-acting"),
        new Med("Ketamine").caption(ANAESTHETIC),
        new Med("Labetalol").caption(BETA_BLOCKER),
        new Med("Levonorgestrel, subdermal implant").caption(CONTRACEPTIVE),
        new Med("Lidocaine", "Lignocaine").caption(ANAESTHETIC),
        new Med("Magnesium Sulfate", "MgSO4").caption(ANTICONVULSANT),
        new Med("Medroxyprogesterone").caption(CONTRACEPTIVE),
        new Med("Melarsoprol").caption(ANTIPROTOZOAL_FOR_SLEEPING_SICKNESS),
        // ! new Med("Metamizole"),
        new Med("Methylergometrine").caption(OXYTOCIC),
        new Med("Metoclopramide").caption(ANTIEMETIC),
        new Med("Metronidazole").caption(ANTIPROTOZOAL, ANTIBACTERIAL),
        new Med("Morphine").caption(OPIOID_ANALGESIC),
        new Med("Naloxone").caption(OPIOID_ANTAGONIST),
        // ! new Med("Noramidopyrine"),
        new Med("Omeprazole").caption(ANTACID),
        new Med("Ondansetron").caption(ANTIEMETIC),
        new Med("Oxytocin").caption(OXYTOCIC),
        new Med("Paracetamol", "Acetaminophen").caption(ANALGESIC, ANTIPYRETIC),
        new Med("Penicillin G").caption(ANTIBACTERIAL),
        new Med("Pentamidine").caption(ANTIPROTOZOAL),
        new Med("Phenobarbital").caption(ANTICONVULSANT),
        new Med("Phytomenadione", "Vitamin K1").caption(SUPPLEMENT),
        new Med("Potassium Chloride, 10%", "KCl, 10%").caption(),
        new Med("Promethazine").caption(ANTIHISTAMINE, ANTIEMETIC),
        new Med("Protamine").caption(HEPARIN_ANTIDOTE),
        new Med("Quinine").caption(ANTIMALARIAL),
        new Med("Salbutamol", "Albuterol").caption(BRONCHODILATOR),
        new Med("Sodium Bicarbonate, 8.4%"),
        new Med("Spectinomycin").caption(ANTIBACTERIAL),
        new Med("Streptomycin", "S").caption(ANTIBACTERIAL),
        new Med("Suramin").caption(ANTIPROTOZOAL_FOR_SLEEPING_SICKNESS),
        new Med("Thiamine", "Vitamin B1").caption(SUPPLEMENT),
        new Med("Tramadol").caption(OPIOID_ANALGESIC),
        new Med("Tranexamic Acid").caption(ANTIFIBRINOLYTIC),

        // Infusion fluids
        new Med("Glucose, 5%", "Dextrose, 5%").caption(),
        new Med("Glucose, 10%", "Dextrose, 10%").caption(),
        new Med("Modified Fluid Gelatin").caption(PLASMA_SUBSTITUTE),
        new Med("Polygeline").caption(PLASMA_SUBSTITUTE),
        new Med("Ringer Lactate").caption(FLUID_REPLACER),
        new Med("RLG 5% mix", "Ringer Lactate/Glucose, 5%").caption(FLUID_REPLACER),
        new Med("RLG 10% mix", "Ringer Lactate/Glucose, 10%").caption(FLUID_REPLACER),
        new Med("Sodium Chloride, 0.9%", "NaCl").caption(FLUID_REPLACER),

        // Vaccines, immunoglobulins, and antisera
        new Med("Oral Cholera Vaccine O1+O139").caption(VACCINE),
        new Med("Diphtheria/Tetanus/Pertussis Vaccine", "DTP").caption(VACCINE),
        new Med("Diphtheria/Tetanus/Pertussis/Hepatitis B Vaccine").caption(VACCINE),
        new Med("Diphtheria/Tetanus/Pertussis/Hepatitis B/Hib Vaccine").caption(VACCINE),
        new Med("Hepatitis B Vaccine").caption(VACCINE),
        new Med("Japanese Encephalitis Vaccine").caption(VACCINE),
        new Med("Measles Vaccine").caption(VACCINE),
        new Med("Meningococcal A Conjugate Vaccine").caption(VACCINE),
        new Med("Meningococcal A+C Vaccine").caption(VACCINE),
        new Med("Meningococcal A+C+W135 Vaccine").caption(VACCINE),
        new Med("Human Papillomavirus Vaccine", "HPV").caption(VACCINE),
        new Med("Pneumococcal Conjugate Vaccine", "PCV").caption(VACCINE),
        new Med("Inactivated Poliomyelitis Vaccine", "IPV").caption(VACCINE),
        new Med("Oral Poliomyelitis Vaccine", "OPV").caption(VACCINE),
        new Med("Human Rabies Immunoglobulin", "HRIG").caption(),
        new Med("Rabies Vaccine").caption(VACCINE),
        new Med("Oral Rotavirus Vaccine").caption(VACCINE),
        new Med("Human Tetanus Immunoglobulin", "HTIG").caption(),
        new Med("Tetanus Vaccine", "TT").caption(VACCINE),
        new Med("Tetanus-Diphtheria Vaccine", "Td").caption(VACCINE),
        // ! new Med("Tetanus Antitoxin, Equine"),
        new Med("Tuberculosis Vaccine", "BCG Vaccine").caption(VACCINE),
        new Med("Typhoid Conjugate Vaccine", "TCV").caption(VACCINE),
        new Med("Yellow Fever Vaccine").caption(VACCINE),

        // Drugs for external use, antiseptics, and disinfectants
        new Med("Aciclovir, eye ointment", "Acyclovir").caption(ANTIVIRAL),
        new Med("Alcohol-Based Hand Rub").caption(ANTISEPTIC),
        new Med("Artesunate, rectal").caption(ANTIMALARIAL),
        new Med("Benzoic Acid/Salicylic Acid ointment", "Whitfield's ointment").caption(ANTIFUNGAL),
        new Med("Benzyl Benzoate, lotion").caption(INSECTICIDE_FOR_SCABIES),
        new Med("Calamine, lotion").caption(ANTIPRURITIC),
        new Med("Chlorhexidine, 5% solution").caption(ANTISEPTIC),
        new Med("Chlorhexidine, 7.1% dermal gel").caption(ANTISEPTIC),
        new Med("Chlorhexidine, 0.2% mouthwash").caption(ANTISEPTIC),
        new Med("Ciprofloxacin, ear drops").caption(ANTIBACTERIAL),
        new Med("Clotrimazole, vaginal tablet").caption(ANTIFUNGAL),
        new Med("Dinoprostone, vaginal gel").caption(OXYTOCIC),
        new Med("Ethyl Alcohol", "Ethanol").caption(ANTISEPTIC, DISINFECTANT),
        new Med("Fluorescein, eye drops").caption(DIAGNOSTIC_STAINING_AGENT),
        new Med("Hydrocortisone, cream").caption(CORTICOSTEROID),
        new Med("Malathion, lotion").caption(INSECTICIDE_FOR_LICE),
        // ! new Med("Methylrosanilinium Chloride", "GV", "Crystal violet").caption(GENTIAN VIOLET),
        new Med("Miconazole, cream").caption(ANTIFUNGAL),
        new Med("Mupirocin, ointment").caption(ANTIBACTERIAL),
        new Med("Nystatin, vaginal tablet").caption(ANTIFUNGAL),
        new Med("Oxybuprocaine, eye drops").caption(ANAESTHETIC),
        new Med("Permethrin, 1% lotion").caption(INSECTICIDE_FOR_LICE),
        new Med("Permethrin, 5% lotion").caption(INSECTICIDE_FOR_SCABIES),
        new Med("Pilocarpine, eye drops").caption(MIOTIC),
        new Med("Podophyllotoxin, 0.5% solution").caption(ANTIVIRAL_FOR_HPV),
        new Med("Podophyllum Resin, solution").caption(ANTIVIRAL_FOR_HPV),
        new Med("Povidone Iodine, aqueous solution", "Polyvidone iodine", "PVI").caption(ANTISEPTIC, DISINFECTANT),
        new Med("Povidone Iodine, scrub solution", "Polyvidone iodine", "PVI").caption(ANTISEPTIC, DISINFECTANT),
        new Med("Silver Sulfadiazine, cream").caption(ANTIBACTERIAL),
        new Med("Sodium Dichloroisocyanurate", "NaDCC").caption(DISINFECTANT),
        new Med("Calcium Hypochlorite", "HTH").caption(DISINFECTANT),
        new Med("Sodium Hypochlorite, solution", "Bleach").caption(DISINFECTANT),
        new Med("Chlorinated Lime, powder").caption(DISINFECTANT),
        new Med("Tetracycline, eye ointment").caption(ANTIBACTERIAL),
        new Med("Zinc Oxide, ointment").caption(SKIN_PROTECTOR),

        // ==== Additional Ebola treatments and vaccines

        // Experimental Ebola treatments
        new Med("Amodiaquine").caption(EXPERIMENTAL_EBOLA_TREATMENT),
        new Med("Favipiravir").caption(EXPERIMENTAL_EBOLA_TREATMENT),
        new Med("Remdesivir").caption(EXPERIMENTAL_EBOLA_TREATMENT),
        new Med("ZMapp").caption(EXPERIMENTAL_EBOLA_TREATMENT),

        // Experimental Ebola vaccines
        new Med("cAd3-EBOZ").caption(EXPERIMENTAL_EBOLA_VACCINE),
        new Med("VSV-EBOV").caption(EXPERIMENTAL_EBOLA_VACCINE),
        new Med("Ad5-EBOV").caption(EXPERIMENTAL_EBOLA_VACCINE),
        new Med("Ad26-ZEBOV/MVA-BN").caption(EXPERIMENTAL_EBOLA_VACCINE),
        new Med("rVSV-ZEBOV").caption(EXPERIMENTAL_EBOLA_VACCINE)
    );

    public static List<Med> deduplicate(Med... meds) {
        List<Med> result = new ArrayList<>();
        Set<String> names = new HashSet<>();
        for (Med med : meds) {
            if (!names.contains(normalize(med.name))) {
                names.add(normalize(med.name));
                result.add(med);
            }
        }
        Collections.sort(result, (a, b) -> a.name.compareToIgnoreCase(b.name));
        return result;
    }

    public List<Med> suggestCompletions(CharSequence constraint) {
        String[] searchKeys = normalize(constraint).trim().split(" ");
        for (int i = 0; i < searchKeys.length; i++) {
            searchKeys[i] = " " + searchKeys[i];
        }

        List<Med> results = new ArrayList<>();
        for (Med med : MEDS) {
            // Look for words matching the words in the input as prefixes.
            int score = 0;
            for (String searchKey : searchKeys) {
                score += med.filterTarget.contains(searchKey) ? 1 : 0;
            }
            if (score == searchKeys.length) {
                results.add(med);
                continue;
            }

            if (searchKeys.length == 1) {
                // Look for words matching the letters in the input as initials.
                score = 0;
                char[] initials = searchKeys[0].trim().toCharArray();
                for (char ch : initials) {
                    score += med.filterTarget.contains(" " + ch) ? 1 : 0;
                }
                if (score == initials.length) {
                    results.add(med);
                }
            }
        }
        return results;
    }

    private static String normalize(CharSequence name) {
        return name.toString().toLowerCase().replaceAll("[^a-z0-9]+", " ");
    }

    public static class Med {
        String name;
        Intl[] captions;
        String[] aliases;
        String label;
        String filterTarget;

        public Med(String name, String... aliases) {
            this.name = name;
            this.captions = new Intl[0];
            this.aliases = aliases;
            label = name;
            filterTarget = " " + name.toLowerCase();
            for (String alias : aliases) {
                label += " (" + alias + ")";
                filterTarget += " " + alias;
            }
            String collapsed = filterTarget.replaceAll("[^a-z0-9]+", "");
            filterTarget = normalize(" " + filterTarget + " " + collapsed + " ");
        }

        public Med caption(Intl... captions) {
            this.captions = captions;
            return this;
        }

        public void showInView(View itemView) {
            Locale locale = Locale.getDefault();
            Utils.setText(itemView, R.id.label, label);
            String caption = "";
            for (Intl intl : captions) {
                if (!caption.isEmpty()) caption += ", ";
                caption += intl.loc(locale);
            }
            Utils.setText(itemView, R.id.caption, caption);
        }

        public @NonNull String getValue() {
            return name;
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui;

import android.app.AlertDialog;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.res.Configuration;
import android.net.wifi.WifiManager;
import android.os.Bundle;
import android.os.Handler;
import android.provider.Settings;
import android.support.annotation.StringRes;
import android.support.v4.app.DialogFragment;
import android.support.v4.app.FragmentActivity;
import android.view.KeyEvent;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.FrameLayout;
import android.widget.LinearLayout;

import com.joanzapata.iconify.Icon;
import com.joanzapata.iconify.IconDrawable;

import org.joda.time.Duration;
import org.joda.time.Instant;
import org.projectbuendia.client.App;
import org.projectbuendia.client.AppSettings;
import org.projectbuendia.client.R;
import org.projectbuendia.client.diagnostics.HealthIssue;
import org.projectbuendia.client.diagnostics.TroubleshootingAction;
import org.projectbuendia.client.events.diagnostics.TroubleshootingActionsChangedEvent;
import org.projectbuendia.client.receivers.BatteryWatcher;
import org.projectbuendia.client.ui.chart.ChartRenderer;
import org.projectbuendia.client.updater.AvailableUpdateInfo;
import org.projectbuendia.client.updater.DownloadedUpdateInfo;
import org.projectbuendia.client.utils.ContextUtils;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import javax.annotation.Nonnull;

import butterknife.ButterKnife;
import de.greenrobot.event.EventBus;

import static org.projectbuendia.client.utils.Utils.eq;

/**
 * An abstract {@link FragmentActivity} that is the base for all activities
 * except SettingsActivity, providing a "content view" that is populated by
 * subclasses and a SnackBar for troubleshooting and status messages.
 */
public abstract class BaseActivity extends FragmentActivity {
    private static final Logger LOG = Logger.create();
    private static final double PHI = (Math.sqrt(5) + 1)/2; // golden ratio
    private static final double STEP_FACTOR = Math.sqrt(Math.sqrt(PHI)); // each step up/down scales this much
    private static final long MIN_STEP = -4;
    private static final long MAX_STEP = 2;

    protected ContextUtils u;
    protected AppSettings settings;
    protected Instant idleStartTime = null;
    protected Handler tickHandler = new Handler();
    protected Runnable tick = () -> {
        onTick();
        tickHandler.postDelayed(this.tick, 1000);
    };
    protected final BatteryWatcher batteryWatcher = new BatteryWatcher();
    protected boolean mIsCreated = false; // activity creation completed successfully

    private static long sScaleStep = 0; // app-wide scale step, selected by user
    private Long pausedScaleStep = null; // this activity's scale step when last paused
    private LinearLayout mWrapperView;
    private FrameLayout mInnerContent;
    private SnackBar snackBar;
    private Locale initialLocale; // for restarting when locale has changed
    private Set<String> openDialogTypes;
    protected UpdateCheckController updateCheckController = null;

    // NOTE: Don't override this method; override onCreateImpl() instead.
    @Override protected final void onCreate(Bundle state) {
        super.onCreate(state);
        mIsCreated = onCreateImpl(state);
    }

    /**
     * Performs setup operations for this activity and returns true if creation
     * should continue.  All overrides of this method should start with:
     *     if (!super.onCreateImpl(state)) return false;
     */
    protected boolean onCreateImpl(Bundle state) {
        settings = App.getSettings();
        initialLocale = Locale.getDefault();
        openDialogTypes = new HashSet<>();
        updateCheckController =
            new UpdateCheckController(new UpdateNotificationUi());

        if (!settings.isAuthorized() && !(this instanceof AuthorizationActivity)) {
            Utils.jumpToActivity(this, AuthorizationActivity.class);
            return false;
        }
        App.inject(this);
        ChartRenderer.backgroundCompileTemplate();
        return true;
    }

    @Override protected void attachBaseContext(Context base) {
        super.attachBaseContext(App.applyLocaleSetting(base));
        u = ContextUtils.from(this);
    }

    @Override protected void onResume() {
        super.onResume();
        if (!eq(Locale.getDefault(), initialLocale)) Utils.restartActivity(this);
        initializeSnackBar();
        if (pausedScaleStep != null && sScaleStep != pausedScaleStep) {
            // If the font scale was changed while this activity was paused, force a refresh.
            restartWithFontScale(sScaleStep);
        }
        EventBus.getDefault().registerSticky(this);
        registerReceiver(batteryWatcher, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
        App.getHealthMonitor().start();
        App.getSyncManager().applyPeriodicSyncSettings();
        App.getHealthEventBus().post(
            App.getSettings().getPeriodicSyncDisabled() ?
                HealthIssue.PERIODIC_SYNC_DISABLED.discovered :
                HealthIssue.PERIODIC_SYNC_DISABLED.resolved
        );
        Utils.logEvent("resumed_activity", "class", this.getClass().getSimpleName());
        if (updateCheckController != null) {
            updateCheckController.init();
        }
        idleStartTime = Instant.now();
        tick.run();
    }

    @Override protected void onPause() {
        if (updateCheckController != null) {
            updateCheckController.suspend();
        }
        unregisterReceiver(batteryWatcher);
        EventBus.getDefault().unregister(this);
        App.getHealthMonitor().stop();
        pausedScaleStep = sScaleStep;
        tickHandler.removeCallbacks(tick);
        super.onPause();
    }

    /** Invoked once every second. */
    protected void onTick() { }

    @Override public void onUserInteraction() {
        idleStartTime = Instant.now();
    }

    protected @Nonnull Duration getIdleDuration() {
        return idleStartTime != null
            ? new Duration(idleStartTime, Instant.now())
            : new Duration(0);
    }

    /** Opens the dialog and returns true, unless a dialog of this type is already open. */
    public boolean openDialog(DialogFragment fragment) {
        String type = fragment.getClass().getName();
        if (!openDialogTypes.contains(type)) {
            fragment.show(getSupportFragmentManager(), null);
            return true;
        }
        return false;
    }

    public void onDialogOpened(DialogFragment fragment) {
        openDialogTypes.add(fragment.getClass().getName());
    }

    public void onDialogClosed(DialogFragment fragment) {
        openDialogTypes.remove(fragment.getClass().getName());
    }

    /** Intercepts volume-up/volume-down presses and changes the UI scale step. */
    @Override public boolean dispatchKeyEvent(KeyEvent event) {
        int action = event.getAction();
        int keyCode = event.getKeyCode();
        switch (keyCode) {
            case KeyEvent.KEYCODE_VOLUME_UP:
                if (action == KeyEvent.ACTION_DOWN) {
                    adjustFontScale(1);
                }
                return true;
            case KeyEvent.KEYCODE_VOLUME_DOWN:
                if (action == KeyEvent.ACTION_DOWN) {
                    adjustFontScale(-1);
                }
                return true;
            default:
                return super.dispatchKeyEvent(event);
        }
    }

    public void adjustFontScale(int delta) {
        long newScaleStep = Math.max(MIN_STEP, Math.min(MAX_STEP, sScaleStep + delta));
        if (newScaleStep != sScaleStep) {
            restartWithFontScale(newScaleStep);
        }
    }

    public void restartWithFontScale(long newScaleStep) {
        Configuration config = getResources().getConfiguration();
        config.fontScale = (float) Math.pow(STEP_FACTOR, newScaleStep);
        getResources().updateConfiguration(config, getResources().getDisplayMetrics());
        sScaleStep = newScaleStep;
        Utils.restartActivity(this);
    }

    public void setMenuBarIcon(MenuItem item, Icon icon) {
        item.setIcon(createIcon(icon, R.color.menubar_icon));
    }

    public IconDrawable createIcon(Icon icon, int colorRes) {
        int iconSizePx = (int) (36 * getResources().getDisplayMetrics().scaledDensity);
        return new IconDrawable(this, icon).color(getResources().getColor(colorRes)).sizePx(iconSizePx);
    }

    @Override public void setContentView(int layoutResId) {
        initializeWrapperView();
        mInnerContent.removeAllViews();
        getLayoutInflater().inflate(layoutResId, mInnerContent);
        ButterKnife.inject(this);
    }

    private void initializeWrapperView() {
        if (mWrapperView != null) return;

        mWrapperView =
            (LinearLayout) getLayoutInflater().inflate(R.layout.view_status_wrapper, null);
        super.setContentView(mWrapperView);

        mInnerContent =
            mWrapperView.findViewById(R.id.status_wrapper_inner_content);
    }

    private void initializeSnackBar() {
        if ((mWrapperView != null) && (snackBar == null)) {
            snackBar = new SnackBar(mWrapperView);
        }
    }

    /**
     * Adds a message to the SnackBar. Priority defaults to 999.
     * @see "SnackBar Documentation." {@link SnackBar#message(int)}
     */
    public void snackBar(@StringRes int message) {
        initializeSnackBar();
        snackBar.message(message);
    }

    /**
     * Adds a message to the SnackBar with informed priority.
     * @see "SnackBar Documentation." {@link SnackBar#message(int, int)}
     */
    public void snackBar(@StringRes int message, int priority) {
        initializeSnackBar();
        snackBar.message(message, priority);
    }

    /**
     * Adds a message to the SnackBar. Priority defaults to 999.
     * @see "SnackBar Documentation." {@link SnackBar#message(int, int, View.OnClickListener, int)}
     */
    public void snackBar(@StringRes int message, @StringRes int actionMessage, View.OnClickListener listener) {
        initializeSnackBar();
        snackBar.message(message, actionMessage, listener, 999);
    }

    /**
     * Adds a message to the SnackBar with informed priority.
     * @see "SnackBar Documentation." {@link SnackBar#message(int, int, View.OnClickListener, int)}
     */
    public void snackBar(@StringRes int message, @StringRes int actionMessage,
                         View.OnClickListener listener, int priority) {
        initializeSnackBar();
        snackBar.message(message, actionMessage, listener, priority);
    }

    /**
     * Adds a message to the SnackBar with all parameters except for secondsToTimeout.
     * @see "SnackBar Documentation."
     * {@link SnackBar#message(int, int, View.OnClickListener, int, boolean, int)}
     */
    public void snackBar(@StringRes int message, @StringRes int actionMessage,
                         View.OnClickListener actionOnClick, int priority, boolean isDismissible) {
        initializeSnackBar();
        snackBar.message(message, actionMessage, actionOnClick, priority, isDismissible, 0);
    }

    /**
     * Adds a message to the SnackBar with all parameters.
     * @see "SnackBar Documentation."
     * {@link SnackBar#message(int, int, View.OnClickListener, int, boolean, int)}
     */
    public void snackBar(@StringRes int message, @StringRes int actionMessage,
                         View.OnClickListener actionOnClick, int priority,
                         boolean isDismissible, int secondsToTimeOut) {
        initializeSnackBar();
        snackBar.message(message, actionMessage, actionOnClick, priority, isDismissible,
            secondsToTimeOut);
    }

    /**
     * Use it to programmatically dismiss a SnackBar message.
     * @param id The @StringRes for the message.
     */
    public void snackBarDismiss(@StringRes int id) {
        if (snackBar != null) snackBar.dismiss(id);
    }

    /**
     * Programmatically dismiss multiple messages at once
     * @param id a @StringRes message Array
     */
    public void snackBarDismiss(@StringRes int[] ids) {
        if (snackBar != null) snackBar.dismiss(ids);
    }

    @Override public void setContentView(View view) {
        initializeWrapperView();

        mInnerContent.removeAllViews();
        mInnerContent.addView(view);
    }

    @Override public void setContentView(View view, ViewGroup.LayoutParams params) {
        initializeWrapperView();

        mInnerContent.removeAllViews();
        mInnerContent.addView(view, params);
    }

    /** Called when the set of troubleshooting actions changes. */
    public void onEventMainThread(TroubleshootingActionsChangedEvent event) {
        if (event.solvedIssue != null) {
            displayProblemSolvedMessage(event.solvedIssue);
        }

        if (event.actions.isEmpty()) {
            return;
        }

        for (TroubleshootingAction action : event.actions) {
            if (action != null) switch (action) {
                case ENABLE_WIFI:
                    snackBar(R.string.troubleshoot_wifi_disabled,
                        R.string.troubleshoot_wifi_disabled_action_enable,
                        view -> ((WifiManager) getApplicationContext()
                            .getSystemService(Context.WIFI_SERVICE)).setWifiEnabled(true),
                        10, false);
                    break;
                case CONNECT_WIFI:
                    snackBar(R.string.troubleshoot_wifi_disconnected,
                        R.string.troubleshoot_wifi_disconnected_action_connect,
                        view -> startActivity(new Intent(Settings.ACTION_WIFI_SETTINGS)),
                        20, false);
                    break;
                case CHECK_SERVER_CONFIGURATION:
                    snackBar(R.string.troubleshoot_server_address,
                        R.string.troubleshoot_server_address_action_check,
                        view -> SettingsActivity.start(BaseActivity.this),
                        30, false);
                    break;
                case CHECK_SERVER_REACHABILITY:
                    snackBar(R.string.troubleshoot_server_unreachable,
                        R.string.troubleshoot_action_more_info,
                        view -> showMoreInfoDialog(
                            // TODO: Display the actual server URL that couldn't be reached in
                            // this message. This will require that injection be hooked up
                            // through to this inner class, which may be complicated.
                            getString(R.string.troubleshoot_server_unreachable),
                            getString(R.string.troubleshoot_server_unreachable_details),
                            true
                        ), 40, false);
                    break;
                case CHECK_SERVER_AUTH:
                    if (settings.isAuthorized()) {
                        snackBar(R.string.troubleshoot_server_auth,
                            R.string.troubleshoot_server_auth_action_check,
                            view -> SettingsActivity.start(BaseActivity.this),
                            50, false);
                    }
                    break;
                case CHECK_SERVER_PERMISSIONS:
                    if (settings.isAuthorized()) {
                        snackBar(R.string.troubleshoot_server_permission,
                            R.string.troubleshoot_server_auth_action_check,
                            view -> SettingsActivity.start(BaseActivity.this),
                            50, false);
                    }
                    break;
                case CHECK_SERVER_SETUP:  // server is returning 500
                    snackBar(R.string.troubleshoot_server_unstable,
                        R.string.troubleshoot_action_more_info,
                        view -> showMoreInfoDialog(
                            // TODO: Display the actual server URL that couldn't be reached in
                            // this message. This will require that injection be hooked up
                            // through to this inner class, which may be complicated.
                            getString(R.string.troubleshoot_server_unstable),
                            getString(R.string.troubleshoot_server_unstable_details),
                            false
                        ), 60, false);
                    break;
                case CHECK_SERVER_STATUS:  // server is not responding
                    snackBar(R.string.troubleshoot_server_not_responding,
                        R.string.troubleshoot_action_more_info,
                        view -> showMoreInfoDialog(
                            // TODO: Display the actual server URL that couldn't be reached in
                            // this message. This will require that injection be hooked up
                            // through to this inner class, which may be complicated.
                            getString(R.string.troubleshoot_server_not_responding),
                            getString(R.string.troubleshoot_server_not_responding_details),
                            false
                        ), 60, false);
                    break;
                case CHECK_PERIODIC_SYNC_SETTINGS:
                    snackBar(R.string.troubleshoot_periodic_sync_disabled,
                        R.string.troubleshoot_action_check_settings,
                        view -> SettingsActivity.start(BaseActivity.this),
                        70, false);
                    break;
                case CHECK_PACKAGE_SERVER_REACHABILITY:
                    snackBar(R.string.troubleshoot_package_server_unreachable,
                        R.string.troubleshoot_action_more_info,
                        view -> showMoreInfoDialog(
                            getString(R.string.troubleshoot_package_server_unreachable),
                            getString(R.string.troubleshoot_update_server_unreachable_details),
                            true
                        ), 80, false);
                    break;
                case CHECK_PACKAGE_SERVER_CONFIGURATION:
                    snackBar(R.string.troubleshoot_package_server_misconfigured,
                        R.string.troubleshoot_action_more_info,
                        view -> showMoreInfoDialog(
                            getString(R.string.troubleshoot_package_server_misconfigured),
                            getString(R.string.troubleshoot_update_server_misconfigured_details),
                            true
                        ), 90, false);
                    break;
                default:
                    LOG.w("Troubleshooting action '%1$s' is unknown.", action);
                    return;
            }
        }
    }

    private void displayProblemSolvedMessage(HealthIssue solvedIssue) {
        // The troubleShootingMessages Map have the issue as the key and the TroubleshootingMessage
        // object as it's value.
        Map<HealthIssue, TroubleshootingMessage> troubleshootingMessages = new HashMap<>();

        troubleshootingMessages.put(HealthIssue.WIFI_DISABLED,
            new TroubleshootingMessage(
                R.string.troubleshoot_wifi_disabled,
                R.string.troubleshoot_wifi_disabled_solved,
                10
        ));
        troubleshootingMessages.put(HealthIssue.WIFI_NOT_CONNECTED,
            new TroubleshootingMessage(
                R.string.troubleshoot_wifi_disconnected,
                R.string.troubleshoot_wifi_disconnected_solved,
                10
        ));
        troubleshootingMessages.put(HealthIssue.SERVER_AUTHENTICATION_ISSUE,
            new TroubleshootingMessage(
                R.string.troubleshoot_server_auth,
                R.string.troubleshoot_server_auth_solved,
                10
            ));
        troubleshootingMessages.put(HealthIssue.SERVER_PERMISSION_ISSUE,
            new TroubleshootingMessage(
                R.string.troubleshoot_server_permission,
                R.string.troubleshoot_server_permission_solved,
                10
        ));
        troubleshootingMessages.put(HealthIssue.SERVER_CONFIGURATION_INVALID,
            new TroubleshootingMessage(
                R.string.troubleshoot_server_address,
                R.string.troubleshoot_server_address_solved,
                10
        ));
        troubleshootingMessages.put(HealthIssue.SERVER_HOST_UNREACHABLE,
            new TroubleshootingMessage(
                R.string.troubleshoot_server_unreachable,
                R.string.troubleshoot_server_unreachable_solved,
                10
        ));
        troubleshootingMessages.put(HealthIssue.SERVER_INTERNAL_ISSUE,
            new TroubleshootingMessage(
                R.string.troubleshoot_server_unstable,
                R.string.troubleshoot_server_unstable_solved,
                10
        ));
        troubleshootingMessages.put(HealthIssue.SERVER_NOT_RESPONDING,
            new TroubleshootingMessage(
                R.string.troubleshoot_server_not_responding,
                R.string.troubleshoot_server_not_responding_solved,
                10
        ));
        troubleshootingMessages.put(HealthIssue.PACKAGE_SERVER_HOST_UNREACHABLE,
            new TroubleshootingMessage(
                R.string.troubleshoot_package_server_unreachable,
                R.string.troubleshoot_package_server_unreachable_solved,
                5
        ));
        troubleshootingMessages.put(HealthIssue.PACKAGE_SERVER_INDEX_NOT_FOUND,
            new TroubleshootingMessage(
                R.string.troubleshoot_package_server_misconfigured,
                R.string.troubleshoot_package_server_misconfigured_solved,
                10
        ));
        troubleshootingMessages.put(HealthIssue.PERIODIC_SYNC_DISABLED,
            new TroubleshootingMessage(
                R.string.troubleshoot_periodic_sync_disabled,
                R.string.troubleshoot_periodic_sync_disabled_solved,
                10
            ));

        TroubleshootingMessage message = troubleshootingMessages.get(solvedIssue);
        if (message != null) {
            initializeSnackBar();
            SnackBar.Message snackBarMessage = snackBar.getMessage(message.messageId);
            if (snackBarMessage != null) {
                snackBar.dismiss(snackBarMessage.key);
                snackBar.message(message.resolvedMessageId, 0, null, 994, true, message.timeout);
            }
        }
    }

    private void showMoreInfoDialog(String title, String message,
                                    boolean includeSettingsButton) {
        AlertDialog.Builder builder = new AlertDialog.Builder(BaseActivity.this)
            .setIcon(android.R.drawable.ic_dialog_info)
            .setTitle(title)
            .setMessage(message)
            .setNeutralButton(android.R.string.ok, null);
        if (includeSettingsButton) {
            builder.setPositiveButton(R.string.troubleshoot_action_check_settings,
                (dialog, which) -> SettingsActivity.start(BaseActivity.this));
        }
        builder.show();
    }

    /** The user has requested a download of the last known available software update. */
    public static class DownloadRequestedEvent {
    }

    /** The user has requested installation of the last downloaded software update. */
    public static class InstallationRequestedEvent {
    }

    protected class UpdateNotificationUi implements UpdateCheckController.Ui {

        public UpdateNotificationUi() {}

        @Override public void showUpdateAvailableForDownload(AvailableUpdateInfo updateInfo) {
            snackBar(R.string.snackbar_update_available,
                R.string.snackbar_action_download,
                view -> {
                    Utils.logEvent("download_update_button_pressed");
                    //TODO: programatically dismiss the snackbar message
                    EventBus.getDefault().post(new DownloadRequestedEvent());
                }, 35, false);
        }

        @Override public void showUpdateReadyToInstall(DownloadedUpdateInfo updateInfo) {
            snackBar(R.string.snackbar_update_downloaded,
                R.string.snackbar_action_install,
                view -> {
                    Utils.logEvent("install_update_button_pressed");
                    //TODO: programatically dismiss the snackbar message
                    EventBus.getDefault().post(new InstallationRequestedEvent());
                }, 35, false);
        }

        @Override public void hideSoftwareUpdateNotifications() {
        }
    }

    /**
     * The TroubleshootingMessage object relates the error message with the solved message and
     * for how many seconds the solved message is displayed.
     */
    private static class TroubleshootingMessage {
        @StringRes public final int messageId;
        @StringRes public final int resolvedMessageId;
        public final int timeout;

        /**
         *
         * @param messageId The message string id triggered by the issue.
         * @param resolvedMessageId The new message string id (solved message).
         * @param timeout The timeout count (in seconds) for the solved message.
         */
        public TroubleshootingMessage(@StringRes int messageId, @StringRes int resolvedMessageId,
                                      int timeout) {
            this.messageId = messageId;
            this.resolvedMessageId = resolvedMessageId;
            this.timeout = timeout;
        }
    }
}


// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui;

/** The readiness state of an activity that uses data from a remote or local source. */
public enum ReadyState {
    SYNCING,  // syncing data from a remote source
    LOADING,  // loading data from the local database
    READY,  // all necessary data is available
    ERROR;  // necessary data could not be obtained
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distributed
// under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui;

import android.content.Context;
import android.content.res.Resources;
import android.os.CountDownTimer;
import android.support.annotation.NonNull;
import android.support.annotation.StringRes;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.animation.TranslateAnimation;
import android.widget.BaseExpandableListAdapter;
import android.widget.ExpandableListView;
import android.widget.ImageView;
import android.widget.TextView;

import org.projectbuendia.client.R;

import java.util.Map;
import java.util.TreeMap;

/**
 * Snackbars provide lightweight feedback about an operation by showing a brief message at the
 * bottom of the screen. Snackbars can contain an action button with an OnClickListener.
 * Can be auto dismissed by a time out values in seconds and can be prioritized.
 */
public class SnackBar {

    private ViewGroup mTargetParent;
    private Context mContext;
    private SnackBarListView mList;
    private SnackBarListAdapter adapter;
    private int mMessageId;
    private static TreeMap<MessageKey, Message> mMessagesList;


    public SnackBar(ViewGroup parent) {
        mTargetParent = parent;
        mContext = parent.getContext();
        if (mMessagesList == null) {
            mMessagesList = new TreeMap<>();
        }
        buildList();
    }

    /**
     * Show the SnackBar with an slide up animation if hidden.
     */
    public void show() {
        // TODO: discover why does not animate on the first time
        if (mList.getVisibility() != View.VISIBLE) {
            animate(View.VISIBLE);
        }
    }

    /**
     * Hide the SnackBar with a slide down animation if visible.
     */
    public void hide() {
        animate(View.GONE);
    }

    /**
     * Play the slide up / down animation depending on the list current visibility.
     * @param visibility Defines which of the animations will be executed (up or down). Possible
     *                   values are {@link View#VISIBLE} or {@link View#GONE}
     */
    private void animate(int visibility) {
        TranslateAnimation animate = new TranslateAnimation(0, 0,
            visibility == View.VISIBLE ? mList.getHeight() : 0,
            visibility == View.GONE ? mList.getHeight() : 0
        );
        animate.setDuration(700);
        animate.setFillAfter(true);
        mList.startAnimation(animate);
        mList.setVisibility(visibility);
    }

    /**
     * Wrapper to the full message method {@link #message(int, int, View.OnClickListener, int,
     * boolean, int)}
     * The message won't have action button, it's priority will be 999, will be dismissible and
     * won't have timer.
     * @param message The message String.
     */
    public void message(@StringRes int message) {
        message(message, 0, null, 999, true, 0);
    }

    /**
     * Wrapper to the full message method {@link #message(int, int, View.OnClickListener, int,
     * boolean, int)}
     * The message won't have action button, will be dismissible and won't have timer.
     * @param message  The message String resource id.
     * @param priority The priority of the message. The param is a int and the lower the number the
     *                 higher priority the message has. 0 is the highest.
     */
    public void message(@StringRes int message, int priority) {
        message(message, 0, null, priority, true, 0);
    }

    /**
     * Wrapper to the full message method {@link #message(int, int, View.OnClickListener, int,
     * boolean, int)}
     * The message will be dismissible and won't have timer.
     * @param message       The message String resource id.
     * @param actionMessage The resource id of the label for the action button.
     * @param actionOnClick The View.OnClickListener for the action button.
     * @param priority      The priority of the message. The param is a int and the lower the
     *                      number the
     *                      higher priority the message has. 0 is the highest.
     */
    public void message(@StringRes int message, @StringRes int actionMessage, View.OnClickListener
        actionOnClick, int priority) {
        message(message, actionMessage, actionOnClick, priority, true, 0);
    }

    /**
     * Add to the list and display a new message. This is the method that should be used to
     * display messages and it's being called by {@link BaseActivity#snackBar}.
     * @param message          The message String resource id.
     * @param actionMessage    The resource id of the label for the action button.
     * @param actionOnClick    The View.OnClickListener for the action button.
     * @param priority         The priority of the message. The param is a int and the lower the
     *                         number the
     *                         higher priority the message has. 0 is the highest.
     * @param isDismissible    if true the message will have a X button to remove it self from the
     *                         list.
     * @param secondsToTimeOut Number of seconds to message auto dismiss. 0 to never.
     */
    public void message(@StringRes int message, @StringRes int actionMessage, View.OnClickListener
        actionOnClick, int priority, boolean isDismissible, int secondsToTimeOut) {
        mMessageId++;
        MessageKey key = new MessageKey(mMessageId, priority);
        Message value = new Message(key, message, actionMessage, actionOnClick, isDismissible);
        addToQueueWithoutDuplicate(key, value);
        adapter.notifyDataSetChanged();
        if (secondsToTimeOut > 0) {
            setTimer(key, secondsToTimeOut);
        }
        if (mMessagesList.size() == 0) {
            hide();
        } else {
            show();
        }
    }

    /**
     * Checks if a message has duplicate
     */
    private void addToQueueWithoutDuplicate(MessageKey key, Message value) {
        Message existingMessage = getMessage(value.message);
        if (existingMessage != null) {
            mMessagesList.remove(existingMessage.key);
        }
        mMessagesList.put(key, value);
    }

    /**
     * Sets the auto-dismiss timer to the message given it's key and seconds to dismiss.
     * @param key     The message key.
     * @param seconds Seconds until dismiss.
     */
    private void setTimer(final MessageKey key, int seconds) {
        int limit = seconds*1000;
        new CountDownTimer(limit, limit) {
            @Override public void onTick(long millisUntilFinished) {
            }

            @Override public void onFinish() {
                mMessagesList.remove(key);
                adapter.notifyDataSetChanged();
            }
        }.start();
    }

    /**
     * Programmatically dismiss multiple messages by an array of ids.
     * @param id The message id array.
     */
    public void dismiss(int[] id) {
        boolean changed = false;
        for (int i1 : id) {
            MessageKey key = getKey(i1);
            if (key != null) {
                mMessagesList.remove(key);
                changed = true;
            }
        }
        if (changed) {
            adapter.notifyDataSetChanged();
        }
    }

    /**
     * Programmatically dismiss a message by it's id.
     * @param id The message id.
     */
    public void dismiss(@StringRes int id) {
        dismiss(getKey(id));
    }

    /**
     * Programmatically dismiss a message by a MessageKey Object
     * @param key The message Key.
     */
    public void dismiss(MessageKey key) {
        mMessagesList.remove(key);
        adapter.notifyDataSetChanged();
    }

    /**
     * Find message Key by it's id value.
     * @param message The StringRes of the message.
     * @return The MessageKey of the message.
     */
    public MessageKey getKey(@StringRes int message) {
        MessageKey theKey = null;
        for (Map.Entry<MessageKey, Message> entry : mMessagesList.entrySet()) {
            MessageKey key = entry.getKey();
            Message value = entry.getValue();
            if (value.message == message) {
                theKey = key;
                break;
            }
        }
        return theKey;
    }

    public Message getMessage(@StringRes int message){
        Message theMessage = null;
        for (Map.Entry<MessageKey, Message> entry : mMessagesList.entrySet()) {
            Message value = entry.getValue();
            if (value.message == message) {
                theMessage = value;
            }
        }
        return theMessage;
    }

    /**
     * Initiates the SnackBar ExpandableListView.
     */
    private void buildList() {
        mList = new SnackBarListView(mContext);
        mList.setId(R.id.snackbar);
        setListAppearance();
        adapter = new SnackBarListAdapter(mContext);
        mList.setAdapter(adapter);
        mTargetParent.addView(mList);
        if (mMessagesList.size() > 0) {
            show();
        } else {
            hide();
        }
    }

    /**
     * Sets the SnackBar ExpandableListView appearance.
     */
    private void setListAppearance() {
        mList.setDivider(null);
        mList.setChildDivider(null);
    }

    /**
     * The Custom ExpansibleListView used by the SnackBar
     */
    private final class SnackBarListView extends ExpandableListView {

        public SnackBarListView(Context context) {
            super(context);
        }

        /**
         * Updates the SnackBar with the current messages.
         * @param visibility
         */
        @Override protected void onWindowVisibilityChanged(int visibility) {
            super.onWindowVisibilityChanged(visibility);
            adapter.notifyDataSetChanged();
        }

    }

    /**
     * The SnackBar ExpandableListView Adapter responsible to handling the message data.
     */
    private final class SnackBarListAdapter extends BaseExpandableListAdapter {

        private LayoutInflater mInflater;

        public SnackBarListAdapter(Context context) {
            mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        }

        @Override public int getGroupCount() {
            return (mMessagesList.size() == 0) ? 0 : 1;
        }

        @Override public int getChildrenCount(int groupIndex) {
            return mMessagesList.size() - 1;
        }

        @Override public Object getGroup(int groupIndex) {
            return mMessagesList.values().toArray()[groupIndex];
        }

        @Override public Object getChild(int groupIndex, int childIndex) {
            return mMessagesList.values().toArray()[childIndex + 1];
        }

        @Override public long getGroupId(int groupIndex) {
            return groupIndex;
        }

        @Override public long getChildId(int groupIndex, int childIndex) {
            return childIndex;
        }

        @Override public boolean hasStableIds() {
            return false;
        }

        @Override
        public View getGroupView(int groupIndex, boolean isExpanded, View convertView,
                                 ViewGroup parent) {
            View header = getView(convertView, parent, groupIndex);
            TextView count = header.findViewById(R.id.snackbar_count);
            View indicator = header.findViewById(R.id.snackbar_indicator);
            if (mMessagesList.size() > 1) {
                indicator.setVisibility(View.VISIBLE);
                count.setText(String.valueOf(mMessagesList.size()));
                count.setVisibility(View.VISIBLE);
            } else {
                indicator.setVisibility(View.INVISIBLE);
                count.setVisibility(View.INVISIBLE);
            }
            return header;
        }

        @Override
        public View getChildView(int groupIndex, int childIndex, boolean isLastChild,
                                 View convertView, ViewGroup parent) {
            return getView(convertView, parent, (childIndex + 1));
        }

        @Override public boolean isChildSelectable(int groupIndex, int childIndex) {
            return true;
        }

        /**
         * This method is being called by {@code #getChildView} and {@code #getGroupView} to
         * customize the list items depending on the message specifications.
         * It add the click handlers to the buttons or hide them if they aren't being used.
         * @param newView the inflated view by {@code #getChildView} and {@code #getGroupView}
         */
        private View getView(View newView, ViewGroup parent, int position) {
            Object[] messagesArray = mMessagesList.values().toArray();

            if (newView == null) {
                newView = mInflater.inflate(R.layout.snackbar_item, parent, false);
            }

            if ((position >= 0) && (position < messagesArray.length)) {
                final Message m = (Message) messagesArray[position];
                Resources res = mContext.getResources();

                String messageString = res.getString(m.message);
                TextView message = newView.findViewById(R.id.snackbar_message);
                message.setText(messageString);

                TextView action = newView.findViewById(R.id.snackbar_action);
                if (m.actionString != 0) {
                    String actionString = res.getString(m.actionString);
                    action.setText(actionString);
                    // Set action handler
                    if (m.actionHandler != null) {
                        action.setOnClickListener(m.actionHandler);
                        action.setVisibility(View.VISIBLE);
                    }
                } else {
                    action.setVisibility(View.INVISIBLE);
                }

                // Set Dismiss handler
                ImageView dismissButton = newView.findViewById(R.id.snackbar_dismiss);
                if (m.isDismissible) {
                    dismissButton.setOnClickListener(v -> dismiss(m.key));
                    dismissButton.setVisibility(View.VISIBLE);
                } else {
                    dismissButton.setVisibility(View.GONE);
                }
            }
            return newView;
        }

    }

    /**
     * The key of the {@code TreeMap} used to storing the messages.
     * Helps the {@code TreeMap} maintain it's balance using priority as a parameter.
     */
    public class MessageKey implements Comparable<MessageKey> {
        protected final int id;
        protected final int priority;

        public MessageKey(@StringRes int id, int priority) {
            this.id = id;
            this.priority = priority;
        }

        /**
         * Used to TreeMap balancing and ordering by priority but also used by TreeMap get() method.
         * It matches the key with the same id disregarding it's priority.
         * The ordering is Priority first, Most recent second. Most recent messages appear on top
         * unless exists a higher priority message.
         * @param another The key to compare
         * @return 0 to equal, > 0 to greater than and < 0 to less than.
         */
        @Override public int compareTo(@NonNull MessageKey another) {
            int equal = 0;
            int result;
            int idCompare = Integer.compare(this.id, another.id);
            if (idCompare == equal) {
                result = equal;
            } else {
                idCompare = -idCompare; //Reverse the order.
                int priorityCompare = Integer.compare(this.priority, another.priority);
                if (priorityCompare == equal) {
                    result = idCompare;
                } else {
                    result = priorityCompare;
                }
            }
            return result;
        }
    }

    /**
     * The message information.
     */
    public class Message {

        protected MessageKey key;
        protected int message;
        protected int actionString;
        protected View.OnClickListener actionHandler;
        protected boolean isDismissible;

        public Message(MessageKey key, @StringRes int message, @StringRes int actionString,
                       View.OnClickListener handler, boolean isDismissible) {
            this.key = key;
            this.message = message;
            this.actionString = actionString;
            this.actionHandler = handler;
            this.isDismissible = isDismissible;
        }

    }

}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui;

import android.app.Dialog;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;

import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.client.events.user.FetchUsersTaskFailedEvent;
import org.projectbuendia.client.events.user.UsersFetchedEvent;
import org.projectbuendia.client.ui.login.LoginActivity;
import org.projectbuendia.client.user.FetchUsersTask;
import org.projectbuendia.client.utils.Utils;

/**
 * The starting activity for the app.  The app cannot navigate to any other
 * activities until a successful authorization taken place.
 */
public class AuthorizationActivity extends BaseActivity {
    private EditText serverField;
    private EditText usernameField;
    private EditText passwordField;
    private Button authorizeButton;
    private Dialog progressDialog;

    @Override public boolean onCreateImpl(Bundle state) {
        if (!super.onCreateImpl(state)) return false;
        if (settings.isAuthorized()) {
            Utils.jumpToActivity(this, LoginActivity.class);
            return false;
        }

        getActionBar().setDisplayUseLogoEnabled(false);
        getActionBar().setIcon(R.drawable.ic_launcher);  // don't show the back arrow
        getActionBar().setDisplayHomeAsUpEnabled(false);  // don't behave like a back button

        // This is the starting activity for the app, so show the app name and version.
        setTitle(getString(R.string.app_name) + " " + getString(R.string.app_version));

        setContentView(R.layout.authorization_activity);
        serverField = findViewById(R.id.server_field);
        usernameField = findViewById(R.id.openmrs_user_field);
        passwordField = findViewById(R.id.openmrs_password_field);
        authorizeButton = findViewById(R.id.authorize_button);

        new EditTextWatcher(serverField, usernameField, passwordField).onChange(this::updateUi);
        authorizeButton.setOnClickListener(this::submit);

        populateFields();
        updateUi();
        Utils.focusFirstEmptyField(serverField, usernameField, passwordField);
        return true;
    }

    private void populateFields() {
        serverField.setText(settings.getServer());
        usernameField.setText(settings.getOpenmrsUser());
        passwordField.setText(settings.getOpenmrsPassword());
    }

    private void updateUi() {
        String server = serverField.getText().toString().trim();
        String username = usernameField.getText().toString();
        String password = passwordField.getText().toString();
        authorizeButton.setEnabled(Utils.hasChars(server)
            && Utils.hasChars(username) && Utils.hasChars(password));
        settings.setServer(server);
    }

    private void submit(View view) {
        String server = serverField.getText().toString().trim();
        String username = usernameField.getText().toString();
        String password = passwordField.getText().toString();
        new FetchUsersTask(App.getCrudEventBus(), server, username, password).execute();
        progressDialog = u.showProgressDialog(
            getString(R.string.title_authorizing), getString(R.string.please_wait_ellipsis));
    }

    protected void onResume() {
        super.onResume();
        App.getCrudEventBus().register(this);
    }

    protected void onPause() {
        App.getCrudEventBus().unregister(this);
        super.onPause();
    }

    public void onEventMainThread(UsersFetchedEvent event) {
        progressDialog.dismiss();
        BigToast.show(R.string.authorization_successful);
        settings.authorize(event.server, event.username, event.password);
        Utils.jumpToActivity(this, LoginActivity.class);
    }

    public void onEventMainThread(FetchUsersTaskFailedEvent event) {
        progressDialog.dismiss();
        BigToast.show(R.string.authorization_failed);
        settings.deauthorize();
    }
}

package org.projectbuendia.client.ui;

import android.text.Editable;
import android.text.TextWatcher;
import android.widget.EditText;

public class EditTextWatcher implements TextWatcher {
    private Runnable callback = null;
    private boolean inCallback = false;
    private final EditText[] fields;

    public EditTextWatcher(EditText... fields) {
        this.fields = fields;
    }

    public void onChange(Runnable callback) {
        this.callback = callback;
        for (EditText field : fields) {
            field.addTextChangedListener(this);
        }
    }

    @Override public void beforeTextChanged(CharSequence c, int x, int y, int z) { }

    @Override public void onTextChanged(CharSequence c, int x, int y, int z) { }

    @Override public void afterTextChanged(Editable editable) {
        if (callback != null && !inCallback) {
            inCallback = true;
            try {
                callback.run();
            } finally {
                inCallback = false;
            }
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui;

import android.annotation.TargetApi;
import android.app.Activity;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.res.Configuration;
import android.os.Build;
import android.os.Bundle;
import android.preference.EditTextPreference;
import android.preference.ListPreference;
import android.preference.Preference;
import android.preference.PreferenceActivity;
import android.preference.PreferenceFragment;
import android.preference.PreferenceManager;
import android.support.v4.app.NavUtils;
import android.view.MenuItem;

import org.projectbuendia.client.App;
import org.projectbuendia.client.AppSettings;
import org.projectbuendia.client.R;
import org.projectbuendia.client.sync.SyncManager;
import org.projectbuendia.client.ui.login.LoginActivity;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import javax.annotation.Nullable;

import static org.projectbuendia.client.utils.Utils.eq;

/**
 * A {@link PreferenceActivity} that presents a set of application settings. On
 * handset devices, settings are presented as a single list. On tablets,
 * settings are split by category, with category headers shown to the left of
 * the list of settings.
 * <p/>
 * <p>See <a href="http://developer.android.com/design/patterns/settings.html">
 * Android Design: Settings</a> for design guidelines and the <a
 * href="http://developer.android.com/guide/topics/ui/settings.html">Settings
 * API Guide</a> for more information on developing a Settings UI.
 */
public class SettingsActivity extends PreferenceActivity {
    private static final Logger LOG = Logger.create();

    /**
     Controls whether to always show the simplified UI, where settings are
     arranged in a single list without a left navigation panel.
     */
    static final String[] PREF_KEYS = {
        "server",
        "openmrs_user",
        "openmrs_password",
        "openmrs_root_url",
        "locale",
        "package_server_root_url",
        "apk_check_interval",
        "small_sync_interval",
        "medium_sync_interval",
        "large_sync_interval",
        "starting_patient_id",
        "periodic_sync_disabled",
        "form_instances_retained",
        "non_wifi_allowed",
        "server_responses_fabricated"
    };
    static boolean updatingPrefValues = false;

    static final Map<String, EditTextPreference> textPrefs = new HashMap<>();

    static Dialog sSyncPendingDialog = null;

    /** A listener that performs updates when any preference's value changes. */
    static final Preference.OnPreferenceChangeListener sPrefListener = (pref, value) -> {
        updatePrefSummary(pref, value);
        if (updatingPrefValues)
            return true; // prevent endless recursion

        Context context = pref.getContext();
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
        String server = prefs.getString("server", "");
        String str = "" + value;
        try {
            updatingPrefValues = true;
            if (pref.getKey() != null) switch (pref.getKey()) {
                case "server":
                    if (!str.equals("")) {
                        setTextAndSummary(prefs, "openmrs_root_url", "http://" + str + ":9000/openmrs");
                        setTextAndSummary(prefs, "package_server_root_url", "http://" + str + ":9001");
                    }
                    break;
                case "openmrs_root_url":
                    if (!str.equals("http://" + server + ":9000/openmrs")) {
                        setTextAndSummary(prefs, "server", "");
                    }
                    break;
                case "package_server_root_url":
                    if (!str.equals("http://" + server + ":9001")) {
                        setTextAndSummary(prefs, "server", "");
                    }
                    break;
                case "periodic_sync_disabled":
                    SyncManager syncManager = App.getSyncManager();
                    syncManager.applyPeriodicSyncSettings();
                    if (syncManager.isSyncRunningOrPending()) {
                        sSyncPendingDialog = ProgressDialog.show(
                            context, null, context.getString(R.string.waiting_for_sync),
                            true /* indeterminate */, false /* cancelable */);
                        syncManager.stopSyncing(() -> sSyncPendingDialog.dismiss());
                    }
                    break;
            }
        } finally {
            updatingPrefValues = false;
        }
        return true;
    };

    public static void start(Context caller) {
        caller.startActivity(new Intent(caller, SettingsActivity.class));
    }

    private static void setTextAndSummary(SharedPreferences prefs, String key, String value) {
        // Update the preference edit field, if it's currently showing.
        EditTextPreference pref = textPrefs.get(key);
        if (pref != null) {
            pref.setText(value);
            pref.setSummary(value);
        }

        // Update the preference itself, even if the edit field isn't visible.
        prefs.edit().putString(key, value).commit();
    }

    @Override public boolean onOptionsItemSelected(MenuItem item) {
        int id = item.getItemId();
        if (id == android.R.id.home) {
            // This ID represents the Home or Up button. In the case of this
            // activity, the Up button is shown. Use NavUtils to allow users
            // to navigate up one level in the application structure. For
            // more details, see the Navigation pattern on Android Design:
            //
            // http://developer.android.com/design/patterns/navigation.html#up-vs-back
            //
            // TODO: If Settings has multiple levels, Up should navigate up
            // that hierarchy.
            NavUtils.navigateUpFromSameTask(this);
            return true;
        }
        return super.onOptionsItemSelected(item);
    }

    @Override public boolean onIsMultiPane() {
        return isXLargeTablet(this) && !useSimplePreferences(this);
    }

    @Override @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    public void onBuildHeaders(List<Header> target) {
        if (!useSimplePreferences(this)) {
            loadHeadersFromResource(R.xml.pref_headers, target);
        }
    }

    /** When the UI has two panes, this fragment shows just the general settings. */
    public static class GeneralPreferenceFragment extends PreferenceFragment {
        @Override public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            addPreferencesFromResource(R.xml.pref_general);
            initPrefs(this);
        }
    }

    /** When the UI has two panes, this fragment shows just the advanced settings. */
    public static class AdvancedPreferenceFragment extends PreferenceFragment {
        @Override public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            addPreferencesFromResource(R.xml.pref_advanced);
            initPrefs(this);
        }
    }

    /** When the UI has two panes, this fragment shows just the developer settings. */
    public static class DeveloperPreferenceFragment extends PreferenceFragment {
        @Override public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            addPreferencesFromResource(R.xml.pref_developer);
            initPrefs(this);
        }
    }

    /** Sets up all the preferences in a fragment. */
    private static void initPrefs(PreferenceFragment fragment) {
        textPrefs.clear();
        for (String key : PREF_KEYS) {
            initPref(fragment.findPreference(key), fragment.getActivity());
        }
    }

    /** Sets up the listener and summary for a preference. */
    private static void initPref(@Nullable Preference pref, Activity activity) {
        if (pref == null) return;

        updatePrefSummary(pref, App.getPrefs().getAll().get(pref.getKey()));
        pref.setOnPreferenceChangeListener(sPrefListener);

        if (pref instanceof EditTextPreference) {
            textPrefs.put(pref.getKey(), (EditTextPreference) pref);
        }
        if (eq(pref.getKey(), "locale")) {
            ListPreference localePref = (ListPreference) pref;
            localePref.setEntryValues(AppSettings.getLocaleOptionValues());
            localePref.setEntries(AppSettings.getLocaleOptionLabels());
            localePref.setOnPreferenceChangeListener((changedPref, value) -> {
                Utils.restartActivity(activity); // to apply the new locale setting
                return true;
            });
        }
    }

    static void updatePrefSummary(Preference pref, Object value) {
        String str = Utils.toNonnullString(value);
        if (pref.getKey() != null) switch (pref.getKey()) {
            case "server":
            case "openmrs_user":
            case "openmrs_root_url":
            case "package_server_root_url":
            case "apk_check_interval":
            case "small_sync_interval":
            case "medium_sync_interval":
            case "large_sync_interval":
                pref.setSummary(str);
                break;
            case "openmrs_password":
                String dots = "";
                while (dots.length() < str.length()) dots += "";
                pref.setSummary(Utils.isEmpty(str) ? "" : dots);
                break;
            case "locale":
                Locale locale = Utils.toLocale(str);
                pref.setSummary(locale.getDisplayName(locale));
                break;
        }
    }

    @Override protected void attachBaseContext(Context base) {
        super.attachBaseContext(App.applyLocaleSetting(base));
    }

    @Override protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        if (!App.getSettings().isAuthorized()) Utils.jumpToActivity(this, AuthorizationActivity.class);

        setTitle(R.string.title_activity_settings);
        setupActionBar();
    }

    /** Set up the {@link android.app.ActionBar}, if the API is available. */
    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    private void setupActionBar() {
        getActionBar().setIcon(R.drawable.ic_back_36dp);
        getActionBar().setDisplayHomeAsUpEnabled(true);
    }

    @Override protected boolean isValidFragment(String fragmentName) {
        return true;
    }

    @Override protected void onPostCreate(Bundle savedInstanceState) {
        super.onPostCreate(savedInstanceState);
        setupSimplePreferencesScreen();
    }

    /**
     Shows the simplified settings UI if the device configuration dictates
     that a simplified, single-pane UI should be shown.
     */
    private void setupSimplePreferencesScreen() {
        if (useSimplePreferences(this)) {
            // The simplified UI uses the old PreferenceActivity API instead of PreferenceFragment.
            addPreferencesFromResource(R.xml.pref_general);
            addPreferencesFromResource(R.xml.pref_advanced);
            addPreferencesFromResource(R.xml.pref_developer);
            initPrefs(this);
        }
    }

    /** Determines whether the simplified settings UI should be shown. */
    private static boolean useSimplePreferences(Context context) {
        return !isXLargeTablet(context);
    }

    /** Sets up all the preferences in an activity. */
    private static void initPrefs(PreferenceActivity activity) {
        textPrefs.clear();
        for (String key : PREF_KEYS) {
            initPref(activity.findPreference(key), activity);
        }
    }

    /** Checks if the screen is extra-large (e.g. a 10" tablet is extra-large). */
    private static boolean isXLargeTablet(Context context) {
        return (context.getResources().getConfiguration().screenLayout
            & Configuration.SCREENLAYOUT_SIZE_MASK) >= Configuration.SCREENLAYOUT_SIZE_XLARGE;
    }

    @Override protected void onPause() {
        super.onPause();
        if (!App.getModel().isReady()) {
            // The database was cleared; go back to the login activity.
            LOG.w("Database is empty; restarting at login activity");
            startActivity(new Intent(this, LoginActivity.class).addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK));
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.lists;

import org.projectbuendia.client.filter.db.SimpleSelectionFilter;
import org.projectbuendia.client.filter.db.patient.PatientDbFilters;
import org.projectbuendia.models.AppModel;

import java.util.List;

/** A controller for setting up user-selectable filters in a patient list. */
public class PatientFilterController {
    private final Ui mUi;

    public interface Ui {
        public void populateActionBar(List<SimpleSelectionFilter<?>> filters);
    }

    /**
     * Creates a {@link PatientFilterController} with the specified UI implementation, event
     * bus, model, and locale.  @param ui           a {@link Ui} that will receive UI events
     * @param model     an {@link AppModel} used to retrieve patients
     */
    public PatientFilterController(Ui ui, AppModel model) {
        mUi = ui;
        mUi.populateActionBar(PatientDbFilters.getFiltersForDisplay(model.getForest()));
        model.setOnForestReplacedListener(() -> {
            mUi.populateActionBar(PatientDbFilters.getFiltersForDisplay(model.getForest()));
        });
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.lists;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;

import org.projectbuendia.client.R;
import org.projectbuendia.models.Location;
import org.projectbuendia.models.Patient;
import org.projectbuendia.models.TypedCursor;

/** A patient list for a single location. */
public class SingleLocationActivity extends PatientListActivity {
    private String mLocationUuid;
    private long mPatientCount;

    public static void start(Context caller, Location location) {
        caller.startActivity(
            new Intent(caller, SingleLocationActivity.class)
                .putExtra("uuid", location.uuid));
    }

    @Override protected boolean onCreateImpl(Bundle state) {
        if (!super.onCreateImpl(state)) return false;

        setTitle(R.string.title_single_location);
        mLocationUuid = getIntent().getStringExtra("uuid");
        setContentView(R.layout.activity_single_location);
        getSearchController().setLocationFilter(mLocationUuid);
        return true;
    }

    @Override protected void setPatients(TypedCursor<Patient> patients) {
        mPatientCount = patients.getCount();
        setTitle(u.formatLocationHeading(mLocationUuid, mPatientCount));
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.lists;

import android.content.Context;
import android.database.Cursor;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;
import android.view.inputmethod.InputMethodManager;
import android.widget.SearchView;

import com.joanzapata.iconify.fonts.FontAwesomeIcons;

import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.client.events.sync.SyncSucceededEvent;
import org.projectbuendia.models.Patient;
import org.projectbuendia.models.TypedCursor;
import org.projectbuendia.client.providers.Contracts.Patients;
import org.projectbuendia.client.ui.BigToast;
import org.projectbuendia.client.ui.LoggedInActivity;
import org.projectbuendia.client.ui.ReadyState;
import org.projectbuendia.client.ui.chart.PatientChartActivity;
import org.projectbuendia.client.ui.dialogs.PatientDialogFragment;
import org.projectbuendia.client.utils.EventBusWrapper;
import org.projectbuendia.client.utils.Utils;

import javax.inject.Inject;

import de.greenrobot.event.EventBus;

/**
 * A {@link LoggedInActivity} with a {@link SearchView} that filters a patient list.
 * Clicking on patients in the list displays details for that patient.
 */
public abstract class PatientListActivity extends LoggedInActivity {
    @Inject EventBus mEventBus;

    private PatientSearchController mSearchController;
    private SearchView mSearchView;
    private static boolean sSkippedPatientList;
    private final EventBusSubscriber mSubscriber = new EventBusSubscriber();

    public PatientSearchController getSearchController() {
        return mSearchController;
    }

    @Override public void onExtendOptionsMenu(Menu menu) {
        super.onExtendOptionsMenu(menu);

        getMenuInflater().inflate(R.menu.main, menu);

        menu.findItem(R.id.action_new_patient).setOnMenuItemClickListener(
            menuItem -> {
                Utils.logEvent("add_patient_pressed");
                return openDialog(PatientDialogFragment.create(null));
            }
        );

        MenuItem search = menu.findItem(R.id.action_search);
        setMenuBarIcon(search, FontAwesomeIcons.fa_filter);
        search.setVisible(getReadyState() == ReadyState.READY);

        MenuItem addPatient = menu.findItem(R.id.action_new_patient);
        setMenuBarIcon(addPatient, FontAwesomeIcons.fa_user_plus);
        addPatient.setVisible(getReadyState() == ReadyState.READY);

        mSearchView = (SearchView) search.getActionView();
        mSearchView.setIconifiedByDefault(false);

        InputMethodManager mgr =
            (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
        mgr.hideSoftInputFromWindow(mSearchView.getWindowToken(), 0);

        mSearchView.setOnQueryTextListener(new SearchView.OnQueryTextListener() {
            @Override public boolean onQueryTextSubmit(String query) {
                InputMethodManager mgr = (InputMethodManager) getSystemService(
                    Context.INPUT_METHOD_SERVICE);
                mgr.hideSoftInputFromWindow(mSearchView.getWindowToken(), 0);
                return true;
            }

            @Override public boolean onQueryTextChange(String newText) {
                mSearchController.onQuerySubmitted(newText);
                return true;
            }
        });
    }

    @Override protected boolean onCreateImpl(Bundle state) {
        if (!super.onCreateImpl(state)) return false;

        mSearchController = new PatientSearchController(
            new SearchUi(),
            App.getCrudEventBus(),
            new EventBusWrapper(mEventBus),
            App.getModel(),
            App.getSyncManager());

        // To facilitate chart development, there's a developer setting that
        // causes the app to go straight to a patient chart on startup.
        if (!sSkippedPatientList && settings.shouldSkipToPatientChart()) {
            try (Cursor cursor = getContentResolver().query(
                Patients.URI, null, Patients.ID + " = ?",
                new String[] {settings.getStartingPatientId()}, null)) {
                if (cursor.moveToNext()) {
                    sSkippedPatientList = true;
                    PatientChartActivity.start(this, Utils.getString(cursor, Patients.UUID, null));
                }
            }
        }
        return true;
    }

    @Override protected void onResumeImpl() {
        super.onResumeImpl();
        attemptInit();
    }

    protected void attemptInit() {
        if (App.getModel().isReady()) {
            mSearchController.init();
            mSearchController.loadSearchResults();
        } else {
            mEventBus.register(mSubscriber);
        }
    }

    @Override protected void onPauseImpl() {
        super.onPauseImpl();
        if (mEventBus.isRegistered(mSubscriber)) mEventBus.unregister(mSubscriber);
        mSearchController.suspend();
    }

    protected void setPatients(TypedCursor<Patient> patients) {
        // By default, do nothing.
    }

    private final class SearchUi implements PatientSearchController.Ui {
        @Override public void setPatients(TypedCursor<Patient> patients) {
            // Delegate to implementers.
            PatientListActivity.this.setPatients(patients);
        }

        @Override public void goToPatientChart(String patientUuid) {
            BigToast.show(R.string.patient_creation_success);
            PatientChartActivity.start(PatientListActivity.this, patientUuid);
        }
    }

    private final class EventBusSubscriber {
        public void onEventMainThread(SyncSucceededEvent event) {
            mEventBus.unregister(mSubscriber);
            attemptInit();
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.lists;

import org.projectbuendia.client.AppSettings;
import org.projectbuendia.client.events.CrudEventBus;
import org.projectbuendia.client.events.actions.SyncCancelRequestedEvent;
import org.projectbuendia.client.events.sync.SyncCancelledEvent;
import org.projectbuendia.client.events.sync.SyncFailedEvent;
import org.projectbuendia.client.events.sync.SyncProgressEvent;
import org.projectbuendia.client.events.sync.SyncSucceededEvent;
import org.projectbuendia.models.AppModel;
import org.projectbuendia.models.Location;
import org.projectbuendia.models.LocationForest;
import org.projectbuendia.client.sync.SyncManager;
import org.projectbuendia.client.ui.ReadyState;
import org.projectbuendia.client.utils.EventBusRegistrationInterface;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

/** Controller for {@link LocationListActivity}. */
final class LocationListController {

    private static final Logger LOG = Logger.create();

    private final AppModel mAppModel;
    private final AppSettings mSettings;
    private final CrudEventBus mCrudEventBus;
    private final Ui mUi;
    private final Set<LocationListFragmentUi> mFragmentUis = new HashSet<>();
    private final EventBusRegistrationInterface mEventBus;
    private final EventBusSubscriber mEventBusSubscriber = new EventBusSubscriber();
    private final SyncManager mSyncManager;
    private final PatientSearchController mPatientSearchController;

    @Nullable private LocationForest mForest;

    /**
     * The ready state is SYNCING only when there is no data model yet and the
     * initial sync is running.  LOADING is the default non-ready state.
     */
    private ReadyState mReadyState = ReadyState.LOADING;

    /** True when the user has requested to cancel a sync and the sync hasn't stopped yet. */
    private boolean mUserCancelRequestPending = false;
    private final Object mSyncCancelLock = new Object();

    public interface Ui {

        void switchToLocationList();

        void switchToPatientList();

        void openSingleLocation(Location location);

        void showSyncFailedDialog(boolean show);

        void setReadyState(ReadyState state);

        void finish();
    }

    public interface LocationListFragmentUi {

        void setLocations(LocationForest forest, Collection<Location> locations);

        void setReadyState(ReadyState state);

        void setSyncProgress(int numerator, int denominator, Integer messageId);

        void showSyncCancelRequested();
    }

    public LocationListController(
        AppModel appModel,
        AppSettings settings,
        CrudEventBus crudEventBus,
        Ui ui,
        EventBusRegistrationInterface eventBus,
        SyncManager syncManager,
        PatientSearchController patientSearchController) {
        mAppModel = appModel;
        mSettings = settings;
        mCrudEventBus = crudEventBus;
        mUi = ui;
        mEventBus = eventBus;
        mSyncManager = syncManager;
        mPatientSearchController = patientSearchController;
    }

    public void init() {
        mUserCancelRequestPending = false;
        mEventBus.register(mEventBusSubscriber);
        mCrudEventBus.register(mEventBusSubscriber);
        if (mAppModel.isReady()) {
            loadForest();
        } else {
            LOG.w("Model has not been synced successfully yet; initiating full sync.");
            startInitialSync();
        }
    }

    public void loadForest() {
        setReadyState(ReadyState.LOADING);
        setForest(mAppModel.getForest());
        setReadyState(ReadyState.READY);
    }

    public void startInitialSync() {
        setReadyState(ReadyState.SYNCING);
        if (!mSyncManager.isSyncRunningOrPending()) {
            mSyncManager.syncAll();
        }
    }

    private void setForest(@Nonnull LocationForest forest) {
        mForest = forest;
        for (LocationListFragmentUi fragmentUi : mFragmentUis) {
            updateFragmentUi(fragmentUi);
        }
    }

    private void updateFragmentUi(LocationListFragmentUi fragmentUi) {
        if (mForest != null) {
            fragmentUi.setLocations(mForest, mForest.allNodes());
        }
        fragmentUi.setReadyState(mReadyState);
    }

    private void setReadyState(ReadyState state) {
        mReadyState = state;
        mUi.setReadyState(state);
        for (LocationListFragmentUi fragmentUi : mFragmentUis) {
            fragmentUi.setReadyState(state);
        }
    }

    public void attachFragmentUi(LocationListFragmentUi fragmentUi) {
        mFragmentUis.add(fragmentUi);
        updateFragmentUi(fragmentUi);
    }

    public void detachFragmentUi(LocationListFragmentUi fragmentUi) {
        mFragmentUis.remove(fragmentUi);
    }

    /** Frees any resources used by the controller. */
    public void suspend() {
        mCrudEventBus.unregister(mEventBusSubscriber);
        mEventBus.unregister(mEventBusSubscriber);
    }

    /** Call when the user presses the search button. */
    public void onSearchPressed() {
        Utils.logUserAction("search_pressed");
        mUi.switchToPatientList();
    }

    /** Call when the user exits search mode. */
    public void onSearchCancelled() {
        Utils.logUserAction("search_cancelled");
        mUi.switchToLocationList();
    }

    /** Call when the user presses a location. */
    public void onLocationSelected(Location location) {
        Utils.logUserAction("location_pressed", "location", location.name);
        mUi.openSingleLocation(location);
    }

    @SuppressWarnings("unused") // Called by reflection from EventBus
    private final class EventBusSubscriber {

        public void onEventMainThread(SyncCancelRequestedEvent event) {
            if (mReadyState == ReadyState.SYNCING) {
                synchronized (mSyncCancelLock) {
                    mUserCancelRequestPending = true;
                    for (LocationListFragmentUi fragmentUi : mFragmentUis) {
                        fragmentUi.showSyncCancelRequested();
                    }
                }
            }
        }

        public void onEventMainThread(SyncCancelledEvent event) {
            // If user-initiated cancellation occurred, close the activity even if we're no longer
            // waiting on a sync (continuing to load the activity might be jarring).
            synchronized (mSyncCancelLock) {
                if (mUserCancelRequestPending) {
                    LOG.d("User-initiated sync cancellation completed; finishing activity.");
                    mUi.finish();
                } else {
                    LOG.d("Sync cancelled, but not by the user.");
                }
            }
        }

        public void onEventMainThread(SyncProgressEvent event) {
            for (LocationListFragmentUi fragmentUi : mFragmentUis) {
                fragmentUi.setSyncProgress(event.numerator, event.denominator, event.messageId);
            }
        }

        public void onEventMainThread(SyncSucceededEvent event) {
            mUi.showSyncFailedDialog(false);
            loadForest();
        }

        public void onEventMainThread(SyncFailedEvent event) {
            if (mReadyState == ReadyState.SYNCING) {
                // Show the dialog only if the UI is waiting for this sync.
                mUi.showSyncFailedDialog(true);
                Utils.logEvent("sync_failed_dialog_shown");
                for (LocationListFragmentUi fragmentUi : mFragmentUis) {
                    fragmentUi.setSyncProgress(0, 0, null);
                }
                setReadyState(ReadyState.ERROR);
            }
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.lists;

import org.projectbuendia.client.App;
import org.projectbuendia.client.events.CrudEventBus;
import org.projectbuendia.client.events.actions.PatientChartRequestedEvent;
import org.projectbuendia.client.events.data.AppPatientsLoadedEvent;
import org.projectbuendia.client.events.data.ItemCreatedEvent;
import org.projectbuendia.client.events.sync.SyncSucceededEvent;
import org.projectbuendia.client.filter.db.SimpleSelectionFilter;
import org.projectbuendia.client.filter.db.SimpleSelectionFilterGroup;
import org.projectbuendia.client.filter.db.patient.LocationUuidFilter;
import org.projectbuendia.client.filter.db.patient.PatientDbFilters;
import org.projectbuendia.client.filter.matchers.FilteredCursor;
import org.projectbuendia.client.filter.matchers.MatchingFilter;
import org.projectbuendia.client.filter.matchers.MatchingFilterGroup;
import org.projectbuendia.client.filter.matchers.patient.IdFilter;
import org.projectbuendia.client.filter.matchers.patient.NameFilter;
import org.projectbuendia.models.AppModel;
import org.projectbuendia.models.LocationForest;
import org.projectbuendia.models.Patient;
import org.projectbuendia.models.TypedCursor;
import org.projectbuendia.client.sync.SyncManager;
import org.projectbuendia.client.utils.EventBusRegistrationInterface;
import org.projectbuendia.client.utils.Utils;

import java.util.HashSet;
import java.util.Set;

import de.greenrobot.event.EventBus;

import static org.projectbuendia.client.filter.matchers.MatchingFilterGroup.FilterType.OR;

/** Controller for {@link PatientListActivity}. */
public class PatientSearchController {

    private static final String TAG = PatientSearchController.class.getSimpleName();
    private static final boolean DEBUG = true;
    private final Ui mUi;
    private final CrudEventBus mCrudEventBus;
    private final EventBusRegistrationInterface mGlobalEventBus;
    private final AppModel mModel;
    private final SyncManager mSyncManager;
    private final Set<FragmentUi> mFragmentUis = new HashSet<>();
    private LocationForest mForest;
    private String mRootLocationUuid;
    private SimpleSelectionFilter mFilter;
    private String mFilterQueryTerm = "";
    private FilterSubscriber mFilterSubscriber;
    private final Object mFilterSubscriberLock = new Object();
    private final MatchingFilter<Patient> mSearchFilter =
        new MatchingFilterGroup<>(OR, new IdFilter(), new NameFilter());
    private TypedCursor<Patient> mPatientsCursor;
    private final SyncSubscriber mSyncSubscriber;
    private final CreationSubscriber mCreationSubscriber;

    public interface Ui {
        void setPatients(TypedCursor<Patient> patients);
        void goToPatientChart(String patientUuid);
    }

    public interface FragmentUi {
        void setPatients(TypedCursor<Patient> patients, LocationForest forest, String rootLocationUuid);
        void showSpinner(boolean show);
    }

    /**
     * Instantiates a {@link PatientSearchController} with the given UI implementation, event bus,
     * app model, and locale. The global event bus must also be passed in in order to reload results
     * after a sync.
     * @param ui             a {@link Ui} that will respond to UI events
     * @param crudEventBus   a {@link CrudEventBus} that will listen for patient and location fetch
     *                       events
     * @param globalEventBus a {@link EventBusRegistrationInterface} that will listen for sync
     *                       events
     * @param model          an {@link AppModel} for fetching patient and location data
     * @param syncManager    a {@link SyncManager} for listening for canceling syncs
     * @param locale         a language code/locale for presenting localized information (e.g. en)
     */
    public PatientSearchController(
        Ui ui,
        CrudEventBus crudEventBus,
        EventBusRegistrationInterface globalEventBus,
        AppModel model,
        SyncManager syncManager
    ) {
        mUi = ui;
        mCrudEventBus = crudEventBus;
        mGlobalEventBus = globalEventBus;
        mModel = model;
        mSyncManager = syncManager;
        mFilter = PatientDbFilters.getDefaultFilter();
        mSyncSubscriber = new SyncSubscriber();
        mCreationSubscriber = new CreationSubscriber();
    }

    /**
     * Requests resources required by this controller. Note that some resources may be fetched
     * asynchronously after this function returns.
     */
    public void init() {
        mGlobalEventBus.register(mSyncSubscriber);
        mCrudEventBus.register(mCreationSubscriber);
        mForest = mModel.getForest();
        mModel.setOnForestReplacedListener(() -> {
            mForest = mModel.getForest();
            updatePatients();
        });
    }

    /** Releases resources required by this controller. */
    public void suspend() {
        mGlobalEventBus.unregister(mSyncSubscriber);
        mCrudEventBus.unregister(mCreationSubscriber);
        // Close any outstanding cursors. New results will be fetched when requested.
        if (mPatientsCursor != null) {
            mPatientsCursor.close();
            mPatientsCursor = null;
        }
        mModel.setOnForestReplacedListener(null);
    }

    /** Updates the list of patients in the UI. */
    private void updatePatients() {
        if (mPatientsCursor != null) {
            mUi.setPatients(getFilteredCursor());
        }
        for (FragmentUi fragmentUi : mFragmentUis) {
            updateFragmentUi(fragmentUi);
        }
    }

    /** Registers a {@link FragmentUi} with this controller. */
    public void attachFragmentUi(FragmentUi fragmentUi) {
        mFragmentUis.add(fragmentUi);
        updateFragmentUi(fragmentUi);
    }

    private void updateFragmentUi(FragmentUi fragmentUi) {
        if (mPatientsCursor != null) {
            fragmentUi.setPatients(getFilteredCursor(), mForest, mRootLocationUuid);
            fragmentUi.showSpinner(false);
        }
    }

    /** Unregisters a {@link FragmentUi} with this controller. */
    public void detachFragmentUi(FragmentUi fragmentUi) {
        mFragmentUis.remove(fragmentUi);
    }

    /** Gets a cursor that returns the filtered list of patients. */
    private TypedCursor<Patient> getFilteredCursor() {
        return new FilteredCursor<>(mPatientsCursor, mSearchFilter, mFilterQueryTerm);
    }

    public void onPatientSelected(Patient patient) {
        EventBus.getDefault().post(new PatientChartRequestedEvent(patient.uuid));
    }

    public void onQuerySubmitted(String constraint) {
        App.getServer().cancelPendingRequests();

        mFilterQueryTerm = constraint;

        if (mPatientsCursor == null) {
            loadSearchResults();
            return;
        }
        updatePatients();
    }

    public void loadSearchResults() {
        loadSearchResults(true); // By default, show spinner.
    }

    /**
     * Asynchronously loads or reloads the search results based on previously specified filter and
     * root location. If no filter is specified, all results are shown be default.
     * @param showSpinner whether or not to show a spinner until operation is complete
     */
    public void loadSearchResults(boolean showSpinner) {
        // Ensure only one subscriber is listening to filter events.
        synchronized (mFilterSubscriberLock) {
            if (mFilterSubscriber != null) {
                mCrudEventBus.unregister(mFilterSubscriber);
            }
        }
        mFilterSubscriber = new FilterSubscriber();

        if (showSpinner) {
            for (FragmentUi fragmentUi : mFragmentUis) {
                fragmentUi.showSpinner(true);
            }
        }
        mCrudEventBus.register(mFilterSubscriber);
        mModel.loadPatients(mCrudEventBus, getLocationSubfilter(), mFilterQueryTerm);
    }

    private SimpleSelectionFilter getLocationSubfilter() {
        SimpleSelectionFilter filter;

        // Tack on a location filter to the filter to show only known locations.
        if (mRootLocationUuid == null) {
            filter = mFilter;
        } else {
            filter = new SimpleSelectionFilterGroup(new LocationUuidFilter(
                mForest, mForest.get(mRootLocationUuid)), mFilter);
        }

        return filter;
    }

    /**
     * Sets a root location for the purposes of filtering.
     * @param locationUuid UUID of the location to filter by
     */
    public void setLocationFilter(String locationUuid) {
        mRootLocationUuid = locationUuid;
    }

    /**
     * Sets the filter to filter by, which may be (optionally) in conjunction with a root location
     * specified by {@link PatientSearchController#setLocationFilter(String)}.
     * @param filter the {@link SimpleSelectionFilter} that will be applied to search results
     */
    public void setFilter(SimpleSelectionFilter filter) {
        mFilter = filter;
    }

    private class CreationSubscriber {
        public void onEventMainThread(ItemCreatedEvent<?> event) {
            if (event.item instanceof Patient) {
                Utils.logEvent("add_patient_succeeded");
                mUi.goToPatientChart(((Patient) event.item).uuid);
            }
        }
    }

    private class SyncSubscriber {
        public void onEventMainThread(SyncSucceededEvent event) {
            // Load search results, but don't show the spinner, as the user may be in the middle
            // of performing an operation.
            loadSearchResults(false);
        }
    }

    private final class FilterSubscriber {
        public void onEventMainThread(AppPatientsLoadedEvent event) {
            mCrudEventBus.unregister(this);

            // If a patient cursor was already open, close it.
            if (mPatientsCursor != null) {
                mPatientsCursor.close();
            }

            // Replace the patient cursor with the newly-fetched results.
            mPatientsCursor = event.cursor;
            updatePatients();
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.lists;

import org.projectbuendia.client.App;
import org.projectbuendia.client.diagnostics.HealthMonitor;
import org.projectbuendia.client.events.sync.SyncFailedEvent;
import org.projectbuendia.client.events.sync.SyncSucceededEvent;
import org.projectbuendia.client.sync.SyncManager;
import org.projectbuendia.client.utils.EventBusRegistrationInterface;
import org.projectbuendia.client.utils.Logger;

import javax.inject.Inject;

/** Controller for non-inherited parts of {@link PatientListFragment}. */
public class PatientListController {

    private static final Logger LOG = Logger.create();
    private final SyncSubscriber mSyncSubscriber = new SyncSubscriber();
    private final Ui mUi;
    private final SyncManager mSyncManager;
    @Inject HealthMonitor mHealthMonitor;
    /** True if a full sync initiated by this activity is in progress. */
    private boolean mInitiatedFullSync;
    private EventBusRegistrationInterface mEventBus;

    public interface Ui {
        /** Stops the refresh-in-progress animation. */
        void stopRefreshAnimation();

        /** Notifies the user that the refresh failed. */
        void showRefreshError();

        /** Notifies the user that the API is unhealthy. */
        void showApiHealthProblem();
    }

    /**
     * Initializes this with the given UI, sync manager, and event bus.
     * @param ui          {@link Ui} that will respond to list refresh events
     * @param syncManager a {@link SyncManager} for performing sync operations
     * @param eventBus    the {@link EventBusRegistrationInterface} that will listen for sync events
     */
    public PatientListController(
        Ui ui, SyncManager syncManager, EventBusRegistrationInterface eventBus) {
        mUi = ui;
        mSyncManager = syncManager;
        mEventBus = eventBus;
        App.inject(this);
    }

    public void init() {
        mEventBus.register(mSyncSubscriber);
    }

    public void suspend() {
        mEventBus.unregister(mSyncSubscriber);
    }

    /**
     * Forces a new sync of all data from server, unless this activity is already
     * waiting for a previously initiated sync.
     */
    public void onRefreshRequested() {
        if (mHealthMonitor.isApiUnavailable()) {
            mUi.stopRefreshAnimation();
            mUi.showApiHealthProblem();
        } else if (!mInitiatedFullSync) {
            LOG.d("onRefreshRequested");
            mSyncManager.syncAll();
            mInitiatedFullSync = true;
        }
    }

    private void onSyncFinished(boolean success) {
        mUi.stopRefreshAnimation();
        if (mInitiatedFullSync && !success) {
            mUi.showRefreshError();
        }
        mInitiatedFullSync = false;
    }

    private final class SyncSubscriber {
        public synchronized void onEventMainThread(SyncSucceededEvent event) {
            onSyncFinished(true);
        }

        public synchronized void onEventMainThread(SyncFailedEvent event) {
            onSyncFinished(false);
        }
    }
}

package org.projectbuendia.client.ui.lists;

import android.content.Context;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseExpandableListAdapter;

import org.projectbuendia.client.R;
import org.projectbuendia.models.Obs;
import org.projectbuendia.client.ui.dialogs.ObsDetailDialogFragment;
import org.projectbuendia.client.ui.dialogs.ObsDetailDialogFragment.Group;
import org.projectbuendia.client.utils.ContextUtils;
import org.projectbuendia.client.utils.Utils;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;

import static org.projectbuendia.client.utils.Utils.DateStyle.HOUR_MINUTE;
import static org.projectbuendia.client.utils.Utils.DateStyle.MONTH_DAY;

public class ExpandableObsAdapter extends BaseExpandableListAdapter {
    private final ContextUtils u;
    private final List<Group> mGroups;
    private final List<List<Obs>> mSectionObservations;

    private static String EM_DASH = "\u2014";
    private static String BULLET = "\u2022";

    public ExpandableObsAdapter(Context context, Map<Group, List<Obs>> observationsBySection) {
        u = ContextUtils.from(context);
        mGroups = new ArrayList<>(observationsBySection.keySet());
        mSectionObservations = new ArrayList<>();

        Comparator<Obs> orderByTime = (a, b) -> a.time.compareTo(b.time);

        for (int i = 0; i < mGroups.size(); i++) {
            ObsDetailDialogFragment.Group group = mGroups.get(i);
            List<Obs> observations = new ArrayList<>(observationsBySection.get(group));
            Collections.sort(observations, orderByTime);
            mSectionObservations.add(observations);
        }
    }

    @Override public View getGroupView(
        int groupIndex, boolean isExpanded, View view, ViewGroup parent) {
        view = u.reuseOrInflate(view, R.layout.obs_heading, parent);
        u.setText(R.id.heading_text, (String) getGroup(groupIndex));
        return view;
    }

    @Override public View getChildView(
        int groupIndex, int childIndex, boolean isLastChild, View view, ViewGroup parent) {
        view = u.reuseOrInflate(view, R.layout.obs_item, parent);
        u.setText(R.id.item_text, (String) getChild(groupIndex, childIndex));
        return view;
    }

    @Override public Object getGroup(int groupIndex) {
        Group group = mGroups.get(groupIndex);
        return Utils.format("%s " + BULLET + " %s",
            group.conceptUuid, Utils.format(group.date, MONTH_DAY));
    }

    @Override public Object getChild(int groupIndex, int childIndex) {
        Obs obs = mSectionObservations.get(groupIndex).get(childIndex);
        return Utils.format("%s " + EM_DASH + " %s",
            Utils.format(obs.time, HOUR_MINUTE), obs.valueName);
    }

    @Override public int getGroupCount() {
        return mGroups.size();
    }

    @Override public int getChildrenCount(int groupIndex) {
        return mSectionObservations.get(groupIndex).size();
    }

    @Override public long getGroupId(int groupIndex) {
        return groupIndex;
    }

    @Override public long getChildId(int groupIndex, int childIndex) {
        return childIndex;
    }

    @Override public boolean isChildSelectable(int groupIndex, int childIndex) {
        return true;
    }

    @Override public boolean hasStableIds() {
        return false;
    }
}


// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.lists;

import android.app.ActionBar;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;

import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.client.filter.db.SimpleSelectionFilter;
import org.projectbuendia.client.ui.SectionedSpinnerAdapter;
import org.projectbuendia.client.utils.Utils;

import java.util.List;

/** A list of patients with a choice of several filters in a dropdown menu. */
public class FilteredPatientListActivity extends PatientListActivity {
    private static final String SELECTED_FILTER_KEY = "selected_filter";

    private PatientFilterController mFilterController;
    private int mSelectedFilter = 0;

    public static void start(Context caller) {
        caller.startActivity(new Intent(caller, FilteredPatientListActivity.class));
    }

    @Override protected boolean onCreateImpl(Bundle state) {
        if (!super.onCreateImpl(state)) return false;

        setContentView(R.layout.activity_patient_list);
        if (state != null) mSelectedFilter = state.getInt(SELECTED_FILTER_KEY, 0);
        mFilterController = new PatientFilterController(new FilterUi(), App.getModel());
        return true;
    }

    @Override protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putInt(SELECTED_FILTER_KEY, getActionBar().getSelectedNavigationIndex());
    }

    private final class FilterUi implements PatientFilterController.Ui {

        private int lastPosition = 0;

        @Override public void populateActionBar(List<SimpleSelectionFilter<?>> filters) {
            SectionedSpinnerAdapter<SimpleSelectionFilter<?>> adapter = new SectionedSpinnerAdapter<>(
                FilteredPatientListActivity.this,
                R.layout.patient_list_spinner_dropdown_item,
                R.layout.patient_list_spinner_expanded_dropdown_item,
                R.layout.patient_list_spinner_expanded_section_divider,
                filters);

            ActionBar.OnNavigationListener callback = (position, id) -> {
                if (position != lastPosition) {
                    SimpleSelectionFilter<?> filter = filters.get(position);
                    getSearchController().setFilter(filter);
                    Utils.logUserAction("filter_selected", "filter", filter.toString());
                    getSearchController().loadSearchResults();
                    lastPosition = position;
                }
                return true;
            };

            final ActionBar actionBar = getActionBar();
            actionBar.setDisplayShowTitleEnabled(false);
            actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_LIST);
            actionBar.setListNavigationCallbacks(adapter, callback);
            actionBar.setSelectedNavigationItem(mSelectedFilter);

            getSearchController().setFilter(filters.get(mSelectedFilter));
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.lists;

import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ScrollView;

import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.models.Location;
import org.projectbuendia.models.LocationForest;
import org.projectbuendia.client.ui.ProgressFragment;
import org.projectbuendia.client.ui.ReadyState;
import org.projectbuendia.client.utils.Logger;

import java.util.Collection;

/** Displays a list of all locations. */
public final class LocationListFragment extends ProgressFragment {
    private static final Logger LOG = Logger.create();

    private LocationListController mController;
    private final Ui mUi = new Ui();
    private LocationOptionList mList;
    private ScrollView mScroll;
    private View mEmpty;

    public LocationListFragment() {
        // Required empty public constructor
    }

    @Override public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentLayout(R.layout.fragment_location_selection);
    }

    @Override public View onCreateView(
        LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = super.onCreateView(inflater, container, savedInstanceState);

        mScroll = view.findViewById(R.id.scroll_container);
        mEmpty = view.findViewById(R.id.empty);
        mList = new LocationOptionList(view.findViewById(R.id.list_container), false);
        if (App.getModel().isReady()) {
            LocationForest forest = App.getModel().getForest();
            mUi.setLocations(forest, forest.allNodes());
        }
        return view;
    }

    @Override public void onViewStateRestored(Bundle savedInstanceState) {
        super.onViewStateRestored(savedInstanceState);
        mController = ((LocationListActivity) getActivity()).getController();
        if (mController == null) {
            LOG.w("No controller for " + getActivity().getClass().getSimpleName());
        } else {
            mController.attachFragmentUi(mUi);
        }
    }

    @Override public void onResume() {
        super.onResume();
        if (mController != null) mController.init();
        mList.setOnLocationSelectedListener(location -> mController.onLocationSelected(location));
        ViewGroup.LayoutParams lp = mScroll.getLayoutParams();
        lp.width = ViewGroup.LayoutParams.MATCH_PARENT;
        mScroll.setLayoutParams(lp);
    }

    @Override public void onPause() {
        mList.setOnLocationSelectedListener(null);
        if (mController != null) mController.suspend();
        super.onPause();
    }

    @Override public void onDestroyView() {
        if (mController == null) {
            LOG.w("No controller for " + getActivity().getClass().getSimpleName());
        } else {
            mController.detachFragmentUi(mUi);
        }
        super.onDestroyView();
    }

    private final class Ui implements LocationListController.LocationListFragmentUi {
        @Override public void setLocations(LocationForest forest, Collection<Location> locations) {
            mEmpty.setVisibility(locations.isEmpty() ? View.VISIBLE : View.INVISIBLE);
            mScroll.setVisibility(locations.isEmpty() ? View.INVISIBLE : View.VISIBLE);
            mList.setLocations(forest, locations);
        }

        @Override public void setReadyState(ReadyState state) {
            LocationListFragment.this.setReadyState(state);
        }

        @Override public void setSyncProgress(int numerator, int denominator, Integer messageId) {
            setProgress(numerator, denominator);
            if (messageId != null) setProgressMessage(messageId);
        }

        @Override public void showSyncCancelRequested() {
            setProgressMessage(R.string.cancelling_sync);
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.lists;

import android.os.Bundle;
import android.support.v4.widget.SwipeRefreshLayout;
import android.view.View;
import android.widget.ExpandableListView;
import android.widget.ListView;

import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.models.AppModel;
import org.projectbuendia.models.Location;
import org.projectbuendia.models.LocationForest;
import org.projectbuendia.models.Patient;
import org.projectbuendia.models.TypedCursor;
import org.projectbuendia.client.sync.SyncManager;
import org.projectbuendia.client.ui.BigToast;
import org.projectbuendia.client.ui.PatientListAdapter;
import org.projectbuendia.client.ui.ProgressFragment;
import org.projectbuendia.client.ui.ReadyState;
import org.projectbuendia.client.utils.EventBusWrapper;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import javax.inject.Inject;

import de.greenrobot.event.EventBus;

/** A fragment showing a filterable list of patients. */
public class PatientListFragment extends ProgressFragment implements
    ExpandableListView.OnChildClickListener {
    private static final Logger LOG = Logger.create();

    /**
     * The serialization (saved instance state) Bundle key representing the
     * activated item position. Only used on tablets.
     */
    private static final String STATE_ACTIVATED_POSITION = "activated_position";
    private PatientSearchController mController;
    private PatientListController mListController;
    private PatientListAdapter mPatientAdapter;
    private FragmentUi mFragmentUi;
    private ListUi mListUi;

    @Inject AppModel mModel;
    @Inject SyncManager mSyncManager;

    /** The current activated item position. Only used on tablets. */
    private int mActivatedPosition = ListView.INVALID_POSITION;

    private ExpandableListView mListView;

    private SwipeRefreshLayout mSwipeToRefresh;

    /**
     * Mandatory empty constructor for the fragment manager to instantiate the
     * fragment (e.g. upon screen orientation changes).
     */
    public PatientListFragment() {
        mFragmentUi = new FragmentUi();
        mListUi = new ListUi();
    }

    @Override public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        App.inject(this);
        mListController = new PatientListController(
            mListUi, mSyncManager, new EventBusWrapper(EventBus.getDefault()));
        setContentLayout(R.layout.fragment_patient_list);
    }

    @Override public void onResume() {
        super.onResume();
        mListController.init();
    }

    @Override public void onPause() {
        mListController.suspend();
        super.onPause();
    }

    @Override public void onViewStateRestored(Bundle savedInstanceState) {
        super.onViewStateRestored(savedInstanceState);
        mController = ((PatientListActivity) getActivity()).getSearchController();
        mController.attachFragmentUi(mFragmentUi);
    }

    @Override public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        mListView = view.findViewById(R.id.fragment_patient_list);
        mListView.setEmptyView(view.findViewById(R.id.empty));
        mListView.setOnChildClickListener(this);
        mPatientAdapter = new PatientListAdapter(getActivity());
        mListView.setAdapter(mPatientAdapter);

        mSwipeToRefresh =
            view.findViewById(R.id.fragment_patient_list_swipe_to_refresh);
        mSwipeToRefresh.setOnRefreshListener(() -> {
            Utils.logUserAction("refresh_requested");
            mListController.onRefreshRequested();
        });

        // Restore the previously serialized activated item position.
        if (savedInstanceState != null
            && savedInstanceState.containsKey(STATE_ACTIVATED_POSITION)) {
            setActivatedPosition(savedInstanceState.getInt(STATE_ACTIVATED_POSITION));
        }
    }

    private void setActivatedPosition(int position) {
        if (position == ListView.INVALID_POSITION) {
            mListView.setItemChecked(mActivatedPosition, false);
        } else {
            mListView.setItemChecked(position, true);
        }

        mActivatedPosition = position;
    }

    @Override public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        if (mActivatedPosition != ListView.INVALID_POSITION) {
            // Serialize and persist the activated item position.
            outState.putInt(STATE_ACTIVATED_POSITION, mActivatedPosition);
        }
    }

    @Override public boolean onChildClick(
        ExpandableListView parent, View v, int groupIndex, int childIndex, long id) {
        Patient patient = (Patient) mPatientAdapter.getChild(groupIndex, childIndex);
        Utils.logUserAction("patient_pressed", "patient_uuid", patient.uuid);
        mController.onPatientSelected(patient);
        return true;
    }

    @Override public void onDestroyView() {
        mController.detachFragmentUi(mFragmentUi);
        super.onDestroyView();
    }

    private class FragmentUi implements PatientSearchController.FragmentUi {
        @Override public void setPatients(
            TypedCursor<Patient> patients, LocationForest forest, String rootLocationUuid) {
            if (mPatientAdapter != null) {
                Location root = forest.get(rootLocationUuid);
                mPatientAdapter.setPatients(patients, forest, !forest.isLeaf(root));
            }
        }

        @Override public void showSpinner(boolean show) {
            LOG.w("showSpinner %s", show);
            setReadyState(show ? ReadyState.LOADING : ReadyState.READY);
        }
    }

    private class ListUi implements PatientListController.Ui {

        @Override public void stopRefreshAnimation() {
            mSwipeToRefresh.setRefreshing(false);
        }

        @Override public void showRefreshError() {
            BigToast.show(R.string.patient_list_fragment_sync_error);
        }

        @Override public void showApiHealthProblem() {
            BigToast.show(R.string.api_health_problem);
        }
    }
}

package org.projectbuendia.client.ui.lists;

import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import com.google.android.flexbox.FlexboxLayout;

import org.projectbuendia.client.R;
import org.projectbuendia.models.Location;
import org.projectbuendia.models.LocationForest;
import org.projectbuendia.client.utils.ContextUtils;
import org.projectbuendia.client.utils.Utils;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.Nullable;

/**
 * An arrangement of selectable, nested buttons representing locations,
 * with the number of patients shown for each location.
 */
public class LocationOptionList {
    protected final ContextUtils c;
    protected final FlexboxLayout container;
    protected final List<Location> locations;
    protected final Map<String, View> itemsByUuid;
    protected final boolean highlightSelection;
    protected LocationForest forest;
    protected Location selectedLocation;
    protected OnItemSelectedListener onLocationSelectedListener;

    public LocationOptionList(FlexboxLayout container, boolean highlightSelection) {
        c = ContextUtils.from(container);
        this.container = container;
        this.locations = new ArrayList<>();
        this.itemsByUuid = new HashMap<>();
        this.selectedLocation = null;
        this.onLocationSelectedListener = null;
        this.highlightSelection = highlightSelection;
    }

    public void setLocations(LocationForest forest, Iterable<Location> locations) {
        clear();

        // First count how many colours we'll need.  Leaf nodes that are siblings
        // have the same colour; otherwise, we advance to a new colour.
        int colorIndexMax = 0;
        Location lastParent = null;
        for (Location location : locations) {
            Location parent = forest.getParent(location);
            if (parent != lastParent) colorIndexMax++;
            lastParent = parent;
        }
        if (colorIndexMax == 0) colorIndexMax = 1;  // avoid division by zero

        // Then create the option buttons with appropriate contents and colours.
        float colorIndex = 0;
        lastParent = null;
        for (Location location : locations) {
            double size = forest.isLeaf(location) ? 0.49 : 1;
            Location parent = forest.getParent(location);
            String parentUuid = parent != null ? parent.uuid : null;

            if (parent != lastParent) colorIndex++;
            int bgColor = getBgColor(colorIndex / colorIndexMax);
            int fgColor = getFgColor(bgColor);
            lastParent = parent;

            int numPatients = forest.countPatientsIn(location);
            View item = createItem(
                location.name, numPatients, parentUuid, fgColor, bgColor, size);

            item.setTag(location);
            item.setOnClickListener(clickedItem -> {
                setSelectedLocation((Location) clickedItem.getTag());
            });

            this.locations.add(location);
            itemsByUuid.put(location.uuid, item);
        }

        // Watch for updates to the patient counts.
        if (this.forest != null) {
            this.forest.setOnPatientCountsUpdatedListener(null);
        }
        this.forest = forest;
        this.forest.setOnPatientCountsUpdatedListener(() -> updateCounts(forest));
    }

    protected void updateCounts(LocationForest forest) {
        for (Location location : locations) {
            View item = itemsByUuid.get(location.uuid);
            TextView patientCount = item.findViewById(R.id.patient_count);
            int numPatients = forest.countPatientsIn(location);
            TextView locationName = item.findViewById(R.id.location_name);
            int fgColor = locationName.getCurrentTextColor();
            patientCount.setText("" + numPatients);
            patientCount.setTextColor(Utils.colorWithOpacity(fgColor, numPatients > 0 ? 1 : 0.25));
        }
    }

    protected void clear() {
        locations.clear();
        for (View item : itemsByUuid.values()) {
            item.setOnClickListener(null);
        }
        itemsByUuid.clear();
        while (container.getChildCount() > 0) {  // ViewGroup doesn't have a child iterator
            container.removeViewAt(0);
        }
    }

    protected View createItem(
        String label, int numPatients, String parentUuid,
        int fgColor, int bgColor, double relativeWidth) {
        ViewGroup parent = findContainer(parentUuid);
        View item = c.inflate(R.layout.location_list_item, parent);
        View button = item.findViewById(R.id.button);
        TextView locationName = item.findViewById(R.id.location_name);
        TextView patientCount = item.findViewById(R.id.patient_count);

        locationName.setText(label);
        patientCount.setText("" + numPatients);

        locationName.setTextColor(fgColor);
        patientCount.setTextColor(Utils.colorWithOpacity(fgColor, numPatients > 0 ? 1 : 0.25));
        button.setBackgroundColor(bgColor);

        FlexboxLayout.LayoutParams params = (FlexboxLayout.LayoutParams) item.getLayoutParams();
        // The method refers to "percent", but it takes a value between 0 and 1, not 0 and 100!
        params.setFlexBasisPercent((float) relativeWidth);
        item.setLayoutParams(params);
        parent.addView(item);
        parent.setVisibility(View.VISIBLE);
        return item;
    }

    private ViewGroup findContainer(String uuid) {
        View item = itemsByUuid.get(uuid);
        if (item != null) {
            return item.findViewById(R.id.child_container);
        }
        return container;
    }

    private int getBgColor(float fraction) {
        float rStart = 200;
        float gStart = 200;
        float bStart = 200;
        float rEnd = 10;
        float gEnd = 92;
        float bEnd = 80;
        int r = (int) (rStart + (rEnd - rStart) * fraction);
        int g = (int) (gStart + (gEnd - gStart) * fraction);
        int b = (int) (bStart + (bEnd - bStart) * fraction);
        return (0xff << 24) + (r << 16)+ (g << 8) + b;
    }

    private int getFgColor(int bg) {
        int r = (bg >> 16) & 0xff;
        int g = (bg >> 8) & 0xff;
        int b = bg & 0xff;
        double luminance = 0.3 * r + 0.58 * g + 0.12 * b;
        return luminance > 128 ? 0xff_00_00_00 : 0xff_ff_ff_ff;
    }

    public void setSelectedLocation(Location selectedLocation) {
        this.selectedLocation = selectedLocation;

        if (highlightSelection) {
            for (Location location : locations) {
                itemsByUuid.get(location.uuid).setSelected(location.equals(selectedLocation));
            }
        }
        if (onLocationSelectedListener != null) {
            onLocationSelectedListener.onSelected(selectedLocation);
        }
    }

    public Location getSelectedLocation() {
        return selectedLocation;
    }

    public void setOnLocationSelectedListener(OnItemSelectedListener listener) {
        onLocationSelectedListener = listener;
    }

    public interface OnItemSelectedListener {
        void onSelected(@Nullable Location option);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.lists;

import android.app.AlertDialog;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;

import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.models.Location;
import org.projectbuendia.client.ui.ReadyState;
import org.projectbuendia.client.ui.SettingsActivity;
import org.projectbuendia.client.utils.EventBusWrapper;
import org.projectbuendia.client.utils.Utils;

import de.greenrobot.event.EventBus;

/** Displays a list of locations and allows users to search through a list of patients. */
public final class LocationListActivity extends PatientListActivity {

    private LocationListController mController;
    private AlertDialog mSyncFailedDialog;

    public static void start(Context caller) {
        caller.startActivity(new Intent(caller, LocationListActivity.class));
    }

    @Override public void onExtendOptionsMenu(Menu menu) {
        super.onExtendOptionsMenu(menu);

        MenuItem searchItem = menu.findItem(R.id.action_search);
        searchItem.setOnActionExpandListener(new MenuItem.OnActionExpandListener() {
            @Override public boolean onMenuItemActionExpand(MenuItem item) {
                mController.onSearchPressed();
                return true;
            }

            @Override public boolean onMenuItemActionCollapse(MenuItem item) {
                mController.onSearchCancelled();
                return true;
            }
        });
    }

    @Override protected boolean onCreateImpl(Bundle state) {
        if (!super.onCreateImpl(state)) return false;
        setTitle(R.string.title_location_list);

        mController = new LocationListController(
            App.getModel(),
            settings,
            App.getCrudEventBus(),
            new Ui(),
            new EventBusWrapper(EventBus.getDefault()),
            App.getSyncManager(),
            getSearchController());

        mSyncFailedDialog = new AlertDialog.Builder(this)
            .setIcon(android.R.drawable.ic_dialog_alert)
            .setTitle(getString(R.string.sync_failed_dialog_title))
            .setMessage(R.string.sync_failed_dialog_message)
            .setNegativeButton(
                R.string.sync_failed_back, (dialog, which) -> {
                    Utils.logEvent("sync_failed_back_pressed");
                    finish();
                })
            .setNeutralButton(
                R.string.sync_failed_settings, (dialog, which) -> {
                    Utils.logEvent("sync_failed_settings_pressed");
                    SettingsActivity.start(LocationListActivity.this);
                })
            .setPositiveButton(
                R.string.sync_failed_retry, (dialog, which) -> {
                    Utils.logEvent("sync_failed_retry_pressed");
                    mController.startInitialSync();
                })
            .setCancelable(false)
            .create();

        setContentView(R.layout.activity_location_selection);
        if (state == null) {
            getSupportFragmentManager().beginTransaction()
                .add(R.id.location_selection_container, new LocationListFragment())
                .commit();
        }
        return true;
    }

    LocationListController getController() {
        return mController;
    }

    private final class Ui implements LocationListController.Ui {
        @Override public void switchToLocationList() {
            getSupportFragmentManager().popBackStack();
        }

        @Override public void switchToPatientList() {
            getSupportFragmentManager().beginTransaction()
                .replace(R.id.location_selection_container, new PatientListFragment())
                .addToBackStack(null)
                .commit();
        }

        @Override public void showSyncFailedDialog(boolean show) {
            Utils.showDialogIf(mSyncFailedDialog, show);
        }

        @Override public void setReadyState(ReadyState state) {
            LocationListActivity.this.setReadyState(state);
        }

        @Override public void finish() {
            LocationListActivity.this.finish();
        }

        @Override public void openSingleLocation(Location location) {
            SingleLocationActivity.start(LocationListActivity.this, location);
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.chart;

import android.app.Activity;
import android.content.Intent;
import android.graphics.Point;
import android.support.annotation.VisibleForTesting;
import android.webkit.JavascriptInterface;

import org.joda.time.DateTime;
import org.joda.time.Interval;
import org.joda.time.LocalDate;
import org.odk.collect.android.model.Preset;
import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.client.events.CrudEventBus;
import org.projectbuendia.client.events.FetchXformFailedEvent;
import org.projectbuendia.client.events.FetchXformFailedEvent.Reason;
import org.projectbuendia.client.events.FetchXformSucceededEvent;
import org.projectbuendia.client.events.SubmitXformFailedEvent;
import org.projectbuendia.client.events.SubmitXformSucceededEvent;
import org.projectbuendia.client.events.actions.ObsDeleteRequestedEvent;
import org.projectbuendia.client.events.actions.OrderAddRequestedEvent;
import org.projectbuendia.client.events.actions.OrderDeleteRequestedEvent;
import org.projectbuendia.client.events.actions.OrderDialogRequestedEvent;
import org.projectbuendia.client.events.actions.OrderExecutionAddRequestedEvent;
import org.projectbuendia.client.events.actions.OrderStopRequestedEvent;
import org.projectbuendia.client.events.data.EncounterAddFailedEvent;
import org.projectbuendia.client.events.data.ItemDeletedEvent;
import org.projectbuendia.client.events.data.ItemLoadedEvent;
import org.projectbuendia.client.events.data.PatientUpdateFailedEvent;
import org.projectbuendia.client.events.sync.SyncSucceededEvent;
import org.projectbuendia.client.json.Datatype;
import org.projectbuendia.client.json.JsonUser;
import org.projectbuendia.models.AppModel;
import org.projectbuendia.models.Chart;
import org.projectbuendia.models.ChartItem;
import org.projectbuendia.models.ChartSection;
import org.projectbuendia.models.ConceptUuids;
import org.projectbuendia.models.Encounter;
import org.projectbuendia.models.Obs;
import org.projectbuendia.models.ObsValue;
import org.projectbuendia.models.Order;
import org.projectbuendia.models.Patient;
import org.projectbuendia.client.sync.ChartDataHelper;
import org.projectbuendia.client.sync.ConceptService;
import org.projectbuendia.client.utils.EventBusRegistrationInterface;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.Nullable;

import static org.projectbuendia.client.utils.Utils.eq;

/** Controller for {@link PatientChartActivity}. */
public final class PatientChartController implements ChartRenderer.JsInterface {

    private static final Logger LOG = Logger.create();
    private static final boolean DEBUG = true;

    @VisibleForTesting public static String currentPatientUuid;

    // Form UUIDs specific to Ebola deployments.
    static final String EBOLA_LAB_TEST_FORM_UUID = "buendia_form_ebola_lab_test";

    /**
     * Period between observation syncs while the chart view is active.
     * It would be nice to make this very short, but note that the grid
     * scroll position resets every time the sync causes data to change.
     */
    private static final int PATIENT_UPDATE_PERIOD_MILLIS = 10000;

    private Patient mPatient = null;
    private String mPatientUuid = "";
    private Map<String, Order> mOrdersByUuid;
    private List<Obs> mObservations;

    private final EventBusRegistrationInterface mDefaultEventBus;
    private final CrudEventBus mCrudEventBus;
    private final OdkResultSender mOdkResultSender;
    private final Ui mUi;
    private final ChartDataHelper mChartHelper;
    private final AppModel mModel;
    private final EventSubscriber mEventBusSubscriber = new EventSubscriber();
    private final MinimalHandler mMainThreadHandler;
    private AssignGeneralConditionDialog mAssignGeneralConditionDialog;
    private Runnable mActivePatientUpdater;

    /** The user has requested a form, and it's either open or about to be opened. */
    private boolean mFormPending = false;

    private List<Chart> mCharts;
    private int mChartIndex = 0;  // the currently selected tab (chart number)

    // Every form request made by this controller is kept in this list until
    // the form is closed.
    List<FormRequest> mFormRequests = new ArrayList<>();

    // Store chart's last scroll position
    private Point mLastScrollPosition;
    public Point getLastScrollPosition() {
        return mLastScrollPosition;
    }

    public interface Ui {
        /** Sets the activity title. */
        void setTitle(String title);

        /** Updates the UI showing the history of observations and orders for this patient. */
        void updateTilesAndGrid(Chart chart, Map<String, Obs> latestObservations,
            List<Obs> observations, List<Order> orders);

        /** Updates the UI with the patient's personal details (name, sex, etc.) */
        void updatePatientDetailsUi(Patient patient);

        /** Shows a progress dialog with an indeterminate spinner in it. */
        void showWaitDialog(int titleId);

        void hideWaitDialog();

        /** Displays an error message with the given resource id. */
        void showError(int errorMessageResource);

        /** Displays an error with the given resource and optional substitution args. */
        void showError(int errorResource, Object... args);

        /** Starts a new form activity to collect observations from the user. */
        void fetchAndShowXform(
            int requestCode, String formUuid, org.odk.collect.android.model.Patient patient,
            Preset preset);

        void showFormLoadingDialog(boolean show);
        void showFormSubmissionDialog(boolean show);
        void showDateObsDialog(String title, Obs obs);
        void showTextObsDialog(String title, Obs obs);
        void showOrderDialog(String patientUuid, Order order, List<Obs> executions);
        void showOrderExecutionDialog(Order order, Interval interval, List<Obs> executions);
        void showEditPatientDialog(Patient patient);
        void showObsDetailDialog(
            Interval interval, String[] queriedConceptUuids,
            String[] conceptOrdering, List<Obs> observations);
        void showPatientLocationDialog(Patient patient);
        void showPatientUpdateFailed(int reason);
    }

    /** Sends ODK form data. */
    public interface OdkResultSender {
        void sendOdkResultToServer(
            @Nullable String patientUuid,
            int resultCode,
            Intent data);
    }

    public interface MinimalHandler {
        void post(Runnable runnable);
    }

    public PatientChartController(
        EventBusRegistrationInterface defaultEventBus,
        CrudEventBus crudEventBus,
        Ui ui,
        String patientUuid,
        OdkResultSender odkResultSender,
        ChartDataHelper chartHelper,
        MinimalHandler mainThreadHandler) {
        mModel = App.getModel();
        mDefaultEventBus = defaultEventBus;
        mCrudEventBus = crudEventBus;
        mUi = ui;
        currentPatientUuid = mPatientUuid = patientUuid;
        mOdkResultSender = odkResultSender;
        mChartHelper = chartHelper;
        mMainThreadHandler = mainThreadHandler;
        mLastScrollPosition = new Point(Integer.MAX_VALUE, 0);
        mCharts = mChartHelper.getCharts(App.getSettings().getLocale());
    }

    public void setPatient(String uuid) {
        // Clear all patient-specific state.
        mPatient = null;
        mOrdersByUuid = null;
        mObservations = null;
        if (mAssignGeneralConditionDialog != null) {
            mAssignGeneralConditionDialog.dismiss();
            mAssignGeneralConditionDialog = null;
        }

        // Load a new patient, which will trigger UI updates.
        currentPatientUuid = mPatientUuid = uuid;
        mModel.loadSinglePatient(mCrudEventBus, mPatientUuid);
    }

    /** Sets async operations going to collect data required by the UI. */
    public void init() {
        mDefaultEventBus.register(mEventBusSubscriber);
        mCrudEventBus.register(mEventBusSubscriber);
        mModel.loadSinglePatient(mCrudEventBus, mPatientUuid);
    }

    /** Releases any resources used by the controller. */
    public void suspend() {
        mActivePatientUpdater = null;  // clearing this stops the patient update loop

        mCrudEventBus.unregister(mEventBusSubscriber);
        mDefaultEventBus.unregister(mEventBusSubscriber);
    }

    public void onXFormResult(int requestCode, int resultCode, Intent data) {
        App.getSyncManager().setNewSyncsSuppressed(false);
        mFormPending = false;

        FormRequest request = popFormRequest(requestCode);
        if (request == null) {
            LOG.e("Unknown form request code: " + requestCode);
            return;
        }

        boolean cancelled = (resultCode == Activity.RESULT_CANCELED);
        String action = cancelled ? "form_discard_pressed" : "form_save_pressed";
        Utils.logUserAction(action,
            "form", request.formUuid,
            "patient_uuid", request.patientUuid);
        mUi.showFormSubmissionDialog(!cancelled);
        if (!cancelled) {
            mOdkResultSender.sendOdkResultToServer(request.patientUuid, resultCode, data);
        }
    }

    FormRequest popFormRequest(int requestIndex) {
        FormRequest request = mFormRequests.get(requestIndex);
        mFormRequests.set(requestIndex, null);
        return request;
    }

    public void onEditPatientPressed() {
        Utils.logUserAction("edit_patient_pressed", "uuid", mPatientUuid);
        mUi.showEditPatientDialog(mPatient);
    }

    private boolean dialogShowing() {
        return (mAssignGeneralConditionDialog != null && mAssignGeneralConditionDialog.isShowing());
    }

    FormRequest createFormRequest(String formUuid, String patientUuid, Preset preset) {
        // Find an empty slot in the array of all existing form requests.
        int requestIndex = 0;
        while (requestIndex < mFormRequests.size() && mFormRequests.get(requestIndex) != null) {
            requestIndex++;
        }
        if (requestIndex >= mFormRequests.size()) {
            mFormRequests.add(null);
        }
        FormRequest request = new FormRequest(formUuid, patientUuid, preset, requestIndex);
        mFormRequests.set(requestIndex, request);
        return request;
    }

    public void onFormRequested(String formUuid) {
        if (!dialogShowing()) requestForm(formUuid, null);
    }

    public void requestForm(String formUuid, String targetGroup) {
        Utils.logUserAction("form_opener_pressed", "form", "round", "group", targetGroup);
        if (mFormPending) {
            LOG.w("Form request is already pending; not opening another form");
            return;
        }

        JsonUser user = App.getUserManager().getActiveUser();
        if (user == null) {
            mUi.showError(R.string.no_user);
            return;
        }
        if (mModel.getDefaultLocation() == null) {
            mUi.showError(R.string.no_location);
            return;
        }

        // Preset the provider and location so they don't appear as questions in the form.
        Preset preset = new Preset();
        preset.providerUuid = user.getUuid();
        preset.locationUuid = mPatient.locationUuid;
        if (preset.locationUuid == null) {
            if (mModel.getDefaultLocation() != null) {
                preset.locationUuid = mModel.getDefaultLocation().uuid;
            }
        }
        Map<String, Obs> observations = mChartHelper.getLatestObservations(mPatientUuid);
        if (mPatient.pregnancy) {
            preset.pregnancy = Preset.YES;
        }
        if (ConceptUuids.isYes(observations.get(ConceptUuids.IV_UUID))) {
            preset.ivAccess = Preset.YES;
        }
        preset.targetGroup = targetGroup;

        mFormPending = true;
        mUi.showFormLoadingDialog(true);
        openForm(createFormRequest(formUuid, mPatientUuid, preset));
    }

    private void openForm(FormRequest request) {
        LOG.i("Fetching and showing form: %s", request.formUuid);
        mUi.fetchAndShowXform(
            request.requestIndex,
            request.formUuid,
            mPatient.toOdkPatient(),
            request.preset
        );
    }

    @JavascriptInterface public void showObsDialog(String conceptUuids) {
        if (!conceptUuids.contains(",")) {
            String uuid = conceptUuids;
            if (eq(uuid, ConceptUuids.PLACEMENT_UUID)) {
                mUi.showPatientLocationDialog(mPatient);
                return;
            }
            ConceptService concepts = App.getConceptService();
            Datatype type = concepts.getType(uuid);

            if (type == Datatype.TEXT) {
                String title = concepts.getName(uuid, App.getSettings().getLocale());
                Map<String, Obs> latest = mChartHelper.getLatestObservations(mPatientUuid);
                Obs obs = latest.get(uuid);
                if (obs == null) {
                    obs = new Obs(null, null, mPatientUuid, null, uuid, type, DateTime.now(), null, "", "");
                }
                // if (type == Datatype.DATE) mUi.showDateObsDialog(title, obs);
                if (type == Datatype.TEXT) mUi.showTextObsDialog(title, obs);
                return;
            }
        }
        mUi.showObsDetailDialog(
            null,
            conceptUuids.split(","),
            getConceptUuidsInChartOrder(getCurrentChart()),
            mChartHelper.getPatientObservations(mPatientUuid, conceptUuids.split(","), null, null)
        );
    }

    @JavascriptInterface public void showObsDialog(long startMillis, long stopMillis) {
        Interval interval = new Interval(startMillis, stopMillis);
        mUi.showObsDetailDialog(
            interval,
            null,
            getConceptUuidsInChartOrder(getCurrentChart()),
            mChartHelper.getPatientObservations(mPatientUuid, null, startMillis, stopMillis)
        );
    }

    @JavascriptInterface public void showObsDialog(String conceptUuids, long startMillis, long stopMillis) {
        Interval interval = new Interval(startMillis, stopMillis);
        mUi.showObsDetailDialog(
            interval,
            conceptUuids.split(","),
            getConceptUuidsInChartOrder(getCurrentChart()),
            mChartHelper.getPatientObservations(mPatientUuid, conceptUuids.split(","), startMillis, stopMillis)
        );
    }

    @JavascriptInterface public void onNewOrderPressed() {
        mUi.showOrderDialog(mPatientUuid, null, null);
    }

    @JavascriptInterface public void onOrderHeadingPressed(String orderUuid) {
        mUi.showOrderDialog(mPatientUuid, mOrdersByUuid.get(orderUuid), getExecutions(orderUuid));
    }

    @JavascriptInterface public void onOrderCellPressed(String orderUuid, long startMillis) {
        Order order = mOrdersByUuid.get(orderUuid);
        DateTime start = Utils.toLocalDateTime(startMillis);
        Interval interval = new Interval(start, start.plusDays(1));
        mUi.showOrderExecutionDialog(order, interval, getExecutions(orderUuid));
    }

    private List<Obs> getExecutions(String orderUuid) {
        List<Obs> executions = new ArrayList<>();
        for (Obs obs : mObservations) {
            if (eq(obs.conceptUuid, ConceptUuids.ORDER_EXECUTED_UUID) &&
                eq(orderUuid, obs.orderUuid)) {
                executions.add(obs);
            }
        }
        return executions;
    }

    @JavascriptInterface public void onPageUnload(int scrollX, int scrollY) {
        mLastScrollPosition.set(scrollX, scrollY);
    }

    @JavascriptInterface public void log(String message) {
        LOG.elapsed("ChartJS", message);
    }

    @JavascriptInterface public void finish() {
        LOG.finish("ChartJS");
    }

    public void submitDateObs(String conceptUuid, LocalDate date) {
        mUi.showWaitDialog(R.string.title_updating_patient);
        mModel.addObservationEncounter(mCrudEventBus, mPatientUuid, new Obs(
            null, null, mPatientUuid, Utils.getProviderUuid(), conceptUuid, Datatype.DATE,
            DateTime.now(), null, date.toString(), null
        ));
    }

    public void setZoomIndex(int index) {
        App.getSettings().setChartZoomIndex(index);
        updatePatientObsUi();
    }

    public void setChartIndex(int chartIndex) {
        mChartIndex = chartIndex;
        updatePatientObsUi();
    }

    /** Gets the latest observation values and displays them on the UI. */
    public synchronized void updatePatientObsUi() {
        // Get the observations and orders
        // TODO: Background thread this, or make this call async-like.
        String patientId = mPatient != null ? mPatient.id : "(unknown)";
        LOG.start("updatePatientObsUi", "patientId = %s", patientId);

        mObservations = mChartHelper.getObservations(mPatientUuid);
        Map<String, Obs> latestObservations =
            new HashMap<>(mChartHelper.getLatestObservations(mPatientUuid));
        List<Order> orders = mChartHelper.getOrders(mPatientUuid);
        mOrdersByUuid = new HashMap<>();
        for (Order order : orders) {
            mOrdersByUuid.put(order.uuid, order);
        }
        LOG.elapsed("updatePatientObsUi", "%d obs, %d orders", mObservations.size(), orders.size());

        if (!mCharts.isEmpty()) {
            mUi.updateTilesAndGrid(
                mCharts.get(mChartIndex),
                latestObservations, mObservations, orders);
        }

        LOG.finish("updatePatientObsUi");
    }

    public List<Chart> getCharts(){
        return mCharts;
    }

    private Chart getCurrentChart() {
        return mCharts.get(mChartIndex);
    }

    private String[] getConceptUuidsInChartOrder(Chart chart) {
        ArrayList<String> conceptUuids = new ArrayList<>();
        for (ChartSection chartSection : chart.rowGroups) {
            for (ChartItem chartItem : chartSection.items) {
                conceptUuids.addAll(Arrays.asList(chartItem.conceptUuids));
            }
        }
        return conceptUuids.toArray(new String[0]);
    }

    /** Retrieves the value of a date observation as a LocalDate. */
    private @Nullable LocalDate getObservedDate(
        Map<String, Obs> observations, String conceptUuid) {
        Obs obs = observations.get(conceptUuid);
        ObsValue value = obs != null ? obs.getObsValue() : null;
        return value != null ? value.date : null;
    }

    /** Represents an instance of a form being opened by the user. */
    class FormRequest {
        public final String formUuid;
        public final String patientUuid;
        public final Preset preset;
        public final int requestIndex;

        public FormRequest(String formUuid, String patientUuid, Preset preset, int index) {
            this.formUuid = formUuid;
            this.patientUuid = patientUuid;
            this.preset = preset;
            this.requestIndex = index;
        }
    }

    @SuppressWarnings("unused") // Called by reflection from EventBus.
    private final class EventSubscriber {

        public void onEventMainThread(SyncSucceededEvent event) {
            updatePatientObsUi(); // if the sync fetched observations
            mModel.loadSinglePatient(mCrudEventBus, mPatientUuid); // if the sync touched this patient
        }

        public void onEventMainThread(EncounterAddFailedEvent event) {
            LOG.e(event.exception, "Encounter add failed.");
            mUi.hideWaitDialog();
            if (mAssignGeneralConditionDialog != null) {
                mAssignGeneralConditionDialog.onEncounterAddFailed(event);
            }
        }

        // We get a ItemLoadedEvent when the initial patient data is loaded
        // from SQLite or after an edit has been successfully posted to the server.
        public void onEventMainThread(ItemLoadedEvent<?> event) {
            if (event.item instanceof Patient) {
                mUi.hideWaitDialog();

                // Update the parts of the UI that use data in the Patient.
                Patient patient = (Patient) event.item;
                if (patient.uuid.equals(mPatientUuid)) {
                    mPatient = patient;
                    mUi.updatePatientDetailsUi(mPatient);
                }
            } else if (event.item instanceof Encounter) {
                mUi.hideWaitDialog();

                // We don't need to update the UI here because updatePatientObsUi()
                // below updates all the parts of the UI that use observation data.
            }

            // TODO: Displaying the observations part of the UI takes a lot of main-thread time.
            // This delays rendering of the rest of UI. To allow the rest of the UI to be displayed
            // before we attempt to populate the observations, we delay the observation update
            // slightly. We need this hack because we load observations on the main thread. We
            // should change this to use a background thread. Either an async task or using
            // CrudEventBus events.
            mMainThreadHandler.post(PatientChartController.this::updatePatientObsUi);
        }

        public void onEventMainThread(ItemDeletedEvent event) {
            mMainThreadHandler.post(PatientChartController.this::updatePatientObsUi);
        }

        public void onEventMainThread(PatientUpdateFailedEvent event) {
            LOG.e(event.exception, "Patient update failed.");
            mUi.hideWaitDialog();
            mUi.showPatientUpdateFailed(event.reason);
        }

        public void onEventMainThread(SubmitXformSucceededEvent event) {
            mMainThreadHandler.post(() -> {
                updatePatientObsUi();
                mUi.showFormSubmissionDialog(false);
            });
        }

        public void onEventMainThread(SubmitXformFailedEvent event) {
            mUi.showFormSubmissionDialog(false);
            // Java switch is not safe to use because it stupidly crashes on null.
            int messageId =
                event.reason == SubmitXformFailedEvent.Reason.SERVER_AUTH ? R.string.submit_xform_failed_server_auth
                : event.reason == SubmitXformFailedEvent.Reason.SERVER_TIMEOUT ? R.string.submit_xform_failed_server_timeout
                : R.string.submit_xform_failed_unknown_reason;
            mUi.showError(messageId);
        }

        public void onEventMainThread(FetchXformSucceededEvent event) {
            mUi.showFormLoadingDialog(false);
        }

        public void onEventMainThread(FetchXformFailedEvent event) {
            // Java switch is not safe to use because it stupidly crashes on null.
            int messageId =
                event.reason == Reason.NO_FORMS_FOUND ? R.string.fetch_xform_failed_no_forms_found
                : event.reason == Reason.SERVER_AUTH ? R.string.fetch_xform_failed_server_auth
                : event.reason == Reason.SERVER_BAD_ENDPOINT ? R.string.fetch_xform_failed_server_bad_endpoint
                : event.reason == Reason.SERVER_FAILED_TO_FETCH ? R.string.fetch_xform_failed_server_failed_to_fetch
                : event.reason == Reason.SERVER_UNKNOWN ? R.string.fetch_xform_failed_server_unknown
                : R.string.fetch_xform_failed_unknown_reason;
            mFormPending = false;
            mUi.showFormLoadingDialog(false);
            mUi.showError(messageId);
        }

        public void onEventMainThread(OrderDialogRequestedEvent event) {
            mUi.showOrderDialog(mPatientUuid, null, null);
        }

        public void onEventMainThread(OrderAddRequestedEvent event) {
            DateTime start = event.start;
            DateTime stop = null;

            if (event.durationDays != null) {
                stop = start.plusDays(event.durationDays);
                // In OpenMRS, OrderServiceImpl.saveOrderInternal() has a crazy
                // special case that changes an expiry time at 00:00:00.000 on
                // any date to 23:59:59.999 on that date.  To prevent such an
                // expiry time from being advanced almost an entire day, we have
                // to detect this special case and shift the expiry time a bit.
                // Because we can't be sure that the client's time zone matches
                // the server's time zone, we have to do this for any time that
                // might be at 00:00:00.000 in any time zone.  Conservatively,
                // we treat any time with a whole number of minutes this way.
                if (stop.getSecondOfMinute() == 0 && stop.getMillisOfSecond() == 0) {
                    stop = stop.withMillisOfSecond(1);
                }
            }

            LOG.i("Saving order: %s", event.instructions);
            mModel.addOrder(mCrudEventBus, new Order(
                event.orderUuid, event.patientUuid, event.providerUuid,
                event.instructions, start, stop));
        }

        public void onEventMainThread(OrderStopRequestedEvent event) {
            Order order = mOrdersByUuid.get(event.orderUuid);
            DateTime newStop = DateTime.now();
            if (order.isSeries() && (order.stop == null || newStop.isBefore(order.stop))) {
                LOG.i("Stopping order: %s", order.instructions);
                mModel.addOrder(mCrudEventBus, new Order(
                    event.orderUuid, order.patientUuid, order.providerUuid,
                    order.instructions, order.start, newStop
                ));
            }
        }

        public void onEventMainThread(OrderDeleteRequestedEvent event) {
            mModel.deleteOrder(mCrudEventBus, event.orderUuid);
        }

        public void onEventMainThread(ObsDeleteRequestedEvent event) {
            for (Obs obs : event.observations) {
                mModel.deleteObs(mCrudEventBus, obs);
            }
            updatePatientObsUi();
        }

        public void onEventMainThread(OrderExecutionAddRequestedEvent event) {
            Order order = mOrdersByUuid.get(event.orderUuid);
            if (order != null) {
                mModel.addOrderExecutionEncounter(
                    mCrudEventBus, mPatient.uuid, order.uuid, event.executionTime);
            }
        }
    }
}

package org.projectbuendia.client.ui.chart;

import org.projectbuendia.models.ChartItem;
import org.projectbuendia.models.ObsPoint;

import java.util.HashMap;
import java.util.Map;

import javax.annotation.Nonnull;

/** Descriptor for a tile (latest observed value) in the patient chart. */
public class Tile {
    public final ChartItem item;
    public final ObsPoint[] points;

    static Map<String, ChartItem> DEFAULTS = new HashMap<>();
    static {
        DEFAULTS.put("select_one", new ChartItem("", "", false, null, "{1,abbr}", "{1,name}", "", "", ""));
        DEFAULTS.put("yes_no", new ChartItem("", "", false, null, "{1,yes_no,Yes;No}", "", "", "", ""));
        DEFAULTS.put("number", new ChartItem("", "", false, null, "0", "", "", "", ""));
        DEFAULTS.put("text", new ChartItem("", "", false, null, "{1,text,60}", "", "", "", ""));
        DEFAULTS.put("date", new ChartItem("", "", false, null, "{1,date,YYYY-MM-dd}", "", "", "", ""));
        DEFAULTS.put("time", new ChartItem("", "", false, null, "{1,time,HH:mm}", "", "", "", ""));
    }

    public Tile(@Nonnull ChartItem item, @Nonnull ObsPoint[] points) {
        this.item = item.withDefaults(DEFAULTS.get(item.type));
        this.points = points;
    }
}

package org.projectbuendia.client.ui.chart;

import org.projectbuendia.models.ChartItem;

import java.util.HashMap;
import java.util.Map;

import javax.annotation.Nonnull;

/** Descriptor for a row (observed attribute) in the patient history grid. */
public class Row {
    public ChartItem item;

    static Map<String, ChartItem> DEFAULTS = new HashMap<>();
    static {
        DEFAULTS.put("select_one", new ChartItem("", "", false, null, "{1,abbr}", "{1,name}", "", "", ""));
        DEFAULTS.put("yes_no", new ChartItem("", "", false, null, "{1,yes_no,\u25cf;\u25cb}", "{1,yes_no,Yes;No}", "", "{1,yes_no,color:#000;color:#ccc}", ""));
        DEFAULTS.put("number", new ChartItem("", "", false, null, "0", "0", "", "", ""));
        DEFAULTS.put("text", new ChartItem("", "", false, null, "{1,text,5}", "{1,text,40}", "", "", ""));
        DEFAULTS.put("date", new ChartItem("", "", false, null, "{1,date,MMM dd}", "{1,date,MMM dd}", "", "", ""));
        DEFAULTS.put("time", new ChartItem("", "", false, null, "{1,time,HH:mm}", "{1,time,HH:mm}", "", "", ""));
        DEFAULTS.put("severity_bars", new ChartItem("", "", false, null, "{1,select,1107:\u25cb;1498:\u002d;1499:\u003d;1500:\u2261}", "{1,name}", "{1,select,1500:critical}", "{1,select,1107:color:#ccc}", ""));
    }

    public Row(@Nonnull ChartItem item) {
        this.item = item.withDefaults(DEFAULTS.get(item.type));
    }
}

package org.projectbuendia.client.ui.chart;

import com.google.common.collect.ImmutableList;
import com.mitchellbosecke.pebble.extension.AbstractExtension;
import com.mitchellbosecke.pebble.extension.Filter;
import com.mitchellbosecke.pebble.extension.Function;

import org.joda.time.Interval;
import org.joda.time.LocalDate;
import org.joda.time.ReadableInstant;
import org.joda.time.format.DateTimeFormat;
import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.models.ObsPoint;
import org.projectbuendia.models.ObsValue;
import org.projectbuendia.models.Order;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.lang.reflect.InvocationTargetException;
import java.text.Format;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;

import javax.annotation.Nullable;

/**
 * Custom filters and functions for our Pebble templates.  These should be written to avoid throwing
 * exceptions as much as possible (as that crashes the rendering of the entire patient chart);
 * it's better to return something that reveals useful information about the problem in the output.
 */
public class PebbleExtension extends AbstractExtension {
    private static final Logger LOG = Logger.create();

    static Map<String, Filter> filters = new HashMap<>();

    static {
        filters.put("min", new MinFilter());
        filters.put("max", new MaxFilter());
        filters.put("avg", new AvgFilter());
        filters.put("js", new JsFilter());
        filters.put("values", new ValuesFilter());
        filters.put("format_value", new FormatValueFilter());
        filters.put("format_values", new FormatValuesFilter());
        filters.put("format_date", new FormatDateFilter());
        filters.put("format_time", new FormatTimeFilter());
        filters.put("line_break_html", new LineBreakHtmlFilter());
        filters.put("to_css_identifier", new ToCssIdentifierFilter());
    }

    static Map<String, Function> functions = new HashMap<>();

    static {
        functions.put("get_string", new GetStringFunction());
        functions.put("get_latest_point", new GetLatestPointFunction());
        functions.put("get_all_points", new GetAllPointsFunction());
        functions.put("interval_contains", new IntervalContainsFunction());
        functions.put("intervals_overlap", new IntervalsOverlapFunction());
        functions.put("get_order_divisions", new GetOrderDivisionsFunction());
        functions.put("count_scheduled_doses", new CountScheduledDosesFunction());
        functions.put("to_dosage_string", new ToDosageStringFunction());
        functions.put("to_frequency_string", new ToFrequencyStringFunction());
    }

    public static final String TYPE_ERROR = "?";

    @Override public Map<String, Filter> getFilters() {
        return filters;
    }

    @Override public Map<String, Function> getFunctions() {
        return functions;
    }

    abstract static class ZeroArgFilter implements Filter {
        @Override public List<String> getArgumentNames() {
            return ImmutableList.of();
        }
    }

    static class MinFilter extends ZeroArgFilter {
        @Override public @Nullable Object apply(Object input, Map<String, Object> args) {
            if (input instanceof Collection) {
                return ((Collection) input).isEmpty() ? null : Collections.min((Collection) input);
            } else return null;
        }
    }

    static class MaxFilter extends ZeroArgFilter {
        @Override public @Nullable Object apply(Object input, Map<String, Object> args) {
            if (input instanceof Collection) {
                return ((Collection) input).isEmpty() ? null : Collections.max((Collection) input);
            } else return null;
        }
    }

    /** Computes the average of a set of numbers or numeric ObsValues. */
    static class AvgFilter extends ZeroArgFilter {
        @Override public @Nullable Object apply(Object input, Map<String, Object> args) {
            double sum = 0;
            int count = 0;
            if (input instanceof Collection) {
                for (Object item : (Collection) input) {
                    if (item instanceof ObsValue) {
                        Double number = ((ObsValue) item).number;
                        if (number != null) {
                            sum += number;
                            count += 1;
                        }
                    } else if (item instanceof Number) {
                        sum += ((Number) item).doubleValue();
                        count += 1;
                    }
                }
            }
            return count == 0 ? null : sum/count;
        }
    }

    /** Converts a Java null, boolean, integer, double, string, or DateTime to a JS expression. */
    static class JsFilter extends ZeroArgFilter {
        @Override public Object apply(Object input, Map<String, Object> args) {
            if (input == null) {
                return "null";
            } else if (input instanceof Boolean) {
                return ((Boolean) input) ? "true" : "false";
            } else if (input instanceof Integer || input instanceof Double) {
                return "" + input;
            } else if (input instanceof String) {
                String s = (String) input;
                return "'" + s.replace("\\", "\\\\").replace("\n", "\\n").replace("'", "\\'") + "'";
            } else if (input instanceof ReadableInstant) {
                return "new Date(" + ((ReadableInstant) input).getMillis() + ")";
            } else {
                return "null";
            }
        }
    }

    /** points | values -> a list of the ObsValues in the given list of ObsPoints */
    static class ValuesFilter extends ZeroArgFilter {
        @Override public Object apply(Object input, Map<String, Object> args) {
            List<ObsValue> values = new ArrayList<>();
            // The input is a tuple, so we must ensure that values has the same number of elements.
            if (input instanceof ObsPoint[]) {
                for (ObsPoint point : (ObsPoint[]) input) {
                    values.add(point != null ? point.value : null);
                }
            } else if (input instanceof Collection) {
                for (Object item : (Collection) input) {
                    values.add((item instanceof ObsPoint) ? ((ObsPoint) item).value : null);
                }
            }
            return values;
        }
    }

    /** Formats a single value. */
    static class FormatValueFilter implements Filter {
        @Override
        public List<String> getArgumentNames() {
            return ImmutableList.of("format");
        }

        @Override
        public Object apply(Object input, Map<String, Object> args) {
            if (input instanceof ObsValue) {
                return formatValues(ImmutableList.of((ObsValue) input), asFormat(args.get("format")));
            }
            return TYPE_ERROR;
        }
    }

    /**
     * Formats a tuple of values corresponding to the concepts listed in the "concept" column
     * in the profile.  This is for formatting values of different concepts together in one
     * string (e.g. systolic / diastolic blood pressure), not a series of values over time.
     */
    static class FormatValuesFilter implements Filter {
        @Override
        public List<String> getArgumentNames() {
            return ImmutableList.of("format");
        }

        @Override
        public Object apply(Object input, Map<String, Object> args) {
            List<ObsValue> values = new ArrayList<>();
            // The input is a tuple, so we must ensure that values has the same number of elements.
            if (input instanceof Object[]) {
                for (Object item : (Object[]) input) {
                    values.add(item instanceof ObsValue ? (ObsValue) item : null);
                }
            } else if (input instanceof Collection) {
                for (Object item : (Collection) input) {
                    values.add(item instanceof ObsValue ? (ObsValue) item : null);
                }
            } else if (input instanceof ObsValue) {
                values.add((ObsValue) input);
            }
            return formatValues(values, asFormat(args.get("format")));
        }
    }

    static Format asFormat(Object arg) {
        return arg instanceof Format ? (Format) arg : arg != null ? new ObsFormat("" + arg) : null;
    }

    static String formatValues(List<ObsValue> values, Format format) {
        if (format == null) return "";  // we use null to represent an empty format

        // ObsFormat expects an array of Obs instances with a 1-based index.
        ObsValue[] array = new ObsValue[values.size() + 1];
        // ExtendedMessageFormat has a bad bug: it silently fails to pass along null values
        // to sub-formatters.  To work around this, replace all nulls with a sentinel object.
        // (See the ObsOutputFormat.format() method, which checks for UNOBSERVED.)
        for (int i = 0; i < values.size(); i++) {
            array[i + 1] = Utils.orDefault(values.get(i), ObsFormat.UNOBSERVED);
        }

        try {
            return format.format(array);
        } catch (Throwable e) {
            while ((e instanceof InvocationTargetException ||
                e.getCause() instanceof InvocationTargetException) && e.getCause() != e) {
                e = e.getCause();
            }
            LOG.e(e, "Could not apply format " + format);
            return "" + format;  // make the problem visible on the page to aid fixes
        }
    }

    /** Formats a LocalDate.  (For times, use format_time, not format_date.) */
    static class FormatDateFilter implements Filter {
        @Override public List<String> getArgumentNames() {
            return ImmutableList.of("pattern");
        }

        @Override public Object apply(Object input, Map<String, Object> args) {
            String pattern = "" + args.get("pattern");

            if (input instanceof LocalDate) {
                return DateTimeFormat.forPattern(pattern).print(new LocalDate(input));
            } else return TYPE_ERROR;
        }
    }

    static class ToCssIdentifierFilter implements Filter {
        @Override public List<String> getArgumentNames() {
            return ImmutableList.of("input");
        }

        @Override public Object apply(Object input, Map<String, Object> args) {
            return Utils.toCssIdentifier(("" + input));
        }
    }

    /** Formats an Instant or DateTime.  (For dates, use format_date, not format_time.) */
    static class FormatTimeFilter implements Filter {
        @Override public List<String> getArgumentNames() {
            return ImmutableList.of("pattern");
        }

        @Override public Object apply(Object input, Map<String, Object> args) {
            String pattern = "" + args.get("pattern");

            if (input instanceof ReadableInstant) {
                return DateTimeFormat.forPattern(pattern).print(
                    Utils.toLocalDateTime((ReadableInstant) input));
            } else return TYPE_ERROR;
        }
    }

    /** line_break_html(text) -> HTML for the given text with newlines replaced by <br> */
    static class LineBreakHtmlFilter extends ZeroArgFilter {
        @Override public Object apply(Object input, Map<String, Object> args) {
            return ("" + input).replace("&", "&amp;").replace("<", "&lt;").replace("\n", "<br>");
        }
    }

    /** get_string(name) -> localized string */
    static class GetStringFunction implements Function {
        static final Map<String, Integer> STRING_IDS = getStringIdMap();

        public static Map<String, Integer> getStringIdMap() {
            Map<String, Integer> map = new HashMap<>();
            map.put("treatments", R.string.treatments);
            map.put("add_new_treatment", R.string.add_new_treatment);
            return map;
        }

        @Override public List<String> getArgumentNames() {
            return ImmutableList.of("name");
        }

        @Override public Object execute(Map<String, Object> args) {
            return App.str(STRING_IDS.get(args.get("name")));
        }
    }

    /** get_all_points(row, column) -> all ObsPoints for concept 1 in a given cell, in time order */
    static class GetAllPointsFunction implements Function {
        @Override public List<String> getArgumentNames() {
            return ImmutableList.of("row", "column");
        }

        @Override public Object execute(Map<String, Object> args) {
            // TODO/robustness: Check types before casting.
            Row row = (Row) args.get("row");
            Column column = (Column) args.get("column");
            return column.pointSetByConceptUuid.get(row.item.conceptUuids[0]);
        }
    }

    /** get_latest_point(row, column) -> the latest ObsPoint for concept 1 in a given cell, or null */
    static class GetLatestPointFunction implements Function {
        @Override public List<String> getArgumentNames() {
            return ImmutableList.of("row", "column");
        }

        @Override public @Nullable Object execute(Map<String, Object> args) {
            // TODO/robustness: Check types before casting.
            Row row = (Row) args.get("row");
            Column column = (Column) args.get("column");
            SortedSet<ObsPoint> obsSet = column.pointSetByConceptUuid.get(row.item.conceptUuids[0]);
            return obsSet.isEmpty() ? null : obsSet.last();
        }
    }

    static class IntervalsOverlapFunction implements Function {
        @Override public List<String> getArgumentNames() {
            return ImmutableList.of("a", "b");
        }

        @Override public Object execute(Map<String, Object> args) {
            // TODO/robustness: Check types before casting.
            Interval a = (Interval) args.get("a");
            Interval b = (Interval) args.get("b");
            return a.overlaps(b);
        }
    }

    static class IntervalContainsFunction implements Function {
        @Override public List<String> getArgumentNames() {
            return ImmutableList.of("interval", "instant");
        }

        @Override public Object execute(Map<String, Object> args) {
            // TODO/robustness: Check types before casting.
            Interval interval = (Interval) args.get("interval");
            ReadableInstant instant = (ReadableInstant) args.get("instant");
            return interval.contains(instant);
        }
    }

    static class GetOrderDivisionsFunction implements Function {
        @Override public List<String> getArgumentNames() {
            return ImmutableList.of("order", "date");
        }

        @Override public Object execute(Map<String, Object> args) {
            // TODO/robustness: Check types before casting.
            Order order = (Order) args.get("order");
            LocalDate date = (LocalDate) args.get("date");
            return order.getDivisionsOfDay(date);
        }
    }

    // TODO(ping): Switch to looking up dose counts by division index instead
    // of using this expensive function.
    static class CountScheduledDosesFunction implements Function {
        @Override public List<String> getArgumentNames() {
            return ImmutableList.of("order", "interval");
        }

        @Override public Object execute(Map<String, Object> args) {
            // TODO/robustness: Check types before casting.
            Order order = (Order) args.get("order");
            Interval interval = (Interval) args.get("interval");
            return order.countScheduledDosesIn(interval);
        }
    }

    static class ToDosageStringFunction implements Function {
        @Override public List<String> getArgumentNames() {
            return ImmutableList.of("instructions");
        }

        @Override public Object execute(Map<String, Object> args) {
            Order.Instructions instr = (Order.Instructions) args.get("instructions");
            return instr.amount != null ? (
                instr.duration != null ? App.str(
                    R.string.amount_in_duration,
                    instr.amount.format(2), instr.duration.format(2)
                ) : instr.amount.format(2)
            ) : "";
        }
    }

    static class ToFrequencyStringFunction implements Function {
        @Override public List<String> getArgumentNames() {
            return ImmutableList.of("instructions");
        }

        @Override public Object execute(Map<String, Object> args) {
            Order.Instructions instr = (Order.Instructions) args.get("instructions");
            return instr.frequency != null ? instr.frequency.format(2) : "";
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.chart;

import android.app.ActionBar;
import android.app.AlertDialog;
import android.app.DatePickerDialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.Intent;
import android.graphics.Point;
import android.os.Bundle;
import android.os.Handler;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.webkit.WebView;
import android.webkit.WebViewClient;

import com.joanzapata.iconify.fonts.FontAwesomeIcons;

import org.joda.time.Interval;
import org.joda.time.LocalDate;
import org.odk.collect.android.model.Preset;
import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.client.events.data.PatientUpdateFailedEvent;
import org.projectbuendia.models.Chart;
import org.projectbuendia.models.Form;
import org.projectbuendia.models.Obs;
import org.projectbuendia.models.Order;
import org.projectbuendia.models.Patient;
import org.projectbuendia.client.ui.BigToast;
import org.projectbuendia.client.ui.LoggedInActivity;
import org.projectbuendia.client.ui.OdkActivityLauncher;
import org.projectbuendia.client.ui.chart.PatientChartController.MinimalHandler;
import org.projectbuendia.client.ui.chart.PatientChartController.OdkResultSender;
import org.projectbuendia.client.ui.dialogs.ObsDetailDialogFragment;
import org.projectbuendia.client.ui.dialogs.OrderDialogFragment;
import org.projectbuendia.client.ui.dialogs.OrderExecutionDialogFragment;
import org.projectbuendia.client.ui.dialogs.PatientDialogFragment;
import org.projectbuendia.client.ui.dialogs.PatientLocationDialogFragment;
import org.projectbuendia.client.ui.dialogs.TextObsDialogFragment;
import org.projectbuendia.client.utils.EventBusWrapper;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.util.List;
import java.util.Map;

import javax.annotation.Nonnull;
import javax.inject.Inject;

import butterknife.InjectView;
import de.greenrobot.event.EventBus;

import static org.projectbuendia.client.utils.ContextUtils.FormatStyle.LONG;

/** Activity displaying a patient's vitals and chart history. */
public final class PatientChartActivity extends LoggedInActivity {
    private static final Logger LOG = Logger.create();

    private PatientChartController mController;
    private ProgressDialog mFormLoadingDialog;
    private ProgressDialog mFormSubmissionDialog;
    private ChartRenderer mChartRenderer;
    private ProgressDialog mProgressDialog;
    private Ui mUi;

    @Inject EventBus mEventBus;
    @InjectView(R.id.chart_webview) WebView mWebView;

    private static final String EN_DASH = "\u2013";

    public static void start(Context caller, String uuid) {
        caller.startActivity(
            new Intent(caller, PatientChartActivity.class)
                .putExtra("uuid", uuid)
        );
    }

    @Override public void onExtendOptionsMenu(Menu menu) {
        // Inflate the menu items for use in the action bar
        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.chart, menu);

        MenuItem zoomItem = menu.findItem(R.id.action_zoom);
        setMenuBarIcon(zoomItem, FontAwesomeIcons.fa_arrows_h);
        zoomItem.setOnMenuItemClickListener(
            item -> {
                Utils.logUserAction("zoom_chart_pressed");
                showZoomDialog();
                return true;
            }
        );

        MenuItem editItem = menu.findItem(R.id.action_edit);
        setMenuBarIcon(editItem, FontAwesomeIcons.fa_pencil_square_o);
        // edit submenu includes edit patient (in xml) and forms
        Menu editSubmenu = editItem.getSubMenu();
        editSubmenu.getItem(0).setOnMenuItemClickListener(
            menuItem -> {
                Utils.logUserAction("edit_patient_pressed");
                mController.onEditPatientPressed();
                return true;
            });

        for (final Form form : App.getChartDataHelper().getForms()) {
            MenuItem item = editSubmenu.add(App.localize(form.name));
            item.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM | MenuItem.SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW);
            item.setOnMenuItemClickListener(
                menuItem -> {
                    mController.onFormRequested(form.uuid);
                    return true;
                }
            );
        }
    }

    @Override protected boolean onCreateImpl(Bundle state) {
        if (!super.onCreateImpl(state)) return false;

        setContentView(R.layout.fragment_patient_chart);

        mFormLoadingDialog = new ProgressDialog(this);
        mFormLoadingDialog.setIcon(android.R.drawable.ic_dialog_info);
        mFormLoadingDialog.setTitle(getString(R.string.retrieving_form_title));
        mFormLoadingDialog.setMessage(getString(R.string.retrieving_form_message));
        mFormLoadingDialog.setIndeterminate(true);
        mFormLoadingDialog.setCancelable(false);

        mFormSubmissionDialog = new ProgressDialog(this);
        mFormSubmissionDialog.setIcon(android.R.drawable.ic_dialog_info);
        mFormSubmissionDialog.setTitle(getString(R.string.submitting_form_title));
        mFormSubmissionDialog.setMessage(getString(R.string.submitting_form_message));
        mFormSubmissionDialog.setIndeterminate(true);
        mFormSubmissionDialog.setCancelable(false);

        // Remembering scroll position and applying it after the chart finished loading.
        mWebView.setWebViewClient(new WebViewClient() {
            public void onPageFinished(WebView view, String url) {
                Point scrollPosition = mController.getLastScrollPosition();
                if (scrollPosition != null) {
                    view.loadUrl("javascript:$('#grid-scroller').scrollLeft(" + scrollPosition.x + ");");
                    view.loadUrl("javascript:$(window).scrollTop(" + scrollPosition.y + ");");
                }
            }
        });
        mChartRenderer = new ChartRenderer(mWebView, getResources(), settings);

        final OdkResultSender odkResultSender = (patientUuid, resultCode, data) ->
            OdkActivityLauncher.sendOdkResultToServer(
                PatientChartActivity.this, settings,
                patientUuid, resultCode, data);
        final MinimalHandler minimalHandler = new MinimalHandler() {
            private final Handler mHandler = new Handler();

            @Override public void post(Runnable runnable) {
                mHandler.post(runnable);
            }
        };
        mUi = new Ui();
        mController = new PatientChartController(
            new EventBusWrapper(mEventBus),
            App.getCrudEventBus(),
            mUi,
            getIntent().getStringExtra("uuid"),
            odkResultSender,
            App.getChartDataHelper(),
            minimalHandler);

        initChartTabs();
        return true;
    }

    public Ui getUi() {
        return mUi;
    }

    @Override protected void onNewIntent(Intent intent) {
        String uuid = intent.getStringExtra("uuid");
        if (uuid != null) {
            // Immediately hide the current patient chart, to avoid giving the
            // misleading impression that it applies to the new patient.
            mWebView.setVisibility(View.INVISIBLE);
            mController.setPatient(uuid);
        }
    }

    class DateObsDialog extends DatePickerDialog {
        private String mTitle;

        public DateObsDialog(String title, final String conceptUuid, @Nonnull LocalDate date) {
            super(
                PatientChartActivity.this,
                (picker, year, zeroBasedMonth, day) -> {
                    int month = zeroBasedMonth + 1;
                    mController.submitDateObs(conceptUuid, new LocalDate(year, month, day));
                },
                date.getYear(),
                date.getMonthOfYear() - 1,
                date.getDayOfMonth()
            );
            getDatePicker().setCalendarViewShown(false);
            mTitle = title;
            setTitle(title);
        }

        public DateObsDialog(int titleId, String conceptUuid) {
            this(PatientChartActivity.this.getString(titleId), conceptUuid, LocalDate.now());
        }

        @Override public void setTitle(CharSequence title) {
            super.setTitle(mTitle);
        }
    }

    private void initChartTabs() {
        List<Chart> charts = mController.getCharts();
        if (charts.size() > 1) {
            final ActionBar actionBar = getActionBar();
            actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);
            ActionBar.TabListener tabListener = new ActionBar.TabListener() {
                @Override
                public void onTabSelected(ActionBar.Tab tab, android.app.FragmentTransaction ft) {
                    mController.setChartIndex(tab.getPosition());
                }

                @Override
                public void onTabUnselected(ActionBar.Tab tab, android.app.FragmentTransaction ft) {
                }

                @Override
                public void onTabReselected(ActionBar.Tab tab, android.app.FragmentTransaction ft) {
                }
            };

            for (int i = 0; i < charts.size(); i++) {
                actionBar.addTab(
                    actionBar.newTab()
                        .setText(charts.get(i).name)
                        .setTabListener(tabListener));
            }
        }
    }

    @Override protected void onStartImpl() {
        super.onStartImpl();
        mController.init();
    }

    @Override protected void onStopImpl() {
        mController.suspend();
        super.onStopImpl();
    }

    @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        mController.onXFormResult(requestCode, resultCode, data);
    }

    private void showZoomDialog() {
        String[] labels = new String[ChartRenderer.ZOOM_LEVELS.length];
        for (int i = 0; i < labels.length; i++) {
            labels[i] = getString(ChartRenderer.ZOOM_LEVELS[i].labelId);
        }
        int selected = settings.getChartZoomIndex();
        new AlertDialog.Builder(this)
            .setTitle(R.string.title_zoom)
            .setSingleChoiceItems(labels, selected, (dialog, which) -> {
                mController.setZoomIndex(which);
                dialog.dismiss();
            })
            .setNegativeButton(R.string.cancel, null)
            .show();
    }

    public final class Ui implements PatientChartController.Ui {
        @Override public void setTitle(String title) {
            PatientChartActivity.this.setTitle(title);
        }

        @Override public void showDateObsDialog(String title, Obs obs) {
            LocalDate date = Utils.toLocalDate(obs.value);
            if (date == null) date = LocalDate.now();
            new DateObsDialog(title, obs.conceptUuid, date).show();
        }

        @Override public void showTextObsDialog(String title, Obs obs) {
            openDialog(TextObsDialogFragment.create(title, obs));
        }

        @Override public void updateTilesAndGrid(Chart chart, Map<String, Obs> latestObservations,
            List<Obs> observations, List<Order> orders) {
            mChartRenderer.render(chart, latestObservations, observations, orders, mController);
        }

        @Override public void updatePatientDetailsUi(Patient patient) {
            ActionBar actionBar = getActionBar();
            if (actionBar != null) {
                String id = Utils.orDefault(patient.id, EN_DASH);
                actionBar.setTitle(id + ". " + u.formatPatientName(patient));
                actionBar.setSubtitle(u.formatPatientDetails(patient, LONG, LONG, LONG));
            }
        }

        @Override public void showWaitDialog(int titleId) {
            hideWaitDialog();
            mProgressDialog = ProgressDialog.show(
                PatientChartActivity.this, getString(titleId),
                getString(R.string.please_wait_ellipsis), true);
        }

        @Override public void hideWaitDialog() {
            if (mProgressDialog != null) {
                mProgressDialog.dismiss();
                mProgressDialog = null;
            }
        }

        @Override public void showError(int messageId, Object... args) {
            BigToast.show(getString(messageId, args));
        }

        @Override public void showError(int messageId) {
            BigToast.show(messageId);
        }

        @Override public synchronized void fetchAndShowXform(
            int requestCode, String formUuid,
            org.odk.collect.android.model.Patient patient, Preset preset) {
            OdkActivityLauncher.fetchAndShowXform(
                PatientChartActivity.this, formUuid, requestCode, patient, preset);
        }

        @Override public void showFormLoadingDialog(boolean show) {
            Utils.showDialogIf(mFormLoadingDialog, show);
        }

        @Override public void showFormSubmissionDialog(boolean show) {
            Utils.showDialogIf(mFormSubmissionDialog, show);
        }

        @Override public void showObsDetailDialog(
            Interval interval, String[] queriedConceptUuids,
            String[] conceptOrdering, List<Obs> observations) {
            ObsDetailDialogFragment.create(interval, queriedConceptUuids, conceptOrdering, observations)
                .show(getSupportFragmentManager(), null);
        }

        @Override public void showOrderDialog(String patientUuid, Order order, List<Obs> executions) {
            openDialog(OrderDialogFragment.create(patientUuid, order, executions));
        }

        @Override public void showOrderExecutionDialog(
            Order order, Interval interval, List<Obs> executions) {
            OrderExecutionDialogFragment.create(order, interval, executions)
                .show(getSupportFragmentManager(), null);
        }

        @Override public void showEditPatientDialog(Patient patient) {
            openDialog(PatientDialogFragment.create(patient));
        }

        @Override public void showPatientLocationDialog(Patient patient) {
            openDialog(PatientLocationDialogFragment.create(patient));
        }

        @Override public void showPatientUpdateFailed(int reason) {
            int messageId;
            switch (reason) {
                case PatientUpdateFailedEvent.REASON_INTERRUPTED:
                    messageId = R.string.patient_location_error_interrupted;
                    break;
                case PatientUpdateFailedEvent.REASON_NETWORK:
                case PatientUpdateFailedEvent.REASON_SERVER:
                    messageId = R.string.patient_location_error_network;
                    break;
                case PatientUpdateFailedEvent.REASON_NO_SUCH_PATIENT:
                    messageId = R.string.patient_location_error_no_such_patient;
                    break;
                case PatientUpdateFailedEvent.REASON_CLIENT:
                default:
                    messageId = R.string.patient_location_error_unknown;
                    break;
            }
            BigToast.show(messageId);
        }
    }
}

package org.projectbuendia.client.ui.chart;

import android.content.res.Resources;
import android.os.AsyncTask;
import android.support.annotation.NonNull;
import android.support.v4.util.Pair;
import android.util.DisplayMetrics;
import android.view.View;
import android.webkit.JavascriptInterface;
import android.webkit.WebChromeClient;
import android.webkit.WebSettings;
import android.webkit.WebView;

import com.google.common.collect.Lists;
import com.mitchellbosecke.pebble.PebbleEngine;
import com.mitchellbosecke.pebble.template.PebbleTemplate;

import org.joda.time.DateTime;
import org.joda.time.LocalDate;
import org.joda.time.ReadableInstant;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.projectbuendia.client.AppSettings;
import org.projectbuendia.client.R;
import org.projectbuendia.models.Chart;
import org.projectbuendia.models.ChartItem;
import org.projectbuendia.models.ChartSection;
import org.projectbuendia.models.ConceptUuids;
import org.projectbuendia.models.Obs;
import org.projectbuendia.models.ObsPoint;
import org.projectbuendia.models.ObsValue;
import org.projectbuendia.models.Order;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;

import javax.annotation.Nonnull;

import static org.projectbuendia.client.utils.Utils.EN_DASH;
import static org.projectbuendia.client.utils.Utils.HOUR;
import static org.projectbuendia.client.utils.Utils.eq;

/** Renders a patient's chart to HTML displayed in a WebView. */
public class ChartRenderer {
    public static ZoomLevel[] ZOOM_LEVELS = new ZoomLevel[] {
        new ZoomLevel(R.string.zoom_day, 0),
        new ZoomLevel(R.string.zoom_half, 0, 12*HOUR),
        new ZoomLevel(R.string.zoom_third, 0, 8*HOUR, 16*HOUR),
        new ZoomLevel(R.string.zoom_bunia_etc, 0, 8*HOUR, 13*HOUR, 18*HOUR),
        new ZoomLevel(R.string.zoom_quarter, 0, 6*HOUR, 12*HOUR, 18*HOUR),
        new ZoomLevel(R.string.zoom_sixth, 0, 4*HOUR, 8*HOUR, 12*HOUR, 16*HOUR, 20*HOUR)
    };

    private static PebbleEngine sEngine;
    private static PebbleTemplate sTemplate;
    private static final Object sTemplateLock = new Object();
    private static final Logger LOG = Logger.create();
    private static final ExecutionHistory EMPTY_HISTORY = new ExecutionHistory();
    private static final String TEMPLATE_PATH = "assets/chart.html";

    private WebView mView;  // view into which the HTML table will be rendered
    private Resources mResources;  // resources used for localizing the rendering
    private AppSettings mSettings;

    private List<Obs> mLastRenderedObs;  // last set of observations rendered
    private List<Order> mLastRenderedOrders;  // last set of orders rendered
    private int mLastRenderedZoomIndex;  // last zoom level index rendered
    private String mLastChartName = "";

    // WARNING(kpy): The WebView only knows how to pass boolean, numeric, or
    // String arguments to these methods from JavaScript, and does not always
    // perform the obvious conversions.  Every parameter must be declared here
    // as boolean, int, long, float, double, or String.  Methods must be called
    // with exactly the declared number of arguments, or the call will cause
    // a JavaScript "Method not found" exception.  Boolean parameters convert
    // all non-boolean values to false.  Numeric parameters convert incoming
    // numbers to the declared type and all non-numeric values to 0.  String
    // parameters pass through nulls, convert all booleans and numbers to
    // strings, and convert anything else to the string "undefined".
    public interface JsInterface {
        @JavascriptInterface void onNewOrderPressed();
        @JavascriptInterface void onOrderHeadingPressed(String orderUuid);
        @JavascriptInterface void onOrderCellPressed(String orderUuid, long startMillis);
        @JavascriptInterface void showObsDialog(String conceptUuids);
        @JavascriptInterface void showObsDialog(long startMillis, long stopMillis);
        @JavascriptInterface void showObsDialog(String conceptUuids, long startMillis, long stopMillis);
        @JavascriptInterface void onPageUnload(int scrollX, int scrollY);
    }

    public ChartRenderer(WebView view, Resources resources, AppSettings settings) {
        mView = view;
        mResources = resources;
        mSettings = settings;
        mView.getSettings().setRenderPriority(WebSettings.RenderPriority.HIGH);
        mView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);
        mView.setLayerType(View.LAYER_TYPE_HARDWARE, null);
    }

    /** Renders a patient's history of observations to an HTML table in the WebView. */
    // TODO/cleanup: Have this take the types that getObservations and getLatestObservations return.
    public void render(Chart chart, Map<String, Obs> latestObservations,
                       @Nonnull List<Obs> observations, @Nonnull List<Order> orders,
                       JsInterface controllerInterface) {
        if (chart == null) {
            mView.loadUrl("file:///android_asset/no_chart.html");
            return;
        }
        if (eq(mLastChartName, chart.name) &&
            mLastRenderedZoomIndex == mSettings.getChartZoomIndex() &&
            eq(observations, mLastRenderedObs) &&
            eq(orders, mLastRenderedOrders)) {
            LOG.i("%d observations, %d orders, and zoom index %d unchanged; skipping render", observations.size(), orders.size(), mSettings.getChartZoomIndex());
            return;
        }

        LOG.start("render", "%d observations, %d orders, zoom index %d", observations.size(), orders.size(), mSettings.getChartZoomIndex());

        // setDefaultFontSize is supposed to take a size in sp, but in practice
        // the fonts don't change size when the user font size preference changes.
        // So, we apply the scaling factor explicitly, defining 1 em to be 10 sp.
        DisplayMetrics metrics = mResources.getDisplayMetrics();
        float defaultFontSize = 10*metrics.scaledDensity/metrics.density;
        mView.getSettings().setDefaultFontSize((int) defaultFontSize);

        mView.getSettings().setJavaScriptEnabled(true);
        mView.addJavascriptInterface(controllerInterface, "c");
        mView.setWebChromeClient(new WebChromeClient());
        String html = new GridHtmlGenerator(
            chart, latestObservations, observations, orders).getHtml();

        LOG.elapsed("render", "HTML generated");

        // Record the scroll position of the viewport in the document so we can restore it.
        mView.evaluateJavascript("getScrollPosition()", (value) -> {
            value = value.replace('"', ' ').trim();
            String scrollJs = "<script>setScrollPosition('" + value + "');</script>";
            LOG.i("scrollJs = %s", Utils.repr(scrollJs));

            // To avoid showing stale, possibly misleading data from a previous
            // patient, clear out any previous chart HTML before showing the WebView.
            mView.loadUrl("about:blank");
            mView.clearView();
            mView.setVisibility(View.VISIBLE);
            mView.loadDataWithBaseURL(
                "file:///android_asset/", html + scrollJs, "text/html; charset=utf-8", "utf-8", null);
            mView.setWebContentsDebuggingEnabled(true);

            LOG.finish("render", "HTML loaded into WebView");

            mLastChartName = chart.name;
            mLastRenderedZoomIndex = mSettings.getChartZoomIndex();
            mLastRenderedObs = observations;
            mLastRenderedOrders = orders;

            LOG.start("ChartJS");
        });
    }

    /** Gets the starting times (in ms) of the segments into which the day is divided. */
    public int[] getSegmentStartTimes() {
        int index = mSettings.getChartZoomIndex();
        return Utils.safeIndex(ZOOM_LEVELS, index).segmentStartTimes;
    }

    class GridHtmlGenerator {
        List<Order> mOrders;
        DateTime mNow;
        Column mNowColumn;
        DateTime mAdmissionDateTime;

        Map<String, ExecutionHistory> mExecutionHistories = new HashMap<String, ExecutionHistory>() {
            @Override public @NonNull ExecutionHistory get(Object key) {
                // Always return non-null, for convenient access from the Pebble template.
                return Utils.orDefault(super.get(key), EMPTY_HISTORY);
            }
        };
        List<List<Tile>> mTileRows = new ArrayList<>();
        List<List<Tile>> mFixedRows = new ArrayList<>();
        List<RowGroup> mRowGroups = new ArrayList<>();
        SortedMap<Long, Column> mColumnsByStartMillis = new TreeMap<>();  // ordered by start millis
        Set<String> mConceptsToDump = new HashSet<>();  // concepts whose data to dump in JSON

        GridHtmlGenerator(Chart chart, Map<String, Obs> latestObservations,
                          List<Obs> observations, List<Order> orders) {
            LOG.start("GridHtmlGenerator");

            mOrders = orders;
            mNow = DateTime.now();
            Obs obs = latestObservations.get(ConceptUuids.ADMISSION_DATETIME_UUID);
            mAdmissionDateTime = obs != null ? Utils.toLocalDateTime(Long.valueOf(obs.value)) : null;
            mNowColumn = getColumnContainingTime(mNow); // ensure there's a column for today

            for (ChartSection section : chart.fixedGroups) {
                mFixedRows.add(createTiles(section, latestObservations));
            }
            for (ChartSection section : chart.tileGroups) {
                mTileRows.add(createTiles(section, latestObservations));
            }
            for (ChartSection section : chart.rowGroups) {
                mRowGroups.add(createRowGroup(section));
            }

            Map<String, Order> ordersByUuid = new HashMap<>();
            for (Order order : orders) {
                ordersByUuid.put(order.uuid, order);
            }
            addObservations(observations, ordersByUuid);
            addOrders(orders);
            insertEmptyColumns();

            LOG.elapsed("GridHtmlGenerator", "Data prepared");
        }

        private List<Tile> createTiles(ChartSection section, Map<String, Obs> observations) {
            List<Tile> tiles = new ArrayList<>();
            for (ChartItem item : section.items) {
                List<ObsPoint> points = new ArrayList<>();
                for (String uuid : item.conceptUuids) {
                    Obs obs = observations.get(uuid);
                    if (eq(uuid, ConceptUuids.PLACEMENT_UUID)) {
                        // Special case: a placement value is split into
                        // two values, a location and a bed number.
                        if (obs == null) {
                            points.add(null);
                            points.add(null);
                            continue;
                        }
                        String value = obs.getObsValue().text;
                        String[] parts = Utils.splitFields(value, "/", 2);
                        points.add(new ObsPoint(obs.time, ObsValue.newText(parts[0])));
                        points.add(new ObsPoint(obs.time, ObsValue.newText(parts[1])));
                    } else {
                        points.add(obs != null ? obs.getObsPoint() : null);
                    }
                }
                tiles.add(new Tile(item, points.toArray(new ObsPoint[0])));
                if (!item.script.trim().isEmpty()) {
                    mConceptsToDump.addAll(Arrays.asList(item.conceptUuids));
                }
            }
            return tiles;
        }

        private RowGroup createRowGroup(ChartSection section) {
            RowGroup rowGroup = new RowGroup(section.label);
            for (ChartItem item : section.items) {
                rowGroup.rows.add(new Row(item));
                if (!item.script.trim().isEmpty()) {
                    mConceptsToDump.addAll(Arrays.asList(item.conceptUuids));
                }
            }
            return rowGroup;
        }

        /** Collects observations into Column objects that make up the grid. */
        void addObservations(List<Obs> observations, Map<String, Order> orders) {
            for (Obs obs : observations) {
                if (obs == null) continue;

                if (obs.conceptUuid.equals(ConceptUuids.ORDER_EXECUTED_UUID)) {
                    Order order = orders.get(obs.orderUuid);
                    if (order != null) {
                        if (!mExecutionHistories.containsKey(order.uuid)) {
                            mExecutionHistories.put(order.uuid, new ExecutionHistory(order));
                        }
                        mExecutionHistories.get(order.uuid).add(obs.time);
                    }
                } else {
                    addObs(getColumnContainingTime(obs.time), obs);
                }
            }
        }

        /** Ensures that columns are shown for any days in which an order is prescribed. */
        void addOrders(List<Order> orders) {
            for (Order order : orders) {
                if (order.stop != null) {
                    for (DateTime dt = order.start; !dt.isAfter(order.stop.plusDays(1)); dt = dt.plusDays(1)) {
                        getColumnContainingTime(dt); // creates the column if it doesn't exist
                    }
                }
            }
        }

        /** Gets the n + 1 boundaries of the n segments of a specific day. */
        public DateTime[] getSegmentFenceposts(LocalDate date) {
            DateTime start = date.toDateTimeAtStartOfDay();
            DateTime stop = date.plusDays(1).toDateTimeAtStartOfDay();
            int[] starts = getSegmentStartTimes();
            DateTime[] fenceposts = new DateTime[starts.length + 1];
            for (int i = 0; i < starts.length; i++) {
                fenceposts[i] = start.plusMillis(starts[i]);
            }
            fenceposts[starts.length] = stop;
            return fenceposts;
        }

        /** Finds the segment that contains the given instant. */
        Pair<DateTime, DateTime> getSegmentBounds(ReadableInstant instant) {
            LocalDate date = Utils.toLocalDateTime(instant).toLocalDate();  // a day in the local time zone
            DateTime[] fenceposts = getSegmentFenceposts(date);
            for (int i = 0; i + 1 < fenceposts.length; i++) {
                if (!instant.isBefore(fenceposts[i]) && instant.isBefore(fenceposts[i + 1])) {
                    return new Pair<>(fenceposts[i], fenceposts[i + 1]);
                }
            }
            return null;  // should never get here because start <= instant < stop
        }

        /** Gets the column for a given instant, creating columns for the whole day if needed. */
        Column getColumnContainingTime(ReadableInstant instant) {
            LocalDate date = Utils.toLocalDateTime(instant).toLocalDate();  // a day in the local time zone
            Pair<DateTime, DateTime> bounds = getSegmentBounds(instant);
            long startMillis = bounds.first.getMillis();
            if (!mColumnsByStartMillis.containsKey(startMillis)) {
                createColumnsForDay(date);
            }
            return mColumnsByStartMillis.get(startMillis);
        }

        /** Creates all the columns for the segments of the given day. */
        void createColumnsForDay(LocalDate date) {
            DateTime[] fenceposts = getSegmentFenceposts(date);
            for (int i = 0; i + 1 < fenceposts.length; i++) {
                DateTime start = fenceposts[i];
                DateTime stop = fenceposts[i + 1];
                Column column = new Column(start, stop, formatDayNumber(date));
                mColumnsByStartMillis.put(column.start.getMillis(), column);
            }
        }

        String formatDayNumber(LocalDate date) {
            if (mAdmissionDateTime == null) return EN_DASH;
            int admitDay = Utils.dayNumberSince(mAdmissionDateTime.toLocalDate(), date);
            return (admitDay >= 1) ? mResources.getString(R.string.day_n, admitDay) : "";
        }

        void addObs(Column column, Obs obs) {
            if (!column.pointSetByConceptUuid.containsKey(obs.conceptUuid)) {
                column.pointSetByConceptUuid.put(obs.conceptUuid, new TreeSet<>());
            }
            ObsPoint point = obs.getObsPoint();
            if (point != null) {
                column.pointSetByConceptUuid.get(obs.conceptUuid).add(point);
            }
        }

        /** Exports a map of concept IDs to arrays of [columnStart, points] pairs. */
        JSONObject getJsonDataDump() {
            JSONObject dump = new JSONObject();
            for (String uuid : mConceptsToDump) {
                try {
                    JSONArray pointGroups = new JSONArray();
                    for (Column column : mColumnsByStartMillis.values()) {
                        JSONArray pointArray = new JSONArray();
                        SortedSet<ObsPoint> points = column.pointSetByConceptUuid.get(uuid);
                        if (points != null && points.size() > 0) {
                            for (ObsPoint point : points) {
                                pointArray.put(point.toJson());
                            }
                            JSONObject pointGroup = new JSONObject();
                            pointGroup.put("start", column.start.getMillis());
                            pointGroup.put("stop", column.stop.getMillis());
                            pointGroup.put("points", pointArray);
                            pointGroups.put(pointGroup);
                        }
                    }
                    dump.put("" + Utils.compressUuid(uuid), pointGroups);
                } catch (JSONException e) {
                    LOG.e(e, "JSON error while dumping chart data");
                }
            }
            return dump;
        }

        // TODO: grouped coded concepts (for select-multiple, e.g. types of bleeding, types of pain)
        // TODO: concept tags for formatting hints (e.g. none/mild/moderate/severe, abbreviated)
        String getHtml() {
            Map<String, Object> context = new HashMap<>();
            context.put("now", mNow);
            context.put("today", mNow.toLocalDate());
            context.put("fixedRows", mFixedRows);
            context.put("tileRows", mTileRows);
            context.put("rowGroups", mRowGroups);
            context.put("columns", Lists.newArrayList(mColumnsByStartMillis.values()));
            context.put("nowColumn", mNowColumn);
            context.put("numColumnsPerDay", getSegmentStartTimes().length);
            context.put("dataCellsByConceptId", getJsonDataDump());
            context.put("orders", getSortedOrders());
            context.put("executionHistories", getSortedExecutionHistories());
            LOG.elapsed("GridHtmlGenerator", "Template context populated");
            String result = renderTemplate(context);
            LOG.finish("GridHtmlGenerator", "Finished rendering HTML");
            return result;
        }

        List<Order> getSortedOrders() {
            List<Order> sortedOrders = new ArrayList<>(mOrders);
            Collections.sort(sortedOrders, (a, b) -> {
                int result = a.instructions.route.compareTo(b.instructions.route);
                if (result != 0) return result;
                return a.start.compareTo(b.start);
            });
            return sortedOrders;
        }

        Map<String, ExecutionHistory> getSortedExecutionHistories() {
            for (ExecutionHistory history : mExecutionHistories.values()) {
                history.sort();
            }
            return mExecutionHistories;
        }

        /**
         * Inserts empty columns to fill in the gaps between the existing columns, wherever
         * the gap can be filled by inserting fewer than 3 adjacent empty columns.
         */
        void insertEmptyColumns() {
            List<DateTime> starts = new ArrayList<>();
            for (Long startMillis : mColumnsByStartMillis.keySet()) {
                starts.add(Utils.toLocalDateTime(startMillis));
            }
            int maxEmptyColumns = 3 / getSegmentStartTimes().length;
            DateTime prev = starts.get(0);
            for (DateTime next : starts) {
                if (!next.isAfter(prev.plusDays(maxEmptyColumns))) {
                    for (DateTime dt = prev.plusDays(1); dt.isBefore(next); dt = dt.plusDays(1)) {
                        getColumnContainingTime(dt); // creates a column if it doesn't exist yet
                    }
                }
                prev = next;
            }
        }

        /** Renders the Pebble template for the chart. */
        String renderTemplate(Map<String, Object> context) {
            LOG.start("renderTemplate");
            foregroundCompileTemplate();
            try {
                StringWriter writer = new StringWriter();
                LOG.elapsed("renderTemplate", "Template loaded");
                sTemplate.evaluate(writer, context);
                LOG.finish("renderTemplate");
                return writer.toString();
            } catch (Exception e) {
                StringWriter writer = new StringWriter();
                e.printStackTrace(new PrintWriter(writer));
                return "<div style=\"font-size: 150%\">" + writer.toString().replace("&", "&amp;").replace("<", "&lt;").replace("\n", "<br>");
            }
        }
    }

    public static void backgroundCompileTemplate() {
        if (sEngine == null || sTemplate == null) {
            new AsyncTask<Void, Void, Void>() {
                public Void doInBackground(Void... param) {
                    compileTemplate();
                    return null;
                }
            }.execute();
        }
    }

    public static void foregroundCompileTemplate() {
        if (sEngine == null || sTemplate == null) {
            compileTemplate();
        }
    }

    private static void compileTemplate() {
        synchronized (sTemplateLock) {
            if (sEngine == null || sTemplate == null) {
                LOG.start("compileTemplate");
                sEngine = new PebbleEngine.Builder().extension(new PebbleExtension()).build();
                sTemplate = sEngine.getTemplate(TEMPLATE_PATH);
                LOG.finish("compileTemplate");
            }
        }
    }

    public static class ZoomLevel {
        public final int labelId;
        public final int[] segmentStartTimes;

        public ZoomLevel(int labelId, int... segmentStartTimes) {
            this.labelId = labelId;
            this.segmentStartTimes = segmentStartTimes;

            if (segmentStartTimes[0] != 0) throw new IllegalArgumentException("First segment must start at time zero");
            int prev = -1;
            for (int next : segmentStartTimes) {
                if (next <= prev) throw new IllegalArgumentException("Segment starting times must strictly increase");
                prev = next;
            }
            if (prev >= 23*HOUR) {
                throw new IllegalArgumentException("Last segment must start before end of a DST-shortened day");
            }
        }
    }
}

package org.projectbuendia.client.ui.chart;

import org.joda.time.Instant;
import org.joda.time.Interval;
import org.joda.time.LocalDate;
import org.joda.time.ReadableInstant;
import org.projectbuendia.models.ObsPoint;
import org.projectbuendia.client.utils.Utils;

import java.util.HashMap;
import java.util.Map;
import java.util.SortedSet;

/** A column (containing the data for its observations) in the patient history grid. */
public class Column {
    public final LocalDate date;
    public final Instant start;
    public final Instant stop;
    public final String dayLabel;
    public final Map<String, SortedSet<ObsPoint>> pointSetByConceptUuid = new HashMap<>();
    public final Map<String, Integer> executionCountsByOrderUuid = new HashMap<>();

    public Column(ReadableInstant start, ReadableInstant stop, String dayLabel) {
        this.date = new LocalDate(start);
        this.start = new Instant(start);
        this.stop = new Instant(stop);
        this.dayLabel = dayLabel;
    }

    public Interval getInterval() {
        return Utils.toInterval(start, stop);
    }

    public Instant getDayStart() {
        return date.toDateTimeAtStartOfDay().toInstant();
    }

    public Instant getDayStop() {
        return date.toDateTimeAtStartOfDay().plusDays(1).toInstant();
    }

    public String getShortDate() {
        return date.toString("d MMM");
    }

    public int getDayNumberSince(LocalDate admissionDate) {
        return Utils.dayNumberSince(admissionDate, date);
    }

    public long getStartHour() {
        return (start.getMillis() - getDayStart().getMillis()) / Utils.HOUR;
    }

    public long getStopHour() {
        return (stop.getMillis() - getDayStart().getMillis()) / Utils.HOUR;
    }
}

package org.projectbuendia.client.ui.chart;

import android.support.annotation.NonNull;
import android.util.SparseArray;

import com.google.common.collect.ImmutableList;

import org.joda.time.DateTime;
import org.joda.time.Interval;
import org.projectbuendia.models.Order;

import java.util.AbstractList;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * A sparse infinite list that maps division indexes to the execution times
 * contained in each division.  To optimize for use in CSS in the chart HTML, each
 * execution time is represented as an integer percentage of the division interval.
 */
public class ExecutionHistory extends AbstractList<List<Integer>> {
    private final Order order;
    private final SparseArray<List<Integer>> timesByIndex = new SparseArray<>();

    private static final List<Integer> EMPTY_LIST = ImmutableList.of();

    /** Constructs a read-only, empty execution history. */
    public ExecutionHistory() {
        this.order = null;
    }

    /** Constructs an appendable execution history. */
    public ExecutionHistory(Order order) {
        this.order = order;
    }

    /** Adds an execution time to the set of times for this order. */
    public void add(DateTime time) {
        if (order == null) {
            throw new UnsupportedOperationException();
        }
        int index = order.getDivisionIndex(time);
        if (timesByIndex.get(index) == null) {
            timesByIndex.put(index, new ArrayList<>());
        }
        Interval division = order.getDivision(index);
        long startMillis = division.getStartMillis();
        long durationMillis = division.toDurationMillis();
        int percentage = (int) (100 * (time.getMillis() - startMillis) / durationMillis);
        timesByIndex.get(index).add(percentage);
    }

    /** Sorts all the lists of execution times within each division. */
    public void sort() {
        for (int i = 0; i < timesByIndex.size(); i++) {
            Collections.sort(timesByIndex.valueAt(i));
        }
    }

    /** Gets the list of execution times for a given division index. */
    @Override public @NonNull List<Integer> get(int index) {
        return timesByIndex.get(index, EMPTY_LIST);
    }

    /** Returns MAX_VALUE to avoid ever throwing IndexOutOfBoundsException. */
    @Override public int size() {
        return Integer.MAX_VALUE;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.chart;

import android.content.Context;
import android.support.annotation.Nullable;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.LinearLayout;
import android.widget.TextView;

import org.projectbuendia.client.R;
import org.projectbuendia.models.ConceptUuids;
import org.projectbuendia.client.resolvables.ResStatus;

import butterknife.ButterKnife;
import butterknife.InjectView;

/** Shows a list of general conditions, with corresponding number, color, and name. */
public class GeneralConditionAdapter extends ArrayAdapter<String> {
    private static final int VIEW_RESOURCE = R.layout.condition_item;
    private String[] mConditions;
    @Nullable private String mSelectedConditionUuid;

    /**
     * Creates a new adapter that displays conditions corresponding to the given UUID's.
     * @param context               an activity context
     * @param conditions            UUID's of the general conditions to display
     * @param selectedConditionUuid UUID of the current general condition, or null if the patient
     *                              has no prior known condition
     */
    public GeneralConditionAdapter(
        Context context, String[] conditions, @Nullable String selectedConditionUuid) {
        super(context, VIEW_RESOURCE, conditions);
        mConditions = conditions;
        mSelectedConditionUuid = selectedConditionUuid;
    }

    public void setSelectedConditionUuid(@Nullable String selectedConditionUuid) {
        mSelectedConditionUuid = selectedConditionUuid;
        notifyDataSetChanged();
    }

    @Override public View getView(int position, View convertView, ViewGroup parent) {
        LayoutInflater inflater = (LayoutInflater) getContext()
            .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        View view;
        ViewHolder holder;
        if (convertView != null) {
            view = convertView;
            holder = (ViewHolder) convertView.getTag();
        } else {
            view = inflater.inflate(VIEW_RESOURCE, parent, false);
            holder = new ViewHolder(view);
            view.setTag(holder);
        }

        String conditionUuid = getItem(position);
        ResStatus.Resolved condition =
            ConceptUuids.getResStatus(conditionUuid).resolve(getContext().getResources());

        holder.mConditionNumber.setText(condition.getShortDescription());
        holder.mConditionNumber.setTextColor(condition.getForegroundColor());
        holder.mConditionText.setText(condition.getMessage());
        holder.mConditionText.setTextColor(condition.getForegroundColor());
        holder.mConditionParent.setBackgroundColor(condition.getBackgroundColor());

        // TODO: Show currently-selected condition differently.

        return view;
    }

    static class ViewHolder {
        @InjectView(R.id.condition_selection_text) TextView mConditionText;
        @InjectView(R.id.condition_selection_number) TextView mConditionNumber;
        @InjectView(R.id.condition_selection_parent) LinearLayout mConditionParent;

        public ViewHolder(View view) {
            ButterKnife.inject(this, view);
        }
    }
}

package org.projectbuendia.client.ui.chart;

import android.support.annotation.NonNull;
import android.support.annotation.Nullable;

import com.google.common.collect.HashMultiset;
import com.google.common.collect.Multiset;

import java.util.Collection;
import java.util.Map;
import java.util.Set;

/** A map from division indexes to execution counts, backed by a Multiset. */
public class ExecutionCounter implements Map<Integer, Integer> {
    private Multiset<Integer> indexes;

    public ExecutionCounter() {
        indexes = HashMultiset.create();
    }

    /** Gets the execution count for a given division index.  Returns 0 instead of null. */
    @Override public @NonNull Integer get(@Nullable Object key) {
        return indexes.count(key);
    }

    /** Increments the execution count for a given division index. */
    public void add(int index) {
        indexes.add(index);
    }

    @Override public int size() {
        return indexes.elementSet().size();
    }

    @Override public boolean isEmpty() {
        return indexes.isEmpty();
    }

    @Override public boolean containsKey(@Nullable Object key) {
        return indexes.count(key) > 0;
    }

    @Override @NonNull public Set<Integer> keySet() {
        return indexes.elementSet();
    }

    @Override public void clear() {
        indexes.clear();
    }

    @Override public Integer put(@NonNull Integer key, @NonNull Integer value) {
        throw new UnsupportedOperationException();
    }

    @Override public Integer remove(@Nullable Object key) {
        throw new UnsupportedOperationException();
    }

    @Override public void putAll(@NonNull Map<? extends Integer, ? extends Integer> map) {
        throw new UnsupportedOperationException();
    }

    @Override public boolean containsValue(@Nullable Object value) {
        throw new UnsupportedOperationException();
    }

    @Override public @NonNull Collection<Integer> values() {
        throw new UnsupportedOperationException();
    }

    @Override public @NonNull Set<Entry<Integer, Integer>> entrySet() {
        throw new UnsupportedOperationException();
    }
}

package org.projectbuendia.client.ui.chart;

import org.apache.commons.text.ExtendedMessageFormat;
import org.apache.commons.text.FormatFactory;
import org.joda.time.LocalDate;
import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.models.Location;
import org.projectbuendia.models.ObsPoint;
import org.projectbuendia.models.ObsValue;
import org.projectbuendia.client.utils.Utils;

import java.lang.reflect.InvocationTargetException;
import java.text.DecimalFormat;
import java.text.FieldPosition;
import java.text.Format;
import java.text.ParsePosition;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

/**
 * Formats an array of ObsValue objects according to a format string.  The format string is
 * based on the MessageFormat syntax, but is 1-based so that "{1}" is replaced with the first
 * observation, "{2} is replaced with the second, and so on.
 *
 * A variety of formats are available for rendering individual observations; see the various
 * ObsOutputFormat classes below.  Each one may be invoked with a short name, e.g.
 * "{1,number,##.#}" renders a numeric value to one decimal place; "{1,yes_no,YES;NO}" renders
 * a coded answer to "YES" or "NO"; "{1,date,YYYY-mm-dd}" renders a date value, etc.
 *
 * Everything in this file should be written to avoid throwing exceptions as much as possible;
 * it's better to return something that reveals useful information about the problem in the output.
 */
public class ObsFormat extends Format {
    /**
     * A value that means "there have been no observations for this concept".  Normally one
     * would use null for this, but unfortunately ExtendedMessageFormat does not pass along
     * null to formatters so we have to use a sentinel.  See PebbleExtension.formatValues.
     */
    public static final ObsValue UNOBSERVED = ObsValue.newCoded("");

    private static final Map<String, Class<? extends Format>> FORMAT_CLASSES = new HashMap<>();
    static {
        FORMAT_CLASSES.put("yes_no", ObsYesNoFormat.class);
        FORMAT_CLASSES.put("abbr", ObsAbbrFormat.class);
        FORMAT_CLASSES.put("name", ObsNameFormat.class);
        FORMAT_CLASSES.put("number", ObsNumberFormat.class);
        FORMAT_CLASSES.put("text", ObsTextFormat.class);
        FORMAT_CLASSES.put("date", ObsDateFormat.class);
        FORMAT_CLASSES.put("time", ObsTimeFormat.class);
        FORMAT_CLASSES.put("select", ObsSelectFormat.class);
        FORMAT_CLASSES.put("day_number", ObsDayNumberFormat.class);
        FORMAT_CLASSES.put("location", ObsLocationFormat.class);
    }

    public static final String ELLIPSIS = "\u2026";  // used when truncating excessively long text
    public static final String EN_DASH = "\u2013";  // an en-dash to mean "nothing has been observed"
    public static final String TYPE_ERROR = "?";  // shown for a type mismatch (e.g. non-ObsValue)

    private String mPattern;
    private Format mFormat;

    /**
     * Formats can instantiate sub-formats; e.g. when "{1,number,0.0}" appears in the format
     * pattern, ObsNumberFormat will get instantiated and invoked with the first argument.
     * In some cases, most notably ObsSelectFormat, the sub-format invokes other formats.
     * We'd like those sub-formats to have access to all the arguments, not just the single
     * argument passed to ObsSelectFormat.  So, we keep a reference to the root ObsFormat
     * from which all others descended, which holds the original array of all the arguments.
     * The sub-format classes are all inner classes, so they can see mRootObsFormat.
     * For convenience, we also make the parent format's first argument available as {0}.
     */
    private ObsFormat mRootObsFormat;  // root ObsFormat from which this ObsFormat descended
    private Object[] mCurrentArgs;  // args currently being formatted by this ObsFormat

    public ObsFormat(String pattern, @Nullable ObsFormat rootObsFormat) {
        if (pattern == null) {
            pattern = "";
        }
        mPattern = pattern;
        if (rootObsFormat == null) {
            // Allow plain numeric formats like "#0.00" as a shorthand for "{0,number,#0.00}".
            if (!pattern.contains("{") && (pattern.contains("#") || pattern.contains("0"))) {
                try {
                    new DecimalFormat(pattern);  // check if it's a valid numeric format
                    pattern = "{0,number," + pattern + "}";
                } catch (IllegalArgumentException e) { }
            } else if (!pattern.contains("{") && pattern.contains("$")) {
                // Allow "$" as a shorthand for "{0,text}".
                pattern = pattern.replaceFirst("$", "{0,text}");
            }
        }
        mRootObsFormat = Utils.orDefault(rootObsFormat, this);
        try {
            // It's unsafe to use the ExtendedMessageFormat(pattern, registry) constructor,
            // as it crashes with a NoClassDefFoundError on java.util.Locale.Category on
            // Android 5.1.  We must use ExtendedMessageFormat(pattern, locale, registry).
            mFormat = new ExtendedMessageFormat(pattern, Locale.US, new FormatFactoryMap());
        } catch (IllegalArgumentException e) {
            // Instead of crashing, display the invalid pattern in the output to aid debugging.
            mFormat = new Format() {
                @Override public StringBuffer format(Object obj, @Nonnull StringBuffer buf,
                                                     @Nonnull FieldPosition pos) {
                    buf.append("??" + mPattern);
                    return buf;
                }

                @Override public Object parseObject(String str, @Nonnull ParsePosition pos) {
                    throw new UnsupportedOperationException();
                }
            };
        }
    }

    public ObsFormat(String pattern) {
        this(pattern, null);
    }

    public String toString() {
        return mPattern;
    }

    /** Returns an ObsFormat for the given pattern, or null for a null or empty pattern. */
    public static @Nullable ObsFormat fromPattern(@Nullable String pattern) {
        // TODO/speed: If creating ObsFormats is slow, we could cache instances here by pattern.
        return Utils.isEmpty(pattern) ? null : new ObsFormat(pattern);
    }

    public Object[] getCurrentArgs() {
        return mCurrentArgs;
    }

    @Override public StringBuffer format(Object obj, @Nonnull StringBuffer buf,
                                         @Nonnull FieldPosition pos) {
        if (obj instanceof ObsValue[]) {
            mCurrentArgs = (ObsValue[]) obj;
            if (mCurrentArgs.length > 1) mCurrentArgs[0] = mCurrentArgs[1];
            return mFormat.format(obj, buf, pos);
        } else {
            buf.append(TYPE_ERROR);
            return buf;
        }
    }

    @Override public Object parseObject(String str, @Nonnull ParsePosition pos) {
        throw new UnsupportedOperationException();
    }

    /** A FormatFactory that can look up and instantiate Format classes by name. */
    class FormatFactoryMap extends AbstractMap<String, FormatFactory> implements FormatFactory {
        public FormatFactoryMap() { }

        @Override public @Nonnull Set<Map.Entry<String, FormatFactory>> entrySet() {
            throw new UnsupportedOperationException();
        }

        /**
         * ExtendedMessageFormat expects a Map containing FormatFactory instances.
         * Rather than defining a separate FormatFactory class for every Format,
         * we return the FormatFactoryMap itself, which can instantiate any Format.
         */
        @Override public @Nullable FormatFactory get(Object name) {
            return FORMAT_CLASSES.containsKey("" + name) ? this : null;
        }

        /** Instantiates a Format class, whose constructor must take one String argument. */
        @Override public Format getFormat(String name, String args, Locale locale) {
            Class formatClass = FORMAT_CLASSES.get(name);
            try {
                return (Format) formatClass.getConstructor(
                    ObsFormat.class, String.class).newInstance(ObsFormat.this, args);
            } catch (NoSuchMethodException | InstantiationException |
                     IllegalAccessException | InvocationTargetException e) {
                throw new RuntimeException(e);
            }
        }
    }

    /**
     * Base class for formats that format a single Obs.  Subclasses should have a
     * public constructor that takes a single String argument, and should implement formatObsValue.
     */
    abstract class ObsOutputFormat extends Format {
        @Override public StringBuffer format(Object obj, @Nonnull StringBuffer buf,
                                             @Nonnull FieldPosition pos) {
            // UNOBSERVED is compared by identity (not using equals()) because it is a sentinel.
            if (mCurrentArgs.length > 0) mCurrentArgs[0] = obj;
            if (obj == UNOBSERVED) {
                buf.append(formatObsValue(null));
            } else if (obj instanceof ObsValue) {
                buf.append(formatObsValue((ObsValue) obj));
            }
            return buf;
        }

        @Override public Object parseObject(String str, @Nonnull ParsePosition pos) {
            throw new UnsupportedOperationException();
        }

        /** Returns the array of arguments that were given to the top-level formatter. */
        public Object[] getRootArgs() {
            return mRootObsFormat.getCurrentArgs();
        }

        /** Formats the value, treating null to mean "there have been no observations". */
        public abstract String formatObsValue(@Nullable ObsValue value);
    }

    /** "yes_no" format for values of any type.  Typical use: {1,yes_no,Present;Not present} */
    class ObsYesNoFormat extends ObsOutputFormat {
        String mYesText;
        String mNoText;
        String mNullText;

        public ObsYesNoFormat(String pattern) {
            String[] parts = pattern.split(";");
            mYesText = parts.length >= 1 ? parts[0] : "";
            mNoText = parts.length >= 2 ? parts[1] : "";
            mNullText = parts.length >= 3 ? parts[2] : EN_DASH;
        }

        @Override public String formatObsValue(@Nullable ObsValue value) {
            if (value == null) return mNullText;
            return value.asBoolean() ? mYesText : mNoText;
        }
    }

    /** "abbr" format for coded values (UUIDs).  Typical use: {1,abbr} */
    class ObsAbbrFormat extends ObsOutputFormat {
        public static final int MAX_ABBR_CHARS = 3;

        public ObsAbbrFormat(String pattern) { }

        @Override public String formatObsValue(@Nullable ObsValue value) {
            if (value == null) return EN_DASH;
            if (value.uuid == null) return TYPE_ERROR;
            if (value.name == null) return "";
            String name = value.name;
            int abbrevLength = name.indexOf('.');
            if (abbrevLength >= 1 && abbrevLength <= MAX_ABBR_CHARS) {
                return name.substring(0, abbrevLength);
            } else if (name.length() <= MAX_ABBR_CHARS) {
                return name;
            } else {
                return name.substring(0, MAX_ABBR_CHARS) + ELLIPSIS;
            }
        }
    }

    /** "name" format for coded values (UUIDs).  Typical use: {1,name} */
    class ObsNameFormat extends ObsOutputFormat {
        int maxLength;

        public ObsNameFormat(String pattern) {
            try {
                maxLength = Integer.valueOf(pattern);
            } catch (NumberFormatException e) {
                maxLength = Integer.MAX_VALUE;
            }
        }

        @Override public String formatObsValue(@Nullable ObsValue value) {
            if (value == null) return EN_DASH;
            if (value.uuid == null) return TYPE_ERROR;
            if (value.name == null) return "";
            String name = value.name;
            int abbrevLength = name.indexOf('.');
            if (abbrevLength >= 1 && abbrevLength <= ObsAbbrFormat.MAX_ABBR_CHARS) {
                name = name.substring(abbrevLength + 1).trim();
            }
            return maxLength < name.length() ? name.substring(0, maxLength) + ELLIPSIS : name;
        }
    }

    /** "number" format for numeric values.  Typical use: {1,number,##.# kg} */
    class ObsNumberFormat extends ObsOutputFormat {
        DecimalFormat mFormat;

        public ObsNumberFormat(String pattern) {
            mFormat = new DecimalFormat(Utils.toNonnull(pattern));
        }

        protected String formatNumber(Double number) {
            return mFormat.format(number).replace('-', '\u2212');  // use a real minus sign
        }

        @Override public String formatObsValue(@Nullable ObsValue value) {
            if (value == null) return EN_DASH;
            if (value.number == null) return TYPE_ERROR;
            return formatNumber(value.number);
        }
    }

    /** "text" format for text values (with optional length limit).  Typical use: {1,text,20} */
    class ObsTextFormat extends ObsOutputFormat {
        int maxLength;

        public ObsTextFormat(String pattern) {
            try {
                maxLength = Integer.valueOf(pattern);
            } catch (NumberFormatException e) {
                maxLength = Integer.MAX_VALUE;
            }
        }

        @Override public String formatObsValue(@Nullable ObsValue value) {
            if (value == null) return EN_DASH;
            if (value.text == null) return TYPE_ERROR;
            return formatText(value.text);
        }

        protected String formatText(String text) {
            return maxLength < text.length() ? text.substring(0, maxLength) + ELLIPSIS : text;
        }
    }

    /** "date" format for date values ("2015-02-26").  Typical use: {1,date,dd MMM} */
    class ObsDateFormat extends ObsOutputFormat {
        String mPattern;

        public ObsDateFormat(String pattern) {
            mPattern = pattern;
        }

        @Override public String formatObsValue(@Nullable ObsValue value) {
            if (value == null) return EN_DASH;
            LocalDate date;
            if (value.instant != null) {
                date = Utils.toLocalDateTime(value.instant).toLocalDate();
            } else if (value.date != null) {
                date = value.date;
            } else {
                return TYPE_ERROR;
            }
            return new LocalDate(date).toString(mPattern);
        }
    }

    /** "time" format for instant values (seconds since epoch).  Typical use: {1,time,MMM dd 'at' HH:mm} */
    class ObsTimeFormat extends ObsOutputFormat {
        String mPattern;

        public ObsTimeFormat(String pattern) {
            mPattern = pattern;
        }

        @Override public String formatObsValue(@Nullable ObsValue value) {
            if (value == null) return EN_DASH;
            if (value.instant == null) return TYPE_ERROR;
            return Utils.toLocalDateTime(value.instant).toString(mPattern);
        }
    }

    /** "day_number" format that describes today, counting the observed date as day 1.  Typical use: {1,day_number,Day #} */
    class ObsDayNumberFormat extends ObsNumberFormat {
        public ObsDayNumberFormat(String pattern) {
            super(pattern);
        }

        @Override public String formatObsValue(@Nullable ObsValue value) {
            if (value == null) return EN_DASH;
            LocalDate date;
            if (value.instant != null) {
                date = Utils.toLocalDateTime(value.instant).toLocalDate();
            } else if (value.date != null) {
                date = value.date;
            } else {
                return TYPE_ERROR;
            }
            return formatNumber((double) Utils.dayNumberSince(date, LocalDate.now()));
        }
    }

    /** "location" format */
    class ObsLocationFormat extends ObsTextFormat {
        public ObsLocationFormat(String pattern) {
            super(pattern);
        }

        @Override public String formatObsValue(@Nullable ObsValue value) {
            if (value == null) return EN_DASH;
            if (value.text == null) return TYPE_ERROR;
            Location location = App.getModel().getForest().get(value.text);
            return formatText(location != null ? location.name : App.str(R.string.unknown));
        }
    }

    private static final Pattern CONDITION_PATTERN = Pattern.compile("([<>=]*)(.+)");

    /**
     * "select" format for coded or numeric values.  Typical use:
     * {1,select,1065:Yes;1066:No;1067:Unknown} - converts a coded value to a string
     * {1,select,>=10:#;>1:#.0;#.00} - selects a format based on the value
     */
    class ObsSelectFormat extends ObsOutputFormat {
        class Option {
            public @Nullable String operator = null;
            public @Nonnull String operand = "";
            public @Nonnull ObsFormat format;
        }
        private final List<Option> mOptions;

        public ObsSelectFormat(String pattern) {
            mOptions = parse(pattern);
        }

        private List<Option> parse(String pattern) {
            List<Option> options = new ArrayList<>();

            pattern += ";";  // ensure every condition:pattern pair is terminated with ;
            int n = pattern.length();

            int pos = 0;
            int start = 0;  // start of the next condition or pattern
            int depth = 0;  // brace nesting depth
            Option option = new Option();
            while (pos < n) {
                char ch = pattern.charAt(pos);
                if (ch == '\'') {
                    pos = skipQuotedString(pattern, pos);
                } else if (depth == 0 && option.operand.isEmpty() && ch == ':') {
                    // A colon separates the condition from its pattern.
                    Matcher matcher = CONDITION_PATTERN.matcher(pattern.substring(start, pos));
                    if (matcher.matches()) {
                        option.operator = matcher.group(1);
                        option.operand = matcher.group(2);
                    }
                    pos += 1;
                    start = pos;
                } else if (depth == 0 && ch == ';') {
                    // A semicolon terminates this condition:pattern pair.
                    option.format = new ObsFormat(pattern.substring(start, pos), mRootObsFormat);
                    options.add(option);
                    option = new Option();
                    pos += 1;
                    start = pos;
                } else {
                    depth += (ch == '{' ? 1 : ch == '}' ? -1 : 0);
                    pos += 1;
                }
            }
            return options;
        }

        /** Skips a quoted string, beginning at the index of the opening quote. */
        private int skipQuotedString(String str, int pos) {
            int n = str.length();
            pos += 1;  // skip opening quote
            while (pos < n) {
                if (str.charAt(pos) == '\'') {
                    if (pos + 1 < n && str.charAt(pos + 1) == '\'') {
                        // Two single quotes are an escaped literal single quote.
                        pos += 2;
                        continue;
                    }
                    return pos + 1;  // skip closing quote
                }
                pos += 1;
            }
            return n;  // not terminated
        }

        /** Returns true if an observed value matches the given condition. */
        private boolean matches(@Nullable Object obj, @Nonnull String operator, @Nonnull String operandStr) {
            ObsValue value;
            if (obj == null) {
                // To test for null, use = to compare to an empty string.
                switch (operator) {
                    case "":
                    case "=":
                    case "==":
                        return operandStr.isEmpty();
                    default:
                        return false;
                }
            } else if (obj instanceof ObsPoint) {
                value = ((ObsPoint) obj).value;
            } else if (obj instanceof ObsValue) {
                value = (ObsValue) obj;
            } else return false;

            // Coerce the string operand to match the value's data type.
            ObsValue operand = null;
            if (value.uuid != null) {
                Object id = Utils.compressUuid(value.uuid);
                if (id instanceof Integer) {
                    // For coded concept IDs, remove the type tag.
                    int untypedId = ((Integer) id) % 1000000;
                    value = ObsValue.newCoded(Utils.expandUuid(untypedId));
                }
                operand = ObsValue.newCoded(Utils.expandUuid(operandStr));
            } else if (value.number != null) {
                try {
                    operand = ObsValue.newNumber(Double.valueOf(operandStr));
                } catch (NumberFormatException e) {
                    operand = ObsValue.ZERO;
                }
            } else if (value.text != null) {
                operand = ObsValue.newText(operandStr);
            } else if (value.date != null) {
                Integer days = Utils.toIntOrNull(operandStr);
                try {
                    if (days != null) {
                        operand = ObsValue.newDate(LocalDate.now().plusDays(days));
                    } else {
                        operand = ObsValue.newDate(LocalDate.parse(operandStr));
                    }
                } catch (IllegalArgumentException e) {
                    operand = ObsValue.MIN_DATE;
                }
            } else if (value.instant != null) {
                try {
                    operand = ObsValue.newTime(Long.valueOf(operandStr));
                } catch (IllegalArgumentException e) {
                    operand = ObsValue.MIN_TIME;
                }
            }

            switch (operator) {
                case "":
                case "=":
                case "==":
                    return value.compareTo(operand) == 0;
                case "<":
                    return value.compareTo(operand) < 0;
                case "<=":
                    return value.compareTo(operand) <= 0;
                case ">":
                    return value.compareTo(operand) > 0;
                case ">=":
                    return value.compareTo(operand) >= 0;
            }
            return false;
        }

        @Override public String formatObsValue(@Nullable ObsValue value) {
            for (Option option : mOptions) {
                if (option.operator == null || matches(value, option.operator, option.operand)) {
                    return option.format.format(getRootArgs());
                }
            }
            return "";
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.chart;

import android.app.AlertDialog;
import android.content.Context;
import android.view.View;
import android.widget.AdapterView;
import android.widget.FrameLayout;
import android.widget.GridView;

import org.projectbuendia.client.R;
import org.projectbuendia.client.events.data.EncounterAddFailedEvent;
import org.projectbuendia.client.events.data.EncounterAddFailedEvent.Reason;
import org.projectbuendia.models.ConceptUuids;
import org.projectbuendia.client.ui.BigToast;
import org.projectbuendia.client.utils.Utils;

import javax.annotation.Nullable;

import static com.google.common.base.Preconditions.checkNotNull;

/** A dialog that allows users to assign or change a patient's general condition. */
public final class AssignGeneralConditionDialog
    implements AdapterView.OnItemClickListener {

    @Nullable private AlertDialog mDialog;
    @Nullable private GridView mGridView;
    @Nullable private GeneralConditionAdapter mAdapter;

    private final Context mContext;
    @Nullable private final String mCurrentConditionUuid;
    private final ConditionSelectedCallback mConditionSelectedCallback;

    // TODO: Consider making this an event bus event rather than a callback so that we don't
    // have to worry about Activity context leaks.
    public interface ConditionSelectedCallback {
        /** Called when then user selects a general condition other than the current one. */
        void onNewConditionSelected(String newConditionUuid);
    }

    /**
     * Creates a new dialog.
     * @param context                   an activity context
     * @param currentConditionUuid      optional UUID representing the current general condition; may
     *                                  eventually be used for highlighting the selected entry but is
     *                                  currently unused
     * @param conditionSelectedCallback callback that responds to a condition selection
     */
    public AssignGeneralConditionDialog(
        Context context,
        @Nullable String currentConditionUuid,
        ConditionSelectedCallback conditionSelectedCallback) {
        mContext = checkNotNull(context);
        mCurrentConditionUuid = currentConditionUuid;
        mConditionSelectedCallback = checkNotNull(conditionSelectedCallback);
    }

    /** Builds and displays the dialog. */
    public void show() {
        FrameLayout frameLayout = new FrameLayout(mContext); // needed for outer margins to work
        View.inflate(mContext, R.layout.condition_grid, frameLayout);
        mGridView = frameLayout.findViewById(R.id.condition_selection_conditions);

        if (mGridView != null) {
            mAdapter = new GeneralConditionAdapter(
                mContext, ConceptUuids.GENERAL_CONDITION_UUIDS, mCurrentConditionUuid);
            mGridView.setAdapter(mAdapter);
            mGridView.setOnItemClickListener(this);
            mGridView.setSelection(1);
        }


        mDialog = new AlertDialog.Builder(mContext)
            .setTitle(R.string.action_assign_condition)
            .setView(frameLayout)
            .create();
        mDialog.show();
    }

    /**
     * Notifies the dialog that updating the patient's location has failed.
     * @param event The EncounterAddFailedEvent for the current failure.
     */
    public void onEncounterAddFailed(EncounterAddFailedEvent event) {
        mAdapter.setSelectedConditionUuid(mCurrentConditionUuid);

        int messageId =
            event.reason == Reason.FAILED_TO_AUTHENTICATE ?
                R.string.encounter_add_failed_to_authenticate :
            event.reason == Reason.FAILED_TO_FETCH_SAVED_OBSERVATION ?
                R.string.encounter_add_failed_to_fetch_saved :
            event.reason == Reason.FAILED_TO_SAVE_ON_SERVER ?
                R.string.encounter_add_failed_to_saved_on_server :
            event.reason == Reason.FAILED_TO_VALIDATE ?
                R.string.encounter_add_failed_invalid_encounter :
            event.reason == Reason.INTERRUPTED ?
                R.string.encounter_add_failed_interrupted :
            event.reason == Reason.INVALID_NUMBER_OF_OBSERVATIONS_SAVED ?
                // Hard to communicate to the user.
                R.string.encounter_add_failed_unknown_server_error :
            event.reason == Reason.UNKNOWN_SERVER_ERROR ?
                R.string.encounter_add_failed_unknown_server_error :
                R.string.encounter_add_failed_unknown_reason;

        String message = event.exception.getMessage();
        if (event.reason == Reason.FAILED_TO_VALIDATE) {
            // Validation reason typically starts after the message below.
            message = message.replaceFirst(".*failed to validate with reason: .*: ", "");
        }
        BigToast.show(messageId, message);
    }

    @Override public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
        if (mAdapter == null) return;

        Utils.logUserAction("condition_assigned");
        String newConditionUuid = mAdapter.getItem(position);
        mAdapter.setSelectedConditionUuid(newConditionUuid);
        if (!isCurrentCondition(newConditionUuid)) {
            mConditionSelectedCallback.onNewConditionSelected(newConditionUuid);
        }
        dismiss();
    }

    private boolean isCurrentCondition(String newConditionUuid) {
        return mCurrentConditionUuid != null
            && mCurrentConditionUuid.equals(newConditionUuid);
    }

    /** Dismisses the dialog. */
    public void dismiss() {
        if (mDialog != null) {
            mDialog.dismiss();
        }
    }

    // TODO: Consider adding the ability to re-enable buttons if a server request fails.

    /** Returns true iff the dialog is currently displayed. */
    public boolean isShowing() {
        return mDialog != null && mDialog.isShowing();
    }
}

package org.projectbuendia.client.ui.chart;

import java.util.ArrayList;
import java.util.List;

/** Descriptor for a group of rows in the patient history grid. */
public class RowGroup {
    public String title;
    public List<Row> rows;

    public RowGroup(String title) {
        this.title = title;
        this.rows = new ArrayList<>();
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.dialogs;

import android.app.Dialog;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.support.v4.app.DialogFragment;
import android.text.Html;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox;
import android.widget.TextView;
import android.widget.ToggleButton;

import com.google.common.base.Joiner;

import org.joda.time.DateTime;
import org.joda.time.Interval;
import org.joda.time.LocalDate;
import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.client.events.actions.ObsDeleteRequestedEvent;
import org.projectbuendia.client.events.actions.OrderExecutionAddRequestedEvent;
import org.projectbuendia.models.Catalog.Drug;
import org.projectbuendia.models.Catalog.Format;
import org.projectbuendia.models.MsfCatalog;
import org.projectbuendia.models.Obs;
import org.projectbuendia.models.Order;
import org.projectbuendia.client.utils.Utils;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import de.greenrobot.event.EventBus;

import static org.projectbuendia.client.utils.Utils.DateStyle.HOUR_MINUTE;
import static org.projectbuendia.client.utils.Utils.DateStyle.SENTENCE_MONTH_DAY;

/** A {@link DialogFragment} for recording that an order was executed. */
public class OrderExecutionDialogFragment extends BaseDialogFragment<OrderExecutionDialogFragment, OrderExecutionDialogFragment.Args> {
    static class Args implements Serializable {
        DateTime now;
        Order order;
        LocalDate date;
        List<Obs> executions;
        boolean executable;
    }

    class Views {
        TextView orderDescription = u.findView(R.id.order_description);
        TextView orderStartTime = u.findView(R.id.order_start_time);
        TextView executionCount = u.findView(R.id.execution_count);
        ViewGroup executionList = u.findView(R.id.execution_list);
        ToggleButton execute = u.findView(R.id.execute_toggle);
    }

    private Views v;
    private List<View> items;
    private View newItem;
    private Set<String> obsUuidsToDelete = new HashSet<>();

    /** Creates a new instance showing a list of executions in the order given. */
    public static OrderExecutionDialogFragment create(
        Order order, Interval interval, List<Obs> executions) {
        Args args = new Args();
        // To avoid the possibility of confusion when the dialog is opened just
        // before midnight, save the current time for use as the encounter time later.
        args.now = DateTime.now();
        args.order = order;
        args.date = interval.getStart().toLocalDate();
        args.executions = new ArrayList<>();
        for (Obs obs : executions) {
            if (interval.contains(obs.time)) args.executions.add(obs);
        }
        args.executable = interval.contains(args.now);
        return new OrderExecutionDialogFragment().withArgs(args);
    }

    @Override public @NonNull Dialog onCreateDialog(Bundle state) {
        return createAlertDialog(R.layout.order_execution_dialog_fragment);
    }

    protected void onOpen() {
        v = new Views();

        dialog.setTitle(getString(
            R.string.order_execution_title, Utils.format(args.date, SENTENCE_MONTH_DAY)));
        dialog.getButton(BUTTON_NEUTRAL).setText(R.string.delete_selected);
        u.show(dialog.getButton(BUTTON_NEUTRAL), args.executions.size() > 0);

        // Show what was ordered and when the order started.
        v.orderDescription.setText(Html.fromHtml(describeOrderHtml(args.order.instructions)));
        v.orderStartTime.setText(getString(
            R.string.order_started_datetime,
            Utils.format(args.order.start, Utils.DateStyle.SENTENCE_MONTH_DAY_HOUR_MINUTE)));

        // Populate the list of execution times with checkable items.
        Utils.showIf(v.executionList, args.executions.size() > 0 || args.executable);

        items = new ArrayList<>();
        for (Obs obs : args.executions) {
            View item = u.addInflated(R.layout.checkable_item, v.executionList);
            u.setText(R.id.text, Utils.format(obs.time, HOUR_MINUTE));
            App.getUserManager().showChip(u.findView(R.id.user_initials), obs.providerUuid);
            item.setTag(obs.uuid);
            items.add(item);

            final CheckBox checkbox = u.findView(R.id.checkbox);
            checkbox.setOnCheckedChangeListener((view, checked) -> updateUi());
            item.setOnClickListener(view -> {
                if (checkbox.isEnabled()) checkbox.setChecked(!checkbox.isChecked());
            });
        }
        if (args.executable) {
            newItem = u.addInflated(R.layout.checkable_item, v.executionList);
            u.setText(R.id.text, Html.fromHtml(toBoldHtml(Utils.format(args.now, HOUR_MINUTE))));
            String providerUuid = App.getUserManager().getActiveUser().getUuid();
            App.getUserManager().showChip(u.findView(R.id.user_initials), providerUuid);
            u.cloak(R.id.checkbox);
            u.show(R.id.arrow);
            u.cloak(newItem);
        }

        u.show(v.execute, args.executable);
        v.execute.setOnCheckedChangeListener((button, checked) -> updateUi());
        dialog.getButton(BUTTON_NEUTRAL).setOnClickListener(v -> deleteSelected());
        updateUi();
    }

    /** Updates the UI to reflect the changes proposed by the user. */
    private void updateUi() {
        boolean executeNow = v.execute.isChecked();

        // Describe how many times the order was executed during the selected interval.
        int count = items.size() - obsUuidsToDelete.size() + (executeNow ? 1 : 0);
        boolean plural = count != 1;
        v.executionCount.setText(Html.fromHtml(getString(
            args.date.equals(LocalDate.now()) ?
                (plural ? R.string.order_execution_today_plural_html
                    : R.string.order_execution_today_singular_html) :
                (plural ? R.string.order_execution_historical_plural_html
                    : R.string.order_execution_historical_singular_html),
            count, Utils.format(args.date, SENTENCE_MONTH_DAY))));

        // Update the list of execution times.
        boolean anyItemsChecked = false;
        for (View item : items) {
            CheckBox checkbox = item.findViewById(R.id.checkbox);
            if (checkbox.isChecked()) anyItemsChecked = true;
            if (obsUuidsToDelete.contains(item.getTag())) {
                strikeCheckableItem(item);
            }
        }
        if (newItem != null) {
            newItem.setVisibility(executeNow ? View.VISIBLE : View.INVISIBLE);
        }

        dialog.getButton(BUTTON_NEUTRAL).setEnabled(anyItemsChecked);
        v.execute.setEnabled(!anyItemsChecked && obsUuidsToDelete.isEmpty());

        // If execution is requested, prevent marking anything for deletion;
        // otherwise, disable the items that are marked for deletion.
        for (View item : items) {
            item.findViewById(R.id.checkbox).setEnabled(
                v.execute.isChecked() ? false : !obsUuidsToDelete.contains(item.getTag())
            );
        }
    }

    /** Constructs an HTML description of the order. */
    private String describeOrderHtml(Order.Instructions instr) {
        Drug drug = MsfCatalog.INDEX.getDrug(instr.code);
        Format format = MsfCatalog.INDEX.getFormat(instr.code);
        String dosage = instr.amount != null ? (
            instr.duration != null ? u.str(
                R.string.amount_in_duration,
                instr.amount.formatLong(2), instr.duration.formatLong(2)
            ) : instr.amount.formatLong(2)
        ) : u.str(R.string.order_unspecified_dosage);
        String htmlDescription = toBoldHtml(App.localize(drug.name))
            + "<br>"
            + (format != null ? toHtml(getString(R.string.order_execution_format,
                App.localize(format.description))
            ) : "")
            + "<br>"
            + toHtml(getString(R.string.order_execution_dosage,
                instr.isSeries()
                    ? getString(R.string.order_dosage_series, dosage, Utils.format(instr.frequency.mag, 2))
                    : getString(R.string.order_dosage_unary, dosage)
            ));
        if (!Utils.isBlank(instr.notes)) {
            htmlDescription += "<br>" + toItalicHtml(instr.notes);
        }
        return htmlDescription;
    }

    /** Marks the checked items for deletion. */
    private void deleteSelected() {
        for (View item : items) {
            CheckBox checkbox = item.findViewById(R.id.checkbox);
            if (checkbox.isChecked()) {
                obsUuidsToDelete.add((String) item.getTag());
                checkbox.setChecked(false);
            }
        }
        updateUi();
    }

    /** Applies the requested new execution or deletions. */
    @Override public void onSubmit() {
        if (v.execute.isChecked()) {
            Utils.logUserAction("order_execution_submitted",
                "orderUuid", args.order.uuid,
                "instructions", "" + args.order.instructions,
                "executionTime", "" + args.now);
            EventBus.getDefault().post(
                new OrderExecutionAddRequestedEvent(args.order.uuid, args.now));
        }

        if (obsUuidsToDelete.size() > 0) {
            List<Obs> executionsToDelete = new ArrayList<>();
            for (Obs obs : args.executions) {
                if (obsUuidsToDelete.contains(obs.uuid)) {
                    executionsToDelete.add(obs);
                }
            }
            Utils.logUserAction("order_execution_deleted",
                "orderUuid", args.order.uuid,
                "obsUuids", Joiner.on(",").join(obsUuidsToDelete));
            EventBus.getDefault().post(
                new ObsDeleteRequestedEvent(executionsToDelete));
        }
        dialog.dismiss();
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.dialogs;

import android.app.AlertDialog;
import android.os.Bundle;
import android.widget.EditText;

import org.joda.time.DateTime;
import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.client.json.Datatype;
import org.projectbuendia.models.Obs;
import org.projectbuendia.client.utils.Utils;

import java.io.Serializable;

import static org.projectbuendia.client.utils.Utils.eq;

/** A DialogFragment for editing a text observation. */
public class TextObsDialogFragment extends BaseDialogFragment<TextObsDialogFragment, TextObsDialogFragment.Args> {
    static class Args implements Serializable {
        String title;
        Obs obs;
    }

    public static TextObsDialogFragment create(String title, Obs obs) {
        Args args = new Args();
        args.title = title;
        args.obs = obs;
        return new TextObsDialogFragment().withArgs(args);
    }

    @Override public AlertDialog onCreateDialog(Bundle state) {
        return createAlertDialog(R.layout.text_obs_dialog_fragment);
    }

    @Override protected void onOpen() {
        dialog.setTitle(args.title);
        u.setText(R.id.text, args.obs.value);
        Utils.showKeyboard(dialog.getWindow());
    }

    @Override protected void onSubmit() {
        String newValue = ((EditText) u.findView(R.id.text)).getText().toString();
        if (eq(newValue, args.obs.value)) return;

        Utils.logUserAction("text_obs_submitted",
            "patient_uuid", args.obs.patientUuid,
            "concept_uuid", args.obs.conceptUuid,
            "text", newValue);

        App.getModel().addObservationEncounter(
            App.getCrudEventBus(), args.obs.patientUuid, new Obs(
                null, null, args.obs.patientUuid, Utils.getProviderUuid(),
                args.obs.conceptUuid, Datatype.TEXT, DateTime.now(), null, newValue, null
            )
        );
        dialog.dismiss();
    }
}

package org.projectbuendia.client.ui.dialogs;

import android.app.Dialog;
import android.os.Bundle;
import android.text.Html;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox;

import com.google.common.base.Joiner;

import org.joda.time.Interval;
import org.joda.time.LocalDate;
import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.client.events.actions.ObsDeleteRequestedEvent;
import org.projectbuendia.client.json.Datatype;
import org.projectbuendia.models.Obs;
import org.projectbuendia.models.ObsValue;
import org.projectbuendia.client.sync.ConceptService;
import org.projectbuendia.client.utils.Utils;
import org.projectbuendia.client.utils.Utils.DateStyle;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.SortedMap;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import de.greenrobot.event.EventBus;

import static org.projectbuendia.client.utils.Utils.DateStyle.HOUR_MINUTE;
import static org.projectbuendia.client.utils.Utils.DateStyle.MONTH_DAY;
import static org.projectbuendia.client.utils.Utils.DateStyle.RELATIVE_HOUR_MINUTE;
import static org.projectbuendia.client.utils.Utils.eq;

public class ObsDetailDialogFragment extends BaseDialogFragment<ObsDetailDialogFragment, ObsDetailDialogFragment.Args> {
    static class Args implements Serializable {
        Interval interval;
        String[] queriedConceptUuids;
        String[] conceptOrdering;
        List<Obs> observations;
    }

    private ViewGroup obsList;
    private ConceptService concepts;
    private boolean empty;
    private SortedMap<Group, List<Obs>> observationsBySection;
    private List<View> items;
    private Set<String> obsUuidsToDelete = new HashSet<>();

    public static ObsDetailDialogFragment create(
        Interval interval, String[] queriedConceptUuids,
        String[] conceptOrdering, List<Obs> observations) {
        Args args = new Args();
        args.interval = interval;
        args.queriedConceptUuids = Utils.orDefault(queriedConceptUuids, new String[0]);
        args.conceptOrdering = conceptOrdering;
        args.observations = observations;
        return new ObsDetailDialogFragment().withArgs(args);
    }

    @Override public @Nonnull Dialog onCreateDialog(Bundle state) {
        return createAlertDialog(R.layout.obs_detail_dialog_fragment);
    }

    @Override public void onOpen() {
        obsList = u.findView(R.id.obs_list);
        concepts = App.getConceptService();
        empty = args.observations.isEmpty();

        dialog.setTitle(R.string.obs_detail_title);
        dialog.getButton(BUTTON_NEUTRAL).setText(R.string.delete_selected);
        u.show(dialog.getButton(BUTTON_NEUTRAL), !empty);
        u.show(dialog.getButton(BUTTON_NEGATIVE), !empty);

        u.setText(R.id.message, Html.fromHtml(describeQueryHtml()));
        u.show(R.id.body, !empty);

        Map<Group, List<Obs>> groupObs = new HashMap<>();
        for (Obs obs : args.observations) {
            Group group = new Group(obs.time.toLocalDate(), obs.conceptUuid);
            if (!groupObs.containsKey(group)) {
                groupObs.put(group, new ArrayList<>());
            }
            groupObs.get(group).add(obs);
        }

        List<Group> groups = new ArrayList<>(groupObs.keySet());
        items = new ArrayList<>();
        Collections.sort(groups, new GroupComparator(args.conceptOrdering));

        u.addInflated(R.layout.group_spacer, obsList);
        for (Group group : groups) {
            if (args.interval == null || args.queriedConceptUuids.length != 1) {
                View heading = u.addInflated(R.layout.heading, obsList);
                u.setText(R.id.heading, formatHeading(group));
            }

            for (Obs obs : groupObs.get(group)) {
                View item = u.addInflated(R.layout.checkable_item, obsList);
                u.setText(R.id.text, formatValue(obs));
                App.getUserManager().showChip(u.findView(R.id.user_initials), obs.providerUuid);
                item.setTag(obs.uuid);
                items.add(item);

                final CheckBox checkbox = u.findView(R.id.checkbox);
                checkbox.setOnCheckedChangeListener((view, checked) -> updateUi());
                item.setOnClickListener(view -> {
                    if (checkbox.isEnabled()) checkbox.setChecked(!checkbox.isChecked());
                });
            }

            u.addInflated(R.layout.group_spacer, obsList);
        }
        dialog.getButton(BUTTON_NEUTRAL).setOnClickListener(v -> deleteSelected());
        updateUi();
    }

    private CharSequence formatHeading(Group group) {
        if (args.queriedConceptUuids.length != 1) {
            return Html.fromHtml(toBoldHtml(concepts.getName(group.conceptUuid)));
        }
        if (args.interval == null) {
            return Html.fromHtml(toAccentHtml(Utils.format(group.date, MONTH_DAY)));
        }
        return "";
    }

    private CharSequence formatValue(Obs obs) {
        ObsValue value = obs.getObsValue();
        String display =
            obs.type == Datatype.DATE ? Utils.format(value.date, DateStyle.YEAR_MONTH_DAY) :
            obs.type == Datatype.DATETIME ? Utils.format(Utils.toLocalDateTime(value.instant), DateStyle.MONTH_DAY_HOUR_MINUTE) :
            obs.valueName;
        String time = Utils.format(obs.time, HOUR_MINUTE);
        String html = "<span style='color: #33b5e5'>" + time + "</span>"
            + "&nbsp;&nbsp;&nbsp;"
            + Html.escapeHtml(display.replace("\n", "\\\\")).replace("\\\\", "<br>");
        return Html.fromHtml(html);
    }

    private void updateUi() {
        boolean anyItemsChecked = false;
        for (View item : items) {
            CheckBox checkbox = item.findViewById(R.id.checkbox);
            if (checkbox.isChecked()) anyItemsChecked = true;
            if (obsUuidsToDelete.contains(item.getTag())) {
                strikeCheckableItem(item);
            }
        }
        dialog.getButton(BUTTON_NEUTRAL).setEnabled(anyItemsChecked);
    }

    private String describeQueryHtml() {
        String htmlConceptNames = null;
        if (args.queriedConceptUuids.length > 0) {
            Locale locale = App.getSettings().getLocale();
            String[] htmlNames = new String[args.queriedConceptUuids.length];
            for (int i = 0; i < args.queriedConceptUuids.length; i++) {
                htmlNames[i] = toBoldHtml(
                    concepts.getName(args.queriedConceptUuids[i], locale));
            }
            // For this to work, R.string.two_items and R.string.more_than_two_items
            // must not contain any HTML special characters.
            htmlConceptNames = u.formatItems(htmlNames);
        }
        if (args.interval != null) {
            LocalDate day = args.interval.getStart().toLocalDate();
            String htmlDate = toAccentHtml(Utils.format(day, MONTH_DAY));
            if (eq(args.interval, day.toInterval())) {
                return htmlConceptNames != null ? getString(
                    empty ? R.string.obs_detail_concept_day_empty
                        : R.string.obs_detail_concept_day,
                    htmlConceptNames, htmlDate
                ) : getString(
                    empty ? R.string.obs_detail_day_empty
                        : R.string.obs_detail_day,
                    htmlDate
                );
            } else {
                String htmlStart = toAccentHtml(Utils.format(
                    args.interval.getStart(), RELATIVE_HOUR_MINUTE));
                String htmlStop = toAccentHtml(Utils.format(
                    args.interval.getEnd(), RELATIVE_HOUR_MINUTE));
                if (eq(args.interval.getEnd(), day.toInterval().getEnd())) {
                    htmlStop = toAccentHtml(getString(R.string.end_of_day_hour_minute));
                }
                return htmlConceptNames != null ? getString(
                    empty ? R.string.obs_detail_concept_interval_empty
                        : R.string.obs_detail_concept_interval,
                    htmlConceptNames, htmlDate, htmlStart, htmlStop
                ) : getString(
                    empty ? R.string.obs_detail_interval_empty
                        : R.string.obs_detail_interval,
                    htmlDate, htmlStart, htmlStop
                );
            }
        } else if (htmlConceptNames != null) {
            return getString(
                empty ? R.string.obs_detail_concept_empty
                    : R.string.obs_detail_concept,
                htmlConceptNames
            );
        }
        // Should never get here (no concepts and no interval).
        return "";
    }

    /** Marks the checked items for deletion. */
    private void deleteSelected() {
        for (View item : items) {
            CheckBox checkbox = item.findViewById(R.id.checkbox);
            if (checkbox.isChecked()) {
                obsUuidsToDelete.add((String) item.getTag());
                checkbox.setChecked(false);
            }
        }
        updateUi();
        // This button doesn't dismiss the dialog.
    }

    @Override protected void onSubmit() {
        if (obsUuidsToDelete.size() > 0) {
            List<Obs> observationsToDelete = new ArrayList<>();
            for (Obs obs : args.observations) {
                if (obsUuidsToDelete.contains(obs.uuid)) {
                    observationsToDelete.add(obs);
                }
            }
            Utils.logUserAction("obs_deleted",
                "obsUuids", Joiner.on(",").join(obsUuidsToDelete));
            EventBus.getDefault().post(
                new ObsDeleteRequestedEvent(observationsToDelete));
        }
        dialog.dismiss();
    }

    /** Observations are grouped by date and concept. */
    public static class Group {
        public final @Nonnull LocalDate date;
        public final @Nonnull String conceptUuid;

        public Group(Obs obs) {
            this(obs.time.toLocalDate(), obs.conceptUuid);
        }

        public Group(@Nonnull LocalDate date, @Nonnull String conceptUuid) {
            this.date = date;
            this.conceptUuid = conceptUuid;
        }

        @Override public boolean equals(Object other) {
            if (other instanceof Group) {
                Group o = (Group) other;
                return eq(date, o.date) && eq(conceptUuid, o.conceptUuid);
            }
            return false;
        }

        @Override public int hashCode() {
            return Objects.hash(date, conceptUuid);
        }
    }

    /** Arranges groups in order by date and by concept according to a given ordering. */
    public static class GroupComparator implements Comparator<Group> {
        private final Map<String, Integer> orderingByUuid = new HashMap<>();
        private final int orderingMax;

        public GroupComparator(@Nullable String[] conceptOrdering) {
            if (conceptOrdering != null) {
                for (int i = 0; i < conceptOrdering.length; i++) {
                    orderingByUuid.put(conceptOrdering[i], i);
                }
                orderingMax = conceptOrdering.length;
            } else {
                orderingMax = 0;
            }
        }

        @Override public int compare(Group a, Group b) {
            int result = a.date.compareTo(b.date);
            if (result != 0) return result;

            result = Integer.compare(getOrdering(a.conceptUuid), getOrdering(b.conceptUuid));
            if (result != 0) return result;

            return a.conceptUuid.compareTo(b.conceptUuid);
        }

        private int getOrdering(String conceptUuid) {
            return Utils.getOrDefault(orderingByUuid, conceptUuid, orderingMax);
        }
    }
}


// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.dialogs;

import android.app.AlertDialog;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.text.InputFilter;
import android.view.WindowManager;
import android.widget.EditText;

import org.joda.time.DateTime;
import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.client.json.Datatype;
import org.projectbuendia.models.ConceptUuids;
import org.projectbuendia.models.Location;
import org.projectbuendia.models.LocationForest;
import org.projectbuendia.models.Obs;
import org.projectbuendia.models.Patient;
import org.projectbuendia.client.ui.EditTextWatcher;
import org.projectbuendia.client.ui.chart.PatientChartActivity;
import org.projectbuendia.client.ui.lists.LocationOptionList;
import org.projectbuendia.client.utils.Utils;

import static org.projectbuendia.client.utils.Utils.eq;

/** A {@link DialogFragment} for updating a patient's location and bed number. */
public class PatientLocationDialogFragment extends BaseDialogFragment<PatientLocationDialogFragment, Patient> {
    private Patient patient;
    private String initialLocationUuid;
    private String initialBedNumber;

    private LocationOptionList list;
    private EditText bedNumber;

    public static PatientLocationDialogFragment create(Patient patient) {
        return new PatientLocationDialogFragment().withArgs(patient);
    }

    @Override public AlertDialog onCreateDialog(Bundle state) {
        return createAlertDialog(R.layout.patient_location_dialog_fragment);
    }

    @Override protected void onOpen() {
        patient = args;
        initialLocationUuid = patient.locationUuid;
        initialBedNumber = patient.bedNumber;

        dialog.setTitle(R.string.action_assign_location);
        dialog.getWindow().setSoftInputMode(
            WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);

        LocationForest forest = App.getModel().getForest();
        list = new LocationOptionList(u.findView(R.id.list_container), true);
        list.setLocations(forest, forest.getLeaves());
        list.setSelectedLocation(forest.get(initialLocationUuid));

        bedNumber = u.findView(R.id.bed_number);
        bedNumber.setFilters(new InputFilter[] {new InputFilter.AllCaps()});
        bedNumber.setText(initialBedNumber);
        bedNumber.setSelection(bedNumber.getText().length());
        new EditTextWatcher(bedNumber).onChange(() -> {
            if (eq(list.getSelectedLocation().uuid, initialLocationUuid)) {
                initialBedNumber = bedNumber.getText().toString();
            }
        });
        list.setOnLocationSelectedListener(location -> {
            if (eq(location.uuid, initialLocationUuid)) {
                bedNumber.setText(initialBedNumber);
                bedNumber.setSelection(bedNumber.getText().length());
            } else {
                bedNumber.setText("");
            }
        });
    }

    @Override protected void onSubmit() {
        Utils.logUserAction("location_assigned");
        ((PatientChartActivity) getActivity()).getUi().showWaitDialog(R.string.title_updating_patient);

        Location location = list.getSelectedLocation();
        String bedNumber = this.bedNumber.getText().toString().toUpperCase();
        String placement = location != null ? location.uuid + "/" + bedNumber : null;
        App.getModel().addObservationEncounter(App.getCrudEventBus(), patient.uuid, new Obs(
            null, null, patient.uuid, Utils.getProviderUuid(),
            ConceptUuids.PLACEMENT_UUID, Datatype.TEXT, DateTime.now(), null, placement, null
        ));
        dismiss();
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.dialogs;

import android.app.AlertDialog;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.widget.EditText;

import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.client.json.JsonNewUser;
import org.projectbuendia.client.utils.Utils;

import java.io.Serializable;

/** A DialogFragment for adding a new user. */
public class NewUserDialogFragment extends BaseDialogFragment<NewUserDialogFragment, Serializable> {
    class Views {
        EditText givenName = u.findView(R.id.given_name_field);
        EditText familyName = u.findView(R.id.family_name_field);
    }
    @Nullable private ActivityUi mActivityUi;  // optional UI for showing a spinner
    private Views v;

    /** Creates a new instance and registers the given UI, if specified. */
    public static NewUserDialogFragment create(ActivityUi activityUi) {
        return new NewUserDialogFragment().setUi(activityUi);
    }

    public NewUserDialogFragment setUi(ActivityUi activityUi) {
        mActivityUi = activityUi;
        return this;
    }

    @Override public AlertDialog onCreateDialog(Bundle state) {
        return createAlertDialog(R.layout.new_user_dialog_fragment);
    }

    @Override protected void onOpen() {
        v = new Views();

        dialog.setTitle(R.string.title_new_user);
        v.givenName.requestFocus();
        Utils.showKeyboard(dialog.getWindow());
    }

    @Override protected void onSubmit() {
        String givenName = Utils.toNonnullString(v.givenName.getText()).trim();
        String familyName = Utils.toNonnullString(v.familyName.getText()).trim();
        boolean valid = true;
        if (givenName.isEmpty()) {
            setError(v.givenName, R.string.given_name_cannot_be_null);
            valid = false;
        }
        if (familyName.isEmpty()) {
            setError(v.familyName, R.string.family_name_cannot_be_null);
            valid = false;
        }
        Utils.logUserAction("add_user_submitted",
            "valid", "" + valid,
            "given_name", givenName,
            "family_name", familyName);
        if (!valid) return;

        App.getUserManager().addUser(new JsonNewUser(givenName, familyName));
        if (mActivityUi != null) {
            mActivityUi.showSpinner(true);
        }
        dialog.dismiss();
    }

    /** An interface to show a spinner while the new user is being saved. */
    public interface ActivityUi {
        void showSpinner(boolean show);
    }
}

package org.projectbuendia.client.ui.dialogs;

import android.view.View;
import android.widget.RadioButton;
import android.widget.RadioGroup;

import java.util.HashMap;
import java.util.Map;

import static org.projectbuendia.client.utils.Utils.eq;

public class ToggleRadioGroup<T> {
    private final RadioGroup group;
    private Map<T, RadioButton> buttons = new HashMap<>();
    private T selection = null;

    public ToggleRadioGroup(RadioGroup group) {
        this.group = group;
        for (int i = 0; i < group.getChildCount(); i++) {
            View child = group.getChildAt(i);
            T value;
            try {
                value = (T) child.getTag();
            } catch (ClassCastException e) {
                continue;
            }
            if (child instanceof RadioButton && value != null) {
                buttons.put(value, (RadioButton) child);
                child.setOnClickListener(view -> setSelection(
                    eq(selection, value) ? null : value));
            }
        }
    }

    public void setSelection(T value) {
        if (value == null) {
            group.clearCheck();
        } else {
            RadioButton button = buttons.get(value);
            if (button != null) button.setChecked(true);
        }
        selection = value;
    }

    public T getSelection() {
        return selection;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.dialogs;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.text.Html;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;

import org.projectbuendia.client.R;
import org.projectbuendia.client.ui.BaseActivity;
import org.projectbuendia.client.utils.ContextUtils;
import org.projectbuendia.client.utils.Utils;

import java.io.Serializable;

import javax.annotation.Nonnull;

import butterknife.ButterKnife;

import static android.util.TypedValue.COMPLEX_UNIT_SP;

/** Common behaviour for all dialogs. */
public abstract class BaseDialogFragment<T extends BaseDialogFragment, A extends Serializable> extends DialogFragment {
    public static int BUTTON_NEGATIVE = DialogInterface.BUTTON_NEGATIVE;
    public static int BUTTON_NEUTRAL = DialogInterface.BUTTON_NEUTRAL;
    public static int BUTTON_POSITIVE = DialogInterface.BUTTON_POSITIVE;
    public static int[] BUTTONS = {BUTTON_NEGATIVE, BUTTON_NEUTRAL, BUTTON_POSITIVE};

    protected ContextUtils u;
    protected AlertDialog dialog;
    protected A args;  // construction arguments passed in via setArguments()

    /** Sets an object that will become the "args" member when the dialog is built. */
    public T withArgs(Serializable args) {
        setArguments(Utils.bundle("args", args));
        return (T) this;
    }

    @Override public void onCreate(Bundle state) {
        super.onCreate(state);
        u = ContextUtils.from(getActivity());
    }

    /** Subclasses should implement onCreateDialog() by calling createAlertDialog(). */
    protected @Nonnull AlertDialog createAlertDialog(int layoutId) {
        Activity activity = getActivity();
        View view = u.inflateForDialog(layoutId);
        ButterKnife.inject(this, view);

        dialog = new AlertDialog.Builder(activity)
            .setTitle("Dialog")  // without this, there is no title bar
            .setView(view)
            .setPositiveButton(getString(R.string.ok), null)
            .setNegativeButton(getString(R.string.cancel), null)
            .create();

        dialog.setCanceledOnTouchOutside(true);

        dialog.setOnShowListener(di -> {
            // Make the "Cancel" and "OK" button text match the rest of the UI text.
            for (int which : BUTTONS) {
                Button button = dialog.getButton(which);
                if (button != null) button.setTextSize(COMPLEX_UNIT_SP, 19);
            }

            // To prevent automatic dismissal of the dialog, we have to override
            // the listener instead of passing it in to setPositiveButton.
            dialog.getButton(BUTTON_POSITIVE).setOnClickListener(v -> onSubmit());
            dialog.getButton(BUTTON_NEGATIVE).setOnClickListener(v -> onCancel());

            if (activity instanceof BaseActivity) {
                ((BaseActivity) activity).onDialogOpened(BaseDialogFragment.this);
            }
            Bundle bundle = getArguments();
            args = bundle != null ? (A) bundle.getSerializable("args") : null;
            onOpen();
        });
        return dialog;
    }

    @Override public void onDismiss(DialogInterface di) {
        super.onDismiss(di);
        Activity activity = getActivity();
        if (activity instanceof BaseActivity) {
            ((BaseActivity) activity).onDialogClosed(this);
        }
        onClose();
    }

    /** Invoked just after the dialog opens; use this to populate the dialog. */
    protected void onOpen() { }

    /** Invoked when the user taps the "OK" button; should call .dismiss() if needed. */
    protected void onSubmit() { }

    /** Invoked when the user taps the "Cancel" button; should call .dismiss() if needed. */
    protected void onCancel() {
        dialog.dismiss();
    }

    /** Invoked when the dialog is closed, either by the "Cancel" button or by .dismiss(). */
    protected void onClose() { }

    /** Attaches a validation error message to a text field. */
    protected void setError(TextView field, int messageId, Object... args) {
        field.setError(getString(messageId, args));
        field.invalidate();
        field.requestFocus();
    }

    /** Returns the HTML for the given text. */
    protected String toHtml(String text) {
        return Html.escapeHtml(text);
    }

    /** Returns the HTML for the given text in bold. */
    protected String toBoldHtml(String text) {
        return "<b>" + Html.escapeHtml(text) + "</b>";
    }

    /** Returns the HTML for the given text. */
    protected String toItalicHtml(String text) {
        return "<i>" + Html.escapeHtml(text) + "</i>";
    }

    /** Applies an accent colour that matches the colour of the dialog title. */
    protected String toAccentHtml(String text) {
        return "<span style='color: #33b5e5'>" + Html.escapeHtml(text) + "</span>";
    }

    /** Strikes through and disables a checkable list item (see checkable_item.xml). */
    protected void strikeCheckableItem(View item) {
        item.setBackgroundColor(0xffffcccc);
        ((TextView) item.findViewById(R.id.text)).setTextColor(0xff999999);
        item.findViewById(R.id.strikethrough).setVisibility(View.VISIBLE);
        item.findViewById(R.id.checkbox).setEnabled(false);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.dialogs;

import android.app.AlertDialog;
import android.database.Cursor;
import android.os.Bundle;
import android.os.Handler;
import android.widget.EditText;
import android.widget.TextView;

import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.client.events.actions.PatientChartRequestedEvent;
import org.projectbuendia.client.events.data.ItemLoadFailedEvent;
import org.projectbuendia.client.events.data.ItemLoadedEvent;
import org.projectbuendia.models.Patient;
import org.projectbuendia.client.providers.Contracts.Patients;
import org.projectbuendia.client.ui.EditTextWatcher;
import org.projectbuendia.client.utils.Utils;

import java.io.Serializable;

import de.greenrobot.event.EventBus;

import static org.projectbuendia.client.utils.ContextUtils.FormatStyle.LONG;
import static org.projectbuendia.client.utils.ContextUtils.FormatStyle.SHORT;

/** A dialog for jumping to a patient by ID. */
public class GoToPatientDialogFragment extends BaseDialogFragment<GoToPatientDialogFragment, Serializable> {
    class Views {
        EditText patientId = u.findView(R.id.go_to_patient_id);
        TextView searchResult = u.findView(R.id.go_to_patient_result);
    }

    private Views v;
    String patientUuid = null;

    @Override public AlertDialog onCreateDialog(Bundle state) {
        return createAlertDialog(R.layout.go_to_patient_dialog_fragment);
    }

    @Override protected void onOpen() {
        v = new Views();
        App.getCrudEventBus().register(this);

        dialog.setTitle(R.string.go_to_patient_title);
        new EditTextWatcher(v.patientId).onChange(this::search);
        v.searchResult.setOnClickListener(view -> onSubmit());
        dialog.getButton(BUTTON_POSITIVE).setText(R.string.go_to_chart);
    }

    @Override protected void onSubmit() {
        Utils.logUserAction("go_to_patient_submitted",
            "query_id", v.patientId.getText().toString(),
            "patient_uuid", patientUuid);
        if (patientUuid != null) {
            dialog.dismiss();

            // NOTE(ping): I don't fully understand why, but posting this on a
            // Handler is necessary to get the numeric keypad to close.  If we
            // post the event to the EventBus immediately, the numeric keypad
            // stays up even as the new activity launches underneath it!
            new Handler().postDelayed(() -> EventBus.getDefault().post(
                new PatientChartRequestedEvent(patientUuid)), 100);
        }
    }

    public void onEventMainThread(ItemLoadedEvent<?> event) {
        if (event.item instanceof Patient) {
            String id = v.patientId.getText().toString().trim();
            Patient patient = (Patient) event.item;
            if (id.equals(patient.id)) {  // server returned the patient we were looking for
                patientUuid = patient.uuid;
                v.searchResult.setText(formatSearchResult(patient));
            }
        }
    }

    public void onEventMainThread(ItemLoadFailedEvent event) {
        String id = v.patientId.getText().toString().trim();
        if (id.equals(event.id)) {  // server returned empty results for the ID we sought
            patientUuid = null;
            v.searchResult.setText(u.str(R.string.patient_not_found, event.id));
        }
    }

    private String formatSearchResult(Patient patient) {
        String details = u.formatPatientDetails(patient, SHORT, LONG, LONG);
        return Utils.format("%s (%s)", u.formatPatientName(patient),
            Utils.nonemptyOrDefault(details, u.str(R.string.unknown)));
    }

    private void search() {
        String id = v.patientId.getText().toString().trim();
        if (id.isEmpty()) {
            patientUuid = null;
            v.searchResult.setText("");
        } else {
            if (id.matches("^\\d+$")) {
                String prefix = Utils.nonemptyOrDefault(App.getSettings().getLastIdPrefix(), "BN"); // TODO(ping): Remove this Bunia-specific hack.
                id = prefix + "/" + id;
            }
            try (Cursor cursor = getActivity().getContentResolver().query(
                Patients.URI, null, Patients.ID + " = ?", new String[] {id}, null)) {
                if (cursor.moveToNext()) {  // found locally
                    Patient patient = Patient.load(cursor);
                    patientUuid = patient.uuid;
                    v.searchResult.setText(formatSearchResult(patient));
                } else {  // not found locally; check server
                    patientUuid = null;
                    v.searchResult.setText(R.string.searching_ellipsis);
                    App.getModel().fetchPatient(App.getCrudEventBus(), id);
                }
            }
        }
        dialog.getButton(BUTTON_POSITIVE).setEnabled(patientUuid != null);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.dialogs;

import android.app.AlertDialog;
import android.graphics.PorterDuff;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.text.method.KeyListener;
import android.view.ActionMode;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.AutoCompleteTextView;
import android.widget.Button;
import android.widget.EditText;
import android.widget.RadioButton;
import android.widget.RadioGroup;
import android.widget.Spinner;
import android.widget.TableRow;
import android.widget.TextView;

import com.google.common.collect.Lists;

import org.joda.time.DateTime;
import org.joda.time.Days;
import org.joda.time.LocalDate;
import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.client.events.actions.OrderAddRequestedEvent;
import org.projectbuendia.client.events.actions.OrderDeleteRequestedEvent;
import org.projectbuendia.client.events.actions.OrderDialogRequestedEvent;
import org.projectbuendia.client.events.actions.OrderStopRequestedEvent;
import org.projectbuendia.client.ui.AutocompleteAdapter;
import org.projectbuendia.client.ui.AutocompleteAdapter.CompletionAdapter;
import org.projectbuendia.client.ui.EditTextWatcher;
import org.projectbuendia.client.utils.Intl;
import org.projectbuendia.client.utils.Utils;
import org.projectbuendia.models.Catalog.Category;
import org.projectbuendia.models.Catalog.Drug;
import org.projectbuendia.models.Catalog.Format;
import org.projectbuendia.models.Catalog.Route;
import org.projectbuendia.models.CatalogIndex;
import org.projectbuendia.models.MsfCatalog;
import org.projectbuendia.models.Obs;
import org.projectbuendia.models.Order;
import org.projectbuendia.models.Order.Instructions;
import org.projectbuendia.models.Quantity;
import org.projectbuendia.models.Unit;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import de.greenrobot.event.EventBus;

import static org.projectbuendia.client.utils.Utils.DateStyle.SENTENCE_MONTH_DAY;
import static org.projectbuendia.client.utils.Utils.eq;

/** A DialogFragment for creating or editing a treatment order. */
public class OrderDialogFragment extends BaseDialogFragment<OrderDialogFragment, OrderDialogFragment.Args> {
    public static final int MAX_FREQUENCY = 24;  // maximum 24 times per day
    public static final int MAX_DURATION_DAYS = 30;  // maximum 30 days

    // This should match the left/right padding in the TextViews in captioned_item.xml.
    private static final int ITEM_HORIZONTAL_PADDING = 12;

    // This custom action mode callback disables the clipboard popup menu.
    private static final ActionMode.Callback PASTE_DISABLED = new ActionMode.Callback() {
        public boolean onPrepareActionMode(ActionMode mode, Menu menu) { return false; }
        public boolean onCreateActionMode(ActionMode mode, Menu menu) { return false; }
        public boolean onActionItemClicked(ActionMode mode, MenuItem item) { return false; }
        public void onDestroyActionMode(ActionMode mode) { }
    };

    static class Args implements Serializable {
        String patientUuid;
        Order order;
        boolean executed;
        boolean stopped;
        DateTime now;
    }

    class Views {
        RadioGroup category = u.findView(R.id.order_category);

        AutoCompleteTextView drug = u.findView(R.id.order_drug);
        Spinner format = u.findView(R.id.order_format);
        TableRow dosageRow = u.findView(R.id.dosage_row);
        EditText dosage = u.findView(R.id.order_dosage);
        TextView dosageUnit = u.findView(R.id.order_dosage_unit);
        Spinner route = u.findView(R.id.order_route);
        TableRow continuousRow = u.findView(R.id.continuous_row);
        EditText amount = u.findView(R.id.order_amount);
        TextView amountUnit = u.findView(R.id.order_amount_unit);
        EditText duration = u.findView(R.id.order_duration);
        TextView durationUnit = u.findView(R.id.order_duration_unit);

        RadioGroup isSeries = u.findView(R.id.order_is_series);
        RadioButton unary = u.findView(R.id.order_unary);
        RadioButton series = u.findView(R.id.order_series);
        TableRow frequencyRow = u.findView(R.id.frequency_row);
        EditText frequency = u.findView(R.id.order_frequency);
        TextView frequencyUnit = u.findView(R.id.order_frequency_unit);
        TableRow seriesLengthRow = u.findView(R.id.series_length_row);
        EditText seriesLength = u.findView(R.id.order_series_length);
        TextView seriesLengthUnit = u.findView(R.id.order_series_length_unit);
        TextView scheduleDescription = u.findView(R.id.order_schedule_description);
        TableRow scheduleDescriptionRow = u.findView(R.id.schedule_description_row);
        EditText notes = u.findView(R.id.order_notes);
        Button stopNow = u.findView(R.id.order_stop_now);
        Button delete = u.findView(R.id.order_delete);
    }

    private Views v;
    private String orderUuid;
    private DateTime start;
    private AutocompleteAdapter autocompleter;
    private DrugCompletionAdapter adapter;
    private KeyListener drugKeyListener;
    private Map<String, Integer> buttonIdsByCategoryCode = new HashMap<>();

    private CatalogIndex index;

    /** The category for which the drug list and route list are configured. */
    private Category activeCategory = Category.UNSPECIFIED;

    /** The drug for which the format list is configured. */
    private Drug activeDrug = Drug.UNSPECIFIED;

    /* The format for which the dosing unit is configured. */
    private Format activeFormat = Format.UNSPECIFIED;

    /* The currently selected unit for dosage quantity. */
    private Unit activeUnit = Unit.UNSPECIFIED;

    /* The currently selected unit for administration duration. */
    private Unit activeDurationUnit = Unit.UNSPECIFIED;

    /** Creates a new instance and registers the given UI, if specified. */
    public static OrderDialogFragment create(
        String patientUuid, Order order, List<Obs> executions) {
        Args args = new Args();

        // This time is used as the current time for all calculations in this dialog.
        // Always use this value instead of calling now(), in order to maintain UI
        // consistency (e.g. if opened before midnight and submitted after midnight).
        args.now = DateTime.now();

        args.patientUuid = patientUuid;
        args.order = order;
        args.executed = Utils.hasItems(executions);
        args.stopped = order != null && (
            !order.isSeries() || (order.stop != null && args.now.isAfter(order.stop)));
        return new OrderDialogFragment().withArgs(args);
    }

    @Override public AlertDialog onCreateDialog(Bundle state) {
        return createAlertDialog(R.layout.order_dialog_fragment);
    }

    @Override public void onOpen() {
        v = new Views();
        drugKeyListener = v.drug.getKeyListener();
        v.drug.setCustomSelectionActionModeCallback(PASTE_DISABLED);

        // Attach the MSF catalog to the UI.
        index = MsfCatalog.INDEX;
        attachCategory(R.id.oral_category, MsfCatalog.ORAL);
        attachCategory(R.id.injectable_category, MsfCatalog.INJECTABLE);
        attachCategory(R.id.infusible_category, MsfCatalog.PERFUSION);
        attachCategory(R.id.external_category, MsfCatalog.EXTERNAL);
        attachCategory(R.id.vaccine_category, MsfCatalog.VACCINE);

        orderUuid = args.order != null ? args.order.uuid : null;
        start = args.order != null ? args.order.start : args.now;

        dialog.setTitle(args.order == null ? R.string.title_new_order : R.string.title_edit_order);
        onCategorySelected();
        if (args.order != null) populateFields();
        updateUi();
        initDrugAutocompletion();
        addListeners();
    }

    private void attachCategory(int buttonId, Category category) {
        RadioButton button = u.findView(buttonId);
        button.setTag(category);
        buttonIdsByCategoryCode.put(category.code, buttonId);
    }

    private void initDrugAutocompletion() {
        adapter = new DrugCompletionAdapter(index);
        adapter.setCategory(activeCategory);
        autocompleter = new AutocompleteAdapter(
            getActivity(), R.layout.captioned_item, adapter);
        v.drug.setAdapter(autocompleter);
        v.drug.setThreshold(1);

        addClearButton(v.drug, R.drawable.abc_ic_clear_mtrl_alpha);

        // After the dialog has been laid out and positioned, we can figure out
        // how to position and size the autocompletion dropdown.
        v.drug.getViewTreeObserver().addOnPreDrawListener(() -> {
            adjustDropDownSize(v.drug, ITEM_HORIZONTAL_PADDING);
            return true;
        });

        // Open the keyboard, ready to type into the drug field.
        // TODO(ping): Figure out why this doesn't open the keyboard.
        v.drug.requestFocus();
    }

    private void addListeners() {
        v.category.setOnCheckedChangeListener((v, id) -> onCategorySelected());

        v.drug.setOnItemClickListener(
            (parent, view, pos, id) -> onDrugSelected(
                (Drug) autocompleter.getItem(pos)));

        v.format.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
            @Override public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                onFormatSelected((Format) v.format.getSelectedItem());
            }

            @Override public void onNothingSelected(AdapterView<?> parent) {
                onFormatSelected(Format.UNSPECIFIED);
            }
        });

        View.OnClickListener onDosageUnitClicked = (view) -> selectUnit(
            R.string.select_dosage_unit, index.getDosageUnits(), (unit) -> {
                activeUnit = unit;
                updateUi();
            }
        );
        v.amountUnit.setOnClickListener(onDosageUnitClicked);
        v.dosageUnit.setOnClickListener(onDosageUnitClicked);
        v.durationUnit.setOnClickListener((view) -> selectUnit(
            R.string.select_duration_unit, index.getDurationUnits(), (unit) -> {
                activeDurationUnit = unit;
                updateUi();
            }
        ));

        v.isSeries.setOnCheckedChangeListener((v, id) -> onIsSeriesChanged());
        new EditTextWatcher(
            v.dosage, v.amount, v.duration, v.frequency, v.seriesLength
        ).onChange(() -> updateUi());

        v.stopNow.setOnClickListener(view -> onStopNow());
        v.delete.setOnClickListener(view -> onDelete());
    }

    interface OnUnitSelectedListener {
        void onUnitSelected(Unit unit);
    }

    private void selectUnit(int titleId, Unit[] units, OnUnitSelectedListener listener) {
        if (args.executed) return;  // Can't change dosage if already executed

        String[] labels = new String[units.length];
        int i = 0;
        for (Unit unit : units) {
            labels[i++] = getString(R.string.unit_with_abbreviation,
                App.localize(unit.abbr), App.localize(unit.plural));
        }

        new AlertDialog.Builder(getActivity())
            .setTitle(titleId)
            .setSingleChoiceItems(
                labels,
                Arrays.asList(units).indexOf(activeUnit),
                (dialog, index) -> {
                    listener.onUnitSelected(units[index]);
                    dialog.dismiss();
                })
            .show();
    }

    private void selectDurationUnit(View v) {
        if (args.executed) return;  // Can't change dosage if already executed

        Unit[] units = index.getDurationUnits();
        String[] labels = new String[units.length];

        int i = 0;
        for (Unit unit : units) {
            labels[i++] = getString(R.string.unit_with_abbreviation,
                App.localize(unit.abbr), App.localize(unit.plural));
        }

        new AlertDialog.Builder(getActivity())
            .setTitle(R.string.select_dosage_unit)
            .setSingleChoiceItems(
                labels,
                Arrays.asList(units).indexOf(activeUnit),
                (dialog, index) -> {
                    activeUnit = units[index];
                    updateUi();
                    dialog.dismiss();
                })
            .show();
    }

    private void setSpinnerSelection(Spinner spinner, Object item) {
        for (int pos = 0; pos < spinner.getCount(); pos++) {
            if (eq(spinner.getItemAtPosition(pos), item)) {
                spinner.setSelection(pos);
                break;
            }
        }
    }

    private void populateFields() {
        Instructions instr = args.order.instructions;
        boolean isContinuous = args.order.isContinuous();
        boolean isSeries = args.order.isSeries();
        DateTime stop = args.order.stop;

        String formatCode = Utils.toNonnull(instr.code);
        String drugCode = formatCode.length() >= 8 ? formatCode.substring(0, 8) : "";
        String categoryCode = formatCode.length() >= 4 ? formatCode.substring(0, 4) : "";

        Integer buttonId = buttonIdsByCategoryCode.get(categoryCode);
        v.category.check(buttonId == null ? -1 : buttonId);
        onCategorySelected();

        Drug drug = index.getDrug(instr.code);
        onDrugSelected(drug);
        v.drug.setText(instr.getDrugName());

        Format format = index.getFormat(instr.code);
        setSpinnerSelection(v.format, format);
        onFormatSelected(format);

        setSpinnerSelection(v.route, index.getRoute(instr.route));
        if (instr.amount != null) {
            activeUnit = instr.amount.unit;
            if (isContinuous) {
                v.amount.setText(Utils.format(instr.amount.mag, 2));
                activeDurationUnit = instr.duration.unit;
                v.duration.setText(Utils.format(instr.duration.mag, 2));
            } else {
                v.dosage.setText(Utils.format(instr.amount.mag, 2));
            }
        }

        v.isSeries.check(isSeries ? v.series.getId() : v.unary.getId());
        v.frequency.setText(isSeries ? Utils.format(instr.frequency.mag, 2) : "");
        if (stop != null) {
            int days = Days.daysBetween(start.toLocalDate(), stop.toLocalDate()).getDays();
            if (days > 0) v.seriesLength.setText("" + days);
        }
        v.notes.setText(instr.notes);
    }

    @Override protected void onSubmit() {
        String code = activeFormat != Format.UNSPECIFIED ? activeFormat.code
            : activeDrug != Drug.UNSPECIFIED ? activeDrug.code
            : Utils.getText(v.drug);  // fall back to free text
        Quantity amount = Quantity.ZERO;
        Quantity duration = Quantity.ZERO;
        if (activeUnit != null) {
            amount = new Quantity(Utils.getDouble(v.dosage, 0), activeUnit);
            if (activeCategory.isContinuous) {
                amount = new Quantity(Utils.getDouble(v.amount, 0), activeUnit);
                duration = new Quantity(Utils.getDouble(v.duration, 0), activeDurationUnit);
            }
        }
        Route activeRoute = Utils.orDefault((Route) v.route.getSelectedItem(), Route.UNSPECIFIED);
        String route = activeRoute.code;
        boolean isSeries = v.isSeries.getCheckedRadioButtonId() == R.id.order_series;
        Quantity frequency = isSeries ?
            new Quantity(Utils.getDouble(v.frequency, 0), Unit.PER_DAY) : null;
        String notes = Utils.getText(v.notes);

        Instructions instructions = new Instructions(
            code, amount, duration, route, frequency, notes
        );

        int seriesLengthDays = Utils.getInt(v.seriesLength, -1);
        boolean valid = true;
        if (code.trim().isEmpty()) {
            setError(v.drug, R.string.enter_medication);
            valid = false;
        }
        if (valid && activeDrug != null) {
            if (activeCategory.isContinuous) {
                if (amount.mag == 0) {
                    setError(v.amount, R.string.enter_dosage);
                    valid = false;
                }
                if (valid && duration.mag == 0) {
                    setError(v.duration, R.string.enter_duration);
                    valid = false;
                }
            } else {
                if (amount.mag == 0) {
                    setError(v.dosage, R.string.enter_dosage);
                    valid = false;
                }
            }
        }
        if (valid && isSeries && frequency.mag == 0) {
            setError(v.frequency, R.string.enter_number);
            valid = false;
        }
        if (valid && isSeries && frequency.mag > MAX_FREQUENCY) {
            setError(v.frequency, R.string.order_cannot_exceed_n_times_per_day, MAX_FREQUENCY);
            valid = false;
        }
        if (valid && seriesLengthDays != -1) {
            if (seriesLengthDays == 0) {
                setError(v.seriesLength, R.string.order_give_for_days_cannot_be_zero);
                valid = false;
            }
            if (seriesLengthDays > MAX_DURATION_DAYS) {
                setError(v.seriesLength, R.string.order_cannot_exceed_n_days, MAX_DURATION_DAYS);
                valid = false;
            }
            if (start.plusDays(seriesLengthDays).isBefore(args.now)) {
                setError(v.seriesLength, R.string.order_cannot_stop_in_past);
                valid = false;
            }
        }
        Utils.logUserAction("order_submitted",
            "valid", "" + valid,
            "uuid", orderUuid,
            "code", code,
            "amount", "" + amount,
            "duration", "" + duration,
            "route", route,
            "frequency", "" + frequency,
            "seriesLengthDays", "" + seriesLengthDays,
            "notes", notes);
        if (!valid) return;

        dialog.dismiss();

        // Facilitate entering several orders one after another.
        u.prompt(R.string.title_next_treatment, R.string.add_another_treatment,
            R.string.title_new_order, R.string.done, this::openNextOrder);

        // Post an event that triggers the PatientChartController to save the order.
        EventBus.getDefault().post(new OrderAddRequestedEvent(
            orderUuid, args.patientUuid, Utils.getProviderUuid(),
            instructions, start, seriesLengthDays > 0 ? seriesLengthDays : null
        ));
    }

    private void openNextOrder() {
        EventBus.getDefault().post(new OrderDialogRequestedEvent());
    }

    private void onStopNow() {
        dialog.dismiss();
        u.prompt(R.string.title_confirmation, R.string.confirm_order_stop, R.string.order_stop_now,
            () -> {
                Instructions instr = args.order.instructions;
                Utils.logUserAction("order_stop_requested",
                    "uuid", orderUuid,
                    "code", instr.code,
                    "amount", "" + instr.amount,
                    "duration", "" + instr.duration,
                    "route", instr.route,
                    "frequency", "" + instr.frequency,
                    "notes", instr.notes);
                EventBus.getDefault().post(new OrderStopRequestedEvent(orderUuid));
            }
        );
    }

    private void onDelete() {
        dialog.dismiss();
        u.prompt(R.string.title_confirmation, R.string.confirm_order_delete, R.string.delete,
            () -> {
                Instructions instr = args.order.instructions;
                Utils.logUserAction("order_delete_requested",
                    "uuid", orderUuid,
                    "code", instr.code,
                    "amount", "" + instr.amount,
                    "duration", "" + instr.duration,
                    "route", instr.route,
                    "frequency", "" + instr.frequency,
                    "notes", instr.notes);
                EventBus.getDefault().post(new OrderDeleteRequestedEvent(orderUuid));
            }
        );
    }

    /** Adds an "X" button to a text edit field. */
    private void addClearButton(final EditText view, int drawableId) {
        final Drawable icon = view.getResources().getDrawable(drawableId);
        icon.setColorFilter(0xff999999, PorterDuff.Mode.MULTIPLY);  // draw icon in grey
        final int iw = icon.getIntrinsicWidth();
        final int ih = icon.getIntrinsicHeight();
        icon.setBounds(0, 0, iw, ih);

        final Drawable cd[] = view.getCompoundDrawables();
        Runnable update = () -> {
            boolean show = view.getText().length() > 0;
            view.setCompoundDrawables(cd[0], cd[1], show ? icon : cd[2], cd[3]);
        };
        update.run();
        new EditTextWatcher(view).onChange(update);

        view.setMinimumHeight(view.getPaddingTop() + ih + view.getPaddingBottom());
        view.setOnTouchListener((v, event) -> {
            if (event.getAction() == MotionEvent.ACTION_UP) {
                int x = (int) event.getX();
                int y = (int) event.getY();
                if (x >= view.getWidth() - view.getPaddingRight() - iw && x < view.getWidth() &&
                    y >= 0 && y < view.getHeight()) {
                    view.setText("");
                    onDrugSelected(Drug.UNSPECIFIED);
                    return true;
                }
            }
            return false;
        });
    }

    private static int getIntField(EditText field, int defaultValue) {
        return Utils.toIntOrDefault(field.getText().toString().trim(), defaultValue);
    }

    /** Updates elements and spinner contents when a category is selected. */
    private void onCategorySelected() {
        int categoryId = v.category.getCheckedRadioButtonId();
        Category category = categoryId == -1 ? Category.UNSPECIFIED :
            (Category) u.findView(categoryId).getTag();
        if (category == activeCategory) return;

        activeCategory = category;
        if (adapter != null) adapter.setCategory(category);
        activeDrug = Drug.UNSPECIFIED;
        v.drug.setText("");
        populateFormatSpinner(new Format[] {Format.UNSPECIFIED});

        Utils.showIf(v.dosageRow, !category.isContinuous);
        Utils.showIf(v.continuousRow, category.isContinuous);

        populateRouteSpinner(category.routes);
        Utils.showIf(v.route, category.routes.length > 0);
        Utils.setEnabled(v.route, activeFormat != null && category.routes.length > 1);

        clearDosage();
        clearSchedule();
        updateUi();
    }

    private void populateRouteSpinner(Route[] routes) {
        v.route.setAdapter(new ArrayAdapter<>(
            getActivity(), R.layout.spinner_item, routes));
        if (routes.length > 0) v.route.setSelection(0);
    }

    private void onDrugSelected(Drug drug) {
        if (drug == activeDrug) return;

        activeDrug = drug;
        populateFormatSpinner(drug.formats);

        clearDosage();
        clearSchedule();
        updateUi();
    }

    private void populateFormatSpinner(Format[] formats) {
        v.format.setAdapter(new ArrayAdapter<>(
            getActivity(), R.layout.spinner_item, formats));
        if (formats.length > 0) v.format.setSelection(0);
        activeFormat = Format.UNSPECIFIED;
    }

    private void onFormatSelected(Format format) {
        if (format == activeFormat) return;

        activeFormat = format;
        activeUnit = format.dosageUnit;
        activeDurationUnit = Unit.HOUR;
        updateUi();
        if (Utils.isVisible(v.dosageRow)) v.dosage.requestFocus();
        if (Utils.isVisible(v.continuousRow)) v.amount.requestFocus();
    }

    private void clearDosage() {
        v.dosage.setText("");
        v.dosage.setError(null);
        v.amount.setText("");
        v.amount.setError(null);
        v.duration.setText("");
        v.duration.setError(null);
        activeUnit = Unit.UNSPECIFIED;
        activeDurationUnit = Unit.UNSPECIFIED;
    }

    private void clearSchedule() {
        v.isSeries.check(v.unary.getId());
        v.frequency.setText("");
        v.frequency.setError(null);
        v.seriesLength.setText("");
        v.seriesLength.setError(null);
        v.scheduleDescription.setText("");
    }

    private void onIsSeriesChanged() {
        updateUi();
        if (Utils.isVisible(v.frequencyRow)) v.frequency.requestFocus();
    }

    /** Updates labels and disables or hides elements according to changes in input fields. */
    private void updateUi() {
        boolean drugSelected = !eq(activeDrug, Drug.UNSPECIFIED);
        boolean formatSelected = !eq(activeFormat, Format.UNSPECIFIED);

        // Disable text editing of the drug when a completion has been selected.
        v.drug.setKeyListener(drugSelected ? null : drugKeyListener);

        Utils.setEnabled(v.format, drugSelected);
        Utils.setEnabled(v.dosage, formatSelected);
        Utils.setEnabled(v.route, formatSelected);
        Utils.setEnabled(v.amount, formatSelected);
        Utils.setEnabled(v.duration, formatSelected);
        Utils.setChildrenEnabled(v.isSeries, formatSelected);
        Utils.setEnabled(v.frequency, formatSelected);
        Utils.setEnabled(v.seriesLength, formatSelected);

        boolean isSeries = v.isSeries.getCheckedRadioButtonId() == R.id.order_series;
        Utils.showIf(v.frequencyRow, isSeries);
        Utils.showIf(v.seriesLengthRow, isSeries);

        double dosage = Utils.getDouble(v.dosage, 0);
        double amount = Utils.getDouble(v.amount, 0);
        double duration = Utils.getDouble(v.duration, 0);
        int timesPerDay = Utils.getInt(v.frequency, 0);
        int days = Utils.getInt(v.seriesLength, 0);

        LocalDate startDay = start.toLocalDate();
        LocalDate stopDay = startDay.plusDays(days);

        Utils.showIf(v.dosageRow, !activeCategory.isContinuous && activeUnit != null);
        Utils.showIf(v.continuousRow, activeCategory.isContinuous && activeUnit != null);

        if (activeUnit != null) {
            if (activeCategory.isContinuous) {
                v.amountUnit.setText(getString(
                    R.string.order_volume_unit_in,
                    App.localize(activeUnit.forCount(amount))
                ));
                v.durationUnit.setText(App.localize(activeDurationUnit.forCount(duration)));
            } else {
                v.dosageUnit.setText(App.localize(activeUnit.forCount(dosage)));
            }
        }
        v.frequencyUnit.setText(App.localize(Unit.PER_DAY.forCount(timesPerDay)));
        v.seriesLengthUnit.setText(App.localize(Unit.DAY.forCount(days)));

        int doses = timesPerDay * days;
        String startDate = friendlyDateFormat(startDay);
        String stopDate = friendlyDateFormat(stopDay);

        if (args.order == null) {
            v.scheduleDescription.setText(
                !isSeries || timesPerDay == 0 || timesPerDay * days == 1 ?
                    u.str(R.string.order_one_dose_only_ordered_date, startDate) :
                days == 0 ?
                    u.str(R.string.order_start_now_indefinitely) :
                days == 1 ?
                    u.str(R.string.order_start_now_stop_after_n_doses, doses) :
                u.str(R.string.order_start_now_after_n_doses_stop_date, doses, stopDate)
            );
        } else {
            v.scheduleDescription.setText(
                !isSeries || timesPerDay == 0 || timesPerDay * days == 1 ?
                    u.str(R.string.order_one_dose_only_ordered_date, startDate) :
                days == 0 ?
                    u.str(R.string.order_started_date_indefinitely, startDate) :
                days == 1 ?
                    u.str(R.string.order_n_doses_in_one_day_ordered_date, doses, startDate) :
                u.str(R.string.order_started_date_after_n_doses_stop_date, startDate, doses, stopDate)
            );
        }

        // If already executed, all dosing fields are read-only.
        if (args.executed) {
            Utils.setChildrenEnabled(v.category, false);
            Utils.setEnabled(v.drug, false);
            Utils.setEnabled(v.format, false);
            Utils.setEnabled(v.dosage, false);
            Utils.setEnabled(v.route, false);
            Utils.setEnabled(v.amount, false);
            Utils.setEnabled(v.duration, false);
            (isSeries ? v.frequency : v.notes).requestFocus();  // focus on first enabled field
        }

        // Hide or show the "Stop" and "Delete" buttons appropriately.
        Utils.showIf(v.stopNow, args.order != null && !args.stopped);
        Utils.showIf(v.delete, args.order != null && !args.executed);
    }

    private String friendlyDateFormat(LocalDate date) {
        int days = Days.daysBetween(LocalDate.now(), date).getDays();
        return days == 0 ? u.str(R.string.sentence_today)
            : days == 1 ? u.str(R.string.sentence_tomorrow)
            : days == -1 ? u.str(R.string.sentence_yesterday)
            : Utils.format(date, SENTENCE_MONTH_DAY);
    }

    /** Adjusts the size of the autocomplete dropdown according to other UI elements. */
    private void adjustDropDownSize(AutoCompleteTextView textView, int itemHorizontalPadding) {
        // Get the visible area of the activity, excluding the soft keyboard.
        View activityRoot = getActivity().getWindow().getDecorView().getRootView();
        Rect visibleFrame = new Rect();
        activityRoot.getWindowVisibleDisplayFrame(visibleFrame);

        // Find the bottom of the text field, where the dropdown list is attached.
        int[] textViewLocation = new int[2];
        textView.getLocationOnScreen(textViewLocation);
        int textViewTop = textViewLocation[1];
        int textViewBottom = textViewTop + textView.getHeight();

        // Limit the height of the autocomplete dropdown list to stay within the
        // visible area of the activity; otherwise, the list will extend to the
        // bottom of the screen, where it is covered up by the soft keyboard.
        textView.setDropDownHeight(visibleFrame.bottom - textViewBottom);

        // Expand the dropdown window left and right to accommodate left/right
        // padding inside dropdown list items, so that the text in the list items
        // is horizontally aligned with the text in the input field.
        textView.setDropDownHorizontalOffset(-itemHorizontalPadding);
        textView.setDropDownWidth(v.drug.getWidth() + itemHorizontalPadding * 2);
    }

    private static Map<Integer, List<String>> getRoutesByCategoryId() {
        Map<Integer, List<String>> map = new HashMap<>();
        map.put(R.id.oral_category, Lists.newArrayList("PO"));
        map.put(R.id.injectable_category, Lists.newArrayList("IV", "SC", "IM"));
        return map;
    }

    /** An adapter that provides completions for the AutocompleteAdapter. */
    class DrugCompletionAdapter implements CompletionAdapter<Drug> {
        private Map<String, String> targetsByDrugCode = new HashMap<>();
        private Category activeCategory = Category.UNSPECIFIED;

        public DrugCompletionAdapter(CatalogIndex index) {
            for (Category category : index.getCategories()) {
                for (Drug drug : category.drugs) {
                    targetsByDrugCode.put(drug.code, constructTarget(drug));
                }
            }
        }

        public void setCategory(Category category) {
            activeCategory = category;
        }

        public List<Drug> suggestCompletions(CharSequence constraint) {
            List<Drug> results = new ArrayList<>();
            String[] searchKeys = getSearchKeys(constraint);
            for (Drug drug : activeCategory.drugs) {
                if (isCompletionFor(searchKeys, drug)) {
                    results.add(drug);
                }
            }
            return results;
        }

        public void showInView(View view, Drug drug) {
            Utils.setText(view, R.id.label, App.localize(drug.name));
            String result = "";
            for (Intl caption : drug.captions) {
                if (!result.isEmpty()) result += ", ";
                result += App.localize(caption);
            }
            Utils.setText(view, R.id.caption, result);
        }

        public @NonNull String getCompletedText(Drug drug) {
            return App.localize(drug.name);
        }

        private String[] getSearchKeys(CharSequence constraint) {
            String[] searchKeys = normalize(constraint).trim().split(" ");
            for (int i = 0; i < searchKeys.length; i++) {
                searchKeys[i] = " " + searchKeys[i];
            }
            return searchKeys;
        }

        private boolean isCompletionFor(String[] searchKeys, Drug drug) {
            String target = targetsByDrugCode.get(drug.code);

            // Look for words matching the words in the input as prefixes.
            int score = 0;
            for (String searchKey : searchKeys) {
                score += target.contains(searchKey) ? 1 : 0;
            }
            if (score == searchKeys.length) return true;

            if (searchKeys.length == 1) {
                // Look for words matching the letters in the input as initials.
                score = 0;
                char[] initials = searchKeys[0].trim().toCharArray();
                for (char ch : initials) {
                    score += target.contains(" " + ch) ? 1 : 0;
                }
                if (score == initials.length) return true;
            }
            return false;
        }

        private String constructTarget(Drug drug) {
            String target = "";
            for (String localizedName : drug.name.getAll()) {
                target += " " + localizedName.toLowerCase();
            }
            for (Intl alias : drug.aliases) {
                for (String localizedAlias : alias.getAll()) {
                    target += " " + localizedAlias;
                }
            }
            String collapsed = target.replaceAll("[^a-z0-9]+", "");
            return normalize(" " + target + " " + collapsed + " ");
        }

        private String normalize(CharSequence name) {
            return name.toString().toLowerCase().replaceAll("[^a-z0-9]+", " ");
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.dialogs;

import android.app.AlertDialog;
import android.os.Bundle;
import android.support.v4.app.DialogFragment;
import android.text.InputFilter;
import android.widget.EditText;
import android.widget.RadioButton;
import android.widget.RadioGroup;

import com.google.common.collect.ImmutableList;

import org.joda.time.DateTime;
import org.joda.time.LocalDate;
import org.joda.time.Period;
import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.client.json.Datatype;
import org.projectbuendia.client.json.JsonObservation;
import org.projectbuendia.client.json.JsonPatient;
import org.projectbuendia.models.ConceptUuids;
import org.projectbuendia.models.Obs;
import org.projectbuendia.models.Patient;
import org.projectbuendia.models.Sex;
import org.projectbuendia.client.ui.BigToast;
import org.projectbuendia.client.ui.EditTextWatcher;
import org.projectbuendia.client.utils.Utils;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/** A {@link DialogFragment} for adding or editing a patient. */
public class PatientDialogFragment extends BaseDialogFragment<PatientDialogFragment, Patient> {
    private static final Pattern ID_PATTERN = Pattern.compile("([a-zA-Z]+)/?([0-9]+)*");

    class Views {
        EditText idPrefix = u.findView(R.id.patient_id_prefix);
        EditText id = u.findView(R.id.patient_id);
        EditText givenName = u.findView(R.id.patient_given_name);
        EditText familyName = u.findView(R.id.patient_family_name);
        EditText ageYears = u.findView(R.id.patient_age_years);
        EditText ageMonths = u.findView(R.id.patient_age_months);
        RadioGroup sexRadioGroup = u.findView(R.id.patient_sex);
        RadioButton sexFemale = u.findView(R.id.patient_sex_female);
        RadioButton sexMale = u.findView(R.id.patient_sex_male);
        RadioButton sexOther = u.findView(R.id.patient_sex_other);
    }

    private Views v;
    private Patient patient;
    private ToggleRadioGroup<Sex> sexToggleGroup;
    private boolean ageChanged;

    public static PatientDialogFragment create(Patient patient) {
        return new PatientDialogFragment().withArgs(patient);
    }

    @Override public AlertDialog onCreateDialog(Bundle state) {
        return createAlertDialog(R.layout.patient_dialog_fragment);
    }

    @Override public void onOpen() {
        v = new Views();
        patient = args;

        dialog.setTitle(patient == null ?
            R.string.title_activity_patient_add : R.string.action_edit_patient);
        v.sexFemale.setTag(Sex.FEMALE);
        v.sexMale.setTag(Sex.MALE);
        v.sexOther.setTag(Sex.OTHER);
        sexToggleGroup = new ToggleRadioGroup<>(v.sexRadioGroup);

        v.idPrefix.setFilters(new InputFilter[] {new InputFilter.AllCaps()});
        v.familyName.setFilters(new InputFilter[] {new InputFilter.AllCaps()});

        if (patient == null) {
            v.idPrefix.setText(App.getSettings().getLastIdPrefix());
        }

        if (patient != null) {
            String idPrefix = "";
            String id = Utils.toNonnull(patient.id);
            Matcher matcher = ID_PATTERN.matcher(id);
            if (matcher.matches()) {
                idPrefix = matcher.group(1);
                id = matcher.group(2);
            }
            if (idPrefix.isEmpty() && id.isEmpty()) {
                idPrefix = App.getSettings().getLastIdPrefix();
            }
            v.idPrefix.setText(idPrefix);
            v.id.setText(id);
            v.givenName.setText(Utils.toNonnull(patient.givenName));
            v.familyName.setText(Utils.toNonnull(patient.familyName));
            if (patient.birthdate != null) {
                Period age = new Period(patient.birthdate, LocalDate.now());
                v.ageYears.setText(String.valueOf(age.getYears()));
                v.ageMonths.setText(String.valueOf(age.getMonths()));
            }

            sexToggleGroup.setSelection(patient.sex);
        }

        new EditTextWatcher(v.ageYears, v.ageMonths).onChange(() -> ageChanged = true);
        // TODO(ping): Figure out why the keyboard doesn't appear and focus
        // isn't placed on the first field.
        // TODO(ping): Make the name fields auto-capitalize the first letter.
        Utils.showKeyboard(dialog.getWindow());
        Utils.focusFirstEmptyField(v.idPrefix, v.id, v.givenName,
            v.familyName, v.ageYears, v.ageMonths);
    }

    @Override public void onSubmit() {
        String idPrefix = v.idPrefix.getText().toString().trim();
        String id = Utils.toNonemptyOrNull(v.id.getText().toString().trim());
        String givenName = Utils.toNonemptyOrNull(v.givenName.getText().toString().trim());
        String familyName = Utils.toNonemptyOrNull(v.familyName.getText().toString().trim());
        Sex sex = sexToggleGroup.getSelection();
        String ageYears = v.ageYears.getText().toString().trim();
        String ageMonths = v.ageMonths.getText().toString().trim();
        LocalDate birthdate = patient != null ? patient.birthdate : null;
        boolean valid = true;

        if (id == null) {
            setError(v.id, R.string.patient_validation_missing_id);
            valid = false;
        }
        // Recalculate the birthdate only when the age fields have been edited;
        // otherwise, simply opening and submitting the dialog would shift the
        // birthdate every time to make the age a whole number of months.
        if (ageChanged) {
            if (ageYears.isEmpty() && ageMonths.isEmpty()) {
                // The user can clear the birthdate information by clearing the fields.
                birthdate = null;
            } else {
                int years = Integer.parseInt("0" + ageYears);
                int months = Integer.parseInt("0" + ageMonths);
                birthdate = LocalDate.now().minusYears(years).minusMonths(months);

                // Pick a birthdate just one day earlier than necessary to put the age
                // at the desired number of years and months, so that the same age
                // appears on all tablets regardless of timezone.  Showing different
                // ages in different timezones isn't truly avoidable because ages are
                // stored as local dates (not timestamps), but the extra day will at
                // least prevent some initial confusion.  After all, the entered age
                // is only precise to the month; the confusion comes from emphasizing
                // precision that isn't there.
                birthdate = birthdate.minusDays(1);
            }
        }
        if (birthdate != null && new Period(
            birthdate, LocalDate.now().plusDays(1)).getYears() >= 120) {
            setError(v.ageYears, R.string.patient_validation_age_limit);
            valid = false;
        }
        if (!valid) return;

        if (!idPrefix.isEmpty()) {
            id = idPrefix + "/" + id;
            App.getSettings().setLastIdPrefix(idPrefix);
        }

        Utils.logUserAction("patient_submitted",
            "id", id,
            "given_name", givenName,
            "family_name", familyName,
            "age_years", ageYears,
            "age_months", ageMonths,
            "sex", "" + sex);
        dialog.dismiss();

        JsonPatient newPatient = new JsonPatient();
        newPatient.id = id;
        newPatient.given_name = givenName;
        newPatient.family_name = familyName;
        newPatient.birthdate = birthdate;
        newPatient.sex = sex;

        if (patient == null) {
            BigToast.show(R.string.adding_new_patient_please_wait);
            DateTime now = DateTime.now(); // not actually used by PatientDelta
            newPatient.observations = ImmutableList.of(
                new JsonObservation(new Obs(
                    null, null, null, Utils.getProviderUuid(),
                    ConceptUuids.ADMISSION_DATETIME_UUID, Datatype.DATETIME,
                    now, null, "" + DateTime.now().getMillis(), ""
                )),
                new JsonObservation(new Obs(
                    null, null, null, Utils.getProviderUuid(),
                    ConceptUuids.PLACEMENT_UUID, Datatype.TEXT,
                    now, null, App.getModel().getDefaultLocation().uuid, ""
                ))
            );
            App.getModel().addPatient(App.getCrudEventBus(), newPatient);
        } else {
            BigToast.brief(R.string.updating_patient_please_wait);
            newPatient.uuid = patient.uuid;
            App.getModel().updatePatient(App.getCrudEventBus(), newPatient);
        }
        // TODO: While the network request is in progress, show a spinner and/or keep the
        // dialog open but greyed out -- keep the UI blocked to make it clear that there is a
        // modal operation going on, while providing a way for the user to abort the operation.
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.login;

import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.GridView;

import org.projectbuendia.client.R;
import org.projectbuendia.client.json.JsonUser;
import org.projectbuendia.client.ui.ProgressFragment;
import org.projectbuendia.client.ui.ReadyState;
import org.projectbuendia.client.utils.Logger;

import java.util.List;

import butterknife.ButterKnife;
import butterknife.InjectView;
import butterknife.OnItemClick;

/** Fragment for {@link LoginActivity}. */
public class LoginFragment extends ProgressFragment {
    private static final Logger LOG = Logger.create();

    private FragmentUi mFragmentUi = new FragmentUi();
    private UserListAdapter mUserListAdapter;
    @InjectView(R.id.users) GridView mUserGrid;

    @Override public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentLayout(R.layout.login_fragment);
        mUserListAdapter = new UserListAdapter(getActivity());
    }

    @Override public View onCreateView(
        LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View v = super.onCreateView(inflater, container, savedInstanceState);
        ButterKnife.inject(this, v);
        mUserGrid.setAdapter(mUserListAdapter);
        return v;
    }

    /** Returns the {@link FragmentUi} for interfacing with the {@link LoginController}. */
    public FragmentUi getFragmentUi() {
        return mFragmentUi;
    }

    @OnItemClick(R.id.users) void onUsersItemClick(int position) {
        LoginController controller =
            ((LoginActivity) getActivity()).getUserLoginController();
        if (controller != null) {
            controller.onUserSelected(mUserListAdapter.getItem(position));
        } else {
            LOG.e("No LoginController available. This should never happen.");
        }
    }

    private class FragmentUi implements LoginController.FragmentUi {

        @Override public void showSpinner(boolean show) {
            setReadyState(show ? ReadyState.LOADING : ReadyState.READY);
        }

        @Override public void showUsers(List<JsonUser> users) {
            mUserListAdapter.setNotifyOnChange(false);
            mUserListAdapter.clear();
            mUserListAdapter.addAll(users);
            mUserListAdapter.notifyDataSetChanged();
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.login;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.TextView;

import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.client.json.JsonUser;

import butterknife.ButterKnife;
import butterknife.InjectView;

/** {@link ArrayAdapter} for a grid of users. */
final class UserListAdapter extends ArrayAdapter<JsonUser> {

    public UserListAdapter(Context context) {
        super(context, R.layout.login_grid_user_item);
    }

    @Override public View getView(int position, View view, ViewGroup parent) {
        ItemViewHolder holder;
        if (view != null) {
            holder = (ItemViewHolder) view.getTag();
        } else {
            view = LayoutInflater.from(getContext())
                .inflate(R.layout.login_grid_user_item, parent, false);
            holder = new ItemViewHolder(view);
            view.setTag(holder);
        }

        JsonUser user = getItem(position);
        holder.initials.setBackgroundColor(App.getUserManager().getColor(user));
        holder.initials.setText(user.getLocalizedInitials());
        holder.fullName.setText(user.getLocalizedName());
        return view;
    }

    static final class ItemViewHolder {
        @InjectView(R.id.user_initials) public TextView initials;
        @InjectView(R.id.user_name) public TextView fullName;

        public ItemViewHolder(View view) {
            ButterKnife.inject(this, view);
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.login;

import android.app.AlertDialog;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;

import com.joanzapata.iconify.fonts.FontAwesomeIcons;

import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.client.diagnostics.Troubleshooter;
import org.projectbuendia.client.sync.BuendiaSyncEngine;
import org.projectbuendia.client.ui.BaseActivity;
import org.projectbuendia.client.ui.BigToast;
import org.projectbuendia.client.ui.SettingsActivity;
import org.projectbuendia.client.ui.dialogs.NewUserDialogFragment;
import org.projectbuendia.client.ui.lists.LocationListActivity;
import org.projectbuendia.client.utils.EventBusWrapper;
import org.projectbuendia.client.utils.Utils;

import javax.inject.Inject;

import de.greenrobot.event.EventBus;

/**
 * {@link BaseActivity} where users log in by selecting their name from a list.
 * This is the starting activity for the app.
 */
public class LoginActivity extends BaseActivity {
    private LoginController mController;
    private AlertDialog mSyncFailedDialog;

    @Inject Troubleshooter mTroubleshooter;

    @Override public boolean onCreateImpl(Bundle state) {
        if (!super.onCreateImpl(state)) return false;

        setTitle(R.string.app_name);
        getActionBar().setDisplayUseLogoEnabled(false);
        getActionBar().setIcon(R.drawable.ic_launcher);  // don't show the back arrow
        getActionBar().setDisplayHomeAsUpEnabled(false);  // don't behave like a back button

        // This is the starting activity for the app, so show the app name and version.
        setTitle(getString(R.string.app_name) + " " + getString(R.string.app_version));

        setContentView(R.layout.activity_user_login);
        LoginFragment fragment = (LoginFragment)
            getSupportFragmentManager().findFragmentById(R.id.fragment_user_login);
        mController = new LoginController(
            App.getUserManager(),
            new EventBusWrapper(EventBus.getDefault()),
            mTroubleshooter,
            new Ui(),
            fragment.getFragmentUi(),
            settings);

        // TODO/cleanup: Consider factoring out some common code between here and tent selection.
        mSyncFailedDialog = new AlertDialog.Builder(this)
            .setIcon(android.R.drawable.ic_dialog_alert)
            .setTitle(getString(R.string.sync_failed_dialog_title))
            .setMessage(R.string.user_sync_failed_dialog_message)
            .setNegativeButton(R.string.sync_failed_settings,
                (dialog, which) -> SettingsActivity.start(LoginActivity.this))
            .setPositiveButton(R.string.sync_failed_retry, (dialog, which) -> mController.onSyncRetry())
            .create();
        return true;
    }

    /**
     * Returns the {@link LoginController} used by this activity. After onCreate, this should
     * never be null.
     */
    public LoginController getUserLoginController() {
        return mController;
    }

    @Override public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.login, menu);

        menu.findItem(R.id.action_new_user).setOnMenuItemClickListener(
            item -> {
                mController.onAddUserPressed();
                return true;
            }
        );

        MenuItem settingsItem = menu.findItem(R.id.settings);
        setMenuBarIcon(settingsItem, FontAwesomeIcons.fa_cog);
        settingsItem.setOnMenuItemClickListener(
            item -> {
                mController.onSettingsPressed();
                return true;
            }
        );

        return true;
    }

    @Override protected void onResume() {
        super.onResume();
        mController.init();
        App.getSyncManager().setPeriodicSync(10, BuendiaSyncEngine.Phase.USERS);
    }

    @Override protected void onPause() {
        App.getSyncManager().setPeriodicSync(0, BuendiaSyncEngine.Phase.USERS);
        mController.suspend();
        super.onPause();
    }

    private final class Ui implements LoginController.Ui {
        @Override public void showAddNewUserDialog() {
            openDialog(NewUserDialogFragment.create(mController.getDialogUi()));
        }

        @Override public void showSettings() {
            SettingsActivity.start(LoginActivity.this);
        }

        @Override public void showErrorToast(int stringResourceId) {
            BigToast.show(stringResourceId);
        }

        @Override public void showSyncFailedDialog(boolean show) {
            Utils.showDialogIf(mSyncFailedDialog, show);
        }

        @Override public void showTentSelectionScreen() {
            LocationListActivity.start(LoginActivity.this);
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.ui.login;

import com.google.common.collect.Ordering;

import org.projectbuendia.client.AppSettings;
import org.projectbuendia.client.R;
import org.projectbuendia.client.diagnostics.Troubleshooter;
import org.projectbuendia.client.events.diagnostics.TroubleshootingActionsChangedEvent;
import org.projectbuendia.client.events.user.KnownUsersLoadFailedEvent;
import org.projectbuendia.client.events.user.KnownUsersLoadedEvent;
import org.projectbuendia.client.events.user.UserAddFailedEvent;
import org.projectbuendia.client.events.user.UserAddedEvent;
import org.projectbuendia.client.json.JsonUser;
import org.projectbuendia.client.ui.dialogs.NewUserDialogFragment;
import org.projectbuendia.client.user.UserManager;
import org.projectbuendia.client.utils.EventBusRegistrationInterface;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

/** Controller for {@link LoginActivity}. */
public final class LoginController {

    private static final Logger LOG = Logger.create();
    private final EventBusRegistrationInterface mEventBus;
    private final Ui mUi;
    private final FragmentUi mFragmentUi;
    private final DialogActivityUi mDialogUi = new DialogActivityUi();
    private final UserManager mUserManager;
    private final List<JsonUser> mUsersSortedByName = new ArrayList<>();
    private final BusEventSubscriber mSubscriber = new BusEventSubscriber();
    private final Troubleshooter mTroubleshooter;
    private final AppSettings mSettings;
    private static boolean sSkippedLogin;

    public interface Ui {

        void showAddNewUserDialog();

        void showSettings();

        void showErrorToast(int stringResourceId);

        void showSyncFailedDialog(boolean show);

        void showTentSelectionScreen();
    }

    public interface FragmentUi {

        void showSpinner(boolean show);

        void showUsers(List<JsonUser> users);
    }

    /**
     * Instantiates a {@link LoginController}.
     * @param userManager    a {@link UserManager} from which users will be fetched
     * @param eventBus       an {@link EventBusRegistrationInterface} for listening to user fetch and
     *                       modification events
     * @param troubleshooter a {@link Troubleshooter} for monitoring server health; if the server
     *                       becomes available and the controller has no data available, the
     *                       controller will automatically retry fetching users
     * @param ui             a {@link Ui} for handling activity changes
     * @param fragmentUi     a {@link FragmentUi} for displaying users
     */
    public LoginController(
        UserManager userManager,
        EventBusRegistrationInterface eventBus,
        Troubleshooter troubleshooter,
        Ui ui,
        FragmentUi fragmentUi,
        AppSettings settings) {
        mUserManager = userManager;
        mEventBus = eventBus;
        mTroubleshooter = troubleshooter;
        mUi = ui;
        mFragmentUi = fragmentUi;
        mSettings = settings;
    }

    /**
     * Requests any necessary resources. Note that some resources may be fetched asynchronously
     * after this function returns.
     */
    public void init() {
        mEventBus.register(mSubscriber);
        mFragmentUi.showSpinner(true);
        mUserManager.loadKnownUsers();
    }

    /** Attempts to reload users. */
    public void onSyncRetry() {
        mFragmentUi.showSpinner(true);
        mUserManager.loadKnownUsers();
    }

    public void suspend() {
        mEventBus.unregister(mSubscriber);
    }

    /** Call when the user presses the 'add user' button. */
    public void onAddUserPressed() {
        Utils.logEvent("add_user_button_pressed");
        mUi.showAddNewUserDialog();
    }

    /** Call when the user presses the settings button. */
    public void onSettingsPressed() {
        Utils.logEvent("settings_button_pressed");
        mUi.showSettings();
    }

    /** Call when the user taps to select a user. */
    public void onUserSelected(JsonUser user) {
        mUserManager.setActiveUser(user);
        Utils.logUserAction("logged_in");
        mUi.showTentSelectionScreen();
    }

    public NewUserDialogFragment.ActivityUi getDialogUi() {
        return mDialogUi;
    }

    public final class DialogActivityUi implements NewUserDialogFragment.ActivityUi {

        @Override public void showSpinner(boolean show) {
            mFragmentUi.showSpinner(show);
        }
    }

    /** Converts a {@link UserAddFailedEvent} to an error string resource id. */
    private static int errorToStringId(UserAddFailedEvent event) {
        switch (event.reason) {
            case UserAddFailedEvent.REASON_UNKNOWN:
                return R.string.add_user_unknown_error;
            case UserAddFailedEvent.REASON_INVALID_USER:
                return R.string.add_user_invalid_user;
            case UserAddFailedEvent.REASON_USER_EXISTS_LOCALLY:
                return R.string.add_user_user_exists_locally;
            case UserAddFailedEvent.REASON_USER_EXISTS_ON_SERVER:
                return R.string.add_user_user_exists_on_server;
            case UserAddFailedEvent.REASON_CONNECTION_ERROR:
                return R.string.add_user_connection_error;
            default:
                return R.string.add_user_unknown_error;
        }
    }

    /**
     * Given a sorted list, inserts a new element in the correct position to maintain the sorted
     * order.
     */
    private static <T> void insertIntoSortedList(
        List<T> list, Comparator<T> comparator, T newItem) {
        int index;
        for (index = 0; index < list.size(); index++) {
            if (comparator.compare(list.get(index), newItem) > 0) break;
        }
        list.add(index, newItem);
    }

    @SuppressWarnings("unused") // Called by reflection from event bus.
    private final class BusEventSubscriber {
        /** Restart user fetch if we have no users and the Buendia API just became available. */
        public void onEventMainThread(TroubleshootingActionsChangedEvent event) {
            if (mUsersSortedByName.isEmpty() && mTroubleshooter.isServerHealthy()) {
                LOG.d("Buendia API is available and users are not, retrying sync.");
                onSyncRetry();
            }
        }

        /** Updates the UI when the list of users is loaded. */
        public void onEventMainThread(KnownUsersLoadedEvent event) {
            LOG.d("Loaded list of " + event.knownUsers.size() + " users");
            mUsersSortedByName.clear();
            mUsersSortedByName
                .addAll(Ordering.from(JsonUser.COMPARATOR_BY_NAME).sortedCopy(event.knownUsers));
            mFragmentUi.showUsers(mUsersSortedByName);
            mFragmentUi.showSpinner(false);
            mUi.showSyncFailedDialog(false);

            // To facilitate chart development, there's a developer setting that
            // causes the app to go straight to a patient chart on startup.
            if (!sSkippedLogin && mSettings.shouldSkipToPatientChart() && event.knownUsers.size() > 0) {
                sSkippedLogin = true;
                onUserSelected(event.knownUsers.toArray(new JsonUser[0])[0]);
            }
        }

        public void onEventMainThread(KnownUsersLoadFailedEvent event) {
            LOG.e("Failed to load list of users");
            mUi.showSyncFailedDialog(true);
        }

        public void onEventMainThread(UserAddedEvent event) {
            mUi.showSyncFailedDialog(false);  // Just in case.
            LOG.d("User added");
            insertIntoSortedList(mUsersSortedByName, JsonUser.COMPARATOR_BY_NAME, event.addedUser);
            mFragmentUi.showUsers(mUsersSortedByName);
            mFragmentUi.showSpinner(false);
        }

        public void onEventMainThread(UserAddFailedEvent event) {
            LOG.d("Failed to add user");
            mUi.showErrorToast(errorToStringId(event));
            mFragmentUi.showSpinner(false);
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.net;

import com.android.volley.AuthFailureError;
import com.android.volley.NetworkResponse;
import com.android.volley.NoConnectionError;
import com.android.volley.Response.ErrorListener;
import com.android.volley.TimeoutError;
import com.android.volley.VolleyError;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonParser;

import org.projectbuendia.client.App;
import org.projectbuendia.client.diagnostics.HealthIssue;
import org.projectbuendia.client.ui.BigToast;
import org.projectbuendia.client.utils.Logger;

public class OpenMrsErrorListener implements ErrorListener {

    private static final Logger LOG = Logger.create();

    /** Default error-handling behaviour; can be overridden to suit the situation. */
    @Override public void onErrorResponse(VolleyError error) {
        displayVolleyError(error);
    }

    /** Displays a VolleyError as a toast, if it can be made meaningful to the user. */
    public void displayVolleyError(VolleyError error) {
        // TODO(ping): Hand off to the HealthMonitor or use the snackbar.
        LOG.w(error.getClass().getSimpleName() + ": " + error.getMessage());
        if (error instanceof NoConnectionError &&
            App.getTroubleshooter() != null &&
            App.getTroubleshooter().hasIssue(HealthIssue.SERVER_HOST_UNREACHABLE)) {
            return;
        }
        BigToast.show(formatErrorMessage(error));
    }

    /** Parses a JSON-formatted error response from the OpenMRS server. **/
    public static String formatErrorMessage(VolleyError volleyError) {
        if (volleyError instanceof NoConnectionError) {
            return "Failed to connect to the server.";
        }
        if (volleyError instanceof TimeoutError) {
            return "Server did not respond.";
        }
        if (volleyError == null || volleyError.networkResponse == null) {
            return "Sorry, there was a problem communicating with the server.";
        }
        NetworkResponse response = volleyError.networkResponse;
        byte[] data = response.data;
        String problem = "status code " + response.statusCode;
        if (data != null) {
            String json = new String(data);
            LOG.i(json);
            try {
                JsonObject result = new JsonParser().parse(json).getAsJsonObject();
                JsonArray errors = result.getAsJsonArray("errors");
                if (errors != null && errors.size() > 0) {
                    JsonObject error = (JsonObject) errors.get(0);
                    JsonElement message = error.get("message");
                    if (message != null && message.isJsonPrimitive()) {
                        return message.getAsString();
                    }
                    JsonArray frames = error.getAsJsonArray("frames");
                    JsonElement frame = frames.get(0);
                    return frame.getAsString();
                }
            } catch (JsonParseException | IllegalStateException | UnsupportedOperationException e) {
                LOG.w("Problem parsing error message: " + e.getMessage());
            }
        }
        if (volleyError instanceof AuthFailureError) {
            return "Operation was not permitted by the server (" + problem + ").";
        }
        return "Sorry, there was a problem communicating with the server (" + problem + ").";
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.net;

import android.database.Cursor;
import android.provider.BaseColumns;
import android.util.Log;

import java.io.File;

/** A wrapper around basic ODK database operations. */
public class OdkDatabase {
    private static final String TAG = OdkDatabase.class.getSimpleName();

    /**
     * Retrieves the form id from the ODK database referred to by the given File handle.
     * @param path the form File
     * @return the corresponding form id from the ODK database, or -1 if no match was found.
     */
    public static long getFormIdForPath(File path) {
        long formId = -1;
        Log.d(TAG, "Looking up formId with path = " + path);
        try (Cursor cursor = OdkXformSyncTask.getCursorForFormFile(
            path, new String[] {BaseColumns._ID}
        )) {
            //if any form was found by the given file.
            if (cursor.getCount() >= 1) {
                // There should only ever be one form per UUID. But if something goes wrong, we want
                // the app to keep working. Assume the latest one is correct.
                if (cursor.getCount() > 1) {
                    Log.e(TAG, "More than one form in database with the same id. This indicates an "
                        + "error occurred on insert (probably a race condition) and should be "
                        + "fixed. However, the app should still function correctly");
                }
                // getCursorForFormFile returns the most recent element first, so we can just use
                // the first one.
                cursor.moveToNext();
                formId = cursor.getLong(0);
                Log.d(TAG, "Found formId = " + formId);
            }
        }
        return formId;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.net;

import android.content.ContentResolver;
import android.content.ContentValues;
import android.database.Cursor;
import android.database.SQLException;
import android.os.AsyncTask;
import android.support.annotation.Nullable;

import com.google.common.base.Preconditions;

import org.odk.collect.android.application.Collect;
import org.odk.collect.android.provider.FormsProviderAPI;
import org.odk.collect.android.tasks.DiskSyncTask;
import org.projectbuendia.client.App;
import org.projectbuendia.client.events.FetchXformFailedEvent;
import org.projectbuendia.client.events.FetchXformSucceededEvent;
import org.projectbuendia.client.utils.Logger;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

import de.greenrobot.event.EventBus;

/**
 * Synchronizes 1 or more OpenMRS provided forms into the ODK database storage. Very like
 * {@link org.odk.collect.android.tasks.DiskSyncTask} or
 * {@link org.odk.collect.android.tasks.DownloadFormsTask}
 * <p/>
 * <p>Takes the UUID and, if the form doesn't exist in ODK storage, fetches it from OpenMRS, then
 * creates {$uuid}.xml in storage. Finally, the form is inserted into ODK's local metadata DB.
 */
public class OdkXformSyncTask extends AsyncTask<OpenMrsXformIndexEntry, Void, Void> {

    private static final Logger LOG = Logger.create();

    @Nullable
    private final FormWrittenListener mFormWrittenListener;

    public static interface FormWrittenListener {
        public void formWritten(File path, String uuid);
    }

    public OdkXformSyncTask(@Nullable FormWrittenListener formWrittenListener) {
        this.mFormWrittenListener = formWrittenListener;
    }

    @Override protected Void doInBackground(OpenMrsXformIndexEntry... formInfos) {
        for (final OpenMrsXformIndexEntry formInfo : formInfos) {
            final File proposedPath = formInfo.getPathForForm();
            LOG.i("Looking up local entry for %s (%s)", formInfo.uuid, formInfo.name);

            // Check if the uuid already exists in the database.
            boolean isNew;
            final boolean usersHaveChanged = App.getUserManager().isDirty();
            try (Cursor cursor = getCursorForFormFile(proposedPath, new String[] {
                FormsProviderAPI.FormsColumns.DATE
            })) {
                boolean isInDatabase = cursor.getCount() > 0;
                if (isInDatabase) {
                    if (cursor.getCount() != 1) {
                        LOG.e("Saw " + cursor.getCount() + " rows for " + proposedPath.getPath());
                        // In a fail-fast environment we would crash here, but we will keep going
                        // to lead the code more robust to errors in the field.
                    }
                    Preconditions.checkArgument(cursor.getColumnCount() == 1);
                    cursor.moveToNext();
                    long existingTimestamp = cursor.getLong(0);
                    isNew = (existingTimestamp < formInfo.dateChanged);

                    if (isNew || usersHaveChanged) {
                        LOG.i("Form " + formInfo.uuid + " requires an update."
                            + " (Local creation date: " + existingTimestamp
                            + ", (Latest version: " + formInfo.dateChanged + ")"
                            + ", (Invalidated by UserManager: " + usersHaveChanged + ")");
                    }
                } else {
                    LOG.i("Form %s not found in database.", formInfo.uuid);
                    isNew = true;
                }
            }

            if (!isNew && !usersHaveChanged) {
                LOG.i("Form %s is up to date and users have not changed.", formInfo.uuid);
                if (mFormWrittenListener != null) {
                    mFormWrittenListener.formWritten(proposedPath, formInfo.uuid);
                }
                EventBus.getDefault().post(new FetchXformSucceededEvent());
                continue;
            }

            // Doesn't exist, so insert it. Fetch the file from OpenMRS
            fetchAndAddXFormToDb(formInfo.uuid, proposedPath);
        }
        return null;
    }

    /**
     * Fetches the requested xform from the server and adds it into db.
     * @param uuid      UUID of the form to be fetched
     * @param proposedPath          a {@link File} containing the form fields that should be
     *                        added
     */
    public void fetchAndAddXFormToDb(final String uuid, final File proposedPath) {
        LOG.i("Fetching form %s from server", uuid);

        OpenMrsXformsConnection openMrsXformsConnection =
            new OpenMrsXformsConnection(App.getConnectionDetails());
        openMrsXformsConnection.getXform(uuid, response -> {
            if (App.getSyncManager().getNewSyncsSuppressed()) {
                LOG.w("Skipping form save: New syncs are currently suppressed.");
                return;
            }
            LOG.i("Saving form %s to local filesystem and database", uuid);
            new AddFormToDbAsyncTask(mFormWrittenListener, uuid)
                .execute(new FormToWrite(response, proposedPath));
        }, error -> {
            LOG.e(error, "Failed to fetch form %s from server", uuid);
            EventBus.getDefault().post(new FetchXformFailedEvent(
                FetchXformFailedEvent.Reason.SERVER_FAILED_TO_FETCH, error));
        });
    }

    /**
     * Get a Cursor for the form from the filename. If there is more than one they are ordered
     * descending by id, so most recent is first.
     * @param proposedPath the path for the forms file
     * @param projection   a projection of fields to get
     * @return the Cursor pointing to ideally one form.
     */
    public static Cursor getCursorForFormFile(File proposedPath, String[] projection) {
        String[] selectionArgs = {
            proposedPath.getAbsolutePath()
        };
        String selection = FormsProviderAPI.FormsColumns.FORM_FILE_PATH + "=?";
        return Collect.getInstance()
            .getApplication()
            .getContentResolver()
            .query(FormsProviderAPI.FormsColumns.CONTENT_URI, projection, selection,
                selectionArgs, FormsProviderAPI.FormsColumns._ID + " DESC");
    }

    private static class FormToWrite {
        public final String form;
        public final File path;

        private FormToWrite(String form, File path) {
            this.form = Preconditions.checkNotNull(form);
            this.path = Preconditions.checkNotNull(path);
        }
    }

    private static class AddFormToDbAsyncTask extends AsyncTask<FormToWrite, Void, File> {

        private final FormWrittenListener mFormWrittenListener;
        private final String mUuid;

        private AddFormToDbAsyncTask(
            @Nullable FormWrittenListener formWrittenListener,
            String uuid) {
            mFormWrittenListener = formWrittenListener;
            mUuid = uuid;
        }

        @Override protected File doInBackground(FormToWrite[] params) {
            Preconditions.checkArgument(params.length != 0);

            String form = params[0].form;
            File proposedPath = params[0].path;
            // Write file into OpenMRS forms directory.
            if (!writeStringToFile(form, proposedPath)) {
                // we failed to load it, just skip for now
                return null;
            }

            // do the equivalent of DownloadFormsTask.findExistingOrCreateNewUri() or
            // DiskSyncTask step 4 to insert the file into the database
            ContentValues cv;
            try {
                cv = DiskSyncTask.buildContentValues(proposedPath);
            } catch (IllegalArgumentException e) {
                // yuck, but this is what it throws on a bad parse
                LOG.e(e, "Failed to parse: " + proposedPath);
                return null;
            }

            // insert into content provider
            try {
                ContentResolver contentResolver =
                    Collect.getInstance().getApplication().getContentResolver();
                // Always replace existing forms.
                cv.put(FormsProviderAPI.SQL_INSERT_OR_REPLACE, true);
                contentResolver.insert(FormsProviderAPI.FormsColumns.CONTENT_URI, cv);
            } catch (SQLException e) {
                LOG.i(e, "failed to insert fetched file");
            }
            return proposedPath;
        }

        @Override protected void onPostExecute(File path) {
            super.onPostExecute(path);
            if (mFormWrittenListener != null && path != null) {
                mFormWrittenListener.formWritten(path, mUuid);
            }
            EventBus.getDefault().post(new FetchXformSucceededEvent());

            App.getUserManager().setDirty(false);
        }

        private static boolean writeStringToFile(String response, File proposedPath) {
            //Create OKD dirs if necessary
            Collect.getInstance().createODKDirs();

            FileWriter writer = null;
            try {
                writer = new FileWriter(proposedPath);
                writer.write(response);
                return true;
            } catch (IOException e) {
                LOG.e(e, "failed to write downloaded xform to ODK forms directory");
                return false;
            } finally {
                if (writer != null) {
                    try {
                        writer.close();
                    } catch (IOException e) {
                        LOG.e(e, "failed to close writer into ODK directory");
                    }
                }
            }
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.net;

import com.google.common.base.Preconditions;

import org.joda.time.DateTime;
import org.odk.collect.android.application.Collect;
import org.projectbuendia.client.utils.Utils;

import java.io.File;

/**
 * A simple bean for encapsulating the idea of an Xform on the OpenMRS server.
 * Only includes index information that can be processed cheaply, not the full form.
 */
public class OpenMrsXformIndexEntry {

    /** The uuid of the form. */
    public final String uuid;

    /** The name of the form. */
    public final String name;

    /** Milliseconds since epoch when the form was last changed on the server. */
    public final long dateChanged;

    /**
     * Constructs an Xform index entry.
     * @param uuid        UUID of the xform
     * @param name        name of the xform
     * @param dateChanged milliseconds since epoch when the form was last changed on the server
     */
    public OpenMrsXformIndexEntry(String uuid, String name, long dateChanged) {
        this.uuid = Preconditions.checkNotNull(uuid);
        this.name = Preconditions.checkNotNull(name);
        this.dateChanged = dateChanged;
    }

    public String toString() {
        return Utils.format("<OpenMrsXformIndexEntry uuid=%s, name=%s, dateChanged=%s>",
            Utils.repr(uuid), Utils.repr(name), new DateTime(dateChanged));
    }

    /** Returns the unique file path in the ODK file system for storing this form. */
    public File getPathForForm() {
        return new File(Collect.getInstance().getFormsPath() + File.separator + uuid + ".xml");
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.net;

import android.util.Base64;

import org.projectbuendia.client.AppSettings;

import java.util.Map;

/** Provides the URL and credentials for connecting to OpenMRS. */
public class OpenMrsConnectionDetails {

    private final VolleySingleton mVolley;
    private final AppSettings mSettings;

    /**
     * Constructs an {@link OpenMrsConnectionDetails} object.
     * @param volley   the {@link VolleySingleton} for making requests
     * @param settings the application settings
     */
    public OpenMrsConnectionDetails(VolleySingleton volley, AppSettings settings) {
        mVolley = volley;
        mSettings = settings;
    }

    /** Gets the Volley instance to use for network connections. */
    public VolleySingleton getVolley() {
        return mVolley;
    }

    /** Gets the URL to the API served by the Buendia module in OpenMRS. */
    public String getBuendiaApiUrl() {
        // The default value is set by setDefaultValues, not specified here.
        return mSettings.getOpenmrsUrl("/ws/rest/buendia");
    }

    /**
     * Adds an authentication header to an existing map of HTTP headers.
     * @param params the header map to be modified
     * @return the modified header map, for method chaining
     */
    public Map<String, String> addAuthHeader(Map<String, String> params) {
        return addAuthHeader(getUser(), getPassword(), params);
    }

    /**
     * Adds an authentication header to an existing map of HTTP headers.
     * @param username the username
     * @param password the password
     * @param params   the header map to be modified
     * @return the modified header map, for method chaining
     */
    public static Map<String, String> addAuthHeader(
        String username, String password, Map<String, String> params) {
        String creds = String.format("%s:%s", username, password);
        String encoded = Base64.encodeToString(creds.getBytes(), Base64.DEFAULT);
        params.put("Authorization", "Basic " + encoded.trim());
        return params;
    }

    /** Gets the OpenMRS username to use. */
    public String getUser() {
        return mSettings.getOpenmrsUser();
    }

    /** Gets the OpenMRS password to use. */
    public String getPassword() {
        return mSettings.getOpenmrsPassword();
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.net;

import android.app.Application;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import org.projectbuendia.client.AppSettings;
import org.projectbuendia.client.json.Serializers;

import javax.inject.Singleton;

import dagger.Module;
import dagger.Provides;

/** A Dagger module that provides bindings for network-related classes. */
@Module(complete = false,
    library = true)
public class NetModule {

    @Provides
    @Singleton VolleySingleton provideVolleySingleton(Application app) {
        return VolleySingleton.getInstance(app);
    }

    @Provides
    @Singleton OpenMrsConnectionDetails provideOpenMrsConnectionDetails(
        VolleySingleton volley, AppSettings settings) {
        return new OpenMrsConnectionDetails(volley, settings);
    }

    @Provides
    @Singleton RequestConfigurator provideRequestConfigurator() {
        return new RequestConfigurator(10000 /*timeout*/, 2 /*retry attempts*/, 1 /*back-off*/);
    }

    @Provides
    @Singleton
    RequestFactory provideRequestFactory(RequestConfigurator configurator) {
        return new RequestFactory(configurator);
    }

    @Provides
    @Singleton Gson provideGson() {
        GsonBuilder builder = new GsonBuilder();
        Serializers.registerTo(builder);
        return builder.create();
    }

    @Provides
    @Singleton Server provideServer(
        OpenMrsConnectionDetails connectionDetails,
        RequestFactory requestFactory,
        Gson gson) {
        return new OpenMrsServer(connectionDetails, requestFactory, gson);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.net;

import android.database.Cursor;
import android.support.annotation.Nullable;

import com.android.volley.DefaultRetryPolicy;
import com.android.volley.Request;
import com.android.volley.Response;
import com.android.volley.VolleyError;
import com.google.common.base.Joiner;
import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;

import org.joda.time.DateTime;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.projectbuendia.client.App;
import org.projectbuendia.client.json.JsonEncounter;
import org.projectbuendia.client.json.JsonForm;
import org.projectbuendia.client.json.JsonLocation;
import org.projectbuendia.client.json.JsonNewUser;
import org.projectbuendia.client.json.JsonOrder;
import org.projectbuendia.client.json.JsonPatient;
import org.projectbuendia.client.json.JsonUser;
import org.projectbuendia.models.ConceptUuids;
import org.projectbuendia.models.Encounter;
import org.projectbuendia.models.Order;
import org.projectbuendia.client.providers.Contracts.Patients;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import static org.projectbuendia.client.utils.Utils.eq;

/** Implementation of {@link Server} that sends RPC's to OpenMRS. */
public class OpenMrsServer implements Server {
    private static final Logger LOG = Logger.create();
    public static final int TIMEOUT_SECONDS = 10;

    private final OpenMrsConnectionDetails mConnectionDetails;
    private final RequestFactory mRequestFactory;
    private final Gson mGson;

    /**
     * Constructs an interface to the OpenMRS server.
     * @param connectionDetails an {@link OpenMrsConnectionDetails} instance for communicating with
     *                          the server
     * @param requestFactory    a {@link RequestFactory} for generating requests to OpenMRS
     * @param gson              a {@link Gson} instance for serialization/deserialization
     */
    public OpenMrsServer(
        OpenMrsConnectionDetails connectionDetails,
        RequestFactory requestFactory,
        Gson gson) {
        mConnectionDetails = connectionDetails;
        mRequestFactory = requestFactory;
        // TODO: Inject a Gson instance here.
        mGson = gson;
    }

    @Override public void logToServer(List<String> pairs) {
        // To avoid filling the server logs with big messy stack traces, let's make a dummy
        // request that succeeds.  We assume "Pulse" will always be present on the server.
        // Conveniently, extra data after ";" in the URL is included in request logs, but
        // ignored by the REST resource handler, which just returns the "Pulse" concept.
        String timestamp = "time=" + Utils.formatUtc8601(DateTime.now());
        final String urlPath = "/concepts/" + ConceptUuids.PULSE_UUID;
        List<String> params = new ArrayList<>();
        JsonUser user = App.getUserManager().getActiveUser();
        if (user != null) {
            pairs.add("provider_name");
            pairs.add(user.getName());
            pairs.add("provider_uuid");
            pairs.add(user.getUuid());
        }
        String patientUuid = null;
        for (int i = 0; i + 1 < pairs.size(); i += 2) {
            if (eq(pairs.get(i), "patient_uuid")) {
                patientUuid = pairs.get(i + 1);
            }
            params.add(Utils.urlEncode(pairs.get(i)) + "=" + Utils.urlEncode(pairs.get(i + 1)));
        }
        if (patientUuid != null) {
            try (Cursor cursor = App.getResolver().query(
                Patients.URI.buildUpon().appendPath(patientUuid).build(),
                new String[] {Patients.ID, Patients.GIVEN_NAME, Patients.FAMILY_NAME},
                null, null, null, null
            )) {
                if (cursor.moveToFirst()) {
                    String id = cursor.getString(0);
                    String name = cursor.getString(1) + " " + cursor.getString(2);
                    params.add("patient_id=" + Utils.urlEncode(id));
                    params.add("patient_name=" + Utils.urlEncode(name));
                }
            }
        }
        Collections.sort(params);
        params.add(0, timestamp);

        LOG.i("Logging to server: %s", params);
        OpenMrsJsonRequest request = mRequestFactory.newOpenMrsJsonRequest(
            mConnectionDetails, urlPath + ";" + Joiner.on(";").join(params), null,
            response -> { }, null);
        request.setRetryPolicy(new DefaultRetryPolicy(Common.REQUEST_TIMEOUT_MS_SHORT, 0, 1));
        mConnectionDetails.getVolley().addToRequestQueue(request);
    }

    @Override public void addPatient(
        JsonPatient patient,
        final Response.Listener<JsonPatient> successListener,
        final Response.ErrorListener errorListener) {
        JSONObject json = patientToJson(patient);
        LOG.v("Adding patient from JSON: %s", json.toString());

        OpenMrsJsonRequest request = mRequestFactory.newOpenMrsJsonRequest(
            mConnectionDetails,
            "/patients",
            json,
            response -> {
                try {
                    successListener.onResponse(patientFromJson(response));
                } catch (JSONException e) {
                    LOG.e(e, "Failed to parse response");
                    errorListener.onErrorResponse(
                        new VolleyError("Failed to parse response", e));
                }
            },
            wrapErrorListener(errorListener));
        request.setRetryPolicy(new DefaultRetryPolicy(Common.REQUEST_TIMEOUT_MS_SHORT, 1, 1f));
        mConnectionDetails.getVolley().addToRequestQueue(request);
    }

    private JSONObject patientToJson(JsonPatient patient) throws IllegalArgumentException {
        try {
            return new JSONObject(mGson.toJson(patient));
        } catch (JSONException e) {
            throw new IllegalArgumentException("Unable to serialize the patient to JSON.");
        }
    }

    private JsonPatient patientFromJson(JSONObject object) throws JSONException {
        return mGson.fromJson(object.toString(), JsonPatient.class);
    }

    /**
     * Wraps an ErrorListener so as to extract an error message from the JSON
     * content of a response, if possible.
     * @param errorListener An error listener.
     * @return A new error listener that tries to pass a more meaningful message
     * to the original errorListener.
     */
    public static Response.ErrorListener wrapErrorListener(
        final Response.ErrorListener errorListener) {
        return new OpenMrsErrorListener() {
            @Override public void onErrorResponse(VolleyError error) {
                super.onErrorResponse(error);
                errorListener.onErrorResponse(new VolleyError(
                    formatErrorMessage(error), error));
            }
        };
    }

    @Override public void updatePatient(
        JsonPatient patient,
        final Response.Listener<JsonPatient> successListener,
        final Response.ErrorListener errorListener) {
        JSONObject json = patientToJson(patient);
        OpenMrsJsonRequest request = mRequestFactory.newOpenMrsJsonRequest(
            mConnectionDetails,
            "/patients/" + patient.uuid,
            json,
            response -> {
                try {
                    successListener.onResponse(patientFromJson(response));
                } catch (JSONException e) {
                    LOG.e(e, "Failed to parse response");
                    errorListener.onErrorResponse(
                        new VolleyError("Failed to parse response", e));
                }
            },
            wrapErrorListener(errorListener)
        );
        request.setRetryPolicy(new DefaultRetryPolicy(Common.REQUEST_TIMEOUT_MS_SHORT, 1, 1f));
        mConnectionDetails.getVolley().addToRequestQueue(request);
    }

    @Override public void addUser(
        final JsonNewUser user,
        final Response.Listener<JsonUser> successListener,
        final Response.ErrorListener errorListener) {
        JSONObject requestBody = new JSONObject();
        try {
            requestBody.put("given_name", user.givenName);
            requestBody.put("family_name", user.familyName);
        } catch (JSONException e) {
            // This is almost never recoverable, and should not happen in correctly functioning code
            // So treat like NPE and rethrow.
            throw new RuntimeException(e);
        }

        OpenMrsJsonRequest request = mRequestFactory.newOpenMrsJsonRequest(
            mConnectionDetails,
            "/providers",
            requestBody,
            response -> {
                try {
                    successListener.onResponse(userFromJson(response));
                } catch (JSONException e) {
                    LOG.e(e, "Failed to parse response");
                    errorListener.onErrorResponse(
                        new VolleyError("Failed to parse response", e));
                }
            },
            wrapErrorListener(errorListener)
        );
        request.setRetryPolicy(new DefaultRetryPolicy(Common.REQUEST_TIMEOUT_MS_SHORT, 1, 1f));
        mConnectionDetails.getVolley().addToRequestQueue(request);
    }

    private JsonUser userFromJson(JSONObject object) throws JSONException {
        return new JsonUser(object.getString("uuid"), object.getString("full_name"));
    }

    @Override public void addEncounter(Encounter encounter,
                                       final Response.Listener<JsonEncounter> successListener,
                                       final Response.ErrorListener errorListener) {
        JSONObject json;
        try {
            json = encounter.toJson();
        } catch (JSONException e) {
            throw new IllegalArgumentException("Unable to serialize the encounter to JSON.", e);
        }

        OpenMrsJsonRequest request = mRequestFactory.newOpenMrsJsonRequest(
            mConnectionDetails,
            "/encounters",
            json,
            response -> {
                try {
                    successListener.onResponse(encounterFromJson(response));
                } catch (JSONException e) {
                    LOG.e(e, "Failed to parse response");
                    errorListener.onErrorResponse(
                        new VolleyError("Failed to parse response", e));
                }
            },
            wrapErrorListener(errorListener));
        request.setRetryPolicy(new DefaultRetryPolicy(Common.REQUEST_TIMEOUT_MS_SHORT, 1, 1f));
        mConnectionDetails.getVolley().addToRequestQueue(request);
    }

    @Override public void deleteObservation(
        String uuid,
        final Response.Listener<Void> successListener,
        final Response.ErrorListener errorListener) {
        OpenMrsJsonRequest request = mRequestFactory.newOpenMrsJsonRequest(
            mConnectionDetails,
            Request.Method.DELETE,
            "/observations/" + uuid,
            null,
            response -> successListener.onResponse(null),
            wrapErrorListener(errorListener));
        request.setRetryPolicy(new DefaultRetryPolicy(Common.REQUEST_TIMEOUT_MS_SHORT, 1, 1f));
        mConnectionDetails.getVolley().addToRequestQueue(request);
    }

    private JsonEncounter encounterFromJson(JSONObject object) throws JSONException {
        return mGson.fromJson(object.toString(), JsonEncounter.class);
    }

    @Override public void saveOrder(Order order,
                                    final Response.Listener<JsonOrder> successListener,
                                    final Response.ErrorListener errorListener) {
        JSONObject json;
        try {
            json = order.toJson();
            JsonUser user = App.getUserManager().getActiveUser();
            if (user != null) {
                json.put("provider_uuid", user.getUuid());
            }
        } catch (Exception e) {
            errorListener.onErrorResponse(new VolleyError("failed to serialize request", e));
            return;
        }
        LOG.v("Saving order with JSON: %s", json);

        OpenMrsJsonRequest request = mRequestFactory.newOpenMrsJsonRequest(
            mConnectionDetails,
            "/orders" + (order.uuid != null ? "/" + order.uuid : ""),
            json,
            response -> {
                try {
                    successListener.onResponse(
                        mGson.fromJson(response.toString(), JsonOrder.class));
                } catch (JsonSyntaxException e) {
                    LOG.e(e, "Failed to parse response");
                    errorListener.onErrorResponse(
                        new VolleyError("Failed to parse response", e));
                }
            },
            wrapErrorListener(errorListener));
        request.setRetryPolicy(new DefaultRetryPolicy(Common.REQUEST_TIMEOUT_MS_SHORT, 1, 1f));
        mConnectionDetails.getVolley().addToRequestQueue(request);
    }

    @Override public void deleteOrder(String orderUuid,
                                      final Response.Listener<Void> successListener,
                                      final Response.ErrorListener errorListener) {

        OpenMrsJsonRequest request = mRequestFactory.newOpenMrsJsonRequest(
            mConnectionDetails,
            Request.Method.DELETE,
            "/orders/" + orderUuid,
            null,
            response -> {
                try {
                    successListener.onResponse(null);
                } catch (JsonSyntaxException e) {
                    LOG.e(e, "Failed to parse response");
                    errorListener.onErrorResponse(new VolleyError("Failed to parse response", e));
                }
            },
            wrapErrorListener(errorListener));
        request.setRetryPolicy(new DefaultRetryPolicy(Common.REQUEST_TIMEOUT_MS_SHORT, 1, 1f));
        mConnectionDetails.getVolley().addToRequestQueue(request);
    }

    @Override public void getPatient(final String patientId,
                           final Response.Listener<JsonPatient> successListener,
                           final Response.ErrorListener errorListener) {
        OpenMrsJsonRequest request = mRequestFactory.newOpenMrsJsonRequest(
            mConnectionDetails,
            "/patients?id=" + patientId,
            null,
            response -> {
                try {
                    JSONArray results = response.getJSONArray("results");
                    if (results != null && results.length() > 0) {
                        successListener.onResponse(patientFromJson(results.getJSONObject(0)));
                    } else {
                        successListener.onResponse(null);
                    }
                } catch (JSONException e) {
                    LOG.e(e, "Failed to parse response");
                    errorListener.onErrorResponse(
                        new VolleyError("Failed to parse response", e));
                }
            },
            wrapErrorListener(errorListener)
        );
        mConnectionDetails.getVolley().addToRequestQueue(request);
    }

    @Override public void updatePatientLocation(String patientId, String newLocationId) {
        // TODO: Implement or remove (currently handled by updatePatient).
    }

    @Override public void listUsers(@Nullable OpenMrsConnectionDetails connection,
                          final Response.Listener<List<JsonUser>> successListener,
                          Response.ErrorListener errorListener) {
        OpenMrsJsonRequest request = mRequestFactory.newOpenMrsJsonRequest(
            connection != null ? connection : mConnectionDetails,
            "/providers",
            null,
            response -> {
                ArrayList<JsonUser> users = new ArrayList<>();
                try {
                    JSONArray results = response.getJSONArray("results");
                    for (int i = 0; i < results.length(); i++) {
                        users.add(userFromJson(results.getJSONObject(i)));
                    }
                } catch (JSONException e) {
                    LOG.e(e, "Failed to parse response");
                }
                successListener.onResponse(users);
            },
            wrapErrorListener(errorListener)
        );
        request.setRetryPolicy(new DefaultRetryPolicy(Common.REQUEST_TIMEOUT_MS_MEDIUM, 1, 1f));
        mConnectionDetails.getVolley().addToRequestQueue(request);
    }

    @Override public void addLocation(JsonLocation location,
                            final Response.Listener<JsonLocation> successListener,
                            final Response.ErrorListener errorListener) {
        JSONObject requestBody;
        try {
            if (location.uuid != null) {
                throw new IllegalArgumentException("The server sets the uuids for new locations");
            }
            if (location.parent_uuid == null) {
                throw new IllegalArgumentException("You must set a parent_uuid for a new location");
            }
            if (location.names == null || location.names.isEmpty()) {
                throw new IllegalArgumentException(
                    "You must set a name in at least one locale for a new location");
            }
            requestBody = new JSONObject(mGson.toJson(location));
        } catch (JSONException e) {
            // This is almost never recoverable, and should not happen in correctly functioning code
            // So treat like NPE and rethrow.
            throw new RuntimeException(e);
        }

        OpenMrsJsonRequest request = mRequestFactory.newOpenMrsJsonRequest(
            mConnectionDetails,
            "/locations",
            requestBody,
            response -> successListener.onResponse(parseLocationJson(response)),
            errorListener);
        request.setRetryPolicy(new DefaultRetryPolicy(Common.REQUEST_TIMEOUT_MS_SHORT, 1, 1f));
        mConnectionDetails.getVolley().addToRequestQueue(request);
    }

    private JsonLocation parseLocationJson(JSONObject object) {
        return mGson.fromJson(object.toString(), JsonLocation.class);
    }

    @Override public void updateLocation(JsonLocation location,
                               final Response.Listener<JsonLocation> successListener,
                               final Response.ErrorListener errorListener) {

        if (location.uuid == null) {
            throw new IllegalArgumentException("Location must be set for update " + location);
        }
        if (location.names == null || location.names.isEmpty()) {
            throw new IllegalArgumentException("New names must be set for update " + location);
        }
        JSONObject requestBody;
        try {
            requestBody = new JSONObject(mGson.toJson(location));
        } catch (JSONException e) {
            String msg = "Failed to write patient changes to Gson: " + location.toString();
            LOG.e(e, msg);
            errorListener.onErrorResponse(new VolleyError(msg));
            return;
        }

        OpenMrsJsonRequest request = mRequestFactory.newOpenMrsJsonRequest(
            mConnectionDetails,
            "/locations/" + location.uuid,
            requestBody,
            response -> successListener.onResponse(parseLocationJson(response)),
            wrapErrorListener(errorListener)
        );
        request.setRetryPolicy(new DefaultRetryPolicy(Common.REQUEST_TIMEOUT_MS_SHORT, 1, 1f));
        mConnectionDetails.getVolley().addToRequestQueue(request);
    }

    @Override public void deleteLocation(String locationUuid,
                               final Response.ErrorListener errorListener) {
        OpenMrsJsonRequest request = mRequestFactory.newOpenMrsJsonRequest(
            mConnectionDetails,
            Request.Method.DELETE, "/locations/" + locationUuid,
            null,
            null,
            wrapErrorListener(errorListener)
        );
        request.setRetryPolicy(new DefaultRetryPolicy(Common.REQUEST_TIMEOUT_MS_SHORT, 1, 1f));
        mConnectionDetails.getVolley().addToRequestQueue(request);
    }

    @Override public void listLocations(final Response.Listener<List<JsonLocation>> successListener,
                              Response.ErrorListener errorListener) {
        OpenMrsJsonRequest request = mRequestFactory.newOpenMrsJsonRequest(
            mConnectionDetails, "/locations",
            null,
            response -> {
                ArrayList<JsonLocation> result = new ArrayList<>();
                try {
                    JSONArray results = response.getJSONArray("results");
                    for (int i = 0; i < results.length(); i++) {
                        JsonLocation location =
                            parseLocationJson(results.getJSONObject(i));
                        if (location.names != null && !location.names.isEmpty()) {
                            location.name = location.names.values().iterator().next();
                        }
                        result.add(location);
                    }
                } catch (JSONException e) {
                    LOG.e(e, "Failed to parse response");
                }
                successListener.onResponse(result);
            },
            wrapErrorListener(errorListener)
        );
        request.setRetryPolicy(new DefaultRetryPolicy(Common.REQUEST_TIMEOUT_MS_MEDIUM, 1, 1f));
        mConnectionDetails.getVolley().addToRequestQueue(request);
    }

    @Override public void listForms(final Response.Listener<List<JsonForm>> successListener,
                          Response.ErrorListener errorListener) {
        OpenMrsJsonRequest request = mRequestFactory.newOpenMrsJsonRequest(
            mConnectionDetails,
            "/xforms",
            null,
            response -> {
                ArrayList<JsonForm> forms = new ArrayList<>();
                try {
                    JSONArray results = response.getJSONArray("results");
                    for (int i = 0; i < results.length(); i++) {
                        JSONObject result = results.getJSONObject(i);
                        forms.add(mGson.fromJson(result.toString(), JsonForm.class));
                    }
                } catch (JSONException e) {
                    LOG.e(e, "Failed to parse response");
                }
                successListener.onResponse(forms);
            },
            wrapErrorListener(errorListener)
        );
        request.setRetryPolicy(new DefaultRetryPolicy(Common.REQUEST_TIMEOUT_MS_MEDIUM, 1, 1f));
        mConnectionDetails.getVolley().addToRequestQueue(request);
    }

    @Override public void cancelPendingRequests() {
        // TODO: Implement or deprecate. The way this was implemented before, where a string
        // was the tag, is not safe. Only the class that initiated a request (and its delegates)
        // should be able to cancel that request.
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.net;

import com.android.volley.DefaultRetryPolicy;
import com.android.volley.Response;

import org.projectbuendia.client.json.JsonChartsResponse;
import org.projectbuendia.client.json.JsonConceptsResponse;

import java.util.HashMap;

/**
 * A connection to an OpenMRS backend to get chart information (observations on encounters
 * with patients).
 * <p/>
 * <p>There are essentially three endpoints:
 * <ul>
 * <li><code>/encounters</code> gives encoded details of the observations of concept
 * values that happen at an encounter
 * <li><code>/concepts</code> gives localised string and type information for the concepts
 * observed
 * <li><code>/charts</code> gives display information about how to display those encounters,
 * so you can have consistent ordering of observations and grouping into sections.
 * </ul>
 */
public class OpenMrsChartServer {

    private final OpenMrsConnectionDetails mConnectionDetails;

    public OpenMrsChartServer(OpenMrsConnectionDetails connectionDetails) {
        this.mConnectionDetails = connectionDetails;
    }

    /**
     * Retrieves all concepts from the server that are present in at least one chart.
     * @param successListener a {@link Response.Listener} that handles successful concept retrieval
     * @param errorListener   a {@link Response.ErrorListener} that handles failed concept retrieval
     */
    public void getConcepts(Response.Listener<JsonConceptsResponse> successListener,
                            Response.ErrorListener errorListener) {
        GsonRequest<JsonConceptsResponse> request = new GsonRequest<>(
            mConnectionDetails.getBuendiaApiUrl() + "/concepts?locale=buendia",
            JsonConceptsResponse.class,
            mConnectionDetails.addAuthHeader(new HashMap<>()),
            successListener, errorListener);
        request.setRetryPolicy(new DefaultRetryPolicy(Common.REQUEST_TIMEOUT_MS_LONG, 1, 1f));
        mConnectionDetails.getVolley().addToRequestQueue(request);
    }

    /**
     * Retrieves the structure of a given chart (groupings, orderings) from the server.
     * @param uuid            the UUID of the chart
     * @param successListener a {@link Response.Listener} that handles successful structure retrieval
     * @param errorListener   a {@link Response.ErrorListener} that handles failed structure retrieval
     */
    public void getChartStructures(Response.Listener<JsonChartsResponse> successListener,
                                   Response.ErrorListener errorListener) {
        GsonRequest<JsonChartsResponse> request = new GsonRequest<>(
            mConnectionDetails.getBuendiaApiUrl() + "/charts/?v=full",
            JsonChartsResponse.class,
            mConnectionDetails.addAuthHeader(new HashMap<>()),
            successListener, errorListener);
        request.setRetryPolicy(new DefaultRetryPolicy(Common.REQUEST_TIMEOUT_MS_LONG, 1, 1f));
        mConnectionDetails.getVolley().addToRequestQueue(request);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.net;

import com.android.volley.Response;

import org.json.JSONObject;

/** A factory that creates Volley requests configured with a {@link RequestConfigurator}. */
public class RequestFactory {

    private final RequestConfigurator mConfigurator;

    /**
     * Returns an {@link OpenMrsJsonRequest} for a GET or POST request to an API URL.
     * @param connectionDetails the {@link OpenMrsConnectionDetails} used to communicate with the
     *                          OpenMRS server
     * @param urlSuffix         the API url to request, relative to the API root
     * @param jsonRequest       a {@link JSONObject} containing the request body
     * @param listener          a {@link Response.Listener} for handling a successful request
     * @param errorListener     a {@link Response.ErrorListener} for handling a failed request
     * @return the configured {@link OpenMrsJsonRequest}
     */
    public OpenMrsJsonRequest newOpenMrsJsonRequest(
        OpenMrsConnectionDetails connectionDetails,
        String urlSuffix,
        JSONObject jsonRequest,
        Response.Listener<JSONObject> listener,
        Response.ErrorListener errorListener) {
        return mConfigurator.configure(
            new OpenMrsJsonRequest(
                connectionDetails, urlSuffix, jsonRequest, listener, errorListener));
    }

    /**
     * Returns an {@link OpenMrsJsonRequest} for an arbitrary request.
     * @param connectionDetails the {@link OpenMrsConnectionDetails} used to communicate with the
     *                          OpenMRS server
     * @param method            the HTTP method
     * @param url               the absolute URL to request
     * @param jsonRequest       a {@link JSONObject} containing the request body
     * @param listener          a {@link Response.Listener} for handling a successful request
     * @param errorListener     a {@link Response.ErrorListener} for handling a failed request
     * @return the configured {@link OpenMrsJsonRequest}
     */
    public OpenMrsJsonRequest newOpenMrsJsonRequest(
        OpenMrsConnectionDetails connectionDetails,
        int method,
        String url,
        JSONObject jsonRequest,
        Response.Listener<JSONObject> listener,
        Response.ErrorListener errorListener) {
        return mConfigurator.configure(
            new OpenMrsJsonRequest(
                connectionDetails, method, url, jsonRequest, listener, errorListener));
    }

    RequestFactory(RequestConfigurator configurator) {
        mConfigurator = configurator;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.net;

import com.android.volley.AuthFailureError;
import com.android.volley.NetworkResponse;
import com.android.volley.Response;
import com.android.volley.toolbox.JsonObjectRequest;

import org.json.JSONObject;
import org.projectbuendia.client.BuildConfig;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.io.UnsupportedEncodingException;
import java.util.HashMap;
import java.util.Map;

import static org.projectbuendia.client.utils.Utils.eq;

/** Base class for authenticated OpenMRS JSON requests. */
public class OpenMrsJsonRequest extends JsonObjectRequest {
    private final String mUsername;
    private final String mPassword;

    private static Logger LOG = Logger.create();

    /**
     * Constructs a GET or POST request to OpenMRS.
     * @param connectionDetails an {@link OpenMrsConnectionDetails} for communicating with OpenMRS
     * @param urlSuffix         the API URL being requested, relative to the API root
     * @param jsonRequest       a {@link JSONObject} containing the request body
     * @param listener          a {@link Response.Listener} that handles successful requests
     * @param errorListener     a {@link Response.ErrorListener} that handles failed requests
     */
    public OpenMrsJsonRequest(OpenMrsConnectionDetails connectionDetails,
                              String urlSuffix,
                              JSONObject jsonRequest,
                              Response.Listener<JSONObject> listener,
                              Response.ErrorListener errorListener) {
        this(connectionDetails.getUser(), connectionDetails.getPassword(),
            connectionDetails.getBuendiaApiUrl() + urlSuffix,
            jsonRequest, listener, errorListener);
    }

    private OpenMrsJsonRequest(String username, String password, String url, JSONObject jsonRequest,
                               Response.Listener<JSONObject> listener,
                               Response.ErrorListener errorListener) {
        super(url, jsonRequest, listener, errorListener);
        this.mUsername = username;
        this.mPassword = password;
    }

    /**
     * Constructs a request to OpenMRS using an arbitrary HTTP method.
     * @param connectionDetails an {@link OpenMrsConnectionDetails} for communicating with OpenMRS
     * @param method            the HTTP method
     * @param urlSuffix         the API URL being requested, relative to the API root
     * @param jsonRequest       a {@link JSONObject} containing the request body
     * @param listener          a {@link Response.Listener} that handles successful requests
     * @param errorListener     a {@link Response.ErrorListener} that handles failed requests
     */
    public OpenMrsJsonRequest(OpenMrsConnectionDetails connectionDetails,
                              int method, String urlSuffix, JSONObject jsonRequest,
                              Response.Listener<JSONObject> listener,
                              Response.ErrorListener errorListener) {
        super(method, connectionDetails.getBuendiaApiUrl() + urlSuffix,
            jsonRequest, listener, errorListener);
        this.mUsername = connectionDetails.getUser();
        this.mPassword = connectionDetails.getPassword();
    }

    @Override public Map<String, String> getHeaders() throws AuthFailureError {
        // TODO: work out how to do Auth properly
        HashMap<String, String> params = new HashMap<>();
        OpenMrsConnectionDetails.addAuthHeader(mUsername, mPassword, params);
        params.put("Connection-Type", "application/json");
        return params;
    }

    @Override protected Response<JSONObject> parseNetworkResponse(NetworkResponse response) {
        LOG.finish("HTTP." + getSequence(), "Response to %s -> %s", Utils.repr(this), Utils.repr(response.data, 500));
        try {
            if (response.data.length == 0) {
                byte[] responseData = "{}".getBytes("UTF8");
                response = new NetworkResponse(
                    response.statusCode, responseData, response.headers, response.notModified);
            }
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("Should never occur");
        }

        // OkHttp deletes the Content-Type header, which breaks Unicode decoding! :(
        // We have to set it to ensure that the data will be interpreted as UTF-8.
        response.headers.put("Content-Type", "application/json; charset=utf-8");

        String requiredVersion = getMinimumVersionHeader(response);
        LOG.d("Client version is %s; server requires %s",
            BuildConfig.VERSION_NAME, requiredVersion);
        if (requiredVersion != null && isProductionVersion(BuildConfig.VERSION_NAME)) {
            if (Utils.ALPHANUMERIC_COMPARATOR.compare(
                BuildConfig.VERSION_NAME, requiredVersion) < 0) {
                LOG.e("Client version is %s, but server requires at least %s",
                    BuildConfig.VERSION_NAME, requiredVersion);
            }
        }
        return super.parseNetworkResponse(response);
    }

    private boolean isProductionVersion(String version) {
        return version.contains(".");
    }

    private String getMinimumVersionHeader(NetworkResponse response) {
        // HTTP headers are case-insensitive but NetworkResponse stores
        // them in a case-sensitive Map.  Sigh.
        for (String key : response.headers.keySet()) {
            if (eq(key.toLowerCase(), "buendia-client-minimum-version")) {
                return response.headers.get(key);
            }
        }
        return null;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.net;

import com.android.volley.DefaultRetryPolicy;
import com.android.volley.Request;
import com.android.volley.RetryPolicy;

/**
 * Configures Volley requests before they are sent to the server.
 * <p/>
 * <p>The default implementation of this class sets the retry policy to a configurable timeout and
 * no retries.
 */
class RequestConfigurator {

    private final RetryPolicy mRetryPolicy;

    public <T extends Request> T configure(T request) {
        request.setRetryPolicy(mRetryPolicy);
        return request;
    }

    RequestConfigurator(int timeoutMs) {
        mRetryPolicy =
            new DefaultRetryPolicy(timeoutMs, 0 /*maxNumRetries*/, 0 /*backoffMultiplier*/);
    }

    RequestConfigurator(int timeoutMs, int maxNumRetries, int backoffMultiplier) {
        mRetryPolicy = new DefaultRetryPolicy(timeoutMs, maxNumRetries, backoffMultiplier);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.net;

import com.android.volley.AuthFailureError;
import com.android.volley.NetworkResponse;
import com.android.volley.ParseError;
import com.android.volley.Request;
import com.android.volley.Response;
import com.android.volley.toolbox.HttpHeaderParser;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonSyntaxException;

import org.apache.http.protocol.HTTP;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.io.UnsupportedEncodingException;
import java.lang.reflect.Type;
import java.util.Map;

import javax.annotation.Nullable;

/** A {@link Request} with a JSON response parsed by {@link Gson}. */
public class GsonRequest<T> extends Request<T> {
    private final GsonBuilder mGson = new GsonBuilder();
    private final Type mType;
    private final Map<String, String> mHeaders;
    private final Response.Listener<T> mListener;
    private Map<String, String> mBody = null;

    private static Logger LOG = Logger.create();

    /**
     * Makes a GET request and returns a parsed object from JSON.
     * @param url           URL of the request to make
     * @param type          The type of the base response JSON object. Gson reflects on this
     *                      parameter to create the response object. Note that in most situations,
     *                      using {@code MyJsonResponseType.class} will work, but if your response
     *                      object makes use of generics, you will need to generate a type from a
     *                      {@link com.google.gson.reflect.TypeToken TypeToken}, using something
     *                      like {@code new TypeToken<MyJsonResponseType<SubType>>{}.getType()}.
     * @param headers       Map of request headers
     * @param listener      a {@link Response.Listener} that handles successful requests
     * @param errorListener a {@link Response.ErrorListener} that handles failed requests
     */
    public GsonRequest(String url, Type type, Map<String, String> headers,
                       Response.Listener<T> listener, Response.ErrorListener errorListener) {
        this(Method.GET, null, url, type, headers, listener, errorListener);
    }

    /**
     * Makes a request using an arbitrary HTTP method and returns a parsed object from JSON.
     * @param method        the request method
     * @param body          the request body
     * @param url           URL of the request to make
     * @param type          The type of the base response JSON object. Gson reflects on this
     *                      parameter to create the response object. Note that in most situations,
     *                      using {@code MyJsonResponseType.class} will work, but if your response
     *                      object makes use of generics, you will need to generate a type from a
     *                      {@link com.google.gson.reflect.TypeToken TypeToken}, using something
     *                      like {@code new TypeToken<MyJsonResponseType<SubType>>{}.getType()}.
     * @param headers       Map of request headers
     * @param listener      a {@link Response.Listener} that handles successful requests
     * @param errorListener a {@link Response.ErrorListener} that handles failed requests
     */
    public GsonRequest(int method,
                       @Nullable Map<String, String> body,
                       String url, Type type, Map<String, String> headers,
                       Response.Listener<T> listener, Response.ErrorListener errorListener) {
        super(method, url, errorListener);
        this.mBody = body;
        this.mType = type;
        this.mHeaders = headers;
        this.mListener = listener;
    }

    @Override public Map<String, String> getHeaders() throws AuthFailureError {
        return mHeaders != null ? mHeaders : super.getHeaders();
    }

    public GsonBuilder getGson() {
        return mGson;
    }

    @Override protected void deliverResponse(T response) {
        mListener.onResponse(response);
    }

    @Override protected Map<String, String> getParams() {
        return mBody;
    }

    @Override protected Response<T> parseNetworkResponse(NetworkResponse response) {
        LOG.finish("HTTP." + getSequence(), "Response to %s -> %s", Utils.repr(this), Utils.repr(response.data, 500));
        try {
            String json = new String(
                response.data,
                HTTP.UTF_8);  // TODO: HttpHeaderParser.parseCharset(response.mHeaders).
            Gson gsonParser = mGson.create();
            //noinspection unchecked
            return (Response<T>) Response.success(
                gsonParser.fromJson(json, mType),
                HttpHeaderParser.parseCacheHeaders(response));
        } catch (UnsupportedEncodingException e) {
            return Response.error(new ParseError(e));
        } catch (JsonSyntaxException e) {
            return Response.error(new ParseError(e));
        } catch (Exception e) {
            return Response.error(new ParseError(e));
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.net;

import com.android.volley.DefaultRetryPolicy;
import com.android.volley.Request;
import com.android.volley.Response;
import com.android.volley.VolleyError;
import com.google.common.base.Joiner;
import com.google.gson.JsonObject;

import org.joda.time.DateTime;
import org.joda.time.format.ISODateTimeFormat;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.projectbuendia.client.utils.Logger;

import java.util.ArrayList;
import java.util.List;

import javax.annotation.Nullable;

/**
 * A connection to the module deployed in OpenMRS to provide xforms (which is part of the Buendia
 * API module). This is not part of OpenMrsServer as it has entirely its own interface, but should
 * be merged in the future.
 */
public class OpenMrsXformsConnection {

    private static final Logger LOG = Logger.create();

    private final OpenMrsConnectionDetails mConnectionDetails;

    public OpenMrsXformsConnection(OpenMrsConnectionDetails connection) {
        this.mConnectionDetails = connection;
    }

    /** Fetches the XML for a form from the server, using the special "buendia" locale. */
    public void getXform(String uuid, final Response.Listener<String> resultListener,
                         Response.ErrorListener errorListener) {
        Request request = new OpenMrsJsonRequest(mConnectionDetails,
            "/xforms/" + uuid + "?v=full&locale=buendia",
            null, // null implies GET
            response -> {
                try {
                    String xml = response.getString("xml");
                    resultListener.onResponse(xml);
                } catch (JSONException e) {
                    // The result was not in the expected format. Just log, and return
                    // results so far.
                    LOG.e(e, "response was in bad format: " + response);
                }
            }, errorListener
        );
        // Typical response times should be close to 10s, but as the number of users grows, this
        // number scales up quickly, so use a 30s timeout to be safe.
        request.setRetryPolicy(new DefaultRetryPolicy(Common.REQUEST_TIMEOUT_MS_MEDIUM, 1, 1f));
        mConnectionDetails.getVolley().addToRequestQueue(request);
    }

    /** Lists all the forms on the server, without fetching their contents. */
    public void listXforms(final Response.Listener<List<OpenMrsXformIndexEntry>> listener,
                           final Response.ErrorListener errorListener) {
        Request request = new OpenMrsJsonRequest(mConnectionDetails, "/xforms", // list all forms
            null, // null implies GET
            response -> {
                LOG.i("Received form list: " + response);
                ArrayList<OpenMrsXformIndexEntry> result = new ArrayList<>();
                try {
                    // This seems quite code heavy (parsing manually), but is reasonably
                    // efficient as we only look at the fields we need, so we are robust to
                    // changes in the rest of the object.
                    JSONArray results = response.getJSONArray("results");
                    for (int i = 0; i < results.length(); i++) {
                        JSONObject entry = results.getJSONObject(i);

                        // Sometimes date_changed is not set; in this case, date_changed is
                        // simply date_created.
                        long dateChanged;
                        if (entry.get("date_changed") == JSONObject.NULL) {
                            dateChanged = entry.getLong("date_created");
                        } else {
                            dateChanged = entry.getLong("date_changed");
                        }

                        OpenMrsXformIndexEntry indexEntry = new OpenMrsXformIndexEntry(
                            entry.getString("uuid"),
                            entry.getString("name"),
                            dateChanged);
                        result.add(indexEntry);
                    }
                } catch (JSONException e) {
                    // The result was not in the expected format. Just log, and return
                    // results so far.
                    LOG.e(e, "Badly formatted response: " + response);
                }
                LOG.i("Returning index entries: " + Joiner.on(", ").join(result));
                listener.onResponse(result);
            },
            errorListener
        );
        request.setRetryPolicy(new DefaultRetryPolicy(Common.REQUEST_TIMEOUT_MS_MEDIUM, 1, 1f));
        mConnectionDetails.getVolley().addToRequestQueue(request);
    }

    /** Send a single Xform to the OpenMRS server. */
    public void postXformInstance(
        @Nullable String patientUuid,
        String providerUuid,
        String xform,
        final Response.Listener<JSONObject> resultListener,
        Response.ErrorListener errorListener) {

        JsonObject post = new JsonObject();
        post.addProperty("xml", xform);
        // Don't add patient property for create new patient
        if (patientUuid != null) {
            post.addProperty("patient_uuid", patientUuid);
        }
        post.addProperty("provider_uuid", providerUuid);

        post.addProperty("date_entered", ISODateTimeFormat.dateTime().print(new DateTime()));
        JSONObject postBody = null;
        try {
            postBody = new JSONObject(post.toString());
        } catch (JSONException e) {
            LOG.e(e, "This should never happen converting one JSON object to another. " + post);
            errorListener.onErrorResponse(new VolleyError("failed to convert to JSON", e));
        }
        OpenMrsJsonRequest request = new OpenMrsJsonRequest(
            mConnectionDetails, "/xforminstances",
            postBody, // non-null implies POST
            resultListener::onResponse, errorListener
        );
        // Set a permissive timeout.
        request.setRetryPolicy(new DefaultRetryPolicy(Common.REQUEST_TIMEOUT_MS_MEDIUM, 1, 1f));
        mConnectionDetails.getVolley().addToRequestQueue(request);
    }

}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.net;

/** Common constants and helper methods for the network layer. */
public final class Common {

    /**
     * The number of milliseconds before a request is considered timed out for requests expected to
     * finish quickly (e.g. updating or deleting a record).
     */
    public static final int REQUEST_TIMEOUT_MS_SHORT = 15000;

    /**
     * The number of milliseconds before a request is considered timed out for requests expected to
     * finish somewhat quickly (e.g. requesting the list of forms from the server).
     */
    public static final int REQUEST_TIMEOUT_MS_MEDIUM = 30000;

    /**
     * The number of milliseconds before a request is considered timed out for requests that may
     * take a considerable amount of time to complete (e.g. requesting all concepts).
     */
    public static final int REQUEST_TIMEOUT_MS_LONG = 60000;

    /**
     * The number of milliseconds before a request is considered timed out for requests that may
     * take an exceedingly long time (e.g. requesting all patient encounters).
     */
    public static final int REQUEST_TIMEOUT_MS_VERY_LONG = 120000;

    /** If true, allow data to be provided from the sync adapter rather than the network. */
    public static final boolean OFFLINE_SUPPORT = true;

    private Common() {
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.net;

import android.content.Context;

import com.android.volley.DefaultRetryPolicy;
import com.android.volley.Request;
import com.android.volley.RequestQueue;
import com.android.volley.RetryPolicy;
import com.android.volley.toolbox.Volley;
import com.circle.android.api.OkHttpStack;
import com.facebook.stetho.okhttp.StethoInterceptor;
import com.squareup.okhttp.OkHttpClient;

import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

/** Wraps Volley up in a singleton object. */
public class VolleySingleton {
    private static VolleySingleton sInstance;
    private static Logger LOG = Logger.create();
    private final RequestQueue mRequestQueue;
    private static RetryPolicy policy = new DefaultRetryPolicy(5000, 1, 1);

    /**
     * Get the VolleySingleton instance for doing multiple operations on a single context.
     * In general prefer convenience methods unless doing multiple operations.
     * @param context the Android Application context
     * @return the Singleton for accessing Volley.
     */
    public static synchronized VolleySingleton getInstance(Context context) {
        if (sInstance == null) {
            sInstance = new VolleySingleton(context);
        }
        return sInstance;
    }

    /**
     * A convenience method for adding a request to the Volley request queue getting all singleton
     * handling and contexts correct.
     */
    public <T> void addToRequestQueue(Request<T> req) {
        getRequestQueue().add(req.setRetryPolicy(policy));
        LOG.start("HTTP." + req.getSequence(), "Queued %s", Utils.repr(req));
    }

    private RequestQueue getRequestQueue() {
        return mRequestQueue;
    }

    private VolleySingleton(Context context) {
        // Let Stetho inspect all our network requests.
        final OkHttpClient client = new OkHttpClient();
        client.networkInterceptors().add(new StethoInterceptor());

        // getApplicationContext() is key, it keeps you from leaking the
        // Activity or BroadcastReceiver if someone passes one in.
        mRequestQueue = Volley.newRequestQueue(
            context.getApplicationContext(), new OkHttpStack(client));
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.net;

import android.support.annotation.Nullable;

import com.android.volley.Response;

import org.projectbuendia.client.json.JsonEncounter;
import org.projectbuendia.client.json.JsonForm;
import org.projectbuendia.client.json.JsonLocation;
import org.projectbuendia.client.json.JsonNewUser;
import org.projectbuendia.client.json.JsonOrder;
import org.projectbuendia.client.json.JsonPatient;
import org.projectbuendia.client.json.JsonUser;
import org.projectbuendia.models.Encounter;
import org.projectbuendia.models.Order;

import java.util.List;

/** An interface abstracting the idea of an RPC to a server. */
public interface Server {
    /**
     * Logs an event by sending a dummy request to the server.  (The server logs
     * can then be scanned later to produce analytics for the client app.)
     * @param pairs An even number of arguments providing key-value pairs of
     *              arbitrary data to record with the event.
     */
    void logToServer(List<String> pairs);

    /** Adds a patient. */
    void addPatient(
        JsonPatient patient,
        Response.Listener<JsonPatient> successListener,
        Response.ErrorListener errorListener);

    /** Updates a patient. */
    public void updatePatient(
        JsonPatient patient,
        Response.Listener<JsonPatient> successListener,
        Response.ErrorListener errorListener);

    /**
     * Creates a new user.
     * @param user the JsonNewUser to add
     */
    public void addUser(
        JsonNewUser user,
        Response.Listener<JsonUser> successListener,
        Response.ErrorListener errorListener);

    /** Creates a new encounter. */
    void addEncounter(
        Encounter encounter,
        Response.Listener<JsonEncounter> successListener,
        Response.ErrorListener errorListener);

    /** Deletes (voids) an observation by its UUID. */
    void deleteObservation(
        String uuid,
        Response.Listener<Void> successListener,
        Response.ErrorListener errorListener);

    /**
     * Gets the patient record for an existing patient. Currently we are just using a String-String
     * map for parameters, but this is a bit close in implementation details to the old Buendia UI
     * so it will probably need to be generalized in future.
     * @param patientId the unique patient id representing the patients
     */
    public void getPatient(
        String patientId,
        Response.Listener<JsonPatient> successListener,
        Response.ErrorListener errorListener);

    /**
     * Updates the location of a patient.
     * @param patientId     the id of the patient to update
     * @param newLocationId the id of the new location that the patient is assigned to
     */
    public void updatePatientLocation(String patientId, String newLocationId);

    /** Lists all existing users. */
    public void listUsers(@Nullable OpenMrsConnectionDetails connection,
                          Response.Listener<List<JsonUser>> successListener,
                          Response.ErrorListener errorListener);

    /** Lists all published forms. */
    void listForms(Response.Listener<List<JsonForm>> successListener,
                   Response.ErrorListener errorListener);

    /**
     * Adds a new location to the server.
     * @param location        uuid must not be set, parent_uuid must be set, and the names map must have a
     *                        name for at least one locale.
     * @param successListener the listener to be informed of the newly added location
     * @param errorListener   listener to be informed of any errors
     */
    public void addLocation(JsonLocation location,
                            final Response.Listener<JsonLocation> successListener,
                            final Response.ErrorListener errorListener);

    /**
     * Updates the names for a location on the server.
     * @param location        the location, only uuid and new locale names for the location will be used,
     *                        but ideally the other arguments should be correct
     * @param successListener the listener to be informed of the newly added location
     * @param errorListener   listener to be informed of any errors
     */
    public void updateLocation(JsonLocation location,
                               final Response.Listener<JsonLocation> successListener,
                               final Response.ErrorListener errorListener);

    /**
     * Deletes a given location from the server. The location should not be the EMC location or
     * one of the zones - just a client added location, tent or bed.
     */
    public void deleteLocation(String locationUuid,
                               final Response.ErrorListener errorListener);

    /** Lists all locations. */
    public void listLocations(Response.Listener<List<JsonLocation>> successListener,
                              Response.ErrorListener errorListener);

    /** Adds or updates an order. */
    void saveOrder(Order order,
                   Response.Listener<JsonOrder> successListener,
                   Response.ErrorListener errorListener);

    /** Deletes an order. */
    void deleteOrder(String orderUuid,
                     Response.Listener<Void> successListener,
                     Response.ErrorListener errorListener);

    /** Cancels all pending requests. */
    public void cancelPendingRequests();
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.inject;

import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

import javax.inject.Qualifier;

/** Defines qualifiers for dependency injection. */
public class Qualifiers {

    // .diagnostics

    @Qualifier
    @Documented
    @Retention(RetentionPolicy.RUNTIME)
    public @interface HealthEventBus {
    }

    // .events

    @Qualifier
    @Documented
    @Retention(RetentionPolicy.RUNTIME)
    public @interface CrudEventBusBuilder {
    }

    private Qualifiers() {
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.providers;

import android.content.ContentResolver;
import android.content.ContentValues;
import android.database.Cursor;
import android.net.Uri;

import org.projectbuendia.client.sync.Database;
import org.projectbuendia.client.sync.QueryBuilder;
import org.projectbuendia.client.providers.Contracts.Table;

/** A {@link ProviderDelegate} that provides read-write access to users. */
class UsersDelegate implements ProviderDelegate<Database> {

    public static final String NAME = "users";

    public static final String TYPE =
        ContentResolver.CURSOR_DIR_BASE_TYPE + TYPE_PACKAGE_PREFIX + NAME;

    @Override public String getType() {
        return TYPE;
    }

    @Override public Cursor query(
        Database dbHelper, ContentResolver contentResolver, Uri uri,
        String[] projection, String selection, String[] selectionArgs, String sortOrder) {
        Cursor cursor = new QueryBuilder(Table.USERS)
            .where(selection, selectionArgs)
            .orderBy(sortOrder)
            .select(dbHelper.getReadableDatabase(), projection);
        cursor.setNotificationUri(contentResolver, uri);
        return cursor;
    }

    @Override public int bulkInsert(
        Database dbHelper, ContentResolver contentResolver, Uri uri,
        ContentValues[] values) {
        // TODO: optimise this.
        for (ContentValues value : values) {
            insert(dbHelper, contentResolver, uri, value);
        }
        return values.length;
    }

    @Override public Uri insert(
        Database dbHelper, ContentResolver contentResolver, Uri uri,
        ContentValues values) {
        long id = dbHelper.getWritableDatabase()
            .replaceOrThrow(Table.USERS.name, null, values);
        contentResolver.notifyChange(uri, null, false);
        return uri.buildUpon().appendPath(Long.toString(id)).build();
    }

    @Override public int delete(
        Database dbHelper, ContentResolver contentResolver, Uri uri,
        String selection, String[] selectionArgs) {
        int count = new QueryBuilder(Table.USERS)
            .where(selection, selectionArgs)
            .delete(dbHelper.getWritableDatabase());
        if (count > 0) contentResolver.notifyChange(uri, null, false);
        return count;
    }

    @Override public int update(
        Database dbHelper, ContentResolver contentResolver, Uri uri,
        ContentValues values, String selection, String[] selectionArgs) {
        int count = new QueryBuilder(Table.USERS)
            .where(selection, selectionArgs)
            .update(dbHelper.getWritableDatabase(), values);
        if (count > 0) contentResolver.notifyChange(uri, null, false);
        return count;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.providers;

import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;

import org.projectbuendia.client.utils.Logger;

/**
 * An AutoCloseable object representing a SQLite transaction.  Instantiating
 * a DatabaseTransaction starts a transaction.  Closing it with close() finishes
 * the transaction, which causes the operations within the transaction to be
 * rolled back if rollback() was called, or committed otherwise.
 */
public final class DatabaseTransaction implements AutoCloseable { // @nolint
    private final SQLiteDatabase mDatabase;
    private final String mName;

    private static final Logger LOG = Logger.create();

    /** Starts a named transaction by creating a savepoint. */
    public DatabaseTransaction(SQLiteDatabase database, String name) {
        mDatabase = database;
        mName = name;
        LOG.d("Starting transaction with SAVEPOINT " + mName);
        mDatabase.execSQL("SAVEPOINT " + mName);
    }

    public DatabaseTransaction(SQLiteOpenHelper openHelper, String name) {
        this(openHelper.getWritableDatabase(), name);
    }

    /** Rolls back a named transaction to the state just after it started. */
    public void rollback() {
        if (mDatabase.inTransaction()) {
            LOG.d("Rolling back transaction with ROLLBACK TO " + mName);
            mDatabase.execSQL("ROLLBACK TO " + mName);
            LOG.d("Rollback to " + mName + " completed");
        } else {
            LOG.w("There is no current transaction to roll back");
        }
    }

    /**
     * Finishes a named transaction.  The transaction will be cancelled if
     * rollback() was called; otherwise it will be committed.
     */
    @Override public void close() {
        mDatabase.execSQL("RELEASE " + mName);
        LOG.d("Finished transaction " + mName);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.providers;

import android.content.ContentResolver;
import android.content.ContentValues;
import android.database.Cursor;
import android.net.Uri;

import org.projectbuendia.client.sync.Database;
import org.projectbuendia.client.sync.QueryBuilder;
import org.projectbuendia.client.providers.Contracts.Table;

/** A {@link ProviderDelegate} that provides query access to the count of patients in each location. */
public class PatientCountsDelegate implements ProviderDelegate<Database> {

    @Override public String getType() {
        return Contracts.PatientCounts.GROUP_TYPE;
    }

    @Override public Cursor query(
        Database dbHelper, ContentResolver contentResolver, Uri uri, String[] projection,
        String selection, String[] selectionArgs, String sortOrder) {
        return new QueryBuilder(Table.PATIENTS)
            .where(selection, selectionArgs)
            .where(Contracts.Patients.LOCATION_UUID + " is not null")
            .groupBy(Contracts.Patients.LOCATION_UUID)
            .orderBy(sortOrder)
            .select(dbHelper.getReadableDatabase(),
                Contracts.Patients.ID,
                Contracts.Patients.LOCATION_UUID,
                "count(*) as " + Contracts.PatientCounts.PATIENT_COUNT);
    }

    @Override public Uri insert(
        Database dbHelper, ContentResolver contentResolver, Uri uri,
        ContentValues values) {
        throw new UnsupportedOperationException("Insert is not supported for URI '" + uri + "'.");
    }

    @Override public int bulkInsert(
        Database dbHelper, ContentResolver contentResolver, Uri uri,
        ContentValues[] values) {
        throw new UnsupportedOperationException(
            "Bulk insert is not supported for URI '" + uri + "'.");
    }

    @Override public int delete(
        Database dbHelper, ContentResolver contentResolver, Uri uri, String selection,
        String[] selectionArgs) {
        throw new UnsupportedOperationException("Delete is not supported for URI '" + uri + "'.");
    }

    @Override public int update(
        Database dbHelper, ContentResolver contentResolver, Uri uri,
        ContentValues values, String selection, String[] selectionArgs) {
        throw new UnsupportedOperationException("Update is not supported for URI '" + uri + "'.");
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.providers;

import android.content.ContentResolver;
import android.content.ContentValues;
import android.database.Cursor;
import android.net.Uri;

import org.projectbuendia.client.sync.Database;
import org.projectbuendia.client.sync.QueryBuilder;

/**
 * A {@link ProviderDelegate} that provides query, delete, and update access to a single item
 * provided directly from the database.
 */
public class ItemProviderDelegate implements ProviderDelegate<Database> {

    protected final String mName;
    protected final Contracts.Table mTable;
    protected final String mType;
    protected final String mIdColumn;

    /** Creates an instance of {@link ItemProviderDelegate}. */
    public ItemProviderDelegate(String name, Contracts.Table table, String idColumn) {
        mName = name;
        mTable = table;
        mIdColumn = idColumn;
        mType = ContentResolver.CURSOR_ITEM_BASE_TYPE + TYPE_PACKAGE_PREFIX + mName;
    }

    @Override public String getType() {
        return mType;
    }

    @Override public Cursor query(
        Database dbHelper, ContentResolver contentResolver, Uri uri,
        String[] projection, String selection, String[] selectionArgs, String sortOrder) {
        Cursor cursor = new QueryBuilder(mTable)
            .where(mIdColumn + "=?", uri.getLastPathSegment())
            .where(selection, selectionArgs)
            .orderBy(sortOrder)
            .select(dbHelper.getReadableDatabase(), projection);
        cursor.setNotificationUri(contentResolver, uri);
        return cursor;
    }

    @Override public Uri insert(
        Database dbHelper, ContentResolver contentResolver, Uri uri,
        ContentValues values) {
        throw new UnsupportedOperationException("Insert is not supported for URI '" + uri + "'.");
    }

    @Override public int bulkInsert(
        Database dbHelper, ContentResolver contentResolver, Uri uri,
        ContentValues[] allValues) {
        throw new UnsupportedOperationException(
            "Bulk insert is not supported for URI '" + uri + "'.");
    }

    @Override public int delete(
        Database dbHelper, ContentResolver contentResolver, Uri uri,
        String selection, String[] selectionArgs) {
        int count = new QueryBuilder(mTable)
            .where(mIdColumn + "=?", uri.getLastPathSegment())
            .where(selection, selectionArgs)
            .delete(dbHelper.getWritableDatabase());
        if (count > 0) contentResolver.notifyChange(uri, null, false);
        return count;
    }

    @Override public int update(
        Database dbHelper, ContentResolver contentResolver, Uri uri,
        ContentValues values, String selection, String[] selectionArgs) {
        int count = new QueryBuilder(mTable)
            .where(mIdColumn + "=?", uri.getLastPathSegment())
            .where(selection, selectionArgs)
            .update(dbHelper.getWritableDatabase(), values);
        if (count > 0) contentResolver.notifyChange(uri, null, false);
        return count;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.providers;

import android.content.ContentResolver;
import android.content.ContentValues;
import android.database.Cursor;
import android.net.Uri;

import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteStatement;

import org.projectbuendia.client.sync.Database;
import org.projectbuendia.client.sync.QueryBuilder;

/**
 * A {@link ProviderDelegate} that provides query, insert, delete, and update access to a group or
 * list of items provided directly from the database.
 */
class GroupProviderDelegate implements ProviderDelegate<Database> {

    private static final String BULK_INSERT_SAVEPOINT = "GROUP_PROVIDER_DELEGATE_BULK_INSERT";
    private final String mType;
    private final Contracts.Table mTable;

    public GroupProviderDelegate(String type, Contracts.Table table) {
        mType = type;
        mTable = table;
    }

    @Override public String getType() {
        return mType;
    }

    @Override public Cursor query(
        Database dbHelper, ContentResolver contentResolver, Uri uri,
        String[] projection, String selection, String[] selectionArgs, String sortOrder) {
        Cursor cursor = new QueryBuilder(mTable).where(selection, selectionArgs)
            .orderBy(sortOrder)
            .select(dbHelper.getReadableDatabase(), projection);
        cursor.setNotificationUri(contentResolver, uri);
        return cursor;
    }

    @Override public Uri insert(
        Database dbHelper, ContentResolver contentResolver, Uri uri,
        ContentValues values) {
        long id = dbHelper.getWritableDatabase().replaceOrThrow(mTable.name, null, values);
        contentResolver.notifyChange(uri, null, false);
        return uri.buildUpon().appendPath(Long.toString(id)).build();
    }

    @Override public int bulkInsert(
        Database dbHelper, ContentResolver contentResolver, Uri uri,
        ContentValues[] allValues) {
        if (allValues.length == 0) {
            return 0;
        }
        final SQLiteDatabase db = dbHelper.getWritableDatabase();
        ContentValues first = allValues[0];
        String[] columns = first.keySet().toArray(new String[first.size()]);
        try (DatabaseTransaction tx = new DatabaseTransaction(db, BULK_INSERT_SAVEPOINT)) {
            try (SQLiteStatement statement = makeInsertStatement(db, mTable.name, columns)) {
                Object[] bindings = new Object[first.size()];
                for (ContentValues values : allValues) {
                    statement.clearBindings();
                    if (values.size() != first.size()) {
                        throw new AssertionError();
                    }
                    for (int i = 0; i < bindings.length; i++) {
                        Object value = values.get(columns[i]);
                        // This isn't super safe, but is in our context.
                        int bindingIndex = i + 1;
                        if (value instanceof String) {
                            statement.bindString(bindingIndex, (String) value);
                        } else if ((value instanceof Long) || value instanceof Integer) {
                            statement.bindLong(bindingIndex, ((Number) value).longValue());
                        } else if ((value instanceof Double) || value instanceof Float) {
                            statement.bindDouble(bindingIndex, ((Number) value).doubleValue());
                        }
                        bindings[i] = value;
                    }
                    statement.executeInsert();
                }
            } catch (Throwable t) {
                // If absolutely anything goes wrong, rollback to the savepoint.
                tx.rollback();
            }
        }
        contentResolver.notifyChange(uri, null, false);
        return allValues.length;
    }

    private SQLiteStatement makeInsertStatement(
        SQLiteDatabase db, String table, String[] columns) {
        // I kind of hoped this would be provided by SQLiteDatabase or DatabaseHelper,
        // But it doesn't seem to be. Innards copied from SQLiteDatabase.insertWithOnConflict
        StringBuilder sql = new StringBuilder();
        sql.append("INSERT OR REPLACE ");
        sql.append(" INTO ");
        sql.append(table);
        sql.append('(');

        int size = (columns != null && columns.length > 0) ? columns.length : 0;
        if (size <= 0) {
            throw new IllegalArgumentException();
        }
        for (int i = 0; i < columns.length; i++) {
            sql.append((i > 0) ? "," : "");
            sql.append(columns[i]);
        }
        sql.append(')');
        sql.append(" VALUES (");
        for (int i = 0; i < size; i++) {
            sql.append((i > 0) ? ",?" : "?");
        }
        sql.append(')');

        return db.compileStatement(sql.toString());
    }

    @Override public int delete(
        Database dbHelper, ContentResolver contentResolver, Uri uri,
        String selection, String[] selectionArgs) {
        int count = new QueryBuilder(mTable)
            .where(selection, selectionArgs)
            .delete(dbHelper.getWritableDatabase());
        if (count > 0) contentResolver.notifyChange(uri, null, false);
        return count;
    }

    @Override public int update(
        Database dbHelper, ContentResolver contentResolver, Uri uri,
        ContentValues values, String selection, String[] selectionArgs) {
        int count = new QueryBuilder(mTable)
            .where(selection, selectionArgs)
            .update(dbHelper.getWritableDatabase(), values);
        if (count > 0) contentResolver.notifyChange(uri, null, false);
        return count;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.providers;

import android.content.ContentProvider;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.database.Cursor;
import android.net.Uri;

import android.database.sqlite.SQLiteOpenHelper;

/** A {@link ContentProvider} that delegates responsibility to {@link ProviderDelegate}s. */
abstract class DelegatingProvider<T extends SQLiteOpenHelper> extends ContentProvider {

    private ProviderDelegateRegistry<T> mRegistry;
    protected ContentResolver mContentResolver;
    protected T mDatabaseHelper;

    @Override public boolean onCreate() {
        mRegistry = getRegistry();
        mDatabaseHelper = createDatabaseHelper();
        mContentResolver = getContext().getContentResolver();

        return true;
    }

    protected abstract ProviderDelegateRegistry<T> getRegistry();

    protected abstract T createDatabaseHelper();

    @Override public String getType(Uri uri) {
        return mRegistry.getDelegate(uri).getType();
    }

    @Override public Cursor query(
        Uri uri, String[] projection, String selection, String[] selectionArgs,
        String sortOrder) {
        return mRegistry.getDelegate(uri)
            .query(
                mDatabaseHelper, mContentResolver, uri, projection, selection,
                selectionArgs, sortOrder);
    }

    @Override public Uri insert(Uri uri, ContentValues values) {
        return mRegistry.getDelegate(uri)
            .insert(mDatabaseHelper, mContentResolver, uri, values);
    }

    @Override public int bulkInsert(Uri uri, ContentValues[] values) {
        return mRegistry.getDelegate(uri)
            .bulkInsert(mDatabaseHelper, mContentResolver, uri, values);
    }

    @Override public int delete(Uri uri, String selection, String[] selectionArgs) {
        return mRegistry.getDelegate(uri)
            .delete(mDatabaseHelper, mContentResolver, uri, selection, selectionArgs);
    }

    @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
        return mRegistry.getDelegate(uri)
            .update(
                mDatabaseHelper, mContentResolver, uri, values, selection, selectionArgs);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.providers;

import android.content.ContentResolver;
import android.net.Uri;

import org.projectbuendia.client.BuildConfig;

/** The external contracts for {@link BuendiaProvider}. */
@SuppressWarnings("unused")
public interface Contracts {
    String CONTENT_AUTHORITY = BuildConfig.CONTENT_AUTHORITY;
    Uri BASE_CONTENT_URI = Uri.parse("content://" + CONTENT_AUTHORITY);
    String TYPE_PACKAGE_PREFIX = "/vnd.projectbuendia.client.";

    /** Names of tables in the local datastore. */
    enum Table {
        BOOKMARKS("bookmarks"),
        CHART_ITEMS("chart_items"),
        CONCEPTS("concepts"),
        FORMS("forms"),
        LOCATIONS("locations"),
        MISC("misc"),
        OBSERVATIONS("observations"),
        ORDERS("orders"),
        PATIENTS("patients"),
        USERS("users");

        public String name;

        public String toString() {
            return name;
        }

        Table(String name) {
            this.name = name;
        }
    }

    // Each interface below corresponds to one SQLite table in the local datastore.  The column
    // names defined in the constants should exactly match the schemas defined in Database.java.

    interface Bookmarks {
        Uri URI = buildContentUri("bookmarks");
        String ITEM_TYPE = buildItemType("bookmark");
        String TABLE_NAME = "table_name";
        String BOOKMARK = "bookmark";
    }

    interface ChartItems {
        Uri URI = buildContentUri("chart-items");
        String GROUP_TYPE = buildGroupType("chart-item");
        String ITEM_TYPE = buildItemType("chart-item");

        // Sections and items from all charts are stored in this table.  Sections are rows with
        // a section_type and no parent_id; items are rows with a parent_id pointing to a section.
        // To get the description of a chart, filter for a specific chart_uuid and order by weight.

        String ROWID = "rowid";
        String CHART_UUID = "chart_uuid";
        String WEIGHT = "weight";  // sort order
        String SECTION_TYPE = "section_type";  // "TILE_ROW" or "GRID_SECTION" (for sections only)
        String PARENT_ROWID = "parent_rowid";  // null for sections, non-null for items only

        String LABEL = "label";  // label for sections or items
        String TYPE = "type";  // null for sections, rendering type for items only
        String REQUIRED = "required";  // 0 = show in grid if obs exist; 1 = show in grid always
        String CONCEPT_UUIDS = "concept_uuids";  // comma-separated list of concept UUIDs
        String FORMAT = "format";  // format string (see ObsFormat)
        String CAPTION_FORMAT = "caption_format";  // format string for tile caption or grid popup
        String CSS_CLASS = "css_class";  // format string for CSS class on a tile or grid row
        String CSS_STYLE = "css_style";  // format string for CSS properties on a tile or grid row
        String SCRIPT = "script";  // JavaScript for fancy rendering
    }

    interface Concepts {
        Uri URI = buildContentUri("concepts");
        String GROUP_TYPE = buildGroupType("concept");
        String ITEM_TYPE = buildItemType("concept");

        String UUID = "uuid";
        String XFORM_ID = "xform_id";  // ID for the concept in XForms (OpenMRS ID)
        String TYPE = "type";  // data type name, e.g. NUMERIC, TEXT
        String NAME = "name";
    }

    interface Forms {
        Uri URI = buildContentUri("forms");
        String GROUP_TYPE = buildGroupType("form");
        String ITEM_TYPE = buildItemType("form");

        String UUID = "uuid";
        String NAME = "name";
        String VERSION = "version";
    }

    interface Locations {
        Uri URI = buildContentUri("locations");
        String GROUP_TYPE = buildGroupType("location");
        String ITEM_TYPE = buildItemType("location");

        String UUID = "uuid";
        String NAME = "name";
        String PARENT_UUID = "parent_uuid"; // parent location or null
    }

    interface Misc {
        Uri URI = BASE_CONTENT_URI.buildUpon().appendPath("misc").appendPath("0").build();
        String ITEM_TYPE = buildItemType("misc");

        /**
         * The start time of the last full sync operation, according to the
         * local (client's) clock.  Since sync operations are transactional,
         * this should only be set if this sync was completed successfully.
         * <p/>
         * <p>Updated at the very beginning of full sync operations.
         */
        String FULL_SYNC_START_MILLIS = "full_sync_start_millis";

        /**
         * The end time of the last full sync operation, according to the
         * local (client's) clock.  In rare cases, this may correspond to a
         * sync that completed but downloaded incomplete data.
         * <p/>
         * <p>Updated at the very end of full sync operations.
         */
        String FULL_SYNC_END_MILLIS = "full_sync_end_millis";

    }

    interface Observations {
        Uri URI = buildContentUri("observations");
        String GROUP_TYPE = buildGroupType("observation");
        String ITEM_TYPE = buildItemType("observation");

        /**
         * UUID is populated if the record was retrieved from the server. If this observation was
         * written locally as a cached value from a submitted XForm, UUID is null. As part of every
         * successful sync, all observations with null UUIDs are deleted, on the basis that an
         * authoritative version for each has been obtained from the server.
         */
        String UUID = "uuid";
        String ENCOUNTER_UUID = "encounter_uuid";
        String PATIENT_UUID = "patient_uuid";
        String PROVIDER_UUID = "provider_uuid";
        String CONCEPT_UUID = "concept_uuid";
        String TYPE = "type";
        String MILLIS = "millis";
        String ORDER_UUID = "order_uuid";
        String VALUE = "value";  // concept value or order UUID
        String VOIDED = "voided";
    }

    interface Orders {
        Uri URI = buildContentUri("orders");
        String GROUP_TYPE = buildGroupType("order");
        String ITEM_TYPE = buildItemType("order");

        String UUID = "uuid";
        String PATIENT_UUID = "patient_uuid";
        String PROVIDER_UUID = "provider_uuid";
        String INSTRUCTIONS = "instructions";
        String START_MILLIS = "start_millis";  // milliseconds since epoch
        String STOP_MILLIS = "stop_millis";  // milliseconds since epoch
    }

    interface Patients {
        Uri URI = buildContentUri("patients");
        String GROUP_TYPE = buildGroupType("patient");
        String ITEM_TYPE = buildItemType("patient");

        String UUID = "uuid";
        String ID = "id";
        String GIVEN_NAME = "given_name";
        String FAMILY_NAME = "family_name";
        String BIRTHDATE = "birthdate";  // a local date in yyyy-mm-dd format
        String SEX = "sex";
        String PREGNANCY = "pregnancy";  // denormalized observation
        String LOCATION_UUID = "location_uuid";  // denormalized observation
        String BED_NUMBER = "bed_number";  // denormalized observation
    }

    interface Users {
        Uri URI = buildContentUri("users");
        String GROUP_TYPE = buildGroupType("user");
        String ITEM_TYPE = buildItemType("user");

        String UUID = "uuid";
        String FULL_NAME = "full_name";
    }

    // Each interface below describes a derived view implemented by a custom
    // ProviderDelegate.  The column name constants should match the columns
    // returned by the query() method of the corresponding ProviderDelegate.

    interface PatientCounts {
        Uri URI = buildContentUri("patient-counts");
        String GROUP_TYPE = buildGroupType("patient-count");
        String ITEM_TYPE = buildItemType("patient-count");

        String LOCATION_UUID = "location_uuid";
        String PATIENT_COUNT = "patient_count";
    }

    static Uri buildContentUri(String path) {
        return BASE_CONTENT_URI.buildUpon().appendPath(path).build();
    }

    static String buildGroupType(String name) {
        return ContentResolver.CURSOR_DIR_BASE_TYPE + TYPE_PACKAGE_PREFIX + name;
    }

    static String buildItemType(String name) {
        return ContentResolver.CURSOR_ITEM_BASE_TYPE + TYPE_PACKAGE_PREFIX + name;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.providers;

import android.content.UriMatcher;
import android.net.Uri;
import android.util.SparseArray;

import android.database.sqlite.SQLiteOpenHelper;

import java.util.concurrent.atomic.AtomicInteger;

/** A registry for {@link ProviderDelegate}s. */
class ProviderDelegateRegistry<T extends SQLiteOpenHelper> {

    private final UriMatcher mUriMatcher;
    private final AtomicInteger mCodeGenerator;

    private final SparseArray<ProviderDelegate<T>> mDelegates;

    ProviderDelegateRegistry() {
        mUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
        mCodeGenerator = new AtomicInteger(1);
        mDelegates = new SparseArray<>();
    }

    /**
     * Registers the specified delegate to handle the specified path.
     * @throws IllegalStateException if the specified path is already being handled by another
     *                               delegate
     */
    void registerDelegate(String path, ProviderDelegate<T> delegate) {
        int existingCode = mUriMatcher.match(
            Uri.parse("content://" + Contracts.CONTENT_AUTHORITY + "/" + path));
        if (existingCode != UriMatcher.NO_MATCH) {
            throw new IllegalStateException(
                "Path '" + path + "' is already registered to be handled by '"
                    + mDelegates.get(existingCode).toString() + "'.");
        }
        int code = mCodeGenerator.getAndIncrement();
        mUriMatcher.addURI(Contracts.CONTENT_AUTHORITY, path, code);
        mDelegates.put(code, delegate);
    }

    /**
     * Returns the {@link ProviderDelegate} for the specified {@link Uri}.
     * @throws IllegalArgumentException if no matching delegate is registered
     */
    ProviderDelegate<T> getDelegate(Uri uri) {
        int code = mUriMatcher.match(uri);
        if (code == UriMatcher.NO_MATCH) {
            throw new IllegalArgumentException(
                "No ProviderDelegate registered for URI '" + uri.toString() + "'.");
        }

        return mDelegates.get(code);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.providers;

import android.content.ContentProvider;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.database.Cursor;
import android.net.Uri;

import android.database.sqlite.SQLiteOpenHelper;

/** A delegate used to handle a single URI for {@link DelegatingProvider}. */
public interface ProviderDelegate<T extends SQLiteOpenHelper> {

    static final String TYPE_PACKAGE_PREFIX = "/vnd.projectbuendia.client.";

    /** Returns the MIME type this delegate provides. */
    String getType();

    /**
     * Handles a query request.
     * @see ContentProvider#query
     */
    Cursor query(
        T dbHelper, ContentResolver contentResolver, Uri uri, String[] projection,
        String selection, String[] selectionArgs, String sortOrder);

    /**
     * Handles an insert request.
     * @see ContentProvider#insert
     */
    Uri insert(
        T dbHelper, ContentResolver contentResolver, Uri uri, ContentValues values);

    /**
     * Handles a bulk insert request.
     * @see ContentProvider#bulkInsert
     */
    int bulkInsert(
        T dbHelper, ContentResolver contentResolver, Uri uri, ContentValues[] values);

    /**
     * Handles a delete request.
     * @see ContentProvider#delete
     */
    public int delete(
        T dbHelper, ContentResolver contentResolver, Uri uri, String selection,
        String[] selectionArgs);

    /**
     * Handles an update request.
     * @see ContentProvider#update
     */
    int update(
        T dbHelper, ContentResolver contentResolver, Uri uri, ContentValues values,
        String selection, String[] selectionArgs);
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.providers;

import org.projectbuendia.client.providers.Contracts.Bookmarks;
import org.projectbuendia.client.providers.Contracts.ChartItems;
import org.projectbuendia.client.providers.Contracts.Concepts;
import org.projectbuendia.client.providers.Contracts.Forms;
import org.projectbuendia.client.providers.Contracts.Locations;
import org.projectbuendia.client.providers.Contracts.Misc;
import org.projectbuendia.client.providers.Contracts.Observations;
import org.projectbuendia.client.providers.Contracts.Orders;
import org.projectbuendia.client.providers.Contracts.Patients;
import org.projectbuendia.client.providers.Contracts.Table;
import org.projectbuendia.client.providers.Contracts.Users;
import org.projectbuendia.client.sync.Database;

/** A {@link DelegatingProvider} for MSF record info such as patients and locations. */
public class BuendiaProvider extends DelegatingProvider<Database> {

    /** Starts a transaction with the given savepoint name. */
    public DatabaseTransaction startTransaction(String name) {
        return new DatabaseTransaction(mDatabaseHelper, name);
    }

    @Override protected Database createDatabaseHelper() {
        return new Database(getContext());
    }

    @Override protected ProviderDelegateRegistry<Database> getRegistry() {
        ProviderDelegateRegistry<Database> registry = new ProviderDelegateRegistry<>();

        // Providers for groups of things (e.g., all charts).
        registry.registerDelegate(ChartItems.URI.getPath(),
            new GroupProviderDelegate(ChartItems.GROUP_TYPE, Table.CHART_ITEMS));
        registry.registerDelegate(Concepts.URI.getPath(),
            new GroupProviderDelegate(Concepts.GROUP_TYPE, Table.CONCEPTS));
        registry.registerDelegate(Forms.URI.getPath(),
            new GroupProviderDelegate(Forms.GROUP_TYPE, Table.FORMS));
        registry.registerDelegate(Locations.URI.getPath(),
            new GroupProviderDelegate(Locations.GROUP_TYPE, Table.LOCATIONS));
        registry.registerDelegate(Observations.URI.getPath(),
            new GroupProviderDelegate(Observations.GROUP_TYPE, Table.OBSERVATIONS));
        registry.registerDelegate(Orders.URI.getPath(),
            new GroupProviderDelegate(Orders.GROUP_TYPE, Table.ORDERS));
        registry.registerDelegate(Patients.URI.getPath(),
            new GroupProviderDelegate(Patients.GROUP_TYPE, Table.PATIENTS));
        registry.registerDelegate(Users.URI.getPath(),
            new GroupProviderDelegate(Users.GROUP_TYPE, Table.USERS));

        // Providers for individual things (e.g., user with a specific ID).
        registry.registerDelegate(Concepts.URI.getPath() + "/*",
            new ItemProviderDelegate(Forms.GROUP_TYPE, Table.CONCEPTS, Concepts.UUID));
        registry.registerDelegate(Forms.URI.getPath() + "/*",
            new ItemProviderDelegate(Forms.GROUP_TYPE, Table.FORMS, Forms.UUID));
        registry.registerDelegate(Locations.URI.getPath() + "/*",
            new ItemProviderDelegate(Locations.ITEM_TYPE, Table.LOCATIONS, Locations.UUID));
        registry.registerDelegate(Observations.URI.getPath() + "/*",
            new ItemProviderDelegate(Observations.ITEM_TYPE, Table.OBSERVATIONS, Observations.UUID));
        registry.registerDelegate(Orders.URI.getPath() + "/*",
            new InsertableItemProviderDelegate(Orders.ITEM_TYPE, Table.ORDERS, Orders.UUID));
        registry.registerDelegate(Patients.URI.getPath() + "/*",
            new ItemProviderDelegate(Patients.ITEM_TYPE, Table.PATIENTS, Patients.UUID));
        registry.registerDelegate(Users.URI.getPath() + "/*",
            new ItemProviderDelegate(Users.ITEM_TYPE, Table.USERS, Users.UUID));

        // Custom providers with special logic.
        registry.registerDelegate(Contracts.PatientCounts.URI.getPath(),
            new PatientCountsDelegate());

        // Content provider for our single-row table for storing miscellaneous values.
        registry.registerDelegate(Misc.URI.getPath(),
            new InsertableItemProviderDelegate(Misc.ITEM_TYPE, Table.MISC, "rowid"));

        // Custom provider for our bookmark table.
        registry.registerDelegate(Bookmarks.URI.getPath(),
            new GroupProviderDelegate(Bookmarks.ITEM_TYPE, Table.BOOKMARKS));
        registry.registerDelegate(Bookmarks.URI.getPath() + "/*",
                new ItemProviderDelegate(Bookmarks.ITEM_TYPE, Table.BOOKMARKS, Bookmarks.TABLE_NAME));

        return registry;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.providers;

import android.content.ContentResolver;
import android.content.ContentValues;
import android.net.Uri;

import android.database.sqlite.SQLiteDatabase;

import org.projectbuendia.client.sync.Database;

import java.util.List;

/**
 * A {@link ItemProviderDelegate} that supports insertion. Insertion operations will be treated as
 * upserts -- e.g. fields not explicitly overwritten from older entries will be retained.
 */
public class InsertableItemProviderDelegate extends ItemProviderDelegate {

    public InsertableItemProviderDelegate(String name, Contracts.Table table, String idColumn) {
        super(name, table, idColumn);
    }

    @Override public Uri insert(
        Database dbHelper, ContentResolver contentResolver, Uri uri,
        ContentValues values) {
        // Perform an upsert operation, updating only the columns specified in values.
        int done = 0;
        if (mIdColumn != null) {
            values.put(mIdColumn, uri.getLastPathSegment());
            done = dbHelper.getWritableDatabase().updateWithOnConflict(
                mTable.name, values, mIdColumn + "= ?", new String[] {uri.getLastPathSegment()},
                SQLiteDatabase.CONFLICT_IGNORE);
        }
        if (done == 0) {
            dbHelper.getWritableDatabase().insertWithOnConflict(
                mTable.name, null, values, SQLiteDatabase.CONFLICT_IGNORE);
        }
        contentResolver.notifyChange(uri, null, false);
        return getPrefixUriBuilder(uri).appendPath(uri.getLastPathSegment()).build();
    }

    private static Uri.Builder getPrefixUriBuilder(Uri uri) {
        Uri.Builder prefixBuilder = uri.buildUpon()
            .path("");
        List<String> pathSegments = uri.getPathSegments();
        for (int i = 0; i < pathSegments.size() - 1; i++) {
            prefixBuilder.appendPath(pathSegments.get(i));
        }

        return prefixBuilder;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.utils;

import android.os.AsyncTask;
import android.os.Handler;
import android.os.Looper;

/** Runs async tasks in a unit-testable way. */
public interface AsyncTaskRunner {

    public static final AsyncTaskRunner DEFAULT = new AsyncTaskRunner() {
        @Override @SafeVarargs
        public final <ParamsT, ProgressT, ResultT> void runTask(
            final AsyncTask<ParamsT, ProgressT, ResultT> asyncTask,
            final ParamsT... params) {
            // Force the AsyncTask to start from the main thread (since using any other thread will
            // result in an exception, anyway).
            Handler mainHandler = new Handler(Looper.getMainLooper());
            mainHandler.post(() -> asyncTask.execute(params));
        }
    };

    @SuppressWarnings("unchecked")
    public <ParamsT, ProgressT, ResultT> void runTask(
        AsyncTask<ParamsT, ProgressT, ResultT> asyncTask,
        ParamsT... params);
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.utils;

import org.joda.time.DateTime;
import org.joda.time.Days;
import org.joda.time.Duration;
import org.joda.time.LocalDate;

/**
 * An object that pretty-prints JODA {@link LocalDate}s using relative phrases
 * such as "4 days ago" or "yesterday".
 */
public class RelativeDateTimeFormatter {
    public RelativeDateTimeFormatter() {
    }

    public String format(LocalDate date) {
        return format(date, LocalDate.now());
    }

    /** Formats a representation of {@code date} relative to {@code anchor}. */
    public String format(LocalDate date, LocalDate anchor) {
        if (date.isAfter(anchor)) {
            return "in the future"; // TODO/i18n
        }
        int daysAgo = Days.daysBetween(date, anchor).getDays();
        return daysAgo > 1 ? daysAgo + " days ago" : // TODO/i18n
            daysAgo == 1 ? "yesterday" : "today"; // TODO/i18n
    }

    public String format(DateTime dateTime) {
        return format(dateTime, DateTime.now());
    }

    /** Formats a representation of {@code dateTime} relative to {@code anchor}. */
    public String format(DateTime dateTime, DateTime anchor) {
        if (dateTime.isAfter(anchor)) {
            return "in the future"; // TODO/i18n
        }

        long millis = new Duration(dateTime, anchor).getMillis();
        long daysAgo = millis / Utils.DAY;
        long hoursAgo = millis / Utils.HOUR;
        long minutesAgo = millis / Utils.MINUTE;

        return daysAgo > 1 ? daysAgo + " days ago" : // TODO/i18n
            hoursAgo > 1 ? hoursAgo + " hours ago" : // TODO/i18n
                minutesAgo > 1 ? minutesAgo + " min ago" : // TODO/i18n
                    "right now"; // TODO/i18n
    }
}

package org.projectbuendia.client.utils;

import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/** A multilanguage string, made from a string of the form "cat [fr:chat] [es:gato]". */
public class Intl {
    private static final Pattern BRACKETED_PATTERN = Pattern.compile("\\[(.*?)\\]");
    private static final Pattern EXTRA_SPACES = Pattern.compile("^ *| *$");

    protected final String base;
    protected final Map<String, String> options;

    public Intl(String packed) {
        if (packed == null) packed = "";
        String unpacked = BRACKETED_PATTERN.matcher(packed).replaceAll("");
        base = EXTRA_SPACES.matcher(unpacked).replaceAll("");
        options = new HashMap<>();
        Matcher matcher = BRACKETED_PATTERN.matcher(packed);
        for (int pos = 0; matcher.find(pos); pos = matcher.end(1)) {
            String[] parts = Utils.splitFields(matcher.group(1), ":", 2);
            options.put(parts[0], parts[1]);
        }
    }

    public Intl(String base, Map<String, String> options) {
        this.base = base;
        this.options = options;
    }

    public String loc(Locale locale) {
        if (options == null || options.isEmpty() || locale == null) return base;

        String tag = Utils.toLanguageTag(locale);
        if (options.containsKey(tag)) return options.get(tag);

        String lang = locale.getLanguage();
        String region = locale.getCountry();
        String variant = locale.getVariant();
        tag = Utils.toLanguageTag(new Locale(lang, region, variant));
        if (options.containsKey(tag)) return options.get(tag);
        tag = Utils.toLanguageTag(new Locale(lang, region));
        if (options.containsKey(tag)) return options.get(tag);
        tag = Utils.toLanguageTag(new Locale(lang));
        if (options.containsKey(tag)) return options.get(tag);

        return base;
    }

    public String[] getAll() {
        String[] values = options.values().toArray(new String[0]);
        String[] results = new String[values.length + 1];
        results[0] = base;
        System.arraycopy(values, 0, results, 1, values.length);
        return results;
    }

    public static Intl[] newArray(String... strings) {
        Intl[] intls = new Intl[strings.length];
        for (int i = 0; i < intls.length; i++) {
            intls[i] = new Intl(strings[i]);
        }
        return intls;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.utils;

import android.util.Log;

import org.projectbuendia.client.BuildConfig;

import java.util.HashMap;
import java.util.Map;

// @nolint

/**
 * A logging facade that provides enhanced functionality and convenience methods over Android's
 * {@link Log}.
 * <p/>
 * <p>{@link Logger} provides the following benefits:
 * <p/>
 * <ul>
 * <li>Automatic tagging with the calling class's class name.
 * <li>Suppression of verbose, debug, and info messages in release builds.
 * <li>Support for format strings without a separate call to {@link String#format}.
 * </ul>
 * <p/>
 * <p>To use this class, create an instance of {@link Logger} by calling:
 * <code>
 * private static final Logger LOG = Logger.create();
 * </code>
 * <p/>
 * <p>Then, invoke logging methods on the {@code LOG} instance:
 * <code>
 * LOG.e(exception, "Logger is #%1$d!", 1);
 * </code>
 */
public final class Logger {

    private static final int MAX_TAG_LENGTH = 23;
    public final String tag;

    private static Map<String, Long> startTimes = new HashMap<>();
    private static Map<String, Long> lastTimes = new HashMap<>();

    /** Creates a {@link Logger} with the calling class's class name as a tag. */
    public static Logger create() {
        return new Logger(getTag());
    }

    private static String getTag() {
        String[] parts = new Throwable().getStackTrace()[2].getClassName().split("\\.");
        String tag = "buendia/" + parts[parts.length - 1];
        if (tag.length() > MAX_TAG_LENGTH) {
            return tag.substring(0, MAX_TAG_LENGTH);
        } else {
            return tag;
        }
    }

    /** Creates a {@link Logger} with a manually-specified tag. */
    public static Logger create(String tag) {
        if (tag.length() > MAX_TAG_LENGTH) {
            throw new IllegalArgumentException("Tag length should be less than " + MAX_TAG_LENGTH);
        }
        return new Logger(tag);
    }

    public void v(String message, Object... args) {
        if (BuildConfig.DEBUG) {
            Log.v(tag, formatIfNeeded(message, args));
        }
    }

    private static String formatIfNeeded(String message, Object... args) {
        if (args == null || args.length == 0) {
            return message;
        } else {
            return String.format(message, args);
        }
    }

    public void v(Throwable t, String message, Object... args) {
        if (BuildConfig.DEBUG) {
            Log.v(tag, formatIfNeeded(message, args), t);
        }
    }

    public void d(String message, Object... args) {
        if (BuildConfig.DEBUG) {
            Log.d(tag, formatIfNeeded(message, args));
        }
    }

    public void d(Throwable t, String message, Object... args) {
        if (BuildConfig.DEBUG) {
            Log.d(tag, formatIfNeeded(message, args), t);
        }
    }

    public void i(String message, Object... args) {
        Log.i(tag, formatIfNeeded(message, args));
    }

    public void i(Throwable t, String message, Object... args) {
        Log.i(tag, formatIfNeeded(message, args), t);
    }

    public void w(String message, Object... args) {
        Log.w(tag, formatIfNeeded(message, args));
    }

    public void w(Throwable t, String message, Object... args) {
        Log.w(tag, formatIfNeeded(message, args), t);
    }

    public void e(String message, Object... args) {
        Log.e(tag, formatIfNeeded(message, args));
    }

    public void e(Throwable t, String message, Object... args) {
        Log.e(tag, formatIfNeeded(message, args), t);
    }

    public void start(String key) {
        start(key, "Starting");
    }

    public void start(String key, String message, Object... args) {
        long now = System.currentTimeMillis();
        if (startTimes.containsKey(key)) {
            finish(key, "(timer discarded)");
        }
        startTimes.put(key, now);
        lastTimes.put(key, now);
        String formatted = formatIfNeeded(message, args);
        Log.d(tag, "[_" + key + "__ 0 ms: " + formatted);
    }

    public void elapsed(String key, String message, Object... args) {
        elapsedOrFinish(false, key, message, args);
    }

    public void finish(String key) {
        finish(key, "Finished");
    }

    public void finish(String key, String message, Object... args) {
        elapsedOrFinish(true, key, message, args);
    }

    private void elapsedOrFinish(boolean finish, String key, String message, Object... args) {
        long now = System.currentTimeMillis();
        Long start = startTimes.get(key);
        Long last = lastTimes.get(key);
        if (start == null || last == null) {
            start(key, "(timer not started) " + message, args);
        } else {
            String formatted = formatIfNeeded(message, args);
            String timing = "+" + (now - last);
            if (!start.equals(last)) timing += " = " + (now - start);
            String prefix = "__" + key + (finish ? "_]" : "__");
            Log.d(tag, prefix + " " + timing + " ms: " + formatted);
            lastTimes.put(key, now);
        }
        if (finish) {
            startTimes.remove(key);
            lastTimes.remove(key);
        }
    }

    private Logger(String tag) {
        this.tag = tag;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.utils;

import android.app.Activity;
import android.app.ActivityOptions;
import android.app.Dialog;
import android.content.Intent;
import android.database.Cursor;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.View;
import android.view.ViewGroup;
import android.view.Window;
import android.view.WindowManager;
import android.widget.EditText;
import android.widget.TextView;

import com.android.volley.AuthFailureError;
import com.android.volley.Request;
import com.google.common.collect.Lists;

import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.joda.time.Days;
import org.joda.time.Instant;
import org.joda.time.Interval;
import org.joda.time.LocalDate;
import org.joda.time.Period;
import org.joda.time.ReadableInstant;
import org.joda.time.ReadablePartial;
import org.joda.time.base.AbstractInstant;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.client.json.JsonUser;
import org.projectbuendia.client.net.Server;

import java.io.File;
import java.io.PrintWriter;
import java.io.Serializable;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Method;
import java.math.BigInteger;
import java.net.URLEncoder;
import java.text.Normalizer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

/** Utility methods. */
public class Utils {
    public static final int SECOND = 1000;  // in ms
    public static final int MINUTE = 60 * SECOND;  // in ms
    public static final int HOUR = 60 * MINUTE;  // in ms
    public static final int DAY = 24 * HOUR;  // in ms

    public static final String EN_DASH = "\u2013";
    public static final String EM_DASH = "\u2014";
    public static final String BULLET = "\u2022";

    // Minimum and maximum representable Instant, DateTime, and LocalDate values.
    public static final Instant MIN_TIME = new Instant(Long.MIN_VALUE);
    public static final Instant MAX_TIME = new Instant(Long.MAX_VALUE);
    public static final DateTime MIN_DATETIME = new DateTime(MIN_TIME, DateTimeZone.UTC);
    public static final DateTime MAX_DATETIME = new DateTime(MAX_TIME, DateTimeZone.UTC);
    public static final LocalDate MIN_DATE = new LocalDate(0, 1, 1).year().withMinimumValue();
    public static final LocalDate MAX_DATE = new LocalDate(0, 12, 31).year().withMaximumValue();

    private static Map<Integer, String> sHttpMethods = initHttpMethods();
    private static Map<Integer, String> initHttpMethods() {
        Map<Integer, String> map = new HashMap<>();
        map.put(Request.Method.DEPRECATED_GET_OR_POST, "DEPRECATED_GET_OR_POST");
        map.put(Request.Method.GET, "GET");
        map.put(Request.Method.POST, "POST");
        map.put(Request.Method.PUT, "PUT");
        map.put(Request.Method.DELETE, "DELETE");
        map.put(Request.Method.HEAD, "HEAD");
        map.put(Request.Method.OPTIONS, "OPTIONS");
        map.put(Request.Method.TRACE, "TRACE");
        map.put(Request.Method.PATCH, "PATCH");
        return map;
    }


    /** Prevent instantiation. */
    private Utils() { }


    // ==== Basic types ====

    // Java's default .equals() and == are both broken whereas Objects.equals is
    // usually correct, so let's make its logic available under a short, easy name.
    public static boolean eq(Object a, Object b) {
        // noinspection EqualsReplaceableByObjectsCall (this is deliberately inlined)
        return (a == b) || (a != null && a.equals(b));
    }

    public static boolean eqAny(Object x, Object... values) {
        for (Object value : values) {
            if (eq(x, value)) return true;
        }
        return false;
    }

    /** Returns a value if that value is not null, or a specified default value otherwise. */
    public static @Nonnull <T> T orDefault(@Nullable T value, @Nonnull T defaultValue) {
        return value != null ? value : defaultValue;
    }

    /** Returns a value if that value is not null, or a specified default value otherwise. */
    public static @Nonnull String nonemptyOrDefault(@Nullable String value, @Nonnull String defaultValue) {
        return isEmpty(value) ? defaultValue : value;
    }

    /** Converts nulls to a default integer value. */
    public static int toNonnull(@Nullable Integer n, int defaultValue) {
        return n == null ? defaultValue : n;
    }

    /** The same operation as map.getOrDefault(key), which is only available in API 24+. */
    public static <K, V> V getOrDefault(Map<K, V> map, K key, V defaultValue) {
        return map.containsKey(key) ? map.get(key) : defaultValue;
    }

    /** Safely index into an array, clamping the index if it's out of bounds. */
    public static <T> T safeIndex(T[] array, int index) {
        if (array.length == 0) return null;
        if (index < 0) index = 0;
        if (index > array.length - 1) index = array.length - 1;
        return array[index];
    }

    /** Converts a list of Strings to an array of Strings. */
    public static String[] toStringArray(List<String> items) {
        if (items == null) return new String[0];
        return items.toArray(new String[0]);
    }

    /** Converts a list of Longs to an array of primitive longs. */
    public static long[] toLongArray(List<Long> items) {
        if (items == null) return new long[0];
        long[] array = new long[items.size()];
        int i = 0;
        for (Long item : items) {
            array[i++] = item;
        }
        return array;
    }

    /** Provides Math.floorMod for Android versions prior to API level 24, d > 0. */
    public static int floorMod(int x, int d) {
        return ((x % d) + d) % d;
    }

    /** Provides Math.floorDiv for Android versions prior to API level 24, d > 0. */
    public static int floorDiv(int x, int d) {
        return (x - floorMod(x, d)) / d;
    }

    /** Formats a number to the minimum necessary number of decimal places. */
    public static String format(double x, int maxPrec) {
        String result = String.format("%." + maxPrec + "f", x);
        if (result.contains("e")) return result;
        if (!result.contains(".") && !result.contains(",")) return result;
        return result.replaceAll("[.,]?0*$", "");
    }

    // ==== Collections ====

    public static boolean isEmpty(Object obj) {
        if (obj instanceof Collection) {
            return isEmpty((Collection) obj);
        }
        if (obj instanceof String) {
            return eq(obj, "");
        }
        if (obj instanceof Object[]) {
            return ((Object[]) obj).length == 0;
        }
        return obj == null;
    }

    /** Performs a null-safe check for a null or empty array. */
    public static <T> boolean isEmpty(@Nullable T[] array) {
        return array == null || array.length == 0;
    }

    /** Performs a null-safe check for a null or empty Collection. */
    public static boolean isEmpty(@Nullable Collection collection) {
        return collection == null || collection.size() == 0;
    }

    /** Converts nulls to empty Lists. */
    public static <T> List<T> toNonnull(@Nullable List<T> list) {
        return list != null ? list : Arrays.<T>asList();
    }

    /** Performs a null-safe check for an array with at least one item. */
    public static <T> boolean hasItems(@Nullable T[] array) {
        return array != null && array.length > 0;
    }

    /** Performs a null-safe check for a Collection with at least one item. */
    public static boolean hasItems(@Nullable Collection collection) {
        return collection != null && collection.size() > 0;
    }

    /** Concatenates two arrays. */
    public static <T> T[] concat(T[] a, T[] b) {
        List<T> result = new ArrayList<>(Arrays.asList(a));
        result.addAll(Arrays.asList(b));
        return result.toArray(b);
    }

    /** Prepends an item to an array to yield a new array. */
    public static <T> T[] concat(T a, T[] b) {
        List<T> result = new ArrayList<>(Arrays.asList(a));
        result.addAll(Arrays.asList(b));
        return result.toArray(b);
    }

    /** Appends an item to an array to yield a new array. */
    public static <T> T[] concat(T[] a, T b) {
        List<T> result = new ArrayList<>(Arrays.asList(a));
        result.add(b);
        return result.toArray(a);
    }

    /** Gets an item given a Pythonic list index, or null if out of bounds. */
    public static <T> @Nullable T getitem(List<T> list, int index) {
      int n = list.size();
      if (index < 0) index += n;
      if (index > n) index = n;
      return (index >= 0 && index < n) ? list.get(index) : null;
    }

    public static <T> @Nullable T first(List<T> list) {
        return getitem(list, 0);
    }

    public static <T> @Nullable T last(List<T> list) {
        return getitem(list, -1);
    }

    public static <T> List<T> slice(List<T> list, int start, int stop) {
        int n = list.size();
        if (start < 0) start += n;
        if (stop < 0) stop += n;
        if (start > n) start = n;
        if (stop > n) stop = n;
        return list.subList(start, stop);
    }


    // ==== Strings ====

    /** Performs a null-safe check for a null or empty String. */
    public static boolean isEmpty(@Nullable String str) {
        return str == null || str.length() == 0;
    }

    /** Performs a null-safe check for a null, empty, or whitespace String. */
    public static boolean isBlank(@Nullable String str) {
        return str == null || str.length() == 0 || str.trim().length() == 0;
    }

    /** Performs a null-safe check for a String with at least one character. */
    public static boolean hasChars(@Nullable String str) {
        return str != null && str.length() > 0;
    }

    /** Converts empty strings to null. */
    public static @Nullable String toNonemptyOrNull(@Nullable String str) {
        return isEmpty(str) ? null : str;
    }

    /** Converts nulls to empty strings. */
    public static @Nonnull String toNonnull(@Nullable String str) {
        return str != null ? str : "";
    }

    /** Calls toString() on a nullable object, returning an empty string if null. */
    public static @Nonnull String toNonnullString(@Nullable Object obj) {
        return obj != null ? obj.toString() : "";
    }

    /** Calls toString() on a nullable object, returning null if the object is null. */
    public static @Nullable String toNullableString(@Nullable Object obj) {
        return obj != null ? obj.toString() : null;
    }

    /** Calls toString() on a nullable object, returning a default value if the object is null. */
    public static @Nonnull String toStringOrDefault(@Nullable Object obj, @Nonnull String defaultValue) {
        return obj != null ? obj.toString() : defaultValue;
    }

    /** Formats a string using ASCII encoding. */
    public static String format(String template, Object... args) {
        return String.format(Locale.US, template, args);
    }

    /** Splits a string, returning an array padded out to known length with empty strings. */
    public static String[] splitFields(String text, String separator, int count) {
        String[] fields = text.split(separator, -1);
        String[] result = new String[count];
        for (int i = 0; i < count; i++) {
            result[i] = i < fields.length ? fields[i] : "";
        }
        return result;
    }

    /** URL-encodes a nullable string, catching the useless exception that never happens. */
    public static String urlEncode(@Nullable String s) {
        if (s == null) {
            return "";
        }
        try {
            // Oh Java, how you make the simplest operation a waste of millions of programmer-hours.
            return URLEncoder.encode(s, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            throw new AssertionError("UTF-8 should be supported in every JVM");
        }
    }


    // ==== Number parsing ====

    /** Converts a String to an integer, returning null if parsing fails. */
    public static Integer toIntOrNull(@Nullable String str) {
        if (str == null) return null;
        try {
            return Integer.valueOf(str);
        } catch (NumberFormatException e) {
            return null;
        }
    }

    /** Converts a String to an integer, returning a default value if parsing fails. */
    public static int toIntOrDefault(String str, int defaultValue) {
        Integer value = toIntOrNull(str);
        return value == null ? defaultValue : value;
    }

    /** Converts a String to a long integer, returning null if parsing fails. */
    public static @Nullable Long toLongOrNull(@Nullable String str) {
        if (str == null) return null;
        try {
            return Long.parseLong(str);
        } catch (NumberFormatException e) {
            return null;
        }
    }

    /** Converts a String to a double, returning null if parsing fails. */
    public static @Nullable Double toDoubleOrNull(@Nullable String str) {
        if (str == null) return null;
        try {
            return Double.parseDouble(str.trim());
        } catch (NumberFormatException e) {
            return null;
        }
    }

    /** Converts a String to a double, returning a default value if parsing fails. */
    public static double toDoubleOrDefault(@Nullable String str, double defaultValue) {
        Double value = toDoubleOrNull(str);
        return value == null ? defaultValue : value;
    }

    /** Converts objects of integer types to longs. */
    public static Long toLongOrNull(Object obj) {
        if (obj instanceof Integer) return (long) (Integer) obj;
        if (obj instanceof Long) return (long) obj;
        if (obj instanceof BigInteger) return ((BigInteger) obj).longValue();
        if (obj instanceof String) return toLongOrNull((String) obj);
        return null;
    }

    /** Converts objects of integer types to BigIntegers. */
    public static BigInteger toBigInteger(Object obj) {
        if (obj instanceof Integer) return BigInteger.valueOf(((Integer) obj).longValue());
        if (obj instanceof Long) return BigInteger.valueOf((Long) obj);
        if (obj instanceof BigInteger) return (BigInteger) obj;
        return null;
    }


    // ==== Dates and times ====

    private static final DateTimeFormatter ISO8601_UTC_DATETIME_FORMATTER =
        DateTimeFormat.forPattern("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'").withZoneUTC();

    /** Returns the lesser of two DateTimes, treating null as the greatest value. */
    public static @Nullable DateTime min(DateTime a, DateTime b) {
        return a == null ? b : b == null ? a : a.isBefore(b) ? a : b;
    }

    /** Returns the greater of two DateTimes, treating null as the least value. */
    public static @Nullable DateTime max(DateTime a, DateTime b) {
        return a == null ? b : b == null ? a : a.isAfter(b) ? a : b;
    }

    /** Converts a nullable LocalDate to a yyyy-mm-dd String or null. */
    public static @Nullable String format(@Nullable LocalDate date) {
        return date != null ? date.toString() : null;
    }

    /** Creates a DateTime object in the default local time zone. */
    public static @Nullable DateTime toLocalDateTime(@Nullable Long millis) {
        return millis != null ? new DateTime(millis, DateTimeZone.getDefault()) : null;
    }

    /** Creates a DateTime object in the default local time zone. */
    public static @Nullable DateTime toLocalDateTime(@Nullable ReadableInstant instant) {
        return instant != null ? new DateTime(instant, DateTimeZone.getDefault()) : null;
    }

    /** Converts a yyyy-mm-dd String or null to a nullable LocalDate. */
    public static @Nullable LocalDate toLocalDate(@Nullable String string) {
        try {
            return string != null ? LocalDate.parse(string) : null;
        } catch (IllegalArgumentException e) {
            return null;
        }
    }

    /** Formats a nullable DateTime or Instant as "yyyy-mm-ddThh:mm:ssZ" or null. */
    public static @Nullable String formatUtc8601(@Nullable AbstractInstant t) {
        return t != null ? t.toString(ISO8601_UTC_DATETIME_FORMATTER) : null;
    }

    /** Parses a nullable String into a nullable Interval. */
    public static Interval toNullableInterval(String str) {
        return str != null ? Interval.parse(str) : null;
    }

    public static enum DateStyle {
        MONTH_DAY(R.string.month_day_format),
        YEAR_MONTH_DAY(R.string.year_month_day_format),
        HOUR_MINUTE(R.string.hour_minute_format),
        MONTH_DAY_HOUR_MINUTE(R.string.month_day_hour_minute_format),

        // "Sentence" formats should work in phrases like "The store opens X"
        SENTENCE_MONTH_DAY(R.string.sentence_month_day_format),
        SENTENCE_YEAR_MONTH_DAY(R.string.sentence_year_month_day_format),
        SENTENCE_HOUR_MINUTE(R.string.sentence_hour_minute_format),
        SENTENCE_MONTH_DAY_HOUR_MINUTE(R.string.sentence_month_day_hour_minute_format),

        // "Relative" formats should work in phrases like "after X", "until X"
        RELATIVE_MONTH_DAY(R.string.relative_month_day_format),
        RELATIVE_YEAR_MONTH_DAY(R.string.relative_year_month_day_format),
        RELATIVE_HOUR_MINUTE(R.string.relative_hour_minute_format),
        RELATIVE_MONTH_DAY_HOUR_MINUTE(R.string.relative_month_day_hour_minute_format);

        private final int formatId;
        private Map<Locale, DateTimeFormatter> formatters = new HashMap<>();
        private DateTimeFormatter formatter = null;

        private DateStyle(int formatId) {
            this.formatId = formatId;
        }

        public DateTimeFormatter getFormatter() {
            Locale locale = App.getSettings().getLocale();
            if (formatters.get(locale) == null) {
                formatters.put(locale, DateTimeFormat.forPattern(App.str(formatId)));
            }
            return formatters.get(locale);
        }
    }

    public static @Nullable String format(@Nullable ReadablePartial partial, DateStyle style) {
        if (partial == null) return null;
        return style.getFormatter().print(partial);
    }

    public static @Nullable String format(@Nullable DateTime datetime, DateStyle style) {
        if (datetime == null) return null;
        return style.getFormatter().print(datetime);
    }

    /** Gets the DateTime at the start of a day. */
    public static DateTime getDayStart(LocalDate day) {
        return day.toDateTimeAtStartOfDay();
    }

    /** Gets the DateTime at the end of a day. */
    public static DateTime getDayEnd(LocalDate day) {
        return day.plusDays(1).toDateTimeAtStartOfDay();
    }

    /** Creates an interval from a min and max, where null means "unbounded". */
    public static Interval toInterval(ReadableInstant start, ReadableInstant stop) {
        return new Interval(Utils.orDefault(start, MIN_DATETIME), Utils.orDefault(stop, MAX_DATETIME));
    }

    /** Gets the DateTime at the center of an Interval. */
    public static DateTime centerOf(Interval interval) {
        return interval.getStart().plus(interval.toDuration().dividedBy(2));
    }

    /** Converts a nullable DateTime to a nullable number of millis since 1970-01-01T00:00:00. */
    public static Long toNullableMillis(ReadableInstant instant) {
        return instant != null ? instant.getMillis() : null;
    }

    /**
     * Describes a given date as a number of days since a starting date, where the starting date
     * itself is Day 1.  Returns a value <= 0 if the given date is null or in the future.
     */
    public static int dayNumberSince(@Nullable LocalDate startDate, @Nullable LocalDate date) {
        if (startDate == null || date == null) {
            return -1;
        }
        return Days.daysBetween(startDate, date).getDays() + 1;
    }

    /** Checks whether a birthdate indicates an age less than 5 years old. */
    public static boolean isChild(LocalDate birthdate) {
        return birthdate != null && new Period(birthdate, LocalDate.now()).getYears() < 5;
    }

    /** Converts a birthdate to a string describing age in months or years. */
    public static String birthdateToAge(LocalDate birthdate) {
        Period age = new Period(birthdate, LocalDate.now());
        int years = age.getYears(), months = age.getMonths();
        return years >= 5 ? App.str(R.string.abbrev_n_years, years) :
            App.str(R.string.abbrev_n_months, months + years * 12);
    }


    // ==== Localization ====

    public static Locale toLocale(String languageTag) {
        if (Build.VERSION.SDK_INT >= 21) return Locale.forLanguageTag(languageTag);
        String[] parts = splitFields(languageTag, "_", 2);
        return new Locale(parts[0], parts[1]);
    }

    public static @Nullable String toLanguageTag(@Nullable Locale locale) {
        if (locale == null) return null;
        if (Build.VERSION.SDK_INT >= 21) return locale.toLanguageTag();
        return locale.getLanguage() +
            (Utils.isEmpty(locale.getCountry()) ? "" : "-" + locale.getCountry()) +
            (Utils.isEmpty(locale.getVariant()) ? "" : "-" + locale.getVariant());
    }

    /** Clears the activity stack and launches the given activity. */
    public static void jumpToActivity(Activity current, Class target) {
        if (!target.isInstance(current)) {
            current.finish();
            current.startActivity(new Intent(current, target).setFlags(
                Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK));
        }
    }

    /** Restarts the current activity (for use after a configuration change). */
    public static void restartActivity(Activity activity) {
        activity.finish();
        activity.startActivity(
            activity.getIntent(),
            ActivityOptions.makeCustomAnimation(activity, 0, 0).toBundle());
    }


    // ==== System ====

    /**
     * Returns the value for a system property. System properties need to start with "debug." and
     * can be set using "adb shell setprop $propertyName $value".
     */
    public static String getSystemProperty(String key) {
        // Accessing hidden APIs via reflection.
        try {
            final Class<?> systemProperties = Class.forName("android.os.SystemProperties");
            final Method get = systemProperties.getMethod("get", String.class, String.class);
            return (String) get.invoke(null, key, null);
        } catch (Exception e) {  // should never happen
            return null;
        }
    }

    public static void recursivelyDelete(File path) {
        if (path.isDirectory()) {
            for (File child : path.listFiles()) {
                recursivelyDelete(child);
            }
        }
        path.delete();
    }


    // ==== Cursors ====

    /** Gets a nullable string value from a cursor. */
    public static @Nullable String getString(Cursor c, String columnName) {
        return getString(c, columnName, null);
    }

    /** Gets a string value from a cursor, returning a default value instead of null. */
    public static String getString(Cursor c, String columnName, String defaultValue) {
        int index = c.getColumnIndex(columnName);
        return c.isNull(index) ? defaultValue : c.getString(index);
    }

    /** Gets a LocalDate value from a cursor, possibly returning null. */
    public static LocalDate getLocalDate(Cursor c, String columnName) {
        int index = c.getColumnIndex(columnName);
        return c.isNull(index) ? null : new LocalDate(c.getString(index));
    }

    /** Gets a nullable long value (in millis) from a cursor as a DateTime. */
    public static DateTime getDateTime(Cursor c, String columnName) {
        Long millis = getLong(c, columnName);
        return millis == null ? null : Utils.toLocalDateTime(millis);
    }

    /** Gets a nullable boolean value from a cursor. */
    public static Boolean getBoolean(Cursor c, String columnName) {
        int index = c.getColumnIndex(columnName);
        return c.isNull(index) ? null : (c.getLong(index) != 0);
    }

    /** Gets a boolean value from a cursor, returning a default value instead of null. */
    public static boolean getBoolean(Cursor c, String columnName, boolean defaultValue) {
        int index = c.getColumnIndex(columnName);
        return c.isNull(index) ? defaultValue : (c.getLong(index) != 0);
    }

    /** Gets a nullable integer value from a cursor. */
    public static Integer getInt(Cursor c, String columnName) {
        int index = c.getColumnIndex(columnName);
        return c.isNull(index) ? null : (int) c.getLong(index);
    }

    /** Gets an integer value from a cursor, returning a default value instead of null. */
    public static int getInt(Cursor c, String columnName, int defaultValue) {
        int index = c.getColumnIndex(columnName);
        // The cast (Long) c.getLong(index) is necessary to work around the fact that
        // the Java compiler chooses type (long) for (boolean) ? (Long) : (long),
        // causing an NPE when defaultValue is null.  The correct superset of (Long) and
        // (long) is obviously (Long); the Java specification (15.25) is incorrect.
        return c.isNull(index) ? defaultValue : (int) c.getLong(index);
    }

    /** Gets a nullable long value from a cursor. */
    public static Long getLong(Cursor c, String columnName) {
        int index = c.getColumnIndex(columnName);
        return c.isNull(index) ? null : c.getLong(index);
    }

    /** Gets a long integer value from a cursor, returning a default value instead of null. */
    public static long getLong(Cursor c, String columnName, @Nonnull long defaultValue) {
        int index = c.getColumnIndex(columnName);
        // The cast (Long) c.getLong(index) is necessary to work around the fact that
        // the Java compiler chooses type (long) for (boolean) ? (Long) : (long),
        // causing an NPE when defaultValue is null.  The correct superset of (Long) and
        // (long) is obviously (Long); the Java specification (15.25) is incorrect.
        return c.isNull(index) ? defaultValue : c.getLong(index);
    }


    // ==== Bundles ====

    /** Gets a nullable DateTime value from a Bundle.  Always use this instead of getLong() directly. */
    public static DateTime getDateTime(Bundle bundle, String key) {
        // getLong never returns null; we have to check explicitly.
        return bundle.containsKey(key) ? Utils.toLocalDateTime(bundle.getLong(key)) : null;
    }

    /** Creates a Bundle containing one key-value pair. */
    public static Bundle bundle(String key1, Object value1) {
        return addToBundle(new Bundle(), key1, value1);
    }

    /** Creates a Bundle containing two key-value pairs. */
    public static Bundle bundle(String key1, Object value1, String key2, Object value2) {
        return addToBundle(
            addToBundle(
                new Bundle(), key1, value1
            ), key2, value2
        );
    }

    /** Creates a Bundle containing three key-value pairs. */
    public static Bundle bundle(String key1, Object value1, String key2, Object value2,
                                String key3, Object value3) {
        return addToBundle(
            addToBundle(
                addToBundle(
                    new Bundle(), key1, value1
                ), key2, value2
            ), key3, value3
        );
    }

    /** Adds a key-value pair to a Bundle and returns the Bundle for chaining. */
    public static Bundle addToBundle(Bundle bundle, String key, Object value) {
        if (value instanceof String) bundle.putString(key, (String) value);
        else if (value instanceof Double) bundle.putDouble(key, (Double) value);
        else if (value instanceof Float) bundle.putFloat(key, (Float) value);
        else if (value instanceof Long) bundle.putLong(key, (Long) value);
        else if (value instanceof Integer) bundle.putInt(key, (Integer) value);
        else if (value instanceof Boolean) bundle.putBoolean(key, (Boolean) value);
        else if (value instanceof ReadableInstant) bundle.putLong(key, ((ReadableInstant) value).getMillis());
        else if (value instanceof Bundle) bundle.putBundle(key, (Bundle) value);
        else if (value instanceof Serializable) bundle.putSerializable(key, (Serializable) value);
        else if (value != null) throw new IllegalArgumentException(format(
            "Don't know how to put a value of type %s into a Bundle", value.getClass()));
        return bundle;
    }

    /** Builds a Message with a Bundle of data. */
    public static Message newMessage(Handler handler, int what, Bundle data) {
        Message message = handler.obtainMessage(what);
        message.setData(data);
        return message;
    }


    // ==== Colour ====

    public static int colorWithOpacity(int color, double opacity) {
        byte alpha = (byte) (255 * opacity);
        return (color & 0x00_ff_ff_ff) | (alpha * 0x01_00_00_00);
    }


    // ==== UI Views ====

    /** Shows or hides a dialog based on a boolean flag. */
    public static void showDialogIf(@Nullable Dialog dialog, boolean show) {
        if (dialog != null) {
            if (show) {
                dialog.show();
            } else {
                dialog.hide();
            }
        }
    }

    /** Shows or a hides a view based on a boolean flag. */
    public static void showIf(@Nullable View view, boolean show) {
        if (view != null) {
            view.setVisibility(show ? View.VISIBLE : View.GONE);
        }
    }

    /** Returns true if a view's visibility is set to VISIBLE. */
    public static boolean isVisible(@Nullable View view) {
        return view != null && view.getVisibility() == View.VISIBLE;
    }

    /** Sets the text of a child view identified by its ID. */
    public static void setText(@Nullable View view, int id, String text) {
        if (view != null) {
            TextView textView = view.findViewById(id);
            if (textView != null) textView.setText(text);
        }
    }

    /** Sets a view's enabled state and focusable state at the same time. */
    public static void setEnabled(View view, boolean enabled) {
        view.setEnabled(enabled);
        view.setFocusable(enabled);
        if (view instanceof EditText) view.setFocusableInTouchMode(true);
    }

    /** Set the enabled state of all the children of a view. */
    public static void setChildrenEnabled(ViewGroup view, boolean enabled) {
        for (int i = 0; i < view.getChildCount(); i++) {
            setEnabled(view.getChildAt(i), enabled);
        }
    }

    /** Brings up the soft keyboard. */
    public static void showKeyboard(Window window) {
        window.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
    }

    /** Puts focus on the first empty field, or otherwise the first field. */
    public static void focusFirstEmptyField(EditText... fields) {
        for (EditText field : fields) {
            if (field.isEnabled() && field.getText().toString().isEmpty()) {
                field.requestFocus();
                return;
            }
        }

        // If all fields are populated, default to the first field.
        if (fields.length >= 1) {
            fields[0].requestFocus();
            fields[0].setSelection(fields[0].getText().length());
        }
    }

    /** Gets the text in an editable text field and trims away whitespace. */
    public static String getText(EditText field) {
        return field.getText().toString().trim();
    }

    /** Gets the integer value in a text field, or a default value if invalid. */
    public static int getInt(EditText field, int defaultValue) {
        return toIntOrDefault(field.getText().toString().trim(), defaultValue);
    }

    /** Gets the numeric value in a text field, or a default value if invalid. */
    public static double getDouble(EditText field, double defaultValue) {
        return toDoubleOrDefault(field.getText().toString().trim(), defaultValue);
    }


    // ==== OpenMRS ====

    private static final Pattern COMPRESSIBLE_UUID = Pattern.compile("^([0-9]+)A+$");

    /** Compresses a UUID optionally to a small integer. */
    public static Object compressUuid(String uuid) {
        Matcher matcher = COMPRESSIBLE_UUID.matcher(uuid);
        if (uuid.length() == 36 && matcher.matches()) {
            return Integer.valueOf(matcher.group(1));
        }
        return uuid;
    }

    /** Expands a UUID that has been optionally compressed to a small integer. */
    public static String expandUuid(Object id) {
        String str = "" + id;
        if (str.matches("^[0-9]+$")) {
            return (str + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA").substring(0, 36);
        }
        return (String) id;
    }

    /** Expands a UUID from a small integer. */
    public static String toUuid(int id) {
        return expandUuid(id);
    }

    /** Gets the UUID of the currently active user (provider). */
    public static String getProviderUuid() {
        JsonUser user = App.getUserManager().getActiveUser();
        return user != null ? user.getUuid() : null;
    }


    // ==== Ordering ====

    /**
     * Compares two objects that may be null, Integer, Long, BigInteger, or String.
     * null sorts before everything; all integers sort before all strings; integers
     * sort according to numeric value; strings sort according to string value.
     */
    public static final Comparator<Object> NULL_INT_STR_COMPARATOR = new Comparator<Object>() {
        @Override public int compare(Object a, Object b) {
            BigInteger intA = toBigInteger(a);
            BigInteger intB = toBigInteger(b);
            if (intA != null && intB != null) {
                return intA.compareTo(intB);
            }
            if (a instanceof String && b instanceof String) {
                return ((String) a).compareTo((String) b);
            }
            return (a == null ? 0 : intA != null ? 1 : 2)
                - (b == null ? 0 : intB != null ? 1 : 2);
        }
    };

    /**
     * Compares two lists, each of whose elements is a null, Integer, Long,
     * BigInteger, or String, lexicographically by element, just like Python.
     */
    public static final Comparator<List<Object>> NULL_INT_STR_LIST_COMPARATOR = new Comparator<List<Object>>() {
        @Override public int compare(List<Object> a, List<Object> b) {
            for (int i = 0; i < Math.min(a.size(), b.size()); i++) {
                int result = NULL_INT_STR_COMPARATOR.compare(a.get(i), b.get(i));
                if (result != 0) {
                    return result;
                }
            }
            return a.size() - b.size();
        }
    };

    // Note: Use of \L here assumes a string that is already NFC-normalized.
    private static final Pattern NUMBER_OR_WORD_PATTERN = Pattern.compile("([0-9]+)|\\p{L}+");

    /**
     * Compares two strings in a manner that sorts alphabetic parts in alphabetic
     * order and numeric parts in numeric order, while guaranteeing that:
     * - compare(s, t) == 0 if and only if s.equals(t).
     * - compare(s, s + t) < 0 for any strings s and t.
     * - compare(s + x, s + y) == Integer.compare(x, y) for all integers x, y
     * and strings s that do not end in a digit.
     * - compare(s + t, s + u) == compare(t, u) for all strings s and strings
     * t, u that consist entirely of Unicode letters.
     * For example, the strings ["b1", "a11a", "a11", "a2", "a2b", "a2a", "a1"]
     * have the sort order ["a1", "a2", "a2a", "a2b", "a11", "a11a", "b1"].
     */
    public static final Comparator<String> ALPHANUMERIC_COMPARATOR = new Comparator<String>() {
        @Override public int compare(String a, String b) {
            String aNormalized = Normalizer.normalize(a == null ? "" : a, Normalizer.Form.NFC);
            String bNormalized = Normalizer.normalize(b == null ? "" : b, Normalizer.Form.NFC);
            List<Object> aParts = getParts(aNormalized);
            List<Object> bParts = getParts(bNormalized);
            // Add a separator to ensure that the tiebreakers added below are never
            // compared against the actual numeric or alphabetic parts.
            aParts.add(null);
            bParts.add(null);
            // Break ties between strings that yield the same parts (e.g. "a04b"
            // and "a4b") using the normalized original string as a tiebreaker.
            aParts.add(aNormalized);
            bParts.add(bNormalized);
            // Break ties between strings that become the same after normalization
            // using the non-normalized string as a further tiebreaker.
            aParts.add(a);
            bParts.add(b);
            return NULL_INT_STR_LIST_COMPARATOR.compare(aParts, bParts);
        }

        /**
         * Breaks a string into a list of Integers (from sequences of ASCII digits)
         * and Strings (from sequences of letters).  Other characters are ignored.
         */
        private List<Object> getParts(String str) {
            Matcher matcher = NUMBER_OR_WORD_PATTERN.matcher(str);
            List<Object> parts = new ArrayList<>();
            while (matcher.find()) {
                try {
                    String part = matcher.group();
                    String intPart = matcher.group(1);
                    parts.add(intPart != null ? new BigInteger(intPart) : part);
                } catch (Exception e) {  // shouldn't happen, but just in case
                    parts.add(null);
                }
            }
            return parts;
        }
    };


    // ==== Logging ====

    /**
     * Logs a user action by sending a dummy request to the server.  (The server
     * logs can then be scanned later to produce analytics for the client app.)
     * @param action An identifier for the user action; should describe a user-
     *               initiated operation in the UI (e.g. "foo_button_pressed").
     * @param pairs  An even number of arguments providing key-value pairs of
     *               arbitrary data to record with the event.
     */
    public static void logUserAction(String action, String... pairs) {
        Server server = App.getServer();
        if (server != null) {
            List<String> allPairs = Lists.newArrayList("action", action);
            allPairs.addAll(Arrays.asList(pairs));
            server.logToServer(allPairs);
        }
    }

    /**
     * Logs an event by sending a dummy request to the server.  (The server logs
     * can then be scanned later to produce analytics for the client app.)
     * @param event An identifier for an event that is not directly initiated by
     *              the user (e.g. "form_submission_failed").
     * @param pairs An even number of arguments providing key-value pairs of
     *              arbitrary data to record with the event.
     */
    public static void logEvent(String event, String... pairs) {
        Server server = App.getServer();
        if (server != null) {
            List<String> allPairs = Lists.newArrayList("event", event);
            allPairs.addAll(Arrays.asList(pairs));
            server.logToServer(allPairs);
        }
    }


    // ==== Debugging ====

    /** Gets the stack trace as a string.  Handy for looking inside exceptions when debugging. */
    public static String toString(Throwable e) {
        StringWriter sw = new StringWriter();
        e.printStackTrace(new PrintWriter(sw));
        return sw.toString();
    }

    /** Converts a string to a lowercase CSS-safe identifier. */
    // We use this to give predictable class names to HTML rows so that tests
    // can verify the values in the patient chart.  See PatientChartActivityTest.
    public static String toCssIdentifier(String input) {
        return input.trim().toLowerCase().replaceAll("[^a-z0-9-]+", "-");
    }

    /** Returns an unambiguous string representation of a string, prefixed with its length. */
    public static String reprWithLen(String str) {
        return format("(length %d) ", str.length()) + repr(str);
    }

    /** Returns an unambiguous string representation of a string, suitable for logging. */
    public static String repr(String str) {
        return repr(str, 100);
    }

    /** Returns an unambiguous string representation of a string, suitable for logging. */
    public static String repr(String str, int maxLength) {
        try {
            return str != null ? escape(str, maxLength) : "(null String)";
        } catch (Throwable ignored) {
            return "(repr of " + str + " failed)";
        }
    }

    /** Returns an unambiguous string representation of a byte array, suitable for logging. */
    public static String repr(byte[] bytes, int maxLength) {
        try {
            return bytes != null ?
                escape(new String(bytes, "ISO-8859-1"), maxLength) : "(null byte[])";
        } catch (Throwable ignored) {
            return "(repr of " + bytes + " failed)";
        }
    }

    /** Returns a list-like string representation of an array of objects, suitable for logging. */
    public static String repr(Object[] array) {
        return "[" + join(", ", array) + "]";
    }

    public static String join(String sep, Object[] array) {
        String result = "";
        if (array.length > 0) result += array[0];
        for (int i = 1; i < array.length; i++) {
            result += sep + array[i];
        }
        return result;
    }

    public static String join(String sep, Iterable<?> iterable) {
        String result = "";
        int i = 0;
        for (Object obj : iterable) {
            if (i++ > 0) result += sep;
            result += obj;
        }
        return result;
    }

    /** Uses backslash sequences to form a printable representation of a string. */
    private static String escape(String str, int maxLength) {
        StringBuilder buffer = new StringBuilder("\"");
        for (int i = 0; i < str.length() && i < maxLength; i++) {
            char c = str.charAt(i);
            switch (str.charAt(i)) {
                case '\t':
                    buffer.append("\\t");
                    break;
                case '\r':
                    buffer.append("\\r");
                    break;
                case '\n':
                    buffer.append("\\n");
                    break;
                case '\\':
                    buffer.append("\\\\");
                    break;
                case '"':
                    buffer.append("\\\"");
                    break;
                default:
                    if ((int) c >= 32 && (int) c <= 126) {
                        buffer.append(c);
                    } else if ((int) c < 256) {
                        buffer.append(format("\\x%02x", (int) c));
                    } else {
                        buffer.append(format("\\u%04x", (int) c));
                    }
            }
        }
        buffer.append(str.length() > maxLength ? "\"..." : "\"");
        return buffer.toString();
    }

    /** Formats a description of a Request. */
    public static <T> String repr(Request<T> req) {
        try {
            if (req == null) {
                return "(null Request)";
            }
            String method = sHttpMethods.get(req.getMethod());
            if (method == null) {
                method = format("(method %d)", req.getMethod());
            }
            String data = "";
            if (req.getPostBody() != null) {
                try {
                    data = format(" (%s) %s", req.getBodyContentType(), repr(req.getPostBody(), 500));
                } catch (AuthFailureError e) {
                    data += " (" + repr(e) + ")";
                }
            }
            return format("(%s) %s %s%s", typeof(req), method, req.getUrl(), data);
        } catch (Throwable ignored) {
            return "(repr of " + req + " failed)";
        }
    }

    /** Formats a short description of a Throwable. */
    public static <T> String repr(Throwable t) {
        try {
            if (t == null) {
                return "(null Throwable)";
            }
            return format("%s: %s", typeof(t), t.getMessage());
        } catch (Throwable ignored) {
            return "(repr of " + t + " failed)";
        }
    }

    /** Formats a short description of the type of an object. */
    public static String typeof(Object obj) {
        String name = obj.getClass().getSimpleName();
        if (name.isEmpty()) {
            String[] parts = obj.getClass().getName().split("\\.");
            return parts.length == 0 ? "(anonymous)" : parts[parts.length - 1];
        }
        return name;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.utils;

import com.google.common.base.Preconditions;

import java.util.Arrays;

import javax.annotation.concurrent.Immutable;

/** An object that represents a version consisting of any number of numbers separated by dots. */
@Immutable
public class LexicographicVersion implements Comparable<LexicographicVersion> {

    private final String mRaw;
    private final int[] mParts;

    /** Returns an instance of {@link LexicographicVersion} parsed from the specified string. */
    public static LexicographicVersion parse(String raw) {
        Preconditions.checkNotNull(raw);
        Preconditions.checkArgument(!raw.equals(""));

        String[] stringParts = raw.split("\\.");
        int[] parts = new int[stringParts.length];
        for (int i = 0; i < stringParts.length; i++) {
            try {
                parts[i] = Integer.parseInt(stringParts[i]);
            } catch (NumberFormatException e) {
                throw new IllegalArgumentException(
                    "'" + raw + "' is not a valid version string.", e);
            }
        }

        return new LexicographicVersion(raw, parts);
    }

    @Override public String toString() {
        return mRaw;
    }

    public boolean greaterThan(LexicographicVersion other) {
        return compareTo(other) > 0;
    }

    @Override public int compareTo(LexicographicVersion other) {
        Preconditions.checkNotNull(other);
        if (this == other) {
            return 0;
        }

        int minPartsLength = Math.min(mParts.length, other.mParts.length);
        for (int i = 0; i < minPartsLength; i++) {
            if (mParts[i] < other.mParts[i]) {
                return -1;
            } else if (mParts[i] > other.mParts[i]) {
                return 1;
            }
        }

        return mParts.length - other.mParts.length;
    }

    public boolean greaterThanOrEqualTo(LexicographicVersion other) {
        return compareTo(other) >= 0;
    }

    public boolean lessThan(LexicographicVersion other) {
        return compareTo(other) < 0;
    }

    public boolean lessThanOrEqualTo(LexicographicVersion other) {
        return compareTo(other) <= 0;
    }

    @Override public boolean equals(Object other) {
        if (this == other) {
            return true;
        }
        if (!(other instanceof LexicographicVersion)) {
            return false;
        }
        return compareTo((LexicographicVersion) other) == 0;
    }

    @Override public int hashCode() {
        return Arrays.hashCode(mParts);
    }

    private LexicographicVersion(String raw, int[] parts) {
        mRaw = raw;
        mParts = parts;
    }
}

package org.projectbuendia.client.utils;

import android.app.AlertDialog;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.ContextWrapper;
import android.database.Cursor;
import android.net.Uri;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import com.google.common.base.Joiner;

import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.models.Location;
import org.projectbuendia.models.LocationForest;
import org.projectbuendia.models.Patient;
import org.projectbuendia.models.Sex;
import org.projectbuendia.client.resolvables.ResStatus;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.annotation.Nonnull;

public class ContextUtils extends ContextWrapper {
    private static final String EN_DASH = "\u2013";

    private final Context context;
    private LayoutInflater inflater = null;
    private View lastView = null;

    public static ContextUtils from(Context context) {
        return (context instanceof ContextUtils) ? (ContextUtils) context : new ContextUtils(context);
    }

    public static ContextUtils from(ContextProvider provider) {
        return from(provider.getContext());
    }

    public static ContextUtils from(View view) {
        return from(view.getContext());
    }

    private ContextUtils(Context context) {
        super(context);
        this.context = context;
    }

    /** Queries the ContentResolver. */
    public Cursor query(Uri uri, String[] columns, String selection, String... args) {
        return getContentResolver().query(uri, columns, selection, args, null);
    }


    // ==== Views ====

    public View reuseOrInflate(View view, int layoutId, ViewGroup parent) {
        lastView = view != null ? view : inflate(layoutId, parent);
        return lastView;
    }

    public View addInflated(int layoutId, @Nonnull ViewGroup layoutParent) {
        View view = inflate(layoutId, layoutParent);
        layoutParent.addView(view);
        return view;
    }

    /** Always use this method, never the awful, confusing LayoutInflater.inflate(). */
    public View inflate(int layoutId, @Nonnull ViewGroup layoutParent) {
        if (inflater == null) {
            inflater = LayoutInflater.from(this);
        }
        // Provide the parent so that the proper LayoutParams are created, but
        // set attachToRoot = false so that the returned value is the inflated
        // view, not a useless reference to its parent.
        lastView = inflater.inflate(layoutId, layoutParent, false);
        return lastView;
    }

    /** Constructs an AlertDialog.Builder inflated from a given layout. */
    public AlertDialog.Builder buildDialog(int layoutId) {
        // This is the only situation where it's okay to pass null for the parent.
        return new AlertDialog.Builder(this).setView(inflate(layoutId, null));
    }

    /** The parent can be null only when inflating a view for a dialog. */
    public View inflateForDialog(int id) {
        return inflate(id, null);
    }

    public void setContainer(View view) {
        lastView = view;
    }

    /** Sets the view in which findView() will search. */
    public ContextUtils inView(View view) {
        lastView = view;
        return this;
    }

    /** Finds a view in the last view that was inflated. */
    public <T extends View> T findView(int id) {
        return lastView != null ? lastView.findViewById(id) : null;
    }

    public void show(int id, boolean visible) {
        findView(id).setVisibility(visible ? View.VISIBLE : View.GONE);
    }

    public void show(View view, boolean visible) {
        view.setVisibility(visible ? View.VISIBLE : View.GONE);
    }

    public void show(int id) {
        findView(id).setVisibility(View.VISIBLE);
    }

    public void show(View view) {
        view.setVisibility(View.VISIBLE);
    }

    public void hide(int id) {
        findView(id).setVisibility(View.GONE);
    }

    public void hide(View view) {
        view.setVisibility(View.GONE);
    }

    public void cloak(int id) {
        findView(id).setVisibility(View.INVISIBLE);
    }

    public void cloak(View view) {
        view.setVisibility(View.INVISIBLE);
    }

    public void setText(int id, CharSequence text) {
        ((TextView) findView(id)).setText(text);
    }

    public void setTextViewColors(int id, ResStatus.Resolved status) {
        ((TextView) findView(id)).setTextColor(status.getForegroundColor());
        ((TextView) findView(id)).setBackgroundColor(status.getBackgroundColor());
    }

    // ==== String formatting ====

    /** Strings are always available in the app-wide resources. */
    public String str(int id, Object... args) {
        return App.str(id, args);
    }

    /** Formats a list of items in a localized fashion. */
    public String formatItems(String... items) {
        int n = items.length;
        return n == 0 ? ""
            : n == 1 ? items[0]
            : n == 2 ? str(R.string.two_items, items[0], items[1])
            : str(
                R.string.more_than_two_items,
                Joiner.on(", ").join(Arrays.copyOfRange(items, 0, n - 1)),
                items[n - 1]
            );
    }

    /** Formats a location heading with an optional patient count. */
    public String formatLocationHeading(String locationUuid, long patientCount) {
        LocationForest forest = App.getModel().getForest();
        Location location = forest.get(locationUuid);
        String locationName = location != null ? location.name : str(R.string.unknown_location);
        // If no patient count is available, only show the location name.
        if (patientCount < 0) return locationName;
        return locationName + "  \u00b7  " + formatPatientCount(patientCount);
    }

    /** Formats a localized patient count. */
    public String formatPatientCount(long count) {
        return count == 0 ? str(R.string.no_patients)
            : count == 1 ? str(R.string.one_patient)
            : str(R.string.n_patients, count);
    }

    /** Formats a patient name, using an en-dash if either part is missing. */
    public String formatPatientName(Patient patient) {
        String given = Utils.orDefault(patient.givenName, EN_DASH);
        String family = Utils.orDefault(patient.familyName, EN_DASH);
        return given + " " + family;
    }

    public enum FormatStyle { NONE, SHORT, LONG };

    /** Formats the sex, pregnancy status, and/or age of a patient. */
    public String formatPatientDetails(
        Patient patient, FormatStyle sex, FormatStyle pregnancy, FormatStyle age) {
        List<String> labels = new ArrayList<>();
        if (patient.sex != null && (sex == FormatStyle.SHORT || sex == FormatStyle.LONG)) {
            String abbrev = Sex.getAbbreviation(patient.sex);
            labels.add(Utils.isChild(patient.birthdate) ? abbrev.toLowerCase() : abbrev);
        }
        if (patient.sex == null && sex == FormatStyle.LONG) {
            labels.add(str(R.string.sex_unknown));
        }
        if (patient.pregnancy) {
            if (pregnancy == FormatStyle.SHORT) labels.add(str(R.string.pregnant_suffix));
            if (pregnancy == FormatStyle.LONG) labels.add(str(R.string.pregnant).toLowerCase());
        }
        if (patient.birthdate != null && (age == FormatStyle.SHORT || age == FormatStyle.LONG)) {
            labels.add(Utils.birthdateToAge(patient.birthdate));
        }
        if (patient.birthdate == null && (age == FormatStyle.LONG)) {
            labels.add(str(R.string.age_unknown));
        }
        return Joiner.on(", ").join(labels);
    }


    // ==== User interface ====

    public void prompt(int titleId, int messageId, int actionId, Runnable action) {
        prompt(titleId, messageId, actionId, R.string.cancel, action);
    }

    public void prompt(int titleId, int messageId, int actionId, int cancelId, Runnable action) {
        new AlertDialog.Builder(this)
            .setTitle(titleId)
            .setMessage(messageId)
            .setPositiveButton(actionId, (d, i) -> action.run())
            .setNegativeButton(cancelId, null)
            .create()
            .show();
    }

    public Dialog showProgressDialog(String title, String message) {
        ProgressDialog d = new ProgressDialog(this);
        d.setIcon(android.R.drawable.ic_dialog_info);
        d.setTitle(title);
        d.setMessage(message);
        d.setIndeterminate(true);
        d.setCancelable(false);
        d.show();
        return d;
    }

    public interface ContextProvider {
        Context getContext();
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.utils;

import android.support.v4.util.LruCache;

import java.util.Arrays;
import java.util.Random;

/** A class that generates aesthetically pleasing colors based on a color wheel. */
public class Colorizer {
    public static final int[] DEFAULT_PALETTE = {
        0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFF00FFFF, 0xFFFF00FF, 0xFFFFFF00,
        0xFFFF7000, 0xFF7FFF00, 0xFF00FF7F, 0xFF007FFF, 0xFF7F00FF, 0xFFFF007F
    };

    /** A {@link Colorizer} that has 12 colors. */
    public static final Colorizer C_12 = new Colorizer(DEFAULT_PALETTE, 0, 0);
    /** A {@link Colorizer} that has 24 colors. */
    public static final Colorizer C_24 = new Colorizer(DEFAULT_PALETTE, 1, 0);
    /** A {@link Colorizer} that has 48 colors. */
    public static final Colorizer C_48 = new Colorizer(DEFAULT_PALETTE, 2, 0);
    /** A {@link Colorizer} that has 96 colors. */
    public static final Colorizer C_96 = new Colorizer(DEFAULT_PALETTE, 3, 0);
    private static int[] sDefaultPalette;
    private static int[][] sDefaultPaletteBytes;

    private final LruCache<Integer, Integer> mCache = new LruCache<>(128);
    private final int[][] mPaletteBytes;
    private final int mInterpolations;
    private final int mInterpolationMultiplier;
    private final int mColorCount;
    private final double mShift;
    private final Random mRandom;

    public Colorizer interpolate(int interpolation) {
        return new Colorizer(this, interpolation);
    }

    /**
     * Creates a new {@link Colorizer} based on this one but with the specified tint applied to each
     * calculated color.
     */
    public Colorizer withTint(double tint) {
        if (tint < 0. || tint > 1.) {
            throw new IllegalArgumentException("Tint must be between 0 and 1.");
        }

        return new Colorizer(this, tint);
    }

    /**
     * Creates a new {@link Colorizer} based on this one but with the specified shade applied to
     * each calculated color.
     */
    public Colorizer withShade(double shade) {
        if (shade < 0. || shade > 1.) {
            throw new IllegalArgumentException("Shade must be between 0 and 1.");
        }

        return new Colorizer(this, -shade);
    }

    /** Gets an ARGB value for the specified object. */
    public int getColorArgb(Object o) {
        return getColorArgb(mix(o == null ? 0 : o.hashCode()));
    }

    /** Gets an ARGB color value for the specified integer. */
    public int getColorArgb(int i) {
        Integer cachedValue = mCache.get(i);
        if (cachedValue != null) {
            return cachedValue;
        }

        int colorIndex = i%mColorCount;
        if (colorIndex < 0) {
            colorIndex += mColorCount;
        }

        int[] rgb;
        if (mInterpolations == 0) {
            rgb = Arrays.copyOf(mPaletteBytes[colorIndex], 3);
        } else {
            int basePaletteIndex = colorIndex/mInterpolationMultiplier;
            int basePaletteOffset = colorIndex - basePaletteIndex*mInterpolationMultiplier;
            double offsetFraction = (double) basePaletteOffset/mInterpolationMultiplier;

            int[] startRgb = mPaletteBytes[basePaletteIndex];
            int[] endRgb = mPaletteBytes[(basePaletteIndex + 1)%mPaletteBytes.length];

            // TODO: Consider doing interpolations in another color space.
            rgb = new int[] {
                (int) (startRgb[0] + offsetFraction*(endRgb[0] - startRgb[0])),
                (int) (startRgb[1] + offsetFraction*(endRgb[1] - startRgb[1])),
                (int) (startRgb[2] + offsetFraction*(endRgb[2] - startRgb[2]))
            };
        }

        double shift = mShift*0xFF;

        int value = 0xFF000000
            | (int) Math.max(Math.min(rgb[0] + shift, 255.), 0)<<16
            | (int) Math.max(Math.min(rgb[1] + shift, 255.), 0)<<8
            | (int) Math.max(Math.min(rgb[2] + shift, 255.), 0);
        mCache.put(i, value);
        return value;
    }

    private int mix(int value) {
        mRandom.setSeed(value);
        return mRandom.nextInt();
    }

    public Colorizer(int... palette) {
        this(getPaletteBytes(palette), 0, 0.);
    }

    private Colorizer(int[] palette, int interpolations, double shift) {
        this(getPaletteBytes(palette), interpolations, shift);
    }

    private Colorizer(int[][] paletteBytes, int interpolations, double shift) {
        mPaletteBytes = paletteBytes;
        mInterpolations = interpolations;
        mInterpolationMultiplier = 1<<interpolations;
        mColorCount = paletteBytes.length*mInterpolationMultiplier;
        mShift = shift;
        mRandom = new Random();
    }

    private static int[][] getPaletteBytes(int[] palette) {
        int[][] paletteBytes = new int[palette.length][];
        for (int i = 0; i < palette.length; i++) {
            paletteBytes[i] = new int[] {
                ((palette[i]>>>16) & 0xff),
                ((palette[i]>>>8) & 0xff),
                ((palette[i]) & 0xff)
            };
        }

        return paletteBytes;
    }

    private Colorizer(Colorizer colorizer, int interpolations) {
        this(colorizer.mPaletteBytes, colorizer.mInterpolations + interpolations, colorizer.mShift);
    }

    private Colorizer(Colorizer colorizer, double shiftOffset) {
        this(
            colorizer.mPaletteBytes,
            colorizer.mInterpolations,
            Math.max(Math.min(colorizer.mShift + shiftOffset, 1.), -1.));
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.utils;

import de.greenrobot.event.EventBus;

/** Exposes {@link EventBus} APIs in a way that can be mocked/faked in tests. */
public interface EventBusInterface extends EventBusRegistrationInterface {
    /** See {@link EventBus#post(Object)}. */
    void post(Object value);
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.utils;

import de.greenrobot.event.EventBus;

/** Exposes {@link EventBus} registration APIs in a way that can be mocked/faked in tests. */
public interface EventBusRegistrationInterface {
    /** See {@link EventBus#register(Object)}. */
    void register(Object receiver);

    /** See {@link EventBus#unregister(Object)}. */
    void unregister(Object receiver);
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.utils;

import org.projectbuendia.client.ui.BaseActivity;
import org.projectbuendia.client.ui.login.LoginActivity;

import javax.inject.Singleton;

import dagger.Module;
import dagger.Provides;

/** A Dagger module that provides bindings for utilities. */
@Module(
    injects = {
        BaseActivity.class,
        LoginActivity.class
    },
    complete = false,
    library = true)
public class UtilsModule {

    @Provides
    @Singleton AsyncTaskRunner provideAsyncTaskRunner() {
        return AsyncTaskRunner.DEFAULT;
    }

    @Provides
    @Singleton Colorizer provideUserColorizer() {
        return new Colorizer(
            0xffb0120a, 0xff880e4f, 0xff4a148c, 0xff311b92, 0xff1a237e, 0xff2a36b1,
            0xff01579b, 0xff006064, 0xff004d40, 0xff0d5302, 0xff33691e, 0xff827717,
            0xfff57f17, 0xffff6f00, 0xffe65100, 0xffbf360c, 0xff3e2723
        ).withTint(.2);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.utils;

import com.google.common.base.Preconditions;

import de.greenrobot.event.EventBus;

public final class EventBusWrapper implements EventBusInterface {
    private final EventBus mEventBus;

    public EventBusWrapper(EventBus eventBus) {
        mEventBus = Preconditions.checkNotNull(eventBus);
    }

    @Override public void register(Object receiver) {
        mEventBus.register(receiver);
    }

    @Override public void unregister(Object receiver) {
        mEventBus.unregister(receiver);
    }

    @Override public void post(Object value) {
        mEventBus.post(value);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.updater;

import com.android.volley.DefaultRetryPolicy;
import com.android.volley.Response;
import com.google.gson.reflect.TypeToken;

import org.projectbuendia.client.AppSettings;
import org.projectbuendia.client.net.Common;
import org.projectbuendia.client.net.GsonRequest;
import org.projectbuendia.client.net.VolleySingleton;
import org.projectbuendia.client.json.JsonUpdateInfo;

import java.util.List;

/** Encapsulates requests to the package server. */
public class PackageServer {

    /**
     * The package server's module name for updates to this app.  A name of "foo"
     * means the updates are named "foo-1.2.apk", "foo-1.3.apk", etc. and their
     * index is available at "foo.json".
     */
    private static final String MODULE_NAME = "buendia-client";

    private final VolleySingleton mVolley;
    private final AppSettings mSettings;

    public PackageServer(VolleySingleton volley, AppSettings settings) {
        mVolley = volley;
        mSettings = settings;
    }

    /**
     * Asynchronously issues a request to get the index of available Android updates.
     * @param listener      the callback to be invoked if the request succeeds
     * @param errorListener the callback to be invoked if the request fails
     */
    public void getPackageIndex(
        Response.Listener<List<JsonUpdateInfo>> listener,
        Response.ErrorListener errorListener) {
        mVolley.addToRequestQueue(
            new GsonRequest<>(
                mSettings.getPackageServerUrl("/" + MODULE_NAME + ".json"),
                new TypeToken<List<JsonUpdateInfo>>() {}.getType(),
                null /* headers */,
                listener,
                errorListener
            ).setRetryPolicy(
                new DefaultRetryPolicy(Common.REQUEST_TIMEOUT_MS_MEDIUM, 1, 1f)));
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.updater;

import android.app.Application;
import android.app.DownloadManager;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.net.Uri;
import android.os.Environment;

import com.android.volley.NoConnectionError;
import com.android.volley.Response;
import com.android.volley.VolleyError;

import org.joda.time.Duration;
import org.joda.time.Instant;
import org.projectbuendia.client.AppSettings;
import org.projectbuendia.client.events.UpdateAvailableEvent;
import org.projectbuendia.client.events.UpdateNotAvailableEvent;
import org.projectbuendia.client.events.UpdateReadyToInstallEvent;
import org.projectbuendia.client.json.JsonUpdateInfo;
import org.projectbuendia.client.utils.LexicographicVersion;
import org.projectbuendia.client.utils.Logger;

import java.io.File;
import java.util.List;

import de.greenrobot.event.EventBus;

/**
 * An object that manages auto-updating of the application from a configurable package server.
 * <p/>
 * <p>This class requires that all methods be called from the main thread.
 */
public class UpdateManager {

    /**
     * The minimal version number.
     * <p/>
     * <p>This value is smaller than any other version. If the current application has this version,
     * any non-minimal update will be installed over it. If an update has this version, it will
     * never be installed over any the current application.
     */
    public static final LexicographicVersion MINIMAL_VERSION = LexicographicVersion.parse("0");
    private static final Logger LOG = Logger.create();
    /**
     * The update manager's module name for updates to this app.  A name of "foo"
     * means the updates are saved as "foo-1.2.apk", "foo-1.3.apk" on disk.
     */
    private static final String MODULE_NAME = "buendia-client";
    private static final IntentFilter sDownloadCompleteIntentFilter =
        new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE);

    private final Object mLock = new Object();

    private final Application mApplication;
    private final PackageServer mServer;

    private final PackageManager mPackageManager;
    private final LexicographicVersion mCurrentVersion;
    private final DownloadManager mDownloadManager;
    private final AppSettings mSettings;

    private Instant mLastCheckForUpdateTime = new Instant(0 /*instant*/);
    private AvailableUpdateInfo mLastAvailableUpdateInfo = null;

    // TODO: Consider caching this in SharedPreferences OR standardizing the location of it
    // so that we can check for it on application launch.
    private DownloadedUpdateInfo mLastDownloadedUpdateInfo = null;

    private final Object mDownloadLock = new Object();

    // ID of the currently running download, or -1 if no download is underway.
    private long mDownloadId = -1;

    /**
     * Ensures that a check for available updates has been initiated within the
     * last update interval period {@see AppSettings#getApkUpdateInterval()},
     * or initiates one.  May post events that update the UI even if no new
     * server check is initiated.  The check proceeds asynchronously in the
     * background and eventually posts the relevant events {@see postEvent()}.
     * Clients should call this method and then check for two sticky events:
     * UpdateAvailableEvent and UpdateReadyToInstallEvent.
     */
    public void checkForUpdate() {
        Instant now = Instant.now();
        if (now.isBefore(mLastCheckForUpdateTime.plus(
            Duration.standardSeconds(mSettings.getApkUpdateInterval() - 1)))) {
            if (!isDownloadInProgress()) {
                // This immediate check just updates the event state to match any current
                // knowledge of an available or downloaded update.  The more interesting
                // calls to postEvents occur below in PackageIndexReceivedListener and
                // DownloadReceiver.
                postEvents();
            }
            return;
        }

        PackageIndexReceivedListener listener = new PackageIndexReceivedListener();
        mServer.getPackageIndex(listener, listener);
        mLastCheckForUpdateTime = now;
    }

    /** Returns true if a download is in progress. */
    public boolean isDownloadInProgress() {
        return mDownloadId >= 0;
    }

    /**
     * Posts events notifying of whether a file is available to be downloaded, or a
     * file is downloaded and ready to install.  See {@link UpdateReadyToInstallEvent},
     * {@link UpdateAvailableEvent}, and {@link UpdateNotAvailableEvent} for details.
     */
    protected void postEvents() {
        EventBus bus = EventBus.getDefault();
        if (mLastDownloadedUpdateInfo.shouldInstall()
            && mLastDownloadedUpdateInfo.downloadedVersion.greaterThanOrEqualTo(
            mLastAvailableUpdateInfo.availableVersion)) {
            bus.postSticky(new UpdateReadyToInstallEvent(mLastDownloadedUpdateInfo));
        } else if (mLastAvailableUpdateInfo.shouldUpdate()) {
            bus.removeStickyEvent(UpdateReadyToInstallEvent.class);
            bus.postSticky(new UpdateAvailableEvent(mLastAvailableUpdateInfo));
        } else {
            bus.removeStickyEvent(UpdateReadyToInstallEvent.class);
            bus.removeStickyEvent(UpdateAvailableEvent.class);
            bus.post(new UpdateNotAvailableEvent());
        }
    }

    /**
     * Starts downloading an available update in the background, registering a
     * DownloadUpdateReceiver to be invoked when the download is complete.
     * @return whether a new download was started; {@code false} if the download failed to start.
     */
    public boolean startDownload(AvailableUpdateInfo availableUpdateInfo) {
        // TODO(ping): 2019-09-18 - For some reason, this starts the
        // download but Android never reports completion.
        // So, for now, send the user to the /client webpage instead.
        if (2 > 1) {
            Uri uri = Uri.parse("http://" + mSettings.getServer() + "/client");
            mApplication.startActivity(new Intent(Intent.ACTION_VIEW, uri).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));
            return true;
        }

        synchronized (mDownloadLock) {
            cancelDownload();

            mApplication.registerReceiver(
                new DownloadUpdateReceiver(), sDownloadCompleteIntentFilter);

            try {
                String dir = getDownloadDirectory();
                if (dir == null) {
                    LOG.e("no external storage is available, can't start download");
                    return false;
                }
                String filename = MODULE_NAME + "-"
                    + availableUpdateInfo.availableVersion + ".apk";
                DownloadManager.Request request =
                    new DownloadManager.Request(availableUpdateInfo.updateUri)
                        .setDestinationInExternalPublicDir(dir, filename)
                        .setNotificationVisibility(
                            DownloadManager.Request.VISIBILITY_VISIBLE);
                mDownloadId = mDownloadManager.enqueue(request);
                LOG.i("Starting download: " + availableUpdateInfo.updateUri
                    + " -> " + filename + " in " + dir);
                return true;
            } catch (Exception e) {
                LOG.e(e, "Failed to download application update from "
                    + availableUpdateInfo.updateUri);
                return false;
            }
        }
    }

    /** Stops any currently running download. */
    public boolean cancelDownload() {
        if (isDownloadInProgress()) {
            mDownloadManager.remove(mDownloadId);
            mDownloadId = -1;
            return true;
        }
        return false;
    }

    /**
     * Returns the relative path to the directory in which updates will be downloaded,
     * or null if storage is unavailable.
     */
    private String getDownloadDirectory() {
        String externalStorageDirectory =
            Environment.getExternalStorageDirectory().getAbsolutePath();
        File externalFilesDir = mApplication.getExternalFilesDir(null);
        if (externalFilesDir == null) {
            return null;
        }
        String downloadDirectory = externalFilesDir.getAbsolutePath();
        if (downloadDirectory.startsWith(externalStorageDirectory)) {
            downloadDirectory = downloadDirectory.substring(externalStorageDirectory.length());
        }
        return downloadDirectory;
    }

    /** Installs the last downloaded update. */
    public void installUpdate(DownloadedUpdateInfo updateInfo) {
        Uri apkUri = Uri.parse(updateInfo.path);
        Intent installIntent = new Intent(Intent.ACTION_VIEW)
            .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            .setDataAndType(apkUri, "application/vnd.android.package-archive");
        mApplication.startActivity(installIntent);
    }

    UpdateManager(Application application, PackageServer packageServer, AppSettings settings) {
        mApplication = application;
        mServer = packageServer;
        mSettings = settings;
        mPackageManager = application.getPackageManager();
        mDownloadManager =
            (DownloadManager) application.getSystemService(Context.DOWNLOAD_SERVICE);
        mCurrentVersion = getCurrentVersion();
        mLastAvailableUpdateInfo = AvailableUpdateInfo.getInvalid(mCurrentVersion);
        mLastDownloadedUpdateInfo = DownloadedUpdateInfo.getInvalid(mCurrentVersion);
    }

    /** Returns the version of the application. */
    private LexicographicVersion getCurrentVersion() {
        PackageInfo packageInfo;
        try {
            packageInfo =
                mPackageManager.getPackageInfo(mApplication.getPackageName(), 0 /*flags*/);
        } catch (PackageManager.NameNotFoundException e) {
            LOG.e(
                e,
                "No package found with the name " + mApplication.getPackageName() + ". "
                    + "This should never happen.");
            return MINIMAL_VERSION;
        }

        try {
            return LexicographicVersion.parse(packageInfo.versionName);
        } catch (IllegalArgumentException e) {
            LOG.w("App has an invalid version (or is a dev build): " + packageInfo.versionName);
            return MINIMAL_VERSION;
        }
    }

    private DownloadedUpdateInfo getLastDownloadedUpdateInfo() {
        String dir = getDownloadDirectory();
        if (dir == null) {
            LOG.e("no external storage is available, no download directory for updates");
            return DownloadedUpdateInfo.getInvalid(mCurrentVersion);
        }
        File downloadDirectoryFile =
            new File(Environment.getExternalStorageDirectory(), dir);
        if (!downloadDirectoryFile.exists()) {
            return DownloadedUpdateInfo.getInvalid(mCurrentVersion);
        }
        if (!downloadDirectoryFile.isDirectory()) {
            LOG.e(
                "The path in which updates are downloaded is not a directory: '%1$s'",
                downloadDirectoryFile.toString());
            return DownloadedUpdateInfo.getInvalid(mCurrentVersion);
        }

        File[] files = downloadDirectoryFile.listFiles();
        File latestApk = null;
        for (File file : files) {
            if (file.isFile()
                && file.getName().endsWith(".apk")
                && (latestApk == null || file.lastModified() > latestApk.lastModified())) {
                latestApk = file;
            }
        }

        if (latestApk == null) {
            return DownloadedUpdateInfo.getInvalid(mCurrentVersion);
        } else {
            return DownloadedUpdateInfo
                .fromUri(mCurrentVersion, "file://" + latestApk.getAbsolutePath());
        }
    }

    /** A listener that receives the index of available .apk files from the package server. */
    private class PackageIndexReceivedListener
        implements Response.Listener<List<JsonUpdateInfo>>, Response.ErrorListener {

        @Override public void onResponse(List<JsonUpdateInfo> response) {
            synchronized (mLock) {
                mLastAvailableUpdateInfo =
                    AvailableUpdateInfo.fromResponse(mCurrentVersion, response);
                mLastDownloadedUpdateInfo = getLastDownloadedUpdateInfo();
                LOG.i("received package index; lastAvailableUpdate: " + mLastAvailableUpdateInfo);
                postEvents();
            }
        }

        @Override public void onErrorResponse(VolleyError error) {
            String message = "Server failed; will retry shortly";
            if (error != null && error.networkResponse != null) {
                message = "Server failed (" + error.networkResponse.statusCode + "); will retry shortly";
            }
            if (error instanceof NoConnectionError) {
                LOG.w(message + " - " + error);
            } else {
                LOG.w(error, message);
            }
            // assume no update is available
            EventBus.getDefault().post(new UpdateNotAvailableEvent());
        }
    }

    /**
     * A {@link BroadcastReceiver} that listens for
     * {@code DownloadManager.ACTION_DOWNLOAD_COMPLETED} intents.
     */
    private class DownloadUpdateReceiver extends BroadcastReceiver {

        @Override public void onReceive(Context context, Intent intent) {
            synchronized (mDownloadLock) {
                if (!isDownloadInProgress()) {
                    LOG.e(
                        "Received an ACTION_DOWNLOAD_COMPLETED intent when no download was in "
                            + "progress. This indicates that this receiver was registered "
                            + "incorrectly. Unregistering receiver.");
                    mApplication.unregisterReceiver(this);
                    return;
                }

                long receivedDownloadId =
                    intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1);
                if (mDownloadId != receivedDownloadId) {
                    LOG.d(
                        "Received an ACTION_DOWNLOAD_COMPLETED intent with download ID "
                            + receivedDownloadId + " when the expected download ID is "
                            + mDownloadId + ". Download was probably initiated by another "
                            + " application.");
                    return;
                }

                // We have received the intent for our download, so we'll call the download finished
                // and unregister the receiver.
                mDownloadId = -1;
                mApplication.unregisterReceiver(this);

                final String uriString;
                try (Cursor cursor = mDownloadManager.query(
                    new DownloadManager.Query().setFilterById(receivedDownloadId))) {
                    if (!cursor.moveToFirst()) {
                        LOG.w(
                            "Received download ID " + receivedDownloadId + " does not exist.");
                        // TODO: Consider firing an event.
                        return;
                    }

                    int status = cursor.getInt(
                        cursor.getColumnIndex(DownloadManager.COLUMN_STATUS));
                    if (status != DownloadManager.STATUS_SUCCESSFUL) {
                        LOG.w("Update download failed with status " + status + ".");
                        // TODO: Consider firing an event.
                        return;
                    }

                    uriString = cursor.getString(
                        cursor.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI));
                    if (uriString == null) {
                        LOG.w("No path for a downloaded file exists.");
                        // TODO: Consider firing an event.
                        return;
                    }
                }

                try {
                    Uri.parse(uriString);
                } catch (IllegalArgumentException e) {
                    LOG.w(e, "Path for downloaded file is invalid: %1$s.", uriString);
                    // TODO: Consider firing an event.
                    return;
                }

                mLastDownloadedUpdateInfo =
                    DownloadedUpdateInfo.fromUri(mCurrentVersion, uriString);
                LOG.i("downloaded update: " + mLastDownloadedUpdateInfo);

                if (!mLastDownloadedUpdateInfo.isValid) {
                    LOG.w(
                        "The last update downloaded from the server is invalid. Update checks "
                            + "will not occur for the next %1$d seconds.",
                        mSettings.getApkUpdateInterval());

                    // Set the last available update info to an invalid value so as to prevent
                    // further download attempts.
                    mLastAvailableUpdateInfo = AvailableUpdateInfo.getInvalid(mCurrentVersion);

                    return;
                }

                if (!mLastAvailableUpdateInfo.availableVersion
                    .greaterThanOrEqualTo(mLastDownloadedUpdateInfo.downloadedVersion)) {
                    LOG.w(
                        "The last update downloaded from the server was reported to have "
                            + "version '%1$s' but actually has version '%2$s'. This "
                            + "indicates a server configuration problem. Update checks "
                            + "will not occur for the next %3$d seconds.",
                        mLastAvailableUpdateInfo.availableVersion.toString(),
                        mLastDownloadedUpdateInfo.downloadedVersion.toString(),
                        mSettings.getApkUpdateInterval());

                    // Set the last available update info to an invalid value so as to prevent
                    // further download attempts.
                    mLastAvailableUpdateInfo = AvailableUpdateInfo.getInvalid(mCurrentVersion);

                    return;
                }

                postEvents();
            }
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.updater;

import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;

import org.projectbuendia.client.App;
import org.projectbuendia.client.BuildConfig;
import org.projectbuendia.client.utils.LexicographicVersion;
import org.projectbuendia.client.utils.Logger;

/**
 * An object containing information about an update that has been downloaded and is ready to be
 * installed.
 */
public class DownloadedUpdateInfo {

    public final boolean isValid;
    public final LexicographicVersion currentVersion;
    public final LexicographicVersion downloadedVersion;
    public final String path;
    private static final Logger LOG = Logger.create();

    /** Creates an instance of {@link DownloadedUpdateInfo} from a path to an APK on disk. */
    public static DownloadedUpdateInfo fromUri(LexicographicVersion currentVersion, String uri) {
        if (uri == null || uri.equals("") || !uri.startsWith("file://")) {
            LOG.w("URI was not specified or invalid.");
            return getInvalid(currentVersion);
        }

        // Remove the leading "file://".
        String path = uri.substring(7);
        PackageManager packageManager = App.getInstance().getPackageManager();

        PackageInfo packageInfo = packageManager.getPackageArchiveInfo(path, 0 /*flags*/);
        if (packageInfo == null) {
            LOG.w("'%1$s' is not a valid APK.", uri);
            return getInvalid(currentVersion);
        }

        if (!packageInfo.packageName.equals(BuildConfig.APPLICATION_ID)) {
            LOG.w(
                "'%1$s' does not have the correct package name. Expected: '%2$s'; actual: "
                    + "'%3$s'.",
                uri,
                BuildConfig.APPLICATION_ID,
                packageInfo.packageName);
            return getInvalid(currentVersion);
        }

        LexicographicVersion downloadedVersion;
        try {
            downloadedVersion = LexicographicVersion.parse(packageInfo.versionName);
        } catch (IllegalArgumentException e) {
            LOG.w("%1$s has an invalid version: %2$s.", uri, packageInfo.versionName);
            return getInvalid(currentVersion);
        }

        return new DownloadedUpdateInfo(true /*isValid*/, currentVersion, downloadedVersion, uri);
    }

    /** Creates an instance of {@link DownloadedUpdateInfo} for an invalid update. */
    public static DownloadedUpdateInfo getInvalid(LexicographicVersion currentVersion) {
        return new DownloadedUpdateInfo(
            false /*isValid*/, currentVersion, UpdateManager.MINIMAL_VERSION, null /*path*/);
    }

    /** Converts the info as a string for display. */
    public String toString() {
        return "DownloadedUpdateInfo(isValid=" + isValid + ", "
            + "currentVersion=" + currentVersion + ", "
            + "availableVersion=" + downloadedVersion + ", "
            + "path=" + path + ")";
    }

    public boolean shouldInstall() {
        return isValid && downloadedVersion.greaterThan(currentVersion);
    }

    private DownloadedUpdateInfo(
        boolean isValid,
        LexicographicVersion currentVersion,
        LexicographicVersion downloadedVersion,
        String uri) {
        this.isValid = isValid;
        this.currentVersion = currentVersion;
        this.downloadedVersion = downloadedVersion;
        this.path = uri;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.updater;

import android.app.Application;

import org.projectbuendia.client.AppSettings;
import org.projectbuendia.client.net.VolleySingleton;
import org.projectbuendia.client.ui.lists.PatientListActivity;

import javax.inject.Singleton;

import dagger.Module;
import dagger.Provides;

/** A Dagger module that provides bindings for update-related classes. */
@Module(
    injects = {
        PatientListActivity.class
    },
    complete = false,
    library = true)
public class UpdateModule {

    @Provides
    @Singleton
    PackageServer providePackageServer(Application application, AppSettings settings) {
        return new PackageServer(VolleySingleton.getInstance(application), settings);
    }

    @Provides
    @Singleton UpdateManager provideUpdateManager(
        Application application, PackageServer server, AppSettings settings) {
        return new UpdateManager(application, server, settings);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.updater;

import android.net.Uri;

import org.projectbuendia.client.json.JsonUpdateInfo;
import org.projectbuendia.client.utils.LexicographicVersion;
import org.projectbuendia.client.utils.Logger;

import java.util.List;

/** An object containing information about an available application update. */
public class AvailableUpdateInfo {

    public final boolean isValid;
    public final LexicographicVersion currentVersion;
    public final LexicographicVersion availableVersion;
    public final Uri updateUri;
    private static final Logger LOG = Logger.create();

    /** Creates an instance of {@link AvailableUpdateInfo} from a server response. */
    public static AvailableUpdateInfo fromResponse(
        LexicographicVersion currentVersion, List<JsonUpdateInfo> response) {
        if (response == null) {
            LOG.w("The update info response is null.");
            return getInvalid(currentVersion);
        }

        if (response.size() == 0) {
            LOG.w("No versions found in the update info.");
            return getInvalid(currentVersion);
        }

        // The package server is responsible for sorting the index in
        // order by increasing version number, so the last is the highest.
        JsonUpdateInfo latestUpdateInfo = response.get(response.size() - 1);

        LexicographicVersion version = latestUpdateInfo.getParsedVersion();
        if (version == null) {
            LOG.w("Invalid version in 'version' field: " + latestUpdateInfo.version);
            return getInvalid(currentVersion);
        }

        Uri updateUri;
        try {
            updateUri = Uri.parse(latestUpdateInfo.url);
        } catch (IllegalArgumentException e) {
            LOG.w(e, "Invalid URL in 'url' field: " + latestUpdateInfo.url);
            return getInvalid(currentVersion);
        }

        return new AvailableUpdateInfo(true /*isValid*/, currentVersion, version, updateUri);
    }

    /** Creates an instance of {@link AvailableUpdateInfo} for an invalid update. */
    public static AvailableUpdateInfo getInvalid(LexicographicVersion currentVersion) {
        return new AvailableUpdateInfo(
            false /*isValid*/,
            currentVersion,
            UpdateManager.MINIMAL_VERSION,
            null /*updateUri*/);
    }

    /** Converts the info as a string for display. */
    public String toString() {
        return "AvailableUpdateInfo(isValid=" + isValid + ", "
            + "currentVersion=" + currentVersion + ", "
            + "availableVersion=" + availableVersion + ", "
            + "updateUri=" + updateUri + ")";
    }

    /** Returns true if this is a valid update with a higher version number. */
    public boolean shouldUpdate() {
        return isValid && availableVersion.greaterThan(currentVersion);
    }

    private AvailableUpdateInfo(
        boolean isValid,
        LexicographicVersion currentVersion,
        LexicographicVersion availableVersion,
        Uri updateUri) {
        this.isValid = isValid;
        this.currentVersion = currentVersion;
        this.availableVersion = availableVersion;
        this.updateUri = updateUri;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.user;

import android.os.AsyncTask;

import com.google.common.collect.ImmutableSet;

import org.projectbuendia.client.App;
import org.projectbuendia.client.events.CrudEventBus;
import org.projectbuendia.client.events.user.FetchUsersTaskFailedEvent;
import org.projectbuendia.client.events.user.UsersFetchedEvent;
import org.projectbuendia.client.json.JsonUser;
import org.projectbuendia.client.net.OpenMrsConnectionDetails;
import org.projectbuendia.client.net.VolleySingleton;
import org.projectbuendia.client.utils.Logger;

import java.util.Set;

/** Fetches the list of users (providers) from the database. */
public class FetchUsersTask extends AsyncTask<Object, Void, Set<JsonUser>> {
    private static final Logger LOG = Logger.create();

    private final CrudEventBus bus;
    private final String server;
    private final String username;
    private final String password;

    public FetchUsersTask(CrudEventBus bus, String server, String username, String password) {
        this.bus = bus;
        this.server = server;
        this.username = username;
        this.password = password;
    }

    @Override protected Set<JsonUser> doInBackground(Object... unusedObjects) {
        OpenMrsConnectionDetails connection = new OpenMrsConnectionDetails(
            VolleySingleton.getInstance(App.getInstance()), null
        ) {
            @Override public String getBuendiaApiUrl() {
                return "http://" + server + ":9000/openmrs/ws/rest/buendia";
            }

            @Override public String getUser() {
                return username;
            }

            @Override public String getPassword() {
                return password;
            }
        };
        try {
            return new UserStore().getUsersFromServer(connection);
        } catch (Exception e) {
            LOG.e(e, "FetchUsersTask failed");
            bus.post(new FetchUsersTaskFailedEvent());
            return null;
        }
    }

    @Override protected void onPostExecute(Set<JsonUser> users) {
        if (users != null) {
            bus.post(new UsersFetchedEvent(
                server, username, password, ImmutableSet.copyOf(users)));
        }
    }
}


// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.user;

import android.content.ContentProviderClient;
import android.content.ContentProviderOperation;
import android.content.ContentValues;
import android.content.OperationApplicationException;
import android.content.SyncResult;
import android.database.Cursor;
import android.database.sqlite.SQLiteException;
import android.os.RemoteException;

import com.android.volley.VolleyError;
import com.android.volley.toolbox.RequestFuture;
import com.google.common.collect.ImmutableSet;

import org.projectbuendia.client.App;
import org.projectbuendia.client.json.JsonNewUser;
import org.projectbuendia.client.json.JsonUser;
import org.projectbuendia.client.net.OpenMrsConnectionDetails;
import org.projectbuendia.client.net.OpenMrsServer;
import org.projectbuendia.client.providers.BuendiaProvider;
import org.projectbuendia.client.providers.Contracts;
import org.projectbuendia.client.providers.Contracts.Users;
import org.projectbuendia.client.providers.DatabaseTransaction;
import org.projectbuendia.client.utils.Logger;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/** A store for users. */
public class UserStore {

    private static final Logger LOG = Logger.create();
    private static final String USER_SYNC_SAVEPOINT_NAME = "USER_SYNC_SAVEPOINT";

    /** Loads users from the local store, fetching them from the server if there are none. */
    public Set<JsonUser> loadKnownUsers()
        throws InterruptedException, ExecutionException, TimeoutException, RemoteException,
        OperationApplicationException {
        Set<JsonUser> users = getUsersFromDb();
        if (users.isEmpty()) {
            LOG.i("No users in database; fetching from server");
            users = syncKnownUsers();
        }
        LOG.i("Found %d users in db", users.size());
        return users;
    }

    /** Syncs known users with the server. */
    public Set<JsonUser> syncKnownUsers()
        throws ExecutionException, InterruptedException, TimeoutException, RemoteException,
        OperationApplicationException {
        Set<JsonUser> users = getUsersFromServer();
        updateDatabase(users);
        return users;
    }

    /** Adds a new user, both locally and on the server. */
    public JsonUser addUser(JsonNewUser user) throws VolleyError {
        JsonUser newUser = addUserOnServer(user);
        addUserLocally(newUser);
        return newUser;
    }

    private void addUserLocally(JsonUser user) {
        LOG.i("Updating user db with newly added user");
        ContentProviderClient client = App.getResolver()
            .acquireContentProviderClient(Users.URI);
        try {
            ContentValues values = new ContentValues();
            values.put(Users.UUID, user.getUuid());
            values.put(Users.FULL_NAME, user.getName());
            client.insert(Users.URI, values);
        } catch (RemoteException e) {
            LOG.e(e, "Failed to update database");
        } finally {
            client.release();
        }
    }

    private JsonUser addUserOnServer(JsonNewUser user) throws VolleyError {
        // Define a container for the results.
        class Result {
            public JsonUser user = null;
            public VolleyError error = null;
        }

        final Result result = new Result();

        // Make an async call to the server and use a CountDownLatch to block until the result is
        // returned.
        final CountDownLatch latch = new CountDownLatch(1);
        App.getServer().addUser(user,
            response -> {
                result.user = response;
                latch.countDown();
            },
            error -> {
                LOG.e(error, "Unexpected error adding user");
                result.error = error;
                latch.countDown();
            }
        );

        try {
            latch.await();
        } catch (InterruptedException e) {
            LOG.e(e, "Interrupted while loading user list");
        }

        if (result.error != null) {
            throw result.error;
        }
        return  result.user;
    }

    private void  updateDatabase(Set<JsonUser> users) throws RemoteException, OperationApplicationException {
        LOG.i("Updating local database with %d users", users.size());
        ContentProviderClient client = App.getResolver().acquireContentProviderClient(Users.URI);
        try {
            BuendiaProvider provider = (BuendiaProvider) client.getLocalContentProvider();
            try (DatabaseTransaction tx = provider.startTransaction(USER_SYNC_SAVEPOINT_NAME)) {
                try {
                    client.applyBatch(getUserUpdateOps(users, new SyncResult()));
                } catch (RemoteException | OperationApplicationException e) {
                    tx.rollback();
                    throw e;
                }
            }
        } finally {
            // NOTE: We aren't using try-with-resources here because
            // ContentProviderClient wasn't autocloseable in Android 5.
            client.release();
        }
    }

    private Set<JsonUser> getUsersFromServer()
        throws ExecutionException, InterruptedException, TimeoutException {
        return getUsersFromServer(null);
    }

    public Set<JsonUser> getUsersFromServer(OpenMrsConnectionDetails connection)
        throws ExecutionException, InterruptedException, TimeoutException {
        RequestFuture<List<JsonUser>> future = RequestFuture.newFuture();
        App.getServer().listUsers(connection, future, future);
        List<JsonUser> users = future.get(OpenMrsServer.TIMEOUT_SECONDS, TimeUnit.SECONDS);
        LOG.i("Got %d users from server", users.size());
        return new HashSet<>(users);
    }

    /**
     * Retrieves a user set. If there is no user or if an error occurs, then an unmodifiable empty
     * set is returned.
     * */
    private Set<JsonUser> getUsersFromDb() {
        Cursor cursor = null;
        ContentProviderClient client = null;
        try {
            client = App.getResolver()
                .acquireContentProviderClient(Users.URI);

            // Request users from database.
            cursor = client.query(Users.URI, new String[]{Users.FULL_NAME, Users.UUID},
                null, null, Users.FULL_NAME);

            // If no data was retrieved from database
            if (cursor == null || cursor.getCount() == 0) {
                return ImmutableSet.of();
            }

            int fullNameColumn = cursor.getColumnIndex(Users.FULL_NAME);
            int uuidColumn = cursor.getColumnIndex(Users.UUID);
            Set<JsonUser> result = new HashSet<>();
            while (cursor.moveToNext()) {
                JsonUser user =
                    new JsonUser(cursor.getString(uuidColumn), cursor.getString(fullNameColumn));
                result.add(user);
            }
            return result;
        } catch (SQLiteException e) {
            LOG.w(e, "Error retrieving users from database;");
            return ImmutableSet.of();
        } catch (RemoteException e) {
            LOG.w(e, "Error retrieving users from database");
            return ImmutableSet.of();
        }finally {
            if (cursor != null) {
                cursor.close();
            }
            if (client != null) {
                client.release();
            }
        }
    }

    /** Given a set of users, replaces the current set of users with users from that set. */
    private static ArrayList<ContentProviderOperation> getUserUpdateOps(
            Set<JsonUser> response, SyncResult syncResult) {
        ArrayList<ContentProviderOperation> ops = new ArrayList<>();
        // Delete all users before inserting.
        ops.add(ContentProviderOperation.newDelete(Contracts.Users.URI).build());
        // TODO: Update syncResult delete counts.
        for (JsonUser user : response) {
            ops.add(ContentProviderOperation.newInsert(Contracts.Users.URI)
                    .withValue(Contracts.Users.UUID, user.getUuid())
                    .withValue(Contracts.Users.FULL_NAME, user.getName())
                    .build());
            syncResult.stats.numInserts++;
        }
        return ops;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.user;

import android.content.OperationApplicationException;
import android.os.AsyncTask;
import android.os.RemoteException;
import android.view.View;
import android.widget.TextView;

import com.android.volley.VolleyError;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;

import org.projectbuendia.client.events.user.ActiveUserSetEvent;
import org.projectbuendia.client.events.user.ActiveUserUnsetEvent;
import org.projectbuendia.client.events.user.KnownUsersLoadFailedEvent;
import org.projectbuendia.client.events.user.KnownUsersLoadedEvent;
import org.projectbuendia.client.events.user.KnownUsersSyncFailedEvent;
import org.projectbuendia.client.events.user.KnownUsersSyncedEvent;
import org.projectbuendia.client.events.user.UserAddFailedEvent;
import org.projectbuendia.client.events.user.UserAddedEvent;
import org.projectbuendia.client.json.JsonNewUser;
import org.projectbuendia.client.json.JsonUser;
import org.projectbuendia.client.utils.AsyncTaskRunner;
import org.projectbuendia.client.utils.Colorizer;
import org.projectbuendia.client.utils.EventBusInterface;
import org.projectbuendia.client.utils.Logger;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

import javax.annotation.Nullable;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * Manages the available logins and the currently logged-in user.
 * <p/>
 * <p>All classes that care about the current active user should be able to gracefully handle the
 * following event bus events:
 * <ul>
 * <li>{@link ActiveUserSetEvent}
 * <li>{@link ActiveUserUnsetEvent}
 * </ul>
 * <p/>
 * <p>All classes that care about all known users should additionally be able to gracefully handle
 * the following event bus events:
 * <ul>
 * <li>{@link KnownUsersLoadedEvent}
 * <li>{@link KnownUsersLoadFailedEvent}
 * <li>{@link KnownUsersSyncedEvent}
 * <li>{@link KnownUsersSyncFailedEvent}
 * </ul>
 * <p/>
 * <p>All classes that care about being able to add and delete users should additionally be able
 * gracefully handle the following event bus events:
 * <ul>
 * <li>{@link UserAddedEvent}
 * <li>{@link UserAddFailedEvent}
 * </ul>
 * <p/>
 * <p>All methods should be called on the main thread.
 */
public class UserManager {

    private static final Logger LOG = Logger.create();

    private final UserStore mUserStore;
    private final EventBusInterface mEventBus;
    private final AsyncTaskRunner mAsyncTaskRunner;

    private final Set<JsonUser> mKnownUsers = new HashSet<>();
    private final Map<String, JsonUser> mUsersByUuid = new HashMap<>();
    private boolean mSynced = false;
    private boolean mAutoCancelEnabled = false;
    private boolean mIsDirty = false;
    private Colorizer mColorizer;
    @Nullable private AsyncTask mLastTask;
    @Nullable private JsonUser mActiveUser;

    /**
     * Utility function for automatically canceling user load tasks to simulate network connectivity
     * issues.
     * TODO: Move to a fake or mock out when daggered.
     */
    public void setAutoCancelEnabled(boolean autoCancelEnabled) {
        mAutoCancelEnabled = autoCancelEnabled;
    }

    /** Resets the UserManager to its initial empty state. */
    public void reset() {
        mKnownUsers.clear();
        mUsersByUuid.clear();
        mSynced = false;
    }

    /**
     * If true, users have been recently updated and any data relying on a specific view of users
     * may be out of sync.
     */
    public boolean isDirty() {
        return mIsDirty;
    }

    /** Sets whether or not users have been recently updated. */
    public void setDirty(boolean shouldInvalidateFormCache) {
        mIsDirty = shouldInvalidateFormCache;
    }

    /**
     * Loads the set of all users known to the application from local cache.
     * <p/>
     * <p>This method will post a {@link KnownUsersLoadedEvent} if the known users were
     * successfully loaded and a {@link KnownUsersLoadFailedEvent} otherwise.
     * <p/>
     * <p>This method will only perform a local cache lookup once per application lifetime.
     */
    public void loadKnownUsers() {
        if (!mSynced) {
            mLastTask = new LoadKnownUsersTask();
            mAsyncTaskRunner.runTask(mLastTask);
        } else {
            mEventBus.post(new KnownUsersLoadedEvent(ImmutableSet.copyOf(mKnownUsers)));
        }
    }

    /** Sync users synchronously. Blocks until the list of users is synced, or interrupted. */
    public void syncKnownUsersSynchronously()
        throws InterruptedException, ExecutionException, TimeoutException, RemoteException,
        OperationApplicationException, UserSyncException {
        onUsersSynced(mUserStore.syncKnownUsers());
    }

    /**
     * Called when users are retrieved from the server, in order to send events and update user
     * state as necessary.
     */
    private void onUsersSynced(Set<JsonUser> syncedUsers) throws UserSyncException {
        if (syncedUsers == null || syncedUsers.isEmpty()) {
            throw new UserSyncException("Set of users retrieved from server is null or empty.");
        }

        ImmutableSet<JsonUser> addedUsers =
            ImmutableSet.copyOf(Sets.difference(syncedUsers, mKnownUsers));
        ImmutableSet<JsonUser> deletedUsers =
            ImmutableSet.copyOf(Sets.difference(mKnownUsers, syncedUsers));

        mKnownUsers.clear();
        mKnownUsers.addAll(syncedUsers);
        mUsersByUuid.clear();
        for (JsonUser user : mKnownUsers) {
            mUsersByUuid.put(user.getUuid(), user);
        }
        mEventBus.post(new KnownUsersSyncedEvent(addedUsers, deletedUsers));
        if (addedUsers.size() + deletedUsers.size() > 0) {
            mEventBus.post(new KnownUsersLoadedEvent(mKnownUsers));
        }

        if (mActiveUser != null && deletedUsers.contains(mActiveUser)) {
            // TODO: Potentially clear mActiveUser here.
            mEventBus.post(new ActiveUserUnsetEvent(
                mActiveUser, ActiveUserUnsetEvent.REASON_USER_DELETED));
        }

        // If at least one user was added or deleted, the set of known users has changed.
        if (!addedUsers.isEmpty() || !deletedUsers.isEmpty()) {
            setDirty(true);
        }
    }

    /** Returns the current active user or {@code null} if no user is active. */
    @Nullable public JsonUser getActiveUser() {
        return mActiveUser;
    }

    /**
     * Sets the current active user or unsets it if {@code activeUser} is {@code null}, returning
     * whether the operation succeeded.
     * <p/>
     * <p>This method will fail if the specified user is not known to the application.
     * <p/>
     * <p>This method will post an {@link ActiveUserSetEvent} if the active user was successfully
     * set and an {@link ActiveUserUnsetEvent} if the active user was unset successfully; these
     * events will be posted even if the active user did not change.
     */
    public boolean setActiveUser(@Nullable JsonUser activeUser) {
        @Nullable JsonUser previousActiveUser = mActiveUser;
        if (activeUser == null) {
            mActiveUser = null;
            mEventBus.post(new ActiveUserUnsetEvent(
                previousActiveUser, ActiveUserUnsetEvent.REASON_UNSET_INVOKED));
            return true;
        }

        if (!mKnownUsers.contains(activeUser)) {
            LOG.e("Couldn't switch user -- new user is not known");
            return false;
        }

        mActiveUser = activeUser;
        mEventBus.post(new ActiveUserSetEvent(previousActiveUser, activeUser));
        return true;
    }

    /**
     * Adds a user to the set of known users, both locally and on the server.
     * <p/>
     * <p>This method will post a {@link UserAddedEvent} if the user was added successfully and a
     * {@link UserAddFailedEvent} otherwise.
     */
    public void addUser(JsonNewUser user) {
        checkNotNull(user);
        // TODO: Validate user.
        mAsyncTaskRunner.runTask(new AddUserTask(user));
    }

    /** Thrown when an error occurs syncing users from server. */
    public static class UserSyncException extends Throwable {
        public UserSyncException(String s) {
            super(s);
        }
    }

    UserManager(
        UserStore userStore,
        EventBusInterface eventBus,
        AsyncTaskRunner asyncTaskRunner,
        Colorizer colorizer) {
        mAsyncTaskRunner = checkNotNull(asyncTaskRunner);
        mEventBus = checkNotNull(eventBus);
        mUserStore = checkNotNull(userStore);
        mColorizer = colorizer;
    }

    public JsonUser getByUuid(String uuid) {
        return mUsersByUuid.get(uuid);
    }

    public int getColor(JsonUser user) {
        return user.isGuestUser() ? 0xff666666 : mColorizer.getColorArgb(user.getName());
    }

    public void showChip(TextView view, String providerUuid) {
        JsonUser user = getByUuid(providerUuid);
        if (user != null) {
            view.setText(user.getLocalizedInitials());
            view.setBackgroundColor(getColor(user));
            view.setVisibility(View.VISIBLE);
        } else {
            view.setVisibility(View.INVISIBLE);
        }
    }

    /**
     * Loads known users from the database into memory.
     * <p/>
     * <p>Forces a network sync if the database has not been downloaded yet.
     */
    private class LoadKnownUsersTask extends AsyncTask<Object, Void, Set<JsonUser>> {
        @Override protected Set<JsonUser> doInBackground(Object... unusedObjects) {
            if (mAutoCancelEnabled) {
                cancel(true);
                return null;
            }

            try {
                return mUserStore.loadKnownUsers();
            } catch (Exception e) {
                // TODO: Figure out type of exception to throw.
                LOG.e(e, "Load users task failed");
                mEventBus.post(
                    new KnownUsersLoadFailedEvent(KnownUsersLoadFailedEvent.REASON_UNKNOWN));
                return null;
            }
        }

        @Override protected void onCancelled() {
            LOG.w("Load users task cancelled");
            mEventBus.post(
                new KnownUsersLoadFailedEvent(KnownUsersLoadFailedEvent.REASON_CANCELLED));
        }

        @Override protected void onPostExecute(Set<JsonUser> knownUsers) {
            mKnownUsers.clear();
            mUsersByUuid.clear();
            if (knownUsers != null) {
                mKnownUsers.addAll(knownUsers);
                for (JsonUser user : knownUsers) {
                    mUsersByUuid.put(user.getUuid(), user);
                }
            }
            mSynced = true;
            mEventBus.post(new KnownUsersLoadedEvent(ImmutableSet.copyOf(mKnownUsers)));
        }
    }

    /** Adds a user to the database asynchronously. */
    private final class AddUserTask extends AsyncTask<Void, Void, JsonUser> {

        private final JsonNewUser mUser;
        private boolean mAlreadyExists;
        private boolean mFailedToConnect;

        public AddUserTask(JsonNewUser user) {
            mUser = checkNotNull(user);
        }

        @Override protected JsonUser doInBackground(Void... voids) {
            try {
                return mUserStore.addUser(mUser);
            } catch (VolleyError e) {
                if (e.getMessage() != null) {
                    if (e.getMessage().contains("already in use")) {
                        mAlreadyExists = true;
                    } else if (e.getMessage().contains("failed to connect")) {
                        mFailedToConnect = true;
                    }
                }
                return null;
            }
        }

        @Override protected void onPostExecute(JsonUser addedUser) {
            if (addedUser != null) {
                mKnownUsers.add(addedUser);
                mUsersByUuid.put(addedUser.getUuid(), addedUser);
                mEventBus.post(new UserAddedEvent(addedUser));

                // Set of known users has changed.
                setDirty(true);
            } else if (mAlreadyExists) {
                mEventBus.post(new UserAddFailedEvent(
                    mUser, UserAddFailedEvent.REASON_USER_EXISTS_ON_SERVER));
            } else if (mFailedToConnect) {
                mEventBus.post(new UserAddFailedEvent(
                    mUser, UserAddFailedEvent.REASON_CONNECTION_ERROR));
            } else {
                mEventBus.post(new UserAddFailedEvent(mUser, UserAddFailedEvent.REASON_UNKNOWN));
            }
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.user;

import org.projectbuendia.client.utils.AsyncTaskRunner;
import org.projectbuendia.client.utils.Colorizer;
import org.projectbuendia.client.utils.EventBusInterface;

import javax.inject.Singleton;

import dagger.Module;
import dagger.Provides;

/** A Dagger module that provides bindings for user-related classes. */
@Module(
    complete = false,
    library = true)
public class UserModule {

    @Provides
    @Singleton UserStore provideUserStore() {
        return new UserStore();
    }

    @Provides
    @Singleton UserManager provideUserManage(
        UserStore userStore,
        EventBusInterface eventBus,
        AsyncTaskRunner asyncTaskRunner,
        Colorizer colorizer) {
        return new UserManager(userStore, eventBus, asyncTaskRunner, colorizer);
    }
}

package org.projectbuendia.client.receivers;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.BatteryManager;

import org.joda.time.Duration;
import org.joda.time.Instant;
import org.projectbuendia.client.utils.Logger;

import javax.annotation.Nonnull;

public class BatteryWatcher extends BroadcastReceiver {
    private static final Logger LOG = Logger.create();
    private Instant dockTime = null;
    private boolean acPlugged = false;

    @Override public void onReceive(Context context, Intent intent) {
        int plugged = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);
        // NOTE(ping): The charging docks we are using don't seem to trigger
        // DOCK_EVENT actions, so we watch for AC charging instead.
        boolean newAcPlugged = (plugged & BatteryManager.BATTERY_PLUGGED_AC) > 0;
        if (newAcPlugged && !acPlugged) {
            LOG.i("AC charging started");
            dockTime = Instant.now();
        }
        if (acPlugged && !newAcPlugged) {
            LOG.i("AC charging stopped");
            dockTime = null;
        }
        acPlugged = newAcPlugged;
    }

    public @Nonnull boolean isDocked() {
        return dockTime != null;
    }

    public @Nonnull Duration getDockedDuration() {
        return dockTime != null
            ? new Duration(dockTime, Instant.now())
            : new Duration(0);
    }
}

package org.projectbuendia.client.json;

import android.content.ContentValues;

import org.joda.time.DateTime;
import org.joda.time.Instant;
import org.joda.time.LocalDate;
import org.projectbuendia.models.Obs;
import org.projectbuendia.client.providers.Contracts.Observations;
import org.projectbuendia.client.utils.Utils;

/**
 * An plain-object representation of an observation received from the server.
 */
public class JsonObservation {
    public String uuid;
    public String encounter_uuid;
    public String patient_uuid;
    public String provider_uuid;
    public String concept_uuid;
    public Datatype type;
    public DateTime time;
    public String order_uuid;
    public String value_coded;
    public Double value_numeric;
    public String value_text;
    public LocalDate value_date;
    public Instant value_datetime;
    public boolean voided;

    public JsonObservation(Obs obs) {
        this.uuid = obs.uuid;
        this.encounter_uuid = obs.encounterUuid;
        this.patient_uuid = obs.patientUuid;
        this.provider_uuid = obs.providerUuid;
        this.concept_uuid = obs.conceptUuid;
        this.type = obs.type;
        this.time = obs.time;
        this.order_uuid = obs.orderUuid;
        if (obs.value != null) {
            if (obs.type == Datatype.CODED) this.value_coded = obs.value;
            if (obs.type == Datatype.NUMERIC) this.value_numeric = Double.valueOf(obs.value);
            if (obs.type == Datatype.TEXT) this.value_text = obs.value;
            if (obs.type == Datatype.DATE) this.value_date = Utils.toLocalDate(obs.value);
            if (obs.type == Datatype.DATETIME) this.value_datetime = new Instant(Long.valueOf(obs.value));
        }
    }

    public String getValueAsString() {
        switch (type) {
            case CODED:
                return value_coded;
            case NUMERIC:
                return "" + value_numeric;
            case TEXT:
                return value_text;
            case DATE:
                return value_date.toString();
            case DATETIME:
                return "" + value_datetime.getMillis();
        }
        return "";
    }

    /** Converts an observation into ContentValues for the encounters table. */
    public ContentValues toContentValues() {
        ContentValues cvs = new ContentValues();
        cvs.put(Observations.UUID, uuid);
        cvs.put(Observations.ENCOUNTER_UUID, encounter_uuid);
        cvs.put(Observations.PATIENT_UUID, patient_uuid);
        cvs.put(Observations.PROVIDER_UUID, provider_uuid);
        cvs.put(Observations.CONCEPT_UUID, concept_uuid);
        cvs.put(Observations.TYPE, type != null ? type.name() : Datatype.NONE.name());
        cvs.put(Observations.MILLIS, time.getMillis());
        cvs.put(Observations.ORDER_UUID, order_uuid);
        cvs.put(Observations.VALUE, getValueAsString());
        return cvs;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.json;

import com.google.gson.GsonBuilder;

import org.joda.time.DateTime;
import org.joda.time.Instant;
import org.joda.time.LocalDate;

/**
 * Gson serializers for custom types like Joda DateTime. Largely copied from
 * https://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Generic-Types
 */
public class Serializers {

    public static void registerTo(GsonBuilder gson) {
        gson.registerTypeAdapter(DateTime.class, new DateTimeSerializer());
        gson.registerTypeAdapter(Instant.class, new InstantSerializer());
        gson.registerTypeAdapter(LocalDate.class, new LocalDateSerializer());
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.json;

/**
 * A simple Java bean for JSON/Gson encoding/decoding, defining how the patient chart should be
 * displayed, giving the grouping and ordering of fields.
 */
public class JsonChart {
    public String uuid;  // UUID of the OpenMRS Form
    public String version;  // dot-separated decimal integers, e.g. "0.6", "0.7.1"
    public JsonChartSection[] sections;  // sections in display order
}

/*
 * Copyright 2015 The Project Buendia Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at: http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distrib-
 * uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
 * OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
 * specific language governing permissions and limitations under the License.
 */

package org.projectbuendia.client.json;

/**
 * An incremental sync response containing items of type T.  This object is
 * deserialized from JSON, so T should be a type that can be deserialized
 * from the JSON response.
 */
public class IncrementalSyncResponse<T> {
    /** A list of objects returned by the incremental sync operation. */
    public T[] results;

    /** Can be sent with the next request to cause only new data to be returned. */
    public String bookmark;

    /** True if there is more data available to be fetched. */
    public boolean more;
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.json;

import java.io.Serializable;

/** Represents a request to create a new user. */
public class JsonNewUser implements Serializable {
    public String givenName;
    public String familyName;

    public JsonNewUser(String givenName, String familyName) {
        this.givenName = givenName;
        this.familyName = familyName;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.json;

public class JsonForm {
    public String id;
    public String uuid;
    public String name;
    public String version;
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.json;

import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.client.utils.Utils;

import java.io.Serializable;
import java.util.Comparator;
import java.util.Objects;

import javax.annotation.Nonnull;

import static org.projectbuendia.client.utils.Utils.eq;

/** JSON reprsentation of a user (an OpenMRS Provider). */
public class JsonUser implements Serializable {
    private String uuid;
    private String name;

    /** This must match the same constant on the server. */
    public static final String PROVIDER_GUEST_UUID = "buendia_provider_guest";

    public static final Comparator<JsonUser> COMPARATOR_BY_NAME = (a, b) -> {
        // The guest account always sorts first.
        int aSection = a.isGuestUser() ? 1 : 2;
        int bSection = b.isGuestUser() ? 1 : 2;
        if (aSection != bSection) {
            return aSection - bSection;
        }
        return Utils.ALPHANUMERIC_COMPARATOR.compare(a.name, b.name);
    };

    /** Default constructor for serialization. */
    public JsonUser() { }

    /** Creates a user with the given unique id and full name. */
    public JsonUser(@Nonnull String uuid, @Nonnull String name) {
        this.uuid = uuid;
        this.name = name;
    }

    public String toString() {
        return Utils.format("<User %s [%s]>", Utils.repr(name), uuid);
    }

    @Override public int hashCode() {
        return Objects.hash(uuid);
    }

    @Override public boolean equals(Object other) {
        return other instanceof JsonUser && eq(uuid, ((JsonUser) other).uuid);
    }

    public final boolean isGuestUser() {
        return eq(getUuid(), PROVIDER_GUEST_UUID);
    }

    public String getName() {
        return name;
    }

    public String getLocalizedName() {
        return isGuestUser() ? App.str(R.string.guest_user_name) : name;
    }

    /** Returns the user's initials, using the first letter of each word of the user's full name. */
    public String getLocalizedInitials() {
        if (isGuestUser()) {
            return App.str(R.string.guest_user_initials);
        }
        String[] parts = name.split("\\s+");
        switch (parts.length) {
            case 0:
                return "?";
            case 1:
                return parts[0].substring(0, 1);
            default:
                return parts[0].substring(0, 1) + parts[parts.length - 1].substring(0, 1);
        }
    }

    public String getUuid() {
        return uuid;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.json;

import com.google.gson.annotations.SerializedName;

import javax.annotation.Nullable;

/** OpenMRS concept types (used for JSON representation and elsewhere). */
public enum Datatype {
    // These serialized names must match the HL7_TYPE_NAMES on the server side.
    @SerializedName("numeric") NUMERIC,
    @SerializedName("boolean") BOOLEAN,
    @SerializedName("coded") CODED,
    @SerializedName("text") TEXT,
    @SerializedName("date") DATE,
    @SerializedName("datetime") DATETIME,
    @SerializedName("none") NONE;

    /** Converts a Sex value to a code for JSON communication with the server. */
    public static @Nullable String serialize(@Nullable Datatype type) {
        if (type == null) return null;
        try {
            return Datatype.class.getField(type.name()).getAnnotation(SerializedName.class).value();
        } catch (NoSuchFieldException e) {
            return null;
        }
    }

    public static @Nullable Datatype deserialize(@Nullable String name) {
        if (name == null) return null;
        return Datatype.valueOf(name);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.json;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonParseException;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

import org.joda.time.DateTime;

import java.lang.reflect.Type;

/**
 * Utility class for serializing JODA DateTime objects from JSON returned by the OpenMRS Buendia
 * module.
 */
public class DateTimeSerializer implements JsonSerializer<DateTime>, JsonDeserializer<DateTime> {

    @Override
    public JsonElement serialize(DateTime src, Type typeOfSrc, JsonSerializationContext context) {
        return new JsonPrimitive(src.toString());
    }

    @Override
    public DateTime deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
        throws JsonParseException {
        return DateTime.parse(json.getAsString());
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.json;

import com.google.gson.annotations.SerializedName;

import org.projectbuendia.client.utils.LexicographicVersion;

/** A Gson object that represents an available update. */
public class JsonUpdateInfo {

    @SerializedName("url")
    public String url;

    @SerializedName("version")
    public String version;

    /**
     * Returns the parsed {@link LexicographicVersion} or {@code null} if the version is
     * malformed.
     */
    public LexicographicVersion getParsedVersion() {
        try {
            return version != null ? LexicographicVersion.parse(version) : null;
        } catch (IllegalArgumentException e) {
            return null;
        }
    }
}

package org.projectbuendia.client.json;

/** JSON format of a response to GET /charts?v=full */
public class JsonChartsResponse {
    public JsonChart[] results;
    public String snapshotTime;
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.json;

import org.projectbuendia.models.ChartSectionType;

/** A section in a chart (a row of tiles or a group of grid rows). */
public class JsonChartSection {
    public ChartSectionType type;
    public String label;
    public JsonChartItem[] items;
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.json;

import org.joda.time.DateTime;

import java.util.List;

/** JSON representation of an OpenMRS Encounter; call Serializers.registerTo before use. */
public class JsonEncounter {
    public String uuid;
    public String patient_uuid;
    public DateTime time;
    public String provider_uuid;
    public List<JsonObservation> observations;
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.json;

import org.joda.time.DateTime;

public class JsonOrder {
    public String uuid;
    public String patient_uuid;
    public String provider_uuid;
    public String instructions;
    public DateTime start_time;
    public DateTime stop_time;
    public boolean voided;
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.json;

/** A section in a chart (a row of tiles or a group of grid rows). */
public class JsonChartItem {
    public String label;
    public String type;  // rendering type (not the same as a concept data type)
    public boolean required;  // always show this grid row even if there are no observations
    public String[] concepts;  // one or more concepts rendered for this item
    public String format;  // format string, e.g. "##.# kg" or "{1} / {2}"
    public String caption_format;  // format string for tile caption or grid cell popup
    public String css_class;  // format string for CSS class on this tile or grid row
    public String css_style;  // format string for CSS properties on this tile or grid row
    public String script;  // JavaScript for fancy rendering
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.json;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonParseException;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

import org.joda.time.DateTime;
import org.joda.time.Instant;
import org.projectbuendia.client.utils.Utils;

import java.lang.reflect.Type;

/**
 * Utility class for serializing JODA DateTime objects from JSON returned by the OpenMRS Buendia
 * module.
 */
public class InstantSerializer implements JsonSerializer<Instant>, JsonDeserializer<Instant> {

    @Override public JsonElement serialize(Instant src, Type typeOfSrc, JsonSerializationContext context) {
        return new JsonPrimitive(Utils.formatUtc8601(src));
    }

    @Override public Instant deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
        throws JsonParseException {
        return DateTime.parse(json.getAsString()).toInstant();
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.json;

/** A list of concept results returned by the server. */
public class JsonConceptsResponse {
    public JsonConcept[] results;
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.json;

import android.content.ContentValues;

import org.joda.time.LocalDate;
import org.projectbuendia.models.Sex;
import org.projectbuendia.client.providers.Contracts.Patients;

import java.io.Serializable;
import java.util.List;

/** JSON representation of an OpenMRS Patient. */
public class JsonPatient implements Serializable {
    public String uuid;  // OpenMRS record UUID
    public String id;  // user-specified patient ID
    public String given_name;
    public String family_name;
    public Sex sex;
    public LocalDate birthdate;
    public boolean voided;

    public List<JsonObservation> observations;  // observations at patient creation

    public JsonPatient() { }

    /** Populates a ContentValues record with the fields of this patient. */
    public ContentValues toContentValues() {
        ContentValues cv = new ContentValues();
        cv.put(Patients.ID, id);
        cv.put(Patients.GIVEN_NAME, given_name);
        cv.put(Patients.FAMILY_NAME, family_name);
        cv.put(Patients.SEX, Sex.nullableNameOf(sex));
        cv.put(Patients.BIRTHDATE, birthdate != null ? birthdate.toString() : null);
        return cv;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.json;

/** JSON representation of an OpenMRS Concept */
public class JsonConcept {
    public String uuid;
    public Integer xform_id;  // server-side ID, needed for some XForms tasks
    public Datatype type;
    public String name;
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.json;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonParseException;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

import org.joda.time.LocalDate;

import java.lang.reflect.Type;

/** Provides custom Gson serialization for {@link LocalDate} objects. */
public class LocalDateSerializer implements JsonSerializer<LocalDate>, JsonDeserializer<LocalDate> {

    @Override public JsonElement serialize(LocalDate date, Type type, JsonSerializationContext context) {
        return new JsonPrimitive(date.toString());
    }

    @Override public LocalDate deserialize(JsonElement json, Type type, JsonDeserializationContext context)
        throws JsonParseException {
        String text = json.getAsString();
        try {
            return LocalDate.parse(text);
        } catch (IllegalArgumentException e) {
            throw new JsonParseException(e);
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.json;

import java.util.Map;

/** JSON representation of an OpenMRS Location (constructed by Gson using reflection). */
public class JsonLocation {
    public String uuid;
    public String parent_uuid;
    public String name;

    /** A map of locales to localized names (deprecated; replaced by the name field). */
    public Map<String, String> names;

    public JsonLocation() { }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.diagnostics;

import com.google.common.collect.ImmutableSet;

import org.projectbuendia.client.events.diagnostics.TroubleshootingActionsChangedEvent;
import org.projectbuendia.client.utils.Logger;

import java.util.HashSet;
import java.util.Set;

import de.greenrobot.event.EventBus;

/**
 * Aggregates reported {@link HealthIssue}s and fires events containing the appropriate
 * troubleshooting steps.
 */
public class Troubleshooter {

    private static final Logger LOG = Logger.create();

    private final Object mIssuesLock = new Object();
    private final Object mTroubleshootingLock = new Object();

    private final EventBus mEventBus;
    private Set<HealthIssue> mActiveIssues;

    private TroubleshootingActionsChangedEvent mLastTroubleshootingActionsChangedEvent;

    public Troubleshooter(EventBus eventBus) {
        mEventBus = eventBus;
        mActiveIssues = new HashSet<>();
    }

    /** Returns a set of all currently-active health issues. */
    public ImmutableSet<HealthIssue> getActiveIssues() {
        return ImmutableSet.copyOf(mActiveIssues);
    }

    /**
     * Returns true iff the given issue is current active.
     * @param issue {@link HealthIssue} to check for
     */
    public boolean hasIssue(HealthIssue issue) {
        return mActiveIssues.contains(issue);
    }

    /** Returns true iff no active issues exist. */
    public boolean isHealthy() {
        return mActiveIssues.isEmpty();
    }

    /**
     * Returns true if no ongoing issues preventing access to the Buendia server exist. Note that
     * connectivity is still not guaranteed, just not ruled out.
     */
    public boolean isServerHealthy() {
        return getNetworkConnectivityTroubleshootingActions().isEmpty()
            && getConfigurationTroubleshootingActions().isEmpty();
    }

    private Set<TroubleshootingAction> getNetworkConnectivityTroubleshootingActions() {
        Set<TroubleshootingAction> actions = new HashSet<>();

        if (mActiveIssues.contains(HealthIssue.WIFI_DISABLED)) {
            actions.add(TroubleshootingAction.ENABLE_WIFI);
        } else if (mActiveIssues.contains(HealthIssue.WIFI_NOT_CONNECTED)) {
            actions.add(TroubleshootingAction.CONNECT_WIFI);
        } else if (mActiveIssues.contains(HealthIssue.SERVER_HOST_UNREACHABLE)) {
            actions.add(TroubleshootingAction.CHECK_SERVER_REACHABILITY);
        } else if (mActiveIssues.contains(HealthIssue.SERVER_INTERNAL_ISSUE)) {
            actions.add(TroubleshootingAction.CHECK_SERVER_SETUP);
        } else if (mActiveIssues.contains(HealthIssue.SERVER_NOT_RESPONDING)) {
            actions.add(TroubleshootingAction.CHECK_SERVER_STATUS);
        }

        return actions;
    }

    private Set<TroubleshootingAction> getConfigurationTroubleshootingActions() {
        Set<TroubleshootingAction> actions = new HashSet<>();

        if (mActiveIssues.contains(HealthIssue.SERVER_CONFIGURATION_INVALID)) {
            actions.add(TroubleshootingAction.CHECK_SERVER_CONFIGURATION);
        } else if (mActiveIssues.contains(HealthIssue.SERVER_AUTHENTICATION_ISSUE)) {
            actions.add(TroubleshootingAction.CHECK_SERVER_AUTH);
        } else if (mActiveIssues.contains(HealthIssue.SERVER_PERMISSION_ISSUE)) {
            actions.add(TroubleshootingAction.CHECK_SERVER_PERMISSIONS);
        } else if (mActiveIssues.contains(HealthIssue.PERIODIC_SYNC_DISABLED)) {
            actions.add(TroubleshootingAction.CHECK_PERIODIC_SYNC_SETTINGS);
        }

        return actions;
    }

    /** Called when a new health issue is discovered. */
    public <T extends HealthIssue> void onDiscovered(T healthIssue) {
        synchronized (mIssuesLock) {
            mActiveIssues.add(healthIssue);
        }

        // TODO: Consider scheduling this for ~100 milliseconds in the future so as to
        // prevent multiple troubleshooting events from firing for issues resulting from the same
        // root cause.
        postTroubleshootingEvents(null);
    }

    private void postTroubleshootingEvents(HealthIssue solvedIssue) {
        synchronized (mTroubleshootingLock) {
            ImmutableSet.Builder<TroubleshootingAction> actionsBuilder = ImmutableSet.builder();

            actionsBuilder.addAll(getNetworkConnectivityTroubleshootingActions());
            actionsBuilder.addAll(getConfigurationTroubleshootingActions());

            // NOTE(ping): Disable package server troubleshooting for now. 2018-05-21
            // actionsBuilder.addAll(getPackageServerTroubleshootingActions());

            ImmutableSet<TroubleshootingAction> actions = actionsBuilder.build();

            if (mLastTroubleshootingActionsChangedEvent != null) {
                // If nothing's changed since the last time we checked, don't post a new event.
                if (mLastTroubleshootingActionsChangedEvent.actions.equals(actions)) return;

                mEventBus.removeStickyEvent(mLastTroubleshootingActionsChangedEvent);
            }

            mLastTroubleshootingActionsChangedEvent =
                new TroubleshootingActionsChangedEvent(actions, solvedIssue);
            mEventBus.postSticky(mLastTroubleshootingActionsChangedEvent);
        }
    }

    private Set<TroubleshootingAction> getPackageServerTroubleshootingActions() {
        Set<TroubleshootingAction> actions = new HashSet<>();
        if (mActiveIssues.contains(HealthIssue.PACKAGE_SERVER_HOST_UNREACHABLE)) {
            actions.add(TroubleshootingAction.CHECK_PACKAGE_SERVER_REACHABILITY);
        } else if (mActiveIssues.contains(HealthIssue.PACKAGE_SERVER_INDEX_NOT_FOUND)) {
            actions.add(TroubleshootingAction.CHECK_PACKAGE_SERVER_CONFIGURATION);
        }
        return actions;
    }

    /** Called when a health issue is resolved. */
    public void onResolved(HealthIssue healthIssue) {
        synchronized (mIssuesLock) {
            if (!mActiveIssues.remove(healthIssue)) {
                LOG.w(
                    "Attempted to remove health issue '%1$s' that the troubleshooter was not "
                        + "previously aware of.",
                    healthIssue.toString());
            }
        }

        // TODO: Consider scheduling this for ~100 milliseconds in the future so as to
        // prevent multiple troubleshooting events from firing for issues resulting from the same
        // root cause.
        postTroubleshootingEvents(healthIssue);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.diagnostics;

import android.app.Application;

import com.google.common.collect.ImmutableSet;

import org.projectbuendia.client.AppSettings;
import org.projectbuendia.client.inject.Qualifiers;
import org.projectbuendia.client.net.OpenMrsConnectionDetails;

import javax.inject.Singleton;

import dagger.Module;
import dagger.Provides;
import de.greenrobot.event.EventBus;

/** A Dagger module that provides bindings for diagnostics-related classes. */
@Module(complete = false, library = true)
public class DiagnosticsModule {

    @Provides
    @Singleton
    @Qualifiers.HealthEventBus EventBus provideHealthEventBus() {
        return EventBus.builder().build();
    }

    @Provides
    @Singleton ImmutableSet<HealthCheck> provideHealthChecks(
        Application application,
        OpenMrsConnectionDetails connectionDetails,
        AppSettings settings) {
        return ImmutableSet.of(
            new WifiHealthCheck(application, settings),
            new BuendiaApiHealthCheck(application, connectionDetails),
            new PackageServerHealthCheck(application, settings));
    }

    @Provides
    @Singleton Troubleshooter provideTroubleshooter(EventBus eventBus) {
        return new Troubleshooter(eventBus);
    }

    @Provides
    @Singleton HealthMonitor provideHealthMonitor(
        Application application,
        @Qualifiers.HealthEventBus EventBus healthEventBus,
        ImmutableSet<HealthCheck> healthChecks,
        Troubleshooter troubleshooter) {
        return new HealthMonitor(application, healthEventBus, healthChecks, troubleshooter);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.diagnostics;

/**
 * A troubleshooting action that either the application can do automatically on behalf of the user
 * or that the user must do manually.
 */
public enum TroubleshootingAction {

    ENABLE_WIFI,

    CONNECT_WIFI,

    CHECK_SERVER_AUTH,

    CHECK_SERVER_PERMISSIONS,

    CHECK_SERVER_CONFIGURATION,

    CHECK_SERVER_REACHABILITY,

    CHECK_SERVER_SETUP,

    CHECK_SERVER_STATUS,

    CHECK_PACKAGE_SERVER_REACHABILITY,

    CHECK_PACKAGE_SERVER_CONFIGURATION,

    CHECK_PERIODIC_SYNC_SETTINGS
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.diagnostics;

import android.app.Application;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.wifi.WifiManager;

import org.projectbuendia.client.AppSettings;

/** A {@link HealthCheck} that checks whether the current device is connected to a wifi network. */
public class WifiHealthCheck extends HealthCheck {

    private static final IntentFilter sWifiStateChangedIntentFilter = getIntentFilter();

    private final WifiManager mWifiManager;
    private final ConnectivityManager mConnectivityManager;
    private final WifiChangeBroadcastReceiver mWifiStateChangedReceiver;
    private final AppSettings mSettings;

    @Override public boolean isApiUnavailable() {
        // We will get an event that lets us update the set of active issues whenever
        // the wifi state changes, so we can be confident that the API is definitely
        // unavailable whenever either of the wifi-related issues is active.
        if (mSettings.getNonWifiAllowed()) return false;
        return mActiveIssues.contains(HealthIssue.WIFI_NOT_CONNECTED) ||
            mActiveIssues.contains(HealthIssue.WIFI_DISABLED);
    }

    protected WifiHealthCheck(Application application, AppSettings settings) {
        super(application);

        mWifiManager = (WifiManager) application.getSystemService(Context.WIFI_SERVICE);
        mConnectivityManager =
            (ConnectivityManager) application.getSystemService(Context.CONNECTIVITY_SERVICE);
        mWifiStateChangedReceiver = new WifiChangeBroadcastReceiver();
        mSettings = settings;
    }

    private static IntentFilter getIntentFilter() {
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
        intentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
        return intentFilter;
    }

    @Override protected void startImpl() {
        mApplication.registerReceiver(mWifiStateChangedReceiver, sWifiStateChangedIntentFilter);
        checkWifiState();
    }

    private void checkWifiState() {
        if (mSettings.getNonWifiAllowed()) {
            resolveIssue(HealthIssue.WIFI_DISABLED);
            resolveIssue(HealthIssue.WIFI_NOT_CONNECTED);
            return;
        }
        int wifiState = mWifiManager.getWifiState();
        if (wifiState != WifiManager.WIFI_STATE_ENABLING
            && wifiState != WifiManager.WIFI_STATE_ENABLED) {
            reportIssue(HealthIssue.WIFI_DISABLED);
        } else {
            resolveIssue(HealthIssue.WIFI_DISABLED);
            NetworkInfo networkInfo = mConnectivityManager.getActiveNetworkInfo();
            if (networkInfo == null || !networkInfo.isConnectedOrConnecting()) {
                reportIssue(HealthIssue.WIFI_NOT_CONNECTED);
            } else {
                resolveAllIssues();
            }
        }
    }

    @Override protected void stopImpl() {
        mApplication.unregisterReceiver(mWifiStateChangedReceiver);
    }

    private class WifiChangeBroadcastReceiver extends BroadcastReceiver {
        @Override public void onReceive(Context context, Intent intent) {
            checkWifiState();
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.diagnostics;

/**
 * An issue that can be reported by {@link HealthCheck}s.
 * <p/>
 * <p>A {@link HealthIssue} is an ongoing issue with the application (rather than a one-time
 * problematic event): when a new issue is discovered, it will be reported to an instance of
 * {@link HealthMonitor}, which will consider that issue active until the issue is resolved.
 */
public enum HealthIssue {
    WIFI_DISABLED,
    WIFI_NOT_CONNECTED,
    SERVER_AUTHENTICATION_ISSUE,
    SERVER_PERMISSION_ISSUE,
    SERVER_CONFIGURATION_INVALID,
    SERVER_HOST_UNREACHABLE,
    SERVER_INTERNAL_ISSUE,
    SERVER_NOT_RESPONDING,
    PERIODIC_SYNC_DISABLED,
    PACKAGE_SERVER_HOST_UNREACHABLE,
    PACKAGE_SERVER_INDEX_NOT_FOUND;

    /** The event to be posted when a health issue is discovered. */
    public final DiscoveredEvent discovered = new DiscoveredEvent();

    /** The event to be posted when a health issue is resolved. */
    public final ResolvedEvent resolved = new ResolvedEvent();

    class Event {

        public HealthIssue getIssue() {
            return HealthIssue.this;
        }

        private Event() {
        }
    }

    class DiscoveredEvent extends Event {
    }

    class ResolvedEvent extends Event {
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.diagnostics;

import android.app.Application;
import android.net.Uri;
import android.os.Handler;
import android.os.HandlerThread;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;

import org.apache.http.HttpResponse;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.conn.HttpHostConnectException;
import org.apache.http.impl.auth.BasicScheme;
import org.apache.http.impl.client.DefaultHttpClient;
import org.projectbuendia.models.ConceptUuids;
import org.projectbuendia.client.net.OpenMrsConnectionDetails;
import org.projectbuendia.client.utils.Logger;

import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.UnknownHostException;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * A {@link HealthCheck} that checks whether the Buendia API server is up and responding to HTTP
 * requests at the URL in the "OpenMRS root URL" preference setting.
 */
public class BuendiaApiHealthCheck extends HealthCheck {

    private static final Logger LOG = Logger.create();

    // Under normal conditions, make requests to the server with this frequency
    // to check if it's reachable and responding.
    private static final int CHECK_PERIOD_MS = 10000;

    // During certain problem conditions, check more often so that when the
    // problem is resolved, we can hide the snackbar more promptly.
    private static final int FAST_CHECK_PERIOD_MS = 1000;

    // These are the issues for which we use the faster checking period.
    private static final Set<HealthIssue> FAST_CHECK_ISSUES = ImmutableSet.of(
        HealthIssue.SERVER_HOST_UNREACHABLE,
        HealthIssue.SERVER_NOT_RESPONDING
    );

    // Retrieving a concept should be quick and ensures that the module is
    // running and has database access.
    private static final String HEALTH_CHECK_ENDPOINT =
        "/concepts/" + ConceptUuids.PULSE_UUID;

    private final Object mLock = new Object();

    private final OpenMrsConnectionDetails mConnectionDetails;

    private HandlerThread mHandlerThread;
    private Handler mHandler;
    private BuendiaModuleHealthCheckRunnable mRunnable;

    BuendiaApiHealthCheck(
        Application application,
        OpenMrsConnectionDetails connectionDetails) {
        super(application);

        mConnectionDetails = connectionDetails;
    }

    @Override protected void startImpl() {
        synchronized (mLock) {
            if (mHandlerThread == null) {
                mHandlerThread = new HandlerThread("Buendia API Health Check");
                mHandlerThread.start();
                mHandler = new Handler(mHandlerThread.getLooper());
            }

            if (mRunnable == null) {
                mRunnable = new BuendiaModuleHealthCheckRunnable(mHandler);
            }

            if (!mRunnable.isRunning.getAndSet(true)) {
                mHandler.post(mRunnable);
            }
        }
    }

    @Override protected void stopImpl() {
        synchronized (mLock) {
            if (mRunnable != null) {
                mRunnable.isRunning.set(false);
                mRunnable = null;
            }

            if (mHandlerThread != null) {
                mHandlerThread.quit();
                mHandlerThread = null;
            }

            mHandler = null;
        }
    }

    protected int getCheckPeriodMillis() {
        return Sets.intersection(FAST_CHECK_ISSUES, mActiveIssues).isEmpty()
            ? CHECK_PERIOD_MS : FAST_CHECK_PERIOD_MS;
    }

    private class BuendiaModuleHealthCheckRunnable implements Runnable {
        public final AtomicBoolean isRunning;

        private final Handler mHandler;

        public BuendiaModuleHealthCheckRunnable(Handler handler) {
            isRunning = new AtomicBoolean(false);
            mHandler = handler;
        }

        @Override public void run() {
            if (!isRunning.get()) return;

            try {
                Uri uri = Uri.parse(mConnectionDetails.getBuendiaApiUrl() + HEALTH_CHECK_ENDPOINT);
                HttpClient httpClient = new DefaultHttpClient();
                HttpGet httpGet = new HttpGet(uri.toString());
                if (httpGet.getURI().getHost() == null) {
                    LOG.w("Configured OpenMRS server URL is invalid: %s", uri);
                    reportIssue(HealthIssue.SERVER_CONFIGURATION_INVALID);
                    return;
                }

                try {
                    httpGet.addHeader(BasicScheme.authenticate(
                        new UsernamePasswordCredentials(
                            mConnectionDetails.getUser(),
                            mConnectionDetails.getPassword()),
                        "UTF-8", false));
                    LOG.i("HTTP GET: " + httpGet.getURI());
                    HttpResponse httpResponse = httpClient.execute(httpGet);
                    LOG.i("Response: " + httpResponse.getStatusLine());
                    if (httpResponse.getStatusLine().getStatusCode() != HttpURLConnection.HTTP_OK) {
                        LOG.w("The OpenMRS URL '%1$s' returned unexpected error code: %2$s",
                            uri, httpResponse.getStatusLine().getStatusCode());
                        switch (httpResponse.getStatusLine().getStatusCode()) {
                            // TODO(ping): Detect whether the HTTP error code is coming
                            // from a Buendia server or a zealous network firewall.
                            case HttpURLConnection.HTTP_INTERNAL_ERROR:
                                reportIssue(HealthIssue.SERVER_INTERNAL_ISSUE);
                                break;
                            case HttpURLConnection.HTTP_FORBIDDEN:
                                reportIssue(HealthIssue.SERVER_PERMISSION_ISSUE);
                                break;
                            case HttpURLConnection.HTTP_UNAUTHORIZED:
                                reportIssue(HealthIssue.SERVER_AUTHENTICATION_ISSUE);
                                break;
                            case HttpURLConnection.HTTP_NOT_FOUND:
                            default:
                                reportIssue(HealthIssue.SERVER_NOT_RESPONDING);
                                break;
                        }
                        // TODO(ping): Confirm that the content returned is valid JSON,
                        // as some firewalls can return 200 with an error page.
                        if (hasIssue(HealthIssue.SERVER_HOST_UNREACHABLE)){
                            resolveIssue(HealthIssue.SERVER_HOST_UNREACHABLE);
                        }
                        return;
                    }
                } catch (UnknownHostException | IllegalArgumentException e) {
                    LOG.w("OpenMRS server unreachable: %s", uri);
                    reportIssue(HealthIssue.SERVER_HOST_UNREACHABLE);
                    return;
                } catch (HttpHostConnectException e) {
                    LOG.w("OpenMRS server connection refused: %s", e.getHost());
                } catch (IOException e) {
                    LOG.w("OpenMRS server health check failed: %s", uri);
                    return;
                }

                resolveAllIssues();
            } finally {
                mHandler.postDelayed(this, getCheckPeriodMillis());
            }
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.diagnostics;

import android.app.Application;
import android.net.Uri;
import android.os.Handler;
import android.os.HandlerThread;

import org.apache.http.HttpResponse;
import org.apache.http.HttpStatus;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.conn.HttpHostConnectException;
import org.apache.http.impl.client.DefaultHttpClient;
import org.projectbuendia.client.AppSettings;
import org.projectbuendia.client.utils.Logger;

import java.io.IOException;
import java.net.UnknownHostException;

/** A {@link HealthCheck} that checks whether the package server is up and running. */
public class PackageServerHealthCheck extends HealthCheck {

    private static final Logger LOG = Logger.create();

    /** Check for issues with this frequency. */
    private static final int CHECK_PERIOD_MS = 20000;

    private static final String HEALTH_CHECK_ENDPOINT = "/dists/stable/Release";

    private final Object mLock = new Object();

    private HandlerThread mHandlerThread;
    private Handler mHandler;
    private AppSettings mSettings;
    private final Runnable mHealthCheckRunnable = new Runnable() {

        @Override public void run() {
            performCheck();

            synchronized (mLock) {
                if (mHandler != null) {
                    mHandler.postDelayed(this, CHECK_PERIOD_MS);
                }
            }
        }

        private void performCheck() {
            Uri uri = Uri.parse(mSettings.getPackageServerUrl(HEALTH_CHECK_ENDPOINT));
            HttpClient httpClient = new DefaultHttpClient();
            HttpGet getRequest = new HttpGet(uri.toString());
            if (getRequest.getURI().getHost() == null) {
                LOG.w("Configured package server URL is invalid: %s", uri);
                reportIssue(HealthIssue.SERVER_CONFIGURATION_INVALID);
                return;
            }

            try {
                HttpResponse response = httpClient.execute(getRequest);
                switch (response.getStatusLine().getStatusCode()) {
                    case HttpStatus.SC_OK:
                        LOG.d("Package server check completed, OK.");
                        resolveAllIssues();
                        return;
                    case HttpStatus.SC_NOT_FOUND:
                        LOG.d("Package server check completed, 404.");
                        // The package server is reachable if we get a 404.
                        resolveIssue(HealthIssue.PACKAGE_SERVER_HOST_UNREACHABLE);
                        reportIssue(HealthIssue.PACKAGE_SERVER_INDEX_NOT_FOUND);
                        return;
                    default:
                        LOG.w("Package server check failed for URI %1$s.", uri);
                }
            } catch (UnknownHostException | IllegalArgumentException e) {
                LOG.w("Package server unreachable: %s", uri);
                reportIssue(HealthIssue.PACKAGE_SERVER_HOST_UNREACHABLE);
            } catch (HttpHostConnectException e) {
                LOG.w("Package server connection refused: %s", e.getHost());
            } catch (IOException e) {
                LOG.w(e, "Package server check failed: %s", uri);
            }
        }
    };

    PackageServerHealthCheck(Application application, AppSettings settings) {
        super(application);
        mSettings = settings;
    }

    @Override protected void startImpl() {
        synchronized (mLock) {
            if (mHandlerThread == null) {
                mHandlerThread = new HandlerThread("Buendia Package Server Health Check");
                mHandlerThread.start();
                mHandler = new Handler(mHandlerThread.getLooper());
                mHandler.post(mHealthCheckRunnable);
            }
        }
    }

    @Override protected void stopImpl() {
        synchronized (mLock) {
            if (mHandlerThread != null) {
                mHandlerThread.quit();
                mHandlerThread = null;
                mHandler = null;
            }
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.diagnostics;

import android.app.Application;
import android.content.BroadcastReceiver;
import android.support.annotation.Nullable;

import org.projectbuendia.client.utils.Logger;

import java.util.HashSet;
import java.util.Set;

import de.greenrobot.event.EventBus;

/**
 * An individual health check to be performed while the application is active.
 * <p/>
 * <p>Subclasses can choose to implement this class however they see fit so long as they call
 * {@link #reportIssue} when a new issue occurs and {@link #resolveIssue} or
 * {@link #resolveAllIssues} when issues are resolved. For example, if a health change can be
 * triggered by an Android OS broadcast, it may register a {@link BroadcastReceiver}
 * in {@link #startImpl}; if it needs to poll another service, it may start a background thread.
 * <p/>
 * <p>Subclasses must stop checking (e.g., unregister {@link BroadcastReceiver}s or stop
 * background threads) when {@link #stopImpl} is called.
 */
public abstract class HealthCheck {

    private static final Logger LOG = Logger.create();

    private final Object mLock = new Object();

    protected final Application mApplication;
    protected final HashSet<HealthIssue> mActiveIssues;

    @Nullable private EventBus mHealthEventBus;

    /**
     * Starts the health check.
     * <p/>
     * <p>After this method is called, the health check must post any health issue events on the
     * specified {@link EventBus}.
     */
    public final void start(EventBus healthEventBus) {
        synchronized (mLock) {
            mHealthEventBus = healthEventBus;
            startImpl();
        }
    }

    protected abstract void startImpl();

    /**
     * Stops the health check without clearing its issues.
     * <p/>
     * <p>{@link #start} may be called again to restart checks.
     */
    public final void stop() {
        synchronized (mLock) {
            mHealthEventBus = null;
            stopImpl();
        }
    }

    protected abstract void stopImpl();

    /** Clears all the issues for this health check. */
    public final void clear() {
        mActiveIssues.clear();
    }

    /**
     * Returns true if this HealthCheck knows for certain that the Buendia
     * API is unavailable at this moment.  Implementations of this method
     * should never return true unless they can guarantee that their knowledge
     * of the system state is up to date; for example, if a HealthCheck decides
     * to return true when the network is down, it is responsible for detecting
     * any event that could cause the network to come back up.
     */
    public boolean isApiUnavailable() {
        return false;
    }

    protected HealthCheck(Application application) {
        mApplication = application;
        mActiveIssues = new HashSet<>();
    }

    /** Reports an issue as being active. */
    protected final void reportIssue(HealthIssue healthIssue) {
        EventBus eventBus;
        synchronized (mLock) {
            if (mHealthEventBus == null) {
                LOG.w(
                    "A health issue was reported even though no event bus was registered to "
                        + "handle it: %1$s.",
                    healthIssue.toString());
                return;
            }

            mActiveIssues.add(healthIssue);
            eventBus = mHealthEventBus;
        }

        eventBus.post(healthIssue.discovered);
    }

    /** Marks as resolved all issues that are currently active. */
    protected final void resolveAllIssues() {
        EventBus eventBus;
        Set<HealthIssue> activeIssues;
        synchronized (mLock) {
            if (mHealthEventBus == null) {
                LOG.w(
                    "Health issues were resolved even though no event bus was registered to "
                        + "handle them.");
                return;
            }

            eventBus = mHealthEventBus;
            activeIssues = new HashSet<>(mActiveIssues);
            mActiveIssues.clear();
        }

        for (HealthIssue healthIssue : activeIssues) {
            eventBus.post(healthIssue.resolved);
        }
    }

    /**
     * Marks as resolved the specified issue.
     * <p/>
     * <p>If the issue was not previously reported, this method does nothing.
     */
    protected final void resolveIssue(HealthIssue healthIssue) {
        EventBus eventBus;
        boolean wasIssueActive;
        synchronized (mLock) {
            if (mHealthEventBus == null) {
                LOG.w(
                    "A health issue was resolved even though no event bus was registered to "
                        + "handle it: %1$s.",
                    healthIssue.toString());
                return;
            }

            eventBus = mHealthEventBus;
            wasIssueActive = mActiveIssues.remove(healthIssue);
        }

        if (wasIssueActive) {
            eventBus.post(healthIssue.resolved);
        }
    }

    protected final boolean hasIssue(HealthIssue healthIssue) {
        for (HealthIssue issue : mActiveIssues) {
            if (issue.equals(healthIssue)){
                return true;
            }
        }
        return false;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.diagnostics;

import android.app.Application;

import com.google.common.collect.ImmutableSet;

import de.greenrobot.event.EventBus;

/**
 * Monitors the health of the application, collecting issues and passing them on to a
 * {@link Troubleshooter}.
 */
public class HealthMonitor {

    private final Application mApplication;
    private final EventBus mHealthEventBus;
    private final ImmutableSet<HealthCheck> mHealthChecks;
    private final Troubleshooter mTroubleshooter;
    private boolean mRunning = false;

    /** Starts all health checks. */
    public void start() {
        if (!mRunning) {
            mHealthEventBus.register(this);

            for (HealthCheck check : mHealthChecks) {
                check.start(mHealthEventBus);
            }
            mRunning = true;
        }
    }

    /** Stops all health checks. */
    public void stop() {
        if (mRunning) {
            mHealthEventBus.unregister(this);

            for (HealthCheck check : mHealthChecks) {
                check.stop();
            }
            mRunning = false;
        }
    }

    /** Clears all issues for all health checks. */
    public void clear() {
        for (HealthCheck check : mHealthChecks) {
            check.clear();
        }
    }

    public <T extends HealthIssue> void onEvent(HealthIssue.DiscoveredEvent event) {
        mTroubleshooter.onDiscovered(event.getIssue());
    }

    public void onEvent(HealthIssue.ResolvedEvent event) {
        mTroubleshooter.onResolved(event.getIssue());
    }

    /** Returns true if the API is known for certain to be unavailable. */
    public boolean isApiUnavailable() {
        for (HealthCheck check : mHealthChecks) {
            if (check.isApiUnavailable()) {
                return true;
            }
        }
        return false;
    }

    HealthMonitor(
        Application application,
        EventBus healthEventBus,
        ImmutableSet<HealthCheck> healthChecks,
        Troubleshooter troubleshooter) {
        mApplication = application;
        mHealthEventBus = healthEventBus;
        mHealthChecks = healthChecks;
        mTroubleshooter = troubleshooter;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.resolvables;

import android.content.res.Resources;

import org.projectbuendia.client.utils.Logger;

import java.util.HashMap;
import java.util.Map;

/** Resolves resource-backed enumerations against an instance of {@link Resources}. */
class Resolver {

    private static final Logger LOG = Logger.create();

    private static Resources sResources;
    private static Map<Resolvable, Object> sResolvablesToResolveds = new HashMap<>();

    @SuppressWarnings("unchecked") // Checked at runtime.
    public static synchronized <T> T resolve(
        Resolvable resolvable, Resources resources, Class<T> clazz) {
        if (sResources == null) {
            sResources = resources;
        } else if (sResources != resources) {
            LOG.w(
                "Setting Resources instance to a different value than the one already set. "
                    + "All cached Resolvables are being discarded.");
            sResources = resources;
            sResolvablesToResolveds.clear();
        }

        Object resolved = sResolvablesToResolveds.get(resolvable);
        if (resolved == null) {
            if (ResStatus.Resolved.class.equals(clazz)) {
                resolved = new ResStatus.Resolved((ResStatus) resolvable, resources);
            } else {
                throw new IllegalArgumentException("Unknown Resolvable class type.");
            }

            sResolvablesToResolveds.put(resolvable, resolved);
        }

        return (T) resolved;
    }

    private Resolver() {
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.resolvables;

import android.content.res.Resources;

import org.projectbuendia.client.R;

/**
 * Patient statuses and the resources associated with them.
 * <p/>
 * <p>Note: the order of statuses in this enum determines the integer value displayed in the chart.
 */
public enum ResStatus implements Resolvable<ResStatus.Resolved> {

    UNKNOWN(
        R.string.status_unknown,
        R.color.white,
        R.color.vital_fg_unknown,
        R.string.status_short_desc_unknown),
    WELL(
        R.string.status_well,
        R.color.status_well,
        R.color.vital_fg_dark,
        R.string.status_short_desc_well),
    UNWELL(
        R.string.status_unwell,
        R.color.status_unwell,
        R.color.vital_fg_dark,
        R.string.status_short_desc_unwell),
    CRITICAL(
        R.string.status_critical,
        R.color.status_critical,
        R.color.vital_fg_dark,
        R.string.status_short_desc_critical),
    PALLIATIVE(
        R.string.status_palliative,
        R.color.status_palliative,
        R.color.vital_fg_light,
        R.string.status_short_desc_palliative),
    CONVALESCENT(
        R.string.status_convalescent,
        R.color.status_convalescent,
        R.color.vital_fg_light,
        R.string.status_short_desc_convalescent),
    DISCHARGED_NON_CASE(
        R.string.status_discharged_non_case,
        R.color.status_discharged_non_case,
        R.color.vital_fg_light,
        R.string.status_short_desc_discharged_non_case),
    DISCHARGED_CURED(
        R.string.status_discharged_cured,
        R.color.status_discharged_cured,
        R.color.vital_fg_light,
        R.string.status_short_desc_discharged_cured),
    SUSPECTED_DEAD(
        R.string.status_suspected_dead,
        R.color.status_suspected_dead,
        R.color.vital_fg_light,
        R.string.status_short_desc_suspected_dead),
    CONFIRMED_DEAD(
        R.string.status_confirmed_dead,
        R.color.status_confirmed_dead,
        R.color.vital_fg_light,
        R.string.status_short_desc_confirmed_dead);

    public final int messageId;
    public final int backgroundColorId;
    public final int foregroundColorId;
    public final int shortDescriptionId;

    @Override public Resolved resolve(Resources resources) {
        return Resolver.resolve(this, resources, ResStatus.Resolved.class);
    }

    public static class Resolved {

        private final ResStatus mStatus;
        private final Resources mResources;

        public Resolved(ResStatus status, Resources resources) {
            mStatus = status;
            mResources = resources;
        }

        public CharSequence getShortDescription() {
            return mResources.getString(mStatus.shortDescriptionId);
        }

        public CharSequence getMessage() {
            return mResources.getString(mStatus.messageId);
        }

        public int getForegroundColor() {
            return mResources.getColor(mStatus.foregroundColorId);
        }

        public int getBackgroundColor() {
            return mResources.getColor(mStatus.backgroundColorId);
        }
    }

    ResStatus(int messageId, int backgroundColorId, int foregroundColorId, int shortDescriptionId) {
        this.messageId = messageId;
        this.backgroundColorId = backgroundColorId;
        this.foregroundColorId = foregroundColorId;
        this.shortDescriptionId = shortDescriptionId;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.resolvables;

import android.content.res.Resources;

/** A resource (e.g. String, Icon) that can be resolved using Android {@link Resources}. */
interface Resolvable<T> {

    T resolve(Resources resources);
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.filter.db;

import com.google.common.collect.ImmutableList;

import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.models.Model;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * A database filter that acts as a container for multiple filters or filter groups, with
 * an optional name used for string representations.
 */
public final class SimpleSelectionFilterGroup<T extends Model>
    extends SimpleSelectionFilter<T> {

    private final FilterType mFilterType;
    private final ImmutableList<SimpleSelectionFilter> mFilters;
    private String mName = App.str(R.string.filter_group_default_name);

    /**
     * Specifies whether filters in this group will be AND'd or OR'd in the
     * selection.
     */
    public enum FilterType {
        OR,
        AND
    }

    /** Assume AND by default. */
    public SimpleSelectionFilterGroup(SimpleSelectionFilter... filters) {
        this(FilterType.AND, filters);
    }

    public SimpleSelectionFilterGroup(FilterType filterType, SimpleSelectionFilter... filters) {
        mFilters = ImmutableList.copyOf(filters);
        mFilterType = filterType;
    }

    public SimpleSelectionFilterGroup(FilterType filterType, List<SimpleSelectionFilter> filters) {
        mFilters = ImmutableList.copyOf(filters);
        mFilterType = filterType;
    }

    public List<SimpleSelectionFilter> getFilters() {
        return mFilters;
    }

    /**
     * Dynamically build the selection string by combining the selection strings
     * of the filters in this group.
     */
    @Override public String getSelectionString() {
        StringBuilder sb = new StringBuilder();

        String prefix = "";
        sb.append(" (");
        for (SimpleSelectionFilter filter : mFilters) {
            // Ignore empty or null selection strings, which could
            // otherwise result in rogue AND's/OR's.
            String selectionString = filter.getSelectionString();
            if (selectionString == null || selectionString.isEmpty()) continue;

            sb.append(prefix);
            sb.append(" ");
            sb.append(selectionString);
            sb.append(" ");
            prefix = mFilterType.toString();
        }
        sb.append(") ");
        return sb.toString();
    }

    /**
     * Merges all of the selection arguments from filters in this group into a
     * single array.
     * @param constraint the constraint passed into the top-level filter
     */
    @Override public String[] getSelectionArgs(CharSequence constraint) {
        List<String> allArgs = new ArrayList<>();
        for (SimpleSelectionFilter filter : mFilters) {
            Collections.addAll(allArgs, filter.getSelectionArgs(constraint));
        }

        String[] allArgsArray = new String[allArgs.size()];
        allArgs.toArray(allArgsArray);

        return allArgsArray;
    }

    @Override public String getDescription() {
        return mName;
    }

    /**
     * Sets the displayed name for this filter group.
     * @param name the filter name
     * @return this, with the name set
     */
    public SimpleSelectionFilterGroup setName(String name) {
        mName = name;
        return this;
    }

    @Override public String toString() {
        return mName;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.filter.db;

import org.projectbuendia.models.Model;

/**
 * A container for a filter string (part of an SQL WHERE clause) and the arguments to insert into
 * that filter string.
 */
public abstract class SimpleSelectionFilter<T extends Model> {
    /**
     * A selection filter, with the syntax of a structured SQL WHERE clause.
     * For example, a selection filter could be "given_name=? AND family_name LIKE ?".
     */
    public abstract String getSelectionString();

    /**
     * Selection arguments that map to any wild cards in the selection string.
     * For example, for the selection filter "given_name=? and family_name LIKE ?",
     * getSelectionArg(CharSequence) should return two strings.
     * @param constraint the constraint passed into the top-level filter
     */
    public abstract String[] getSelectionArgs(CharSequence constraint);

    @Override public String toString() {
        return getDescription();
    }

    /**
     * Returns a localized, human-readable description for this filter for logging and display
     * purposes.
     */
    public String getDescription() {
        return getClass().getName();
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.filter.db;

import org.projectbuendia.models.Model;

/** A pass-through filter that matches all results. */
public final class AllFilter<T extends Model> extends SimpleSelectionFilter<T> {
    @Override public String getSelectionString() {
        return "";
    }

    @Override public String[] getSelectionArgs(CharSequence constraint) {
        return new String[0];
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.filter.db.encounter;

import org.projectbuendia.client.filter.db.SimpleSelectionFilter;
import org.projectbuendia.models.Encounter;
import org.projectbuendia.client.providers.Contracts;

/** Matches only the encounter with the given UUID. */
public final class EncounterUuidFilter extends SimpleSelectionFilter<Encounter> {

    @Override public String getSelectionString() {
        return Contracts.Observations.ENCOUNTER_UUID + " = ?";
    }

    @Override public String[] getSelectionArgs(CharSequence constraint) {
        return new String[] {constraint.toString()};
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.filter.db.patient;

import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.client.filter.db.SimpleSelectionFilter;
import org.projectbuendia.models.Patient;
import org.projectbuendia.client.providers.Contracts;

/** Matches only patients below a specified age in years. */
final class PregnancyFilter extends SimpleSelectionFilter<Patient> {
    @Override public String getSelectionString() {
        return Contracts.Patients.PREGNANCY;
    }

    @Override public String[] getSelectionArgs(CharSequence constraint) {
        return new String[] {};
    }

    @Override public String getDescription() {
        return App.str(R.string.pregnant);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.filter.db.patient;

import com.google.common.collect.ImmutableList;

import org.projectbuendia.client.filter.db.AllFilter;
import org.projectbuendia.client.filter.db.SimpleSelectionFilter;
import org.projectbuendia.models.Location;
import org.projectbuendia.models.LocationForest;

import java.util.ArrayList;
import java.util.List;

/** All available patient filters available to the user, categorized by filter type. */
public final class PatientDbFilters {
    public static SimpleSelectionFilter getDefaultFilter() {
        return new AllFilter();
    }

    /** Returns a list of all {@link SimpleSelectionFilter}s that should be displayed to the user. */
    public static List<SimpleSelectionFilter<?>> getFiltersForDisplay(LocationForest forest) {
        List<SimpleSelectionFilter<?>> allFilters = new ArrayList<>();
        allFilters.addAll(getLocationFilters(forest));
        allFilters.add(null); // Section break
        allFilters.addAll(getOtherFilters());
        return allFilters;
    }

    /** Returns a list of filters, each representing a location. */
    public static List<SimpleSelectionFilter<?>> getLocationFilters(LocationForest forest) {
        List<SimpleSelectionFilter<?>> filters = new ArrayList<>();
        for (Location location : forest.allNodes()) {
            filters.add(new LocationUuidFilter(forest, location));
        }
        return filters;
    }

    /** Returns a list of all the filters unrelated to locations. */
    public static List<SimpleSelectionFilter<?>> getOtherFilters() {
        return ImmutableList.of(
            new PregnancyFilter(),
            new AgeFilter(5),
            new AgeFilter(2)
        );
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.filter.db.patient;

import org.projectbuendia.client.filter.db.SimpleSelectionFilter;
import org.projectbuendia.models.Patient;
import org.projectbuendia.client.providers.Contracts;

/** Matches only the patient with the given patient UUID. */
public final class UuidFilter extends SimpleSelectionFilter<Patient> {
    @Override public String getSelectionString() {
        return Contracts.Patients.UUID + " = ?";
    }

    @Override public String[] getSelectionArgs(CharSequence constraint) {
        return new String[] {constraint.toString()};
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.filter.db.patient;

import com.google.common.base.Joiner;

import org.projectbuendia.client.filter.db.SimpleSelectionFilter;
import org.projectbuendia.models.Location;
import org.projectbuendia.models.LocationForest;
import org.projectbuendia.models.Patient;
import org.projectbuendia.client.providers.Contracts.Patients;
import org.projectbuendia.client.utils.Utils;

import java.util.Arrays;
import java.util.List;

/** LocationUuidFilter matches all patients in a specified subtree of locations. */
public final class LocationUuidFilter extends SimpleSelectionFilter<Patient> {

    private final String mSelection;
    private final String[] mSelectionArgs;
    private final String mRootUuid;
    private final String mDescription;

    /** Creates a filter returning only patients under a subroot of the given location forest. */
    public LocationUuidFilter(LocationForest forest, Location subroot) {
        if (forest == null || subroot == null) {
            mSelection = "";
            mSelectionArgs = new String[0];
            mRootUuid = null;
            mDescription = "";
            return;
        }
        List<Location> subtreeNodes = forest.getSubtree(subroot);
        int numNodes = subtreeNodes.size();

        String[] placeholders = new String[numNodes];
        Arrays.fill(placeholders, "?");
        String nodePlaceholders = Joiner.on(",").join(placeholders);
        mSelection = Utils.format("%s in (%s)", Patients.LOCATION_UUID, nodePlaceholders);

        mSelectionArgs = new String[numNodes];
        for (int i = 0; i < subtreeNodes.size(); i++) {
            mSelectionArgs[i] = subtreeNodes.get(i).uuid;
        }

        mRootUuid = subroot.uuid;
        String indentedName = subroot.name;
        for (int i = 0; i < forest.getDepth(subroot); i++) {
            indentedName = "        " + indentedName;
        }
        mDescription = indentedName;
    }

    /** Returns the UUID of the root location used for filtering. */
    public String getFilterRootUuid() {
        return mRootUuid;
    }

    @Override public String getSelectionString() {
        return mSelection;
    }

    @Override public String[] getSelectionArgs(CharSequence constraint) {
        return mSelectionArgs;
    }

    @Override public String getDescription() {
        return mDescription;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.filter.db.patient;

import org.joda.time.LocalDate;
import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.client.filter.db.SimpleSelectionFilter;
import org.projectbuendia.models.Patient;
import org.projectbuendia.client.providers.Contracts;

/** Matches only patients below a specified age in years. */
final class AgeFilter extends SimpleSelectionFilter<Patient> {
    private final int mYears;

    public AgeFilter(int years) {
        mYears = years;
    }

    @Override public String getSelectionString() {
        return Contracts.Patients.BIRTHDATE + " > ?";
    }

    @Override public String[] getSelectionArgs(CharSequence constraint) {
        LocalDate minBirthdate = LocalDate.now().minusYears(mYears);
        return new String[] {minBirthdate.toString()};
    }

    @Override public String getDescription() {
        return App.str(R.string.age_filter_description, mYears);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.filter.matchers;

import org.projectbuendia.models.TypedCursor;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/** A view of a cursor that is filtered with a specified {@link MatchingFilter}. */
public class FilteredCursor<T> implements TypedCursor<T> {
    private final TypedCursor<T> mCursor;
    private final List<Integer> mIndices;

    /** Applies a filter to a cursor, given a particular search term. */
    public FilteredCursor(
        TypedCursor<T> cursor, MatchingFilter<T> filter, CharSequence constraint) {
        mCursor = cursor;
        mIndices = new ArrayList<>();

        int count = cursor.getCount();
        for (int i = 0; i < count; i++) {
            T obj = cursor.get(i);
            if (filter.matches(obj, constraint)) {
                mIndices.add(i);
            }
        }
    }

    @Override public void close() {
        mCursor.close();
    }

    @Override public Iterator<T> iterator() {
        return new Iterator<T>() {
            private int mPosition = -1;

            @Override public boolean hasNext() {
                return mPosition + 1 < getCount();
            }

            @Override public T next() {
                mPosition++;
                return get(mPosition);
            }

            @Override public void remove() {
                throw new UnsupportedOperationException();
            }
        };
    }

    @Override public int getCount() {
        return mIndices.size();
    }

    @Override public T get(int position) {
        return mCursor.get(mIndices.get(position));
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.filter.matchers;

/** A filter which operates by selectively matching Objects of the given type. */
public interface MatchingFilter<T> {
    /**
     * Returns true iff the object matches this filter based on the given search term.
     * @param object     the object to match
     * @param constraint the search term
     */
    public boolean matches(T object, CharSequence constraint);
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.filter.matchers;

import com.google.common.collect.ImmutableList;

/** A matcher that acts as a container for multiple filters or filter groups. */
public class MatchingFilterGroup<T> implements MatchingFilter<T> {
    private final FilterType mFilterType;
    private final ImmutableList<MatchingFilter> mFilters;

    /** Specifies whether filters in this group will be AND'd or OR'd in the selection. */
    public enum FilterType {
        OR,
        AND
    }

    public MatchingFilterGroup(FilterType filterType, MatchingFilter... filters) {
        mFilters = ImmutableList.copyOf(filters);
        mFilterType = filterType;
    }

    @Override public boolean matches(T object, CharSequence constraint) {
        if (mFilterType == FilterType.OR) {
            return matchesOr(object, constraint);
        } else {
            return matchesAnd(object, constraint);
        }
    }

    private boolean matchesOr(T object, CharSequence constraint) {
        for (MatchingFilter filter : mFilters) {
            if (filter.matches(object, constraint)) {
                return true;
            }
        }

        return false;
    }

    private boolean matchesAnd(T object, CharSequence constraint) {
        for (MatchingFilter filter : mFilters) {
            if (!filter.matches(object, constraint)) {
                return false;
            }
        }

        return true;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.filter.matchers.patient;

import android.support.annotation.Nullable;

import org.projectbuendia.client.filter.matchers.MatchingFilter;
import org.projectbuendia.models.Patient;

/** Matches based on user-specified patient id. */
public final class IdFilter implements MatchingFilter<Patient> {
    @Override public boolean matches(@Nullable Patient object, CharSequence constraint) {
        if (object == null || object.id == null) {
            return false;
        }
        return object.id.toLowerCase().contains(constraint.toString().toLowerCase());
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.filter.matchers.patient;

import android.support.annotation.Nullable;

import org.projectbuendia.client.filter.matchers.MatchingFilter;
import org.projectbuendia.models.Patient;
import org.projectbuendia.client.utils.Utils;

import java.util.regex.Pattern;

/**
 * Filters by name.
 * <p/>
 * <p>Selects patients for whom each of the words in the parameter string prefix-match any of the
 * words in the given name or family name, even if in a different order.
 */
public final class NameFilter implements MatchingFilter<Patient> {
    private static final Pattern DASH_REGEX = Pattern.compile("^\\p{Pd}*$");

    @Override public boolean matches(@Nullable Patient patient, CharSequence constraint) {
        if (patient == null) {
            return false;
        }

        // Get array of words that appear in any part of the name
        String givenName = Utils.toNonnull(patient.givenName);
        String familyName = Utils.toNonnull(patient.familyName);
        String fullName = givenName + " " + familyName;
        String[] nameParts = fullName.toLowerCase().split(" ");

        // Get array of words in the search query
        String[] searchTerms = constraint.toString().toLowerCase().split(" ");

        // Loop through each of the search terms checking if there is a prefix match
        // for it in any word of the name.
        for (String searchTerm : searchTerms) {
            boolean termMatched = false;
            for (String namePart : nameParts) {
                // If both the search term and a name are dashes, use a more permissive matcher
                // that allows for an arbitrary type of dash. This makes it simpler to search for
                // patients with an unknown name, which is represented by a dash.
                if (namePart.startsWith(searchTerm) || areBothDashes(namePart, searchTerm)) {
                    termMatched = true;
                    break;  // no need to keep checking for this term
                }
            }
            // This search term was not matched to any word of the name,
            // so this patient is not a match
            if (!termMatched) {
                return false;
            }
        }

        // If we've been through all the search terms without returning false,
        // then we must have found a match for all of them
        return true;
    }

    private boolean areBothDashes(String string1, String string2) {
        return isDash(string1) && isDash(string2);
    }

    private boolean isDash(String str) {
        return DASH_REGEX.matcher(str).matches();
    }
}

package org.projectbuendia.client.sync;

import android.content.ContentProviderClient;
import android.content.SyncResult;
import android.os.Bundle;

/** Performs the heavy lifting of a sync (network and database operations). */
public interface SyncEngine {
    /** Runs a sync as a long blocking operation. */
    void sync(Bundle options, ContentProviderClient client, SyncResult result);

    /** Called by other threads to request cancellation of any currently running sync. */
    void cancel();
}

package org.projectbuendia.client.sync;

import android.content.ContentProviderClient;
import android.content.SyncResult;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.support.annotation.NonNull;

import org.projectbuendia.client.App;
import org.projectbuendia.client.providers.Contracts;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/** An implementation of SyncScheduler that runs the SyncEngine on a background thread. */
public class ThreadedSyncScheduler implements SyncScheduler {
    private static Logger LOG = Logger.create();

    private final SyncThread thread;

    // Command codes
    private static final int REQUEST_SYNC = 1;
    private static final int SET_PERIODIC_SYNC = 2;
    private static final int CLEAR_ALL_PERIODIC_SYNCS = 3;
    private static final int LOOP_TICK = 4;

    public ThreadedSyncScheduler(SyncEngine engine) {
        LOG.i("> start new SyncThread");
        thread = new SyncThread(engine);
        thread.start();
    }

    @Override public void requestSync(Bundle options) {
        LOG.i("> requestSync(%s)", options);
        thread.send(REQUEST_SYNC, Utils.bundle("options", options));
    }

    @Override public void stopSyncing() {
        LOG.i("> stopSyncing()");
        thread.stopSyncing();
    }

    @Override public void setPeriodicSync(int periodSec, Bundle options) {
        LOG.i("> setPeriodicSync(periodSec=%d, options=%s)", periodSec, options);
        thread.send(SET_PERIODIC_SYNC, Utils.bundle(
            "options", options, "periodSec", periodSec));
    }

    @Override public void clearAllPeriodicSyncs() {
        LOG.i("> clearAllPeriodicSyncs()");
        thread.send(CLEAR_ALL_PERIODIC_SYNCS, new Bundle());
    }

    @Override public boolean isRunningOrPending() {
        return thread.isSyncRunning() || thread.hasPendingRequests();
    }

    protected static class SyncThread extends Thread {
        private final SyncEngine engine;
        private final Map<Object, Loop> loopStates = new HashMap<>();
        private int nextLoopId = 0;
        private Handler handler = null;
        private boolean running = false;

        // ==== Methods exposed to external threads ====

        public SyncThread(SyncEngine engine) {
            super("SyncThread");
            this.engine = engine;
        }

        public void send(int command, Bundle data) {
            LOG.d("> send(command=%d, data=%s)", command, data);
            handler.sendMessage(Utils.newMessage(handler, command, data));
        }

        public boolean isSyncRunning() {
            LOG.d("> isSyncRunning() = " + running);
            return running;
        }

        public boolean hasPendingRequests() {
            LOG.i("> hasPendingRequests() = " + handler.hasMessages(REQUEST_SYNC));
            return handler.hasMessages(REQUEST_SYNC);
        }

        public void stopSyncing() {
            handler.removeMessages(REQUEST_SYNC);
            engine.cancel();
        }

        // ==== Methods that run inside this thread ====

        @Override public void run() {
            LOG.i("* run())");
            try {
                Looper.prepare();

                handler = new Handler(message -> {
                    Bundle data = message.getData();
                    Bundle options = data.getBundle("options");
                    int periodSec = data.getInt("periodSec", 0);
                    int loopId = data.getInt("loopId", 0);
                    Loop loop = getLoop(options);

                    switch (message.what) {
                        case REQUEST_SYNC:
                            LOG.d("* handleMessage(REQUEST_SYNC, %s)", data);
                            runSync(options);
                            return true;

                        case SET_PERIODIC_SYNC:
                            LOG.d("* handleMessage(SET_PERIODIC_SYNC, %s), loop=%s", data, loop);
                            if (periodSec == loop.periodSec) {
                                LOG.d("* requested period (%s sec) is already in effect", periodSec);
                                return true;
                            }
                            loop.set(periodSec);
                            LOG.d("* activeLoopId is now %d for options=%s", loop.activeLoopId, options);

                            if (loop.periodSec > 0) {
                                sendLoopTick(loop);
                            }
                            return true;

                        case CLEAR_ALL_PERIODIC_SYNCS:
                            LOG.d("* handleMessage(CLEAR_ALL_PERIODIC_SYNCS)");
                            loopStates.clear();
                            nextLoopId = 0;
                            return true;

                        case LOOP_TICK:
                            LOG.d("* handleMessage(LOOP_TICK, %s), loop=%s", data, loop);
                            if (loopId == loop.activeLoopId) {
                                runSync(options);
                                sendLoopTick(loop);
                            } else {
                                LOG.d("* loopId=%d is no longer active; ignoring", loopId);
                            }
                            return true;
                    }
                    return false;
                });

                Looper.loop();
            } catch (Throwable t) {
                LOG.e(t, "run() aborted");
            } finally {
                LOG.i("run() terminated");
            }
        }

        private Loop getLoop(Bundle options) {
            if (options == null) return null;
            Object bundleKey = getHashableObject(options);
            Loop loop = loopStates.get(bundleKey);
            if (loop == null) {
                loop = new Loop(options);
                loopStates.put(bundleKey, loop);
            }
            return loop;
        }

        private void sendLoopTick(Loop loop) {
            LOG.d("* scheduling LOOP_TICK(%d) in %d sec for %s", loop.activeLoopId, loop.periodSec, loop);
            handler.sendMessageDelayed(Utils.newMessage(handler, LOOP_TICK, Utils.bundle(
                "options", loop.options,
                "periodSec", loop.periodSec,
                "loopId", loop.activeLoopId
            )), loop.periodSec * 1000);
        }

        private void runSync(Bundle options) {
            if (!App.getSettings().isAuthorized()) {
                LOG.w("Skipping sync: App is not authorized.");
                return;
            }

            if (App.getSyncManager().getNewSyncsSuppressed()) {
                LOG.w("Skipping sync: New syncs are currently suppressed.");
                return;
            }

            // If we can't access the Buendia API, short-circuit. Before this check
            // was added, sync would occasionally hang indefinitely when Wi-Fi was
            // unavailable.  As a side effect of this change, however, any
            // user-requested sync will instantly fail until the HealthMonitor has
            // made a determination that the server is definitely accessible.
            if (App.getHealthMonitor().isApiUnavailable()) {
                LOG.w("Skipping sync: Buendia API is unavailable.");
                return;
            }

            ContentProviderClient client = App.getResolver().acquireContentProviderClient(Contracts.Users.URI);
            SyncResult result = new SyncResult();
            running = true;
            try {
                LOG.i("* engine.sync(options=%s)", options);
                engine.sync(options, client, result);
            } finally {
                LOG.i("* engine.sync() terminated");
                running = false;
            }
        }

        /** Performs a bijection from a Bundle to an object usable as a Map key. */
        private List<Object> getHashableObject(Bundle bundle) {
            List<String> keys = new ArrayList<>(bundle.keySet());
            Collections.sort(keys);
            List<Object> result = new ArrayList<>();
            for (String key : keys) {
                result.add(key);
                result.add(bundle.get(key));
            }
            return result;
        }

        private class Loop {
            private int periodSec;
            private int activeLoopId;
            private final Bundle options;

            private Loop(Bundle options) {
                this.options = options;
            }

            public void set(int periodSec) {
                this.periodSec = periodSec;
                this.activeLoopId = ++nextLoopId;
            }

            public @NonNull String toString() {
                return Utils.format("Loop(periodSec=%d, activeLoopId=%d, options=%s)",
                    periodSec, activeLoopId, options);
            }
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.sync;

import android.content.ContentProviderClient;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.content.OperationApplicationException;
import android.content.SyncResult;
import android.database.Cursor;
import android.os.Bundle;
import android.os.RemoteException;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.StringRes;

import com.google.common.base.Joiner;
import com.google.common.collect.Sets;

import org.joda.time.DateTime;
import org.joda.time.Instant;
import org.projectbuendia.client.R;
import org.projectbuendia.client.providers.BuendiaProvider;
import org.projectbuendia.client.providers.Contracts.Bookmarks;
import org.projectbuendia.client.providers.Contracts.Misc;
import org.projectbuendia.client.providers.Contracts.Table;
import org.projectbuendia.client.providers.DatabaseTransaction;
import org.projectbuendia.client.sync.SyncManager.SyncStatus;
import org.projectbuendia.client.sync.controllers.ChartsSyncWorker;
import org.projectbuendia.client.sync.controllers.ConceptsSyncWorker;
import org.projectbuendia.client.sync.controllers.FormsSyncWorker;
import org.projectbuendia.client.sync.controllers.LocationsSyncWorker;
import org.projectbuendia.client.sync.controllers.ObservationsSyncWorker;
import org.projectbuendia.client.sync.controllers.OrdersSyncWorker;
import org.projectbuendia.client.sync.controllers.PatientsSyncWorker;
import org.projectbuendia.client.sync.controllers.SyncWorker;
import org.projectbuendia.client.sync.controllers.UsersSyncWorker;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CancellationException;

/** Implementation of sync operations for the Buendia database. */
public class BuendiaSyncEngine implements SyncEngine {
    private static final Logger LOG = Logger.create();
    private static final String SAVEPOINT_NAME = "SYNC_SAVEPOINT";
    private static final String KEY_PHASES = "PHASES";

    private final Context context;
    private final ContentResolver contentResolver;
    private boolean isCancelled = false;

    /** The available phases, in the default order in which to run them. */
    public enum Phase {
        LOCATIONS(R.string.syncing_locations, new LocationsSyncWorker()),
        USERS(R.string.syncing_users, new UsersSyncWorker()),
        CONCEPTS(R.string.syncing_concepts, new ConceptsSyncWorker()),
        CHART_ITEMS(R.string.syncing_charts, new ChartsSyncWorker()),
        FORMS(R.string.syncing_forms, new FormsSyncWorker()),
        PATIENTS(R.string.syncing_patients, new PatientsSyncWorker()),
        OBSERVATIONS(R.string.syncing_observations, new ObservationsSyncWorker()),
        ORDERS(R.string.syncing_orders, new OrdersSyncWorker());

        public final @StringRes int message;
        public final SyncWorker worker;
        public static final Phase[] ALL_PHASES = Phase.values();

        Phase(int message, SyncWorker worker) {
            this.message = message;
            this.worker = worker;
        }
    }

    public BuendiaSyncEngine(Context context) {
        this.context = context;
        this.contentResolver = context.getContentResolver();
    }

    @Override public void cancel() {
        isCancelled = true;
        LOG.i("Received a cancel() request");
    }

    public static Bundle buildOptions(Phase... phases) {
        return Utils.bundle(KEY_PHASES, Joiner.on(",").join(phases));
    }

    public static @NonNull List<Phase> getPhases(Bundle options) {
        List<Phase> phases = new ArrayList<>();
        if (options != null) {
            for (String name : options.getString(KEY_PHASES, "").split(",")) {
                try {
                    phases.add(Phase.valueOf(name));
                } catch (IllegalArgumentException e) {
                    LOG.w("Unrecognized phase name: %s (in options: %s)", Utils.repr(name), options);
                }
            }
        }
        return phases;
    }

    /** Not thread-safe but, by default, this will never be called multiple times in parallel. */
    @Override public void sync(Bundle options, ContentProviderClient client, SyncResult result) {
        isCancelled = false;

        try {
            checkCancellation("before work started");
        } catch (CancellationException e) {
            broadcastSyncStatus(SyncStatus.CANCELLED);
            return;
        }

        List<Phase> phases = getPhases(options);
        boolean fullSync = Sets.newHashSet(phases).equals(Sets.newHashSet(Phase.ALL_PHASES));
        LOG.start("sync", "options = %s", options);

        broadcastSyncProgress(0, 1, R.string.sync_in_progress);

        BuendiaProvider provider = (BuendiaProvider) client.getLocalContentProvider();
        try (DatabaseTransaction tx = provider.startTransaction(SAVEPOINT_NAME)) {
            try {
                if (fullSync) storeFullSyncStartTime(client, Instant.now());
                LOG.elapsed("sync", "Starting phases");
                int completedWork = 0;
                int totalWork = phases.size();

                for (Phase phase : phases) {
                    checkCancellation("before " + phase);
                    broadcastSyncProgress(completedWork, totalWork, phase.message);
                    LOG.i("Start phase: %s", phase);
                    phase.worker.initialize(contentResolver, result, client);
                    boolean done = false;
                    while (!done) {
                        done = phase.worker.sync(contentResolver, result, client);
                        completedWork++;
                        if (!done) {
                            totalWork++;
                            broadcastSyncProgress(completedWork, totalWork, phase.message);
                            checkCancellation("during " + phase);
                        }
                    }
                    phase.worker.finalize(contentResolver, result, client);
                    LOG.elapsed("sync", "Completed phase %s", phase);
                }
                broadcastSyncProgress(1, 1, R.string.completing_sync);
                if (fullSync) storeFullSyncEndTime(client, Instant.now());
            } catch (CancellationException e) {
                LOG.i(e, "Cancelled %s", options);
                tx.rollback();
                // Reset canceled state so that it doesn't interfere with next sync.
                broadcastSyncStatus(SyncStatus.CANCELLED);
                return;
            } catch (OperationApplicationException e) {
                LOG.e(e, "Failed due to database error");
                tx.rollback();
                result.databaseError = true;
                broadcastSyncStatus(SyncStatus.FAILED);
                return;
            } catch (Throwable e) {
                LOG.e(e, "Failed due to exception");
                tx.rollback();
                result.stats.numIoExceptions++;
                broadcastSyncStatus(SyncStatus.FAILED);
                return;
            }
        }
        broadcastSyncStatus(SyncStatus.SUCCEEDED);
        LOG.finish("sync");
        LOG.i("Completed", options);
    }

    /**
     * Enforces sync cancellation, throwing a {@link CancellationException} if the sync has been
     * canceled. It is the responsibility of the caller to perform any actual cancellation
     * procedures.
     */
    private synchronized void checkCancellation(String when) throws CancellationException {
        if (isCancelled) {
            isCancelled = false;
            String message = "Sync cancelled " + when;
            LOG.w(message);
            throw new CancellationException(message);
        }
    }

    private void broadcastSyncStatus(SyncStatus status) {
        context.sendBroadcast(
            new Intent(SyncManager.STATUS_ACTION)
                .putExtra(SyncManager.SYNC_STATUS, status)
                .addFlags(Intent.FLAG_RECEIVER_FOREGROUND)
        );
    }

    private void broadcastSyncProgress(int numerator, int denominator, @StringRes int messageId) {
        context.sendBroadcast(
            new Intent(SyncManager.STATUS_ACTION)
                .putExtra(SyncManager.SYNC_STATUS, SyncStatus.IN_PROGRESS)
                .putExtra(SyncManager.SYNC_NUMERATOR, numerator)
                .putExtra(SyncManager.SYNC_DENOMINATOR, denominator)
                .putExtra(SyncManager.SYNC_MESSAGE_ID, messageId)
                .addFlags(Intent.FLAG_RECEIVER_FOREGROUND)
        );
    }

    private void storeFullSyncStartTime(ContentProviderClient provider, Instant time) throws RemoteException {
        LOG.i("Recording full sync start time: " + time);
        ContentValues cv = new ContentValues();
        cv.put(Misc.FULL_SYNC_START_MILLIS, time.getMillis());
        provider.insert(Misc.URI, cv);
    }

    private void storeFullSyncEndTime(ContentProviderClient provider, Instant time) throws RemoteException {
        DateTime start = null;
        try (Cursor cursor = provider.query(Misc.URI, null, null, null, null)) {
            if (cursor.moveToNext()) {
                start = Utils.getDateTime(cursor, Misc.FULL_SYNC_START_MILLIS);
            }
        }
        Long value = time.getMillis();
        if (start == null) {
            LOG.e("Database was cleared during sync!");
            value = null;
        }
        LOG.i("Recording full sync end time: " + value);
        ContentValues cv = new ContentValues();
        cv.put(Misc.FULL_SYNC_END_MILLIS, value);
        provider.insert(Misc.URI, cv);
    }

    /** Returns the server timestamp corresponding to the last observation sync. */
    @Nullable
    public static String getBookmark(ContentProviderClient provider, Table table)
            throws RemoteException {
        try (Cursor c = provider.query(
                Bookmarks.URI.buildUpon().appendPath(table.name).build(),
                new String[] {Bookmarks.BOOKMARK}, null, null, null)
        ) {
            // Make the linter happy, there's no way that the cursor can be null without throwing
            // an exception.
            assert c != null;
            if (c.moveToNext()) {
                // Whether c.getString is null or not is implementation-defined, so we explicitly
                // check for nullness.
                if (c.isNull(0)) {
                    return null;
                }
                return c.getString(0);
            } else {
                return null;
            }
        }
    }

    public static void setBookmark(ContentProviderClient provider, Table table, String bookmark)
            throws RemoteException {
        ContentValues cv = new ContentValues();
        cv.put(Bookmarks.TABLE_NAME, table.name);
        cv.put(Bookmarks.BOOKMARK, bookmark);
        provider.insert(Bookmarks.URI, cv);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.sync;

import android.content.ContentValues;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;

import com.google.common.collect.ObjectArrays;

import org.projectbuendia.client.providers.Contracts;

/** Constructs and executes SQL queries. */
// TODO/cleanup: Get rid of this class!  In most cases, a query is invoked on a ContentResolver
// with separate table, projection, condition, and order arguments -- which then invokes a
// ProviderDelegate, which instantiates a QueryBuilder, invokes its builder methods to pass in
// the projection, condition, and arguments one by one, and then invokes its select() method,
// which just calls db.query with separate table, projection, condition, and order arguments again!
public class QueryBuilder {
    Contracts.Table mTable;
    String mCondition = "1";
    String[] mArgs = {};
    String mOrderBy = null;
    String mGroupBy = null;

    public QueryBuilder(Contracts.Table table) {
        mTable = table;
    }

    /** Adds a SQL condition to the WHERE clause (joined using AND). */
    public QueryBuilder where(String sqlCondition, String... args) {
        if (sqlCondition != null && !sqlCondition.isEmpty()) {
            mCondition += " and (" + sqlCondition + ")";
            mArgs = args != null ? ObjectArrays.concat(mArgs, args, String.class) : mArgs;
        }
        return this;
    }

    /** Sets the sort key in the ORDER BY clause. */
    public QueryBuilder orderBy(String key) {
        mOrderBy = key;
        return this;
    }

    /** Sets the group key in the GROUP BY clause. */
    public QueryBuilder groupBy(String key) {
        mGroupBy = key;
        return this;
    }

    /** Executes a SELECT query. */
    public Cursor select(SQLiteDatabase db, String... columns) {
        return db.query(mTable.name, columns, mCondition, mArgs, mGroupBy, null, mOrderBy, null);
    }

    /** Executes an UPDATE query. */
    public int update(SQLiteDatabase db, ContentValues values) {
        return db.update(mTable.name, values, mCondition, mArgs);
    }

    /** Executes a DELETE query. */
    public int delete(SQLiteDatabase db) {
        return db.delete(mTable.name, mCondition, mArgs);
    }
}

package org.projectbuendia.client.sync;

import android.os.Bundle;

/** SyncManager-facing interface for scheduling and cancelling sync operations. */
public interface SyncScheduler<T> {
    /** Queues a request for a sync to begin when the sync engine is available. */
    void requestSync(Bundle options);

    /** Aborts any sync currently in progress and cancels any queued requests. */
    void stopSyncing();

    /**
     * Starts, changes, or stops a periodic sync schedule.  There can be at most
     * one such repeating loop for each set of options; if this bundle of options
     * has the same contents as that from a previous call, the repeating loop set
     * by the previous call is terminated and a new loop is started with the given
     * period.  When a loop starts, the first sync occurs after the first period
     * has elapsed.  Specifying a period of zero stops the loop.
     */
    void setPeriodicSync(int periodSec, Bundle options);

    /** Cancels all periodic sync loops. */
    void clearAllPeriodicSyncs();

    /** Returns true if a sync is currently running or pending on the queue. */
    boolean isRunningOrPending();
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.sync;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;

import org.projectbuendia.client.App;
import org.projectbuendia.client.AppSettings;
import org.projectbuendia.client.R;
import org.projectbuendia.client.events.sync.SyncCancelledEvent;
import org.projectbuendia.client.events.sync.SyncFailedEvent;
import org.projectbuendia.client.events.sync.SyncProgressEvent;
import org.projectbuendia.client.events.sync.SyncSucceededEvent;
import org.projectbuendia.client.sync.BuendiaSyncEngine.Phase;
import org.projectbuendia.client.utils.Logger;

import java.util.ArrayList;
import java.util.List;

import javax.annotation.Nullable;

import de.greenrobot.event.EventBus;

/** Provides app-facing methods for requesting and cancelling sync operations. */
public class SyncManager {
    private static final Logger LOG = Logger.create();
    public static final String STATUS_ACTION = "org.projectbuendia.client.SYNC_STATUS";

    // "Small" phases are ones that take <100 ms and send <100 bytes of data, >90% of the time.
    public static final Phase[] SMALL_PHASES = {Phase.OBSERVATIONS, Phase.ORDERS, Phase.PATIENTS};

    // "Medium" phases are ones that take <500 ms and send <4 kb of data, >90% of the time.
    public static final Phase[] MEDIUM_PHASES = {Phase.LOCATIONS, Phase.USERS};

    // "Large" phases are ones that take <2000 ms and send <20 kb of data, >90% of the time.
    public static final Phase[] LARGE_PHASES = Phase.ALL_PHASES;

    /** Key for the current sync status. */
    static final String SYNC_STATUS = "SYNC_STATUS";
    enum SyncStatus {
        IN_PROGRESS, SUCCEEDED, FAILED, CANCELLED
    }

    /** Keys for the amount of progress so far, expressed as a fraction. */
    static final String SYNC_NUMERATOR = "SYNC_NUMERATOR";
    static final String SYNC_DENOMINATOR = "SYNC_DENOMINATOR";

    /** Key for a nullable string describing the sync status to the user. */
    static final String SYNC_MESSAGE_ID = "sync-message-id";

    private boolean newSyncsSuppressed = false;
    private final SyncScheduler mScheduler;
    private final List<Runnable> syncStoppedCallbacks = new ArrayList<>();

    public SyncManager(SyncScheduler scheduler) {
        mScheduler = scheduler;
        App.getContext()
            .registerReceiver(new StatusReceiver(), new IntentFilter(STATUS_ACTION));
    }

    public boolean getNewSyncsSuppressed() {
        return newSyncsSuppressed;
    }

    /**
     * Sets whether all new syncs should be suppressed.  While this flag is true,
     * any attempt to start a new sync (by an explicit call to sync() or by any
     * periodic sync loop) becomes a no-op.  Any loops started by setPeriodicSync
     * continue to loop but do not trigger any syncs.  Setting this flag has no
     * effect on any already running sync.
     */
    public void setNewSyncsSuppressed(boolean suppressed) {
        newSyncsSuppressed = suppressed;
    }

    /** Stops any currently running sync; invokes a callback when stopped or if already stopped. */
    public void stopSyncing(@Nullable Runnable syncStoppedCallback) {
        if (syncStoppedCallback != null) {
            syncStoppedCallbacks.add(syncStoppedCallback);
        }
        if (isSyncRunningOrPending()) {
            mScheduler.stopSyncing();  // let the SyncStoppedEvent trigger the callback
        } else {
            runSyncStoppedCallbacks();
        }
    }

    public boolean isSyncRunningOrPending() {
        return mScheduler.isRunningOrPending();
    }

    /** Starts or cancels regularly repeating syncs, according to the settings. */
    public void applyPeriodicSyncSettings() {
        AppSettings settings = App.getSettings();
        if (settings.getPeriodicSyncDisabled()) {
            mScheduler.clearAllPeriodicSyncs();
        } else {
            setPeriodicSync(settings.getSmallSyncInterval(), SMALL_PHASES);
            setPeriodicSync(settings.getMediumSyncInterval(), MEDIUM_PHASES);
            setPeriodicSync(settings.getLargeSyncInterval(), LARGE_PHASES);
        }
    }

    /** Starts a sync now. */
    public void sync(Phase... phases) {
        mScheduler.stopSyncing();  // cancel any running syncs to avoid delaying this one
        mScheduler.requestSync(buildOptions(phases));
    }

    /** Starts a sync of everything now. */
    public void syncAll() {
        sync(Phase.ALL_PHASES);
    }

    /**
     * Starts, changes, or stops a periodic sync schedule.  There can be at most
     * one such repeating loop for each list of phases; if this list of phases
     * is identical to the list from a previous call, the repeating loop set
     * by the previous call is terminated and a new loop is started with the given
     * period.  When a loop starts, the first sync occurs after the first period
     * has elapsed.  Specifying a period of zero stops the loop.
     */
    public void setPeriodicSync(int periodSec, Phase... phases) {
        mScheduler.setPeriodicSync(periodSec, buildOptions(phases));
    }

    private Bundle buildOptions(Phase... phases) {
        return BuendiaSyncEngine.buildOptions(phases);
    }

    // TODO(ping): This receiver will receive events from any instance of the
    // Buendia app, so if there are two instances running (e.g. dev and prod)
    // sync errors in one will abort the other and cause mayhem.
    /** Listens for sync status events that are broadcast by the BuendiaSyncEngine. */
    public class StatusReceiver extends BroadcastReceiver {
        @Override public void onReceive(Context context, Intent intent) {
            SyncStatus status = (SyncStatus) intent.getSerializableExtra(SYNC_STATUS);
            if (status == SyncStatus.IN_PROGRESS) {
                int numerator = intent.getIntExtra(SYNC_NUMERATOR, 0);
                int denominator = intent.getIntExtra(SYNC_DENOMINATOR, 1);
                int messageId = intent.getIntExtra(SYNC_MESSAGE_ID, R.string.sync_in_progress);
                LOG.d("SyncStatus: IN_PROGRESS: %d/%d", numerator, denominator);
                EventBus.getDefault().postSticky(new SyncProgressEvent(numerator, denominator, messageId));
            } else {
                // All three other statuses indicate that sync has stopped.
                LOG.d("SyncStatus: %s", status);
                runSyncStoppedCallbacks();
                EventBus.getDefault().post(
                    status == SyncStatus.SUCCEEDED ? new SyncSucceededEvent() :
                    status == SyncStatus.FAILED ? new SyncFailedEvent() :
                    /* status == SyncStatus.CANCELLED */ new SyncCancelledEvent());
            }
        }
    }

    /** Invokes any callbacks that are waiting for sync to stop. */
    private void runSyncStoppedCallbacks() {
        for (Runnable callback : syncStoppedCallbacks) {
            try {
                callback.run();
            } catch (Throwable t) {
                LOG.e(t, "Exception in stopSyncing callback");
            }
        }
        syncStoppedCallbacks.clear();
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.sync;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;

import org.projectbuendia.client.providers.Contracts.Table;
import org.projectbuendia.client.utils.Logger;

import java.util.HashMap;
import java.util.Map;

/**
 * Schema definition for the app's database, which contains patient attributes,
 * active patients, locations, and chart information.
 */
public class Database extends SQLiteOpenHelper {

    private static final Logger LOG = Logger.create();

    /** Schema version. */
    public static final int DATABASE_VERSION = 38;

    /** Filename for SQLite file. */
    public static final String DATABASE_FILENAME = "buendia.db";

    /**
     * A map of SQL table schemas, with one entry per table.  The values should
     * be strings that take the place of X in a "CREATE TABLE foo (X)" statement.
     */
    static final Map<Table, String> SCHEMAS = new HashMap<>();

    // For descriptions of these tables and the meanings of their columns, see Contracts.java.
    static {
        SCHEMAS.put(Table.PATIENTS, ""
            + "uuid TEXT PRIMARY KEY NOT NULL,"
            + "id TEXT,"
            + "given_name TEXT,"
            + "family_name TEXT,"
            + "birthdate TEXT,"
            + "sex TEXT,"
            + "pregnancy INTEGER,"
            + "location_uuid TEXT,"
            + "bed_number TEXT"
        );

        SCHEMAS.put(Table.CONCEPTS, ""
            + "uuid TEXT PRIMARY KEY NOT NULL,"
            + "xform_id INTEGER UNIQUE NOT NULL,"
            + "type TEXT,"
            + "name TEXT");

        SCHEMAS.put(Table.FORMS, ""
            + "uuid TEXT PRIMARY KEY NOT NULL,"
            + "name TEXT,"
            + "version TEXT");

        SCHEMAS.put(Table.LOCATIONS, ""
            + "uuid TEXT PRIMARY KEY NOT NULL,"
            + "name TEXT,"
            + "parent_uuid TEXT");

        SCHEMAS.put(Table.OBSERVATIONS, ""
            // uuid intentionally allows null values, because temporary observations inserted
            // locally after submitting a form don't have UUIDs. Note that PRIMARY KEY in SQLite
            // (and many other databases) treats all NULL values as different from all other values,
            // so it's still ok to insert multiple records with a NULL UUID.
            + "uuid TEXT PRIMARY KEY,"
            + "encounter_uuid TEXT,"
            + "patient_uuid TEXT,"
            + "provider_uuid TEXT,"
            + "concept_uuid TEXT,"
            + "type STRING,"
            + "millis INTEGER,"
            + "order_uuid STRING,"
            + "value STRING,"
            + "voided INTEGER,"
            + "UNIQUE (patient_uuid, encounter_uuid, concept_uuid)");

        SCHEMAS.put(Table.ORDERS, ""
            + "uuid TEXT PRIMARY KEY NOT NULL,"
            + "patient_uuid TEXT,"
            + "provider_uuid TEXT,"
            + "instructions TEXT,"
            + "start_millis INTEGER,"
            + "stop_millis INTEGER");

        // TODO(ping): Store multiple charts, sourced from multiple forms,
        // using a CHARTS table (uuid, name), where order is determined by name.
        SCHEMAS.put(Table.CHART_ITEMS, ""
            + "rowid INTEGER PRIMARY KEY NOT NULL,"
            + "chart_uuid TEXT,"
            + "weight INTEGER,"
            + "section_type TEXT,"
            + "parent_rowid INTEGER,"
            + "label TEXT,"
            + "type TEXT,"
            + "required INTEGER,"
            + "concept_uuids TEXT,"
            + "format TEXT,"
            + "caption_format TEXT,"
            + "css_class TEXT,"
            + "css_style TEXT,"
            + "script TEXT");

        SCHEMAS.put(Table.USERS, ""
            + "uuid TEXT PRIMARY KEY NOT NULL,"
            + "full_name TEXT");

        // TODO/cleanup: Store miscellaneous values in the "misc" table as rows with a key column
        // and a value column, not all values in one row with an ever-growing number of columns.
        SCHEMAS.put(Table.MISC, ""
            + "full_sync_start_millis INTEGER,"
            + "full_sync_end_millis INTEGER");

        SCHEMAS.put(Table.BOOKMARKS, ""
            + "table_name TEXT PRIMARY KEY NOT NULL,"
            + "bookmark TEXT NOT NULL");
    }

    public Database(Context context) {
        super(context, DATABASE_FILENAME, null, DATABASE_VERSION);
    }

    @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        // This database is only a cache of data on the server, so its upgrade
        // policy is to discard all the data and start over.
        clear(db);
    }

    private void clear(SQLiteDatabase db) {
        LOG.i("Dropping all tables");
        for (Table table : Table.values()) {
            db.execSQL("DROP TABLE IF EXISTS " + table);
        }
        onCreate(db);
    }

    @Override public void onCreate(SQLiteDatabase db) {
        LOG.i("Creating tables");
        for (Table table : Table.values()) {
            db.execSQL("CREATE TABLE " + table + " (" + SCHEMAS.get(table) + ");");
        }
    }

    public void clear() {
        // Never call zero-argument clear() from onUpgrade, as getWritableDatabase
        // can trigger onUpgrade, leading to endless recursion.
        clear(getWritableDatabase());
    }
}

package org.projectbuendia.client.sync;

import android.content.ContentResolver;
import android.database.Cursor;

import org.projectbuendia.client.App;
import org.projectbuendia.client.json.Datatype;
import org.projectbuendia.models.ConceptUuids;
import org.projectbuendia.client.providers.Contracts.Concepts;
import org.projectbuendia.client.utils.Intl;
import org.projectbuendia.client.utils.Utils;

import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

/** An in-memory cache of concepts name and types, loaded from the local database. */
public class ConceptService {
    private final ContentResolver resolver;

    private Map<String, Datatype> types = null;
    private Map<String, Intl> names = null;

    public ConceptService(ContentResolver resolver) {
        this.resolver = resolver;
    }

    public synchronized Datatype getType(String uuid) {
        if (types == null) load();
        return types.get(uuid);
    }

    public synchronized String getName(String uuid) {
        return getName(uuid, App.getSettings().getLocale());
    }

    public synchronized String getName(String uuid, Locale locale) {
        if (names == null) load();
        Intl intl = names.get(uuid);
        return intl != null ? intl.loc(locale) : Utils.compressUuid(uuid) + "?";
    }

    public synchronized void invalidate() {
        types = null;
        names = null;
    }

    private void load() {
        Map<String, Datatype> types = new HashMap<>();
        Map<String, Intl> names = new HashMap<>();

        try (Cursor c = resolver.query(Concepts.URI, null, null, null, null)) {
            while (c.moveToNext()) {
                String uuid = Utils.getString(c, Concepts.UUID);
                String type = Utils.getString(c, Concepts.TYPE);
                String name = Utils.getString(c, Concepts.NAME);
                try {
                    types.put(uuid, Datatype.valueOf(type));
                } catch (IllegalArgumentException e) {
                    continue;  // bad concept type name
                }
                names.put(uuid, new Intl(name));
            }
        }

        // Special case: yes and no concepts.
        names.put(ConceptUuids.YES_UUID, new Intl("Yes [fr:Oui]"));
        names.put(ConceptUuids.NO_UUID, new Intl("No [fr:Non]"));

        synchronized (this) {
            this.types = types;
            this.names = names;
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.sync;

import android.content.ContentResolver;
import android.database.Cursor;

import com.google.common.base.Joiner;

import org.joda.time.DateTime;
import org.projectbuendia.client.App;
import org.projectbuendia.client.json.Datatype;
import org.projectbuendia.models.Chart;
import org.projectbuendia.models.ChartItem;
import org.projectbuendia.models.ChartSection;
import org.projectbuendia.models.ConceptUuids;
import org.projectbuendia.models.Form;
import org.projectbuendia.models.Obs;
import org.projectbuendia.models.Order;
import org.projectbuendia.client.providers.Contracts;
import org.projectbuendia.client.providers.Contracts.ChartItems;
import org.projectbuendia.client.providers.Contracts.Observations;
import org.projectbuendia.client.providers.Contracts.Orders;
import org.projectbuendia.client.utils.Intl;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.SortedSet;
import java.util.TreeSet;

import static com.google.common.base.Preconditions.checkNotNull;
import static org.projectbuendia.client.utils.Utils.eq;

/** A helper class for retrieving and localizing data to show in patient charts. */
public class ChartDataHelper {
    private static final Logger LOG = Logger.create();
    private static final String[] UUIDS_TO_OMIT = {
        ConceptUuids.ORDER_EXECUTED_UUID,
        ConceptUuids.PLACEMENT_UUID
    };

    private final ContentResolver mContentResolver;

    public ChartDataHelper(ContentResolver contentResolver) {
        mContentResolver = checkNotNull(contentResolver);
    }

    /** Gets all the orders for a given patient. */
    public List<Order> getOrders(String patientUuid) {
        Cursor c = mContentResolver.query(
            Orders.URI, null,
            Orders.PATIENT_UUID + " = ?", new String[] {patientUuid},
            Orders.START_MILLIS);
        List<Order> orders = new ArrayList<>();
        while (c.moveToNext()) {
            orders.add(new Order(
                Utils.getString(c, Orders.UUID),
                patientUuid,
                Utils.getString(c, Orders.PROVIDER_UUID , ""),
                Utils.getString(c, Orders.INSTRUCTIONS, ""),
                Utils.getLong(c, Orders.START_MILLIS),
                Utils.getLong(c, Orders.STOP_MILLIS)));
        }
        c.close();
        return orders;
    }

    private static String formatInstant(long millis) {
        return Utils.formatUtc8601(new DateTime(millis)).replace('T', ' ');
    }
    private static Obs loadObs(Cursor c, Locale locale, ConceptService concepts) {
        String uuid = Utils.getString(c, Observations.UUID);
        String providerUuid = Utils.getString(c, Observations.PROVIDER_UUID);
        String encounterUuid = Utils.getString(c, Observations.ENCOUNTER_UUID);
        String patientUuid = Utils.getString(c, Observations.PATIENT_UUID);
        String conceptUuid = Utils.getString(c, Observations.CONCEPT_UUID, "");
        String orderUuid = Utils.getString(c, Observations.ORDER_UUID);
        DateTime time = Utils.getDateTime(c, Observations.MILLIS);
        Datatype type = Datatype.valueOf(Utils.getString(c, Observations.TYPE));
        String value = Utils.getString(c, Observations.VALUE, "");
        String valueName = type == Datatype.CODED ? concepts.getName(value, locale)
            : type == Datatype.DATETIME ? formatInstant(Long.valueOf(value))
            : value;
        return new Obs(uuid, encounterUuid, patientUuid, providerUuid,
            conceptUuid, type, time, orderUuid, value, valueName);
    }

    /** Gets all observations for a given patient in chronological order. */
    // TODO/cleanup: Consider returning a SortedSet<Obs> or a Map<String, SortedSet<ObsPoint>>.
    public List<Obs> getObservations(String patientUuid) {
        return getObservations(patientUuid, App.getSettings().getLocale());
    }

    /** Gets all observations for a given patient in chronological order. */
    private List<Obs> getObservations(String patientUuid, Locale locale) {
        ConceptService concepts = App.getConceptService();
        List<Obs> results = new ArrayList<>();
        try (Cursor c = mContentResolver.query(
            Observations.URI, null,
            Observations.PATIENT_UUID + " = ? and "
                + Observations.VOIDED + " IS NOT 1",
            new String[] {patientUuid},
            Observations.MILLIS
        )) {
            while (c.moveToNext()) {
                results.add(loadObs(c, locale, concepts));
            }
        }
        return results;
    }

    /** Gets localized observations, filtered by optional concept and time bounds. */
    public List<Obs> getPatientObservations(String patientUuid, String[] conceptUuids, Long startMillis, Long stopMillis) {
        ConceptService concepts = App.getConceptService();
        Locale locale = App.getSettings().getLocale();
        List<String> args = new ArrayList<>();

        String query = Observations.VOIDED + " IS NOT 1";

        query += " AND " + Observations.PATIENT_UUID + " = ?";
        args.add(patientUuid);

        if (Utils.hasItems(conceptUuids)) {
            query += " AND " + Observations.CONCEPT_UUID + " IN " + makeSqlPlaceholderSet(conceptUuids);
            args.addAll(Arrays.asList(conceptUuids));
        } else {
            query += " AND " + Observations.CONCEPT_UUID + " NOT IN " + makeSqlPlaceholderSet(UUIDS_TO_OMIT);
            args.addAll(Arrays.asList(UUIDS_TO_OMIT));
        }
        if (startMillis != null) {
            query += " AND " + Observations.MILLIS + " >= ?";
            args.add("" + startMillis);
        }
        if (stopMillis != null) {
            query += " AND " + Observations.MILLIS + " < ?";
            args.add("" + stopMillis);
        }
        String[] argArray = args.toArray(new String[0]);

        String order = Observations.MILLIS + " ASC";

        List<Obs> results = new ArrayList<>();
        try (Cursor c = mContentResolver.query(Observations.URI, null, query, argArray, order)) {
            while (c.moveToNext()) {
                results.add(loadObs(c, locale, concepts));
            }
        }
        return results;
    }

    private String makeSqlPlaceholderSet(String[] items) {
        String[] placeholders = new String[items.length];
        Arrays.fill(placeholders, "?");
        return "(" + Joiner.on(", ").join(placeholders) + ")";
    }

    /** Gets the latest observation of each concept for a given patient from the app db. */
    // TODO/cleanup: Have this return a Map<String, ObsPoint>.
    public Map<String, Obs> getLatestObservations(String patientUuid) {
        ConceptService concepts = App.getConceptService();
        Locale locale = App.getSettings().getLocale();
        Map<String, Obs> result = new HashMap<>();
        for (Obs obs : getObservations(patientUuid, locale)) {
            Obs existing = result.get(obs.conceptUuid);
            if (existing == null || obs.time.isAfter(existing.time)) {
                result.put(obs.conceptUuid, obs);
            }
        }
        return result;
    }

    /** Gets the latest observation of the specified concept for all patients. */
    // TODO/cleanup: Have this return a Map<String, ObsPoint>.
    public Map<String, Obs> getLatestObservationsForConcept(String conceptUuid) {
        ConceptService concepts = App.getConceptService();
        Locale locale = App.getSettings().getLocale();
        try (Cursor c = mContentResolver.query(
            Observations.URI, null,
            Observations.VOIDED + " IS NOT 1 and "
                + Observations.CONCEPT_UUID + " = ?",
            new String[] {conceptUuid},
            Observations.MILLIS + " DESC"
        )) {
            Map<String, Obs> result = new HashMap<>();
            while (c.moveToNext()) {
                String patientUuid = Utils.getString(c, Observations.PATIENT_UUID);
                if (result.containsKey(patientUuid)) continue;
                result.put(patientUuid, loadObs(c, locale, concepts));
            }
            return result;
        }
    }

    /** Retrieves all the chart definitions from the local datastore. */
    public List<Chart> getCharts(Locale locale) {
        Map<Long, ChartSection> tileGroupsById = new HashMap<>();
        Map<Long, ChartSection> rowGroupsById = new HashMap<>();
        List<Chart> charts = new ArrayList<>();
        Chart chart = null;

        try (Cursor c = mContentResolver.query(ChartItems.URI, null, null, null, "weight")) {
            while (c.moveToNext()) {
                Long rowid = Utils.getLong(c, ChartItems.ROWID);
                Long parentRowid = Utils.getLong(c, ChartItems.PARENT_ROWID);
                String label = new Intl(Utils.getString(c, ChartItems.LABEL, "")).loc(locale);
                if (parentRowid == null) {
                    // Add a section.
                    String sectionType = Utils.getString(c, ChartItems.SECTION_TYPE);
                    if (eq(sectionType, "CHART_DIVIDER") && chart != null) {
                        // TODO(ping): Get rid of CHART_DIVIDER sections and
                        // CHART_DIVIDER items, and instead store multiple
                        // charts each in their own form.
                        if (chart.tileGroups.size() + chart.rowGroups.size() > 0) {
                            charts.add(chart);
                        }
                    } else if (eq(sectionType, "FIXED_ROW") && chart != null) {
                        ChartSection fixedGroup = new ChartSection(label);
                        chart.fixedGroups.add(fixedGroup);
                        tileGroupsById.put(rowid, fixedGroup);
                    } else if (eq(sectionType, "TILE_ROW") && chart != null) {
                        ChartSection tileGroup = new ChartSection(label);
                        chart.tileGroups.add(tileGroup);
                        tileGroupsById.put(rowid, tileGroup);
                    } else if (eq(sectionType, "GRID_SECTION") && chart != null) {
                        ChartSection rowGroup = new ChartSection(label);
                        chart.rowGroups.add(rowGroup);
                        rowGroupsById.put(rowid, rowGroup);
                    }
                } else {
                    // Add a tile to its tile group or a grid row to its row group.
                    ChartSection section = tileGroupsById.containsKey(parentRowid)
                        ? tileGroupsById.get(parentRowid) : rowGroupsById.get(parentRowid);
                    if (section != null) {
                        ChartItem item = new ChartItem(label,
                            Utils.getString(c, ChartItems.TYPE),
                            Utils.getLong(c, ChartItems.REQUIRED, 0L) > 0L,
                            Utils.getString(c, ChartItems.CONCEPT_UUIDS, "").split(","),
                            new Intl(Utils.getString(c, ChartItems.FORMAT)).loc(locale),
                            new Intl(Utils.getString(c, ChartItems.CAPTION_FORMAT)).loc(locale),
                            new Intl(Utils.getString(c, ChartItems.CSS_CLASS)).loc(locale),
                            new Intl(Utils.getString(c, ChartItems.CSS_STYLE)).loc(locale),
                            Utils.getString(c, ChartItems.SCRIPT));
                        section.items.add(item);
                    } else {
                        String type = Utils.getString(c, ChartItems.TYPE);
                        if ((type != null) && (type.equals("CHART_DIVIDER"))) {
                            chart = new Chart(label);
                        }
                    }
                }
            }
        }
        charts.add(chart);
        return charts;
    }

    public List<Form> getForms() {
        SortedSet<Form> forms = new TreeSet<>();
        try (Cursor cursor = mContentResolver.query(
            Contracts.Forms.URI, null, null, null, null)) {
            while (cursor.moveToNext()) {
                forms.add(new Form(
                    Utils.getString(cursor, Contracts.Forms.UUID),
                    Utils.getString(cursor, Contracts.Forms.NAME),
                    Utils.getString(cursor, Contracts.Forms.VERSION)));
            }
        }
        List<Form> sortedForms = new ArrayList<>();
        sortedForms.addAll(forms);
        return sortedForms;
    }
}

package org.projectbuendia.client.sync.controllers;

import android.content.ContentProviderClient;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.SyncResult;

import com.android.volley.toolbox.RequestFuture;

import org.projectbuendia.client.App;
import org.projectbuendia.client.json.JsonConcept;
import org.projectbuendia.client.json.JsonConceptsResponse;
import org.projectbuendia.client.net.OpenMrsChartServer;
import org.projectbuendia.client.net.OpenMrsServer;
import org.projectbuendia.client.providers.Contracts;
import org.projectbuendia.client.utils.Logger;

import java.util.ArrayList;
import java.util.concurrent.TimeUnit;

/** Syncs concepts.  All concepts are fetched every time. */
public class ConceptsSyncWorker implements SyncWorker {
    private static final Logger LOG = Logger.create();

    @Override public boolean sync(
        ContentResolver resolver, SyncResult result, ContentProviderClient client
    ) throws Throwable {
        OpenMrsChartServer chartServer = new OpenMrsChartServer(App.getConnectionDetails());
        RequestFuture<JsonConceptsResponse> future = RequestFuture.newFuture();
        chartServer.getConcepts(future, future); // errors handled by caller
        ArrayList<ContentValues> conceptInserts = new ArrayList<>();
        for (JsonConcept concept : future.get(OpenMrsServer.TIMEOUT_SECONDS, TimeUnit.SECONDS).results) {
            // This is safe because the ContentProvider implements insert as replace.
            ContentValues conceptInsert = new ContentValues();
            conceptInsert.put(Contracts.Concepts.UUID, concept.uuid);
            conceptInsert.put(Contracts.Concepts.XFORM_ID, concept.xform_id);
            conceptInsert.put(Contracts.Concepts.TYPE, concept.type.name());
            conceptInsert.put(Contracts.Concepts.NAME, concept.name);
            conceptInserts.add(conceptInsert);
            result.stats.numInserts++;
        }
        client.bulkInsert(Contracts.Concepts.URI,
            conceptInserts.toArray(new ContentValues[conceptInserts.size()]));
        return true;
    }

    @Override public void finalize(
        ContentResolver resolver, SyncResult result, ContentProviderClient client
    ) throws Throwable {
        App.getConceptService().invalidate();
    }
}

package org.projectbuendia.client.sync.controllers;

import android.content.ContentProviderClient;
import android.content.ContentResolver;
import android.content.SyncResult;

/**
 * A SyncWorker executes the work for a specific sync phase.  First, initialize()
 * is called; then sync() is called repeatedly until it returns true to indicate
 * completion; and finally finalize() is called.
 *
 * An exception thrown in any of the three methods aborts the entire sync,
 * skipping any remaining phases.
 */
public interface SyncWorker {
    // TODO: Replace Throwable with something more specific.

    /** Performs any initial tasks before sync() is called. */
    default void initialize(
        ContentResolver resolver, SyncResult result, ContentProviderClient client
    ) throws Throwable { }

    /** Performs a transactional chunk of sync work, returning true if all done. */
    boolean sync(
        ContentResolver resolver, SyncResult result, ContentProviderClient client
    ) throws Throwable;

    /** Performs any final tasks after all calls to sync() are done. */
    default void finalize(
        ContentResolver resolver, SyncResult result, ContentProviderClient client
    ) throws Throwable { }
}

/*
 * Copyright 2015 The Project Buendia Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at: http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distrib-
 * uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
 * OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
 * specific language governing permissions and limitations under the License.
 */

package org.projectbuendia.client.sync.controllers;

import android.content.ContentProviderClient;
import android.content.ContentProviderOperation;
import android.content.ContentResolver;
import android.content.SyncResult;
import android.net.Uri;
import android.os.RemoteException;

import org.projectbuendia.client.App;
import org.projectbuendia.client.json.JsonObservation;
import org.projectbuendia.models.tasks.DenormalizeObsTask;
import org.projectbuendia.client.providers.Contracts;
import org.projectbuendia.client.providers.Contracts.Observations;
import org.projectbuendia.client.utils.Logger;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

/**
 * Handles syncing observations. Uses an incremental sync mechanism - see
 * {@link IncrementalSyncWorker} for details.
 */
public class ObservationsSyncWorker extends IncrementalSyncWorker<JsonObservation> {
    private static final Logger LOG = Logger.create();
    private Set<String> patientUuidsToUpdate = new HashSet<>();

    public ObservationsSyncWorker() {
        super("observations", Contracts.Table.OBSERVATIONS, JsonObservation.class);
    }

    @Override public void initialize(
        ContentResolver resolver, SyncResult result, ContentProviderClient client) {
        patientUuidsToUpdate.clear();
    }

    @Override
    protected ArrayList<ContentProviderOperation> getUpdateOps(
            JsonObservation[] observations, SyncResult syncResult) {
        int numInserts = 0;
        int numDeletes = 0;
        ArrayList<ContentProviderOperation> ops = new ArrayList<>();
        for (JsonObservation observation : observations) {
            if (observation.voided) {
                Uri uri = Observations.URI.buildUpon().appendPath(observation.uuid).build();
                ops.add(ContentProviderOperation.newDelete(uri).build());
                numDeletes++;
            } else {
                ops.add(ContentProviderOperation.newInsert(Observations.URI)
                        .withValues(observation.toContentValues()).build());
                numInserts++;
            }
            if (DenormalizeObsTask.needsDenormalization(observation.concept_uuid)) {
                patientUuidsToUpdate.add(observation.patient_uuid);
            }
        }
        LOG.d("Observations: %d inserts, %d deletes", numInserts, numDeletes);
        syncResult.stats.numInserts += numInserts;
        syncResult.stats.numDeletes += numDeletes;
        return ops;
    }

    @Override public void finalize(
        ContentResolver resolver, SyncResult result, ContentProviderClient client
    ) throws RemoteException {
        // Remove all temporary observations now we have the real ones
        client.delete(Observations.URI, Observations.UUID + " IS NULL", new String[0]);
        for (String uuid : patientUuidsToUpdate) {
            App.getModel().denormalizeObservations(App.getCrudEventBus(), uuid);
        }
    }
}

/*
 * Copyright 2015 The Project Buendia Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at: http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distrib-
 * uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
 * OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
 * specific language governing permissions and limitations under the License.
 */

package org.projectbuendia.client.sync.controllers;

import android.content.ContentProviderClient;
import android.content.ContentProviderOperation;
import android.content.ContentResolver;
import android.content.SyncResult;
import android.net.Uri;
import android.support.annotation.Nullable;

import com.android.volley.DefaultRetryPolicy;
import com.android.volley.Response;
import com.android.volley.toolbox.RequestFuture;

import org.projectbuendia.client.App;
import org.projectbuendia.client.json.IncrementalSyncResponse;
import org.projectbuendia.client.json.Serializers;
import org.projectbuendia.client.net.Common;
import org.projectbuendia.client.net.GsonRequest;
import org.projectbuendia.client.net.OpenMrsConnectionDetails;
import org.projectbuendia.client.net.OpenMrsServer;
import org.projectbuendia.client.providers.Contracts;
import org.projectbuendia.client.sync.BuendiaSyncEngine;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.concurrent.TimeUnit;

import static org.projectbuendia.client.net.OpenMrsServer.wrapErrorListener;

/**
 * Implements the basic logic for an incremental sync phase.
 * <p>
 * To implement an incremental sync phase, create a subclass, supply the appropriate arguments to
 * {@link IncrementalSyncWorker}'s constructor from the subclasses' public, no-arg
 * constructor, and then implement the {@link #getUpdateOps(Object[], SyncResult)} method.
 * <p>
 * Note: you may also wish to undertake an action at the start and end of the sync phase - hooks are
 * provided for this. See {@link #beforeSyncStarted(ContentResolver, SyncResult,
 * ContentProviderClient)} and {@link #afterSyncFinished(ContentResolver, SyncResult,
 * ContentProviderClient)}.
 */
public abstract class IncrementalSyncWorker<T> implements SyncWorker {

    private static final Logger LOG = Logger.create();

    private final String resourceType;
    private final Contracts.Table dbTable;
    private final Class<T> clazz;

    /**
     * Instantiate a new IncrementalSyncWorker. This is designed to be called from a no-arg
     * constructor of subclasses.
     *
     * @param resourceType The path name appended to {@link OpenMrsConnectionDetails#getBuendiaApiUrl()}
     *                     to fetch the desired resource.
     * @param dbTable      The database table in which to store the fetched data.
     * @param clazz        The Class object for the JSON response model.
     */
    protected IncrementalSyncWorker(String resourceType, Contracts.Table dbTable, Class<T> clazz) {
        this.resourceType = resourceType;
        this.dbTable = dbTable;
        this.clazz = clazz;
    }

    @Override public final boolean sync(ContentResolver contentResolver, SyncResult syncResult,
        ContentProviderClient providerClient) throws Throwable {

        String bookmark = BuendiaSyncEngine.getBookmark(providerClient, dbTable);
        LOG.d("%s: Using bookmark %s", dbTable, Utils.repr(bookmark));

        RequestFuture<IncrementalSyncResponse<T>> future = RequestFuture.newFuture();
        createRequest(bookmark, future, future);
        IncrementalSyncResponse<T> response = future.get(OpenMrsServer.TIMEOUT_SECONDS, TimeUnit.SECONDS);
        ArrayList<ContentProviderOperation> ops = getUpdateOps(response.results, syncResult);
        providerClient.applyBatch(ops);
        LOG.i("%s: Applied %d db ops", dbTable, ops.size());
        bookmark = response.bookmark;

        LOG.d("%s: Saving bookmark %s", dbTable, Utils.repr(bookmark));
        BuendiaSyncEngine.setBookmark(providerClient, dbTable, response.bookmark);
        return !response.more;
    }

    // Mandatory callback

    /** Produces a list of the operations needed to bring the local database in sync with the server. */
    protected abstract ArrayList<ContentProviderOperation> getUpdateOps(T[] list, SyncResult result);


    private void createRequest(@Nullable String bookmark,
        Response.Listener<IncrementalSyncResponse<T>> successListener,
        final Response.ErrorListener errorListener) {
        if (bookmark == null) {
            bookmark = "0000-00-00T00:00:00.000Z";
        }
        OpenMrsConnectionDetails connectionDetails = App.getConnectionDetails();
        Uri uri = Uri.parse(connectionDetails.getBuendiaApiUrl())
            .buildUpon()
            .appendPath(resourceType)
            .encodedQuery("since=" + bookmark)
            .build();
        GsonRequest<IncrementalSyncResponse<T>> request = new GsonRequest<>(
            uri.toString(),
            new IncrementalSyncResponseType(clazz),
            connectionDetails.addAuthHeader(new HashMap<>()),
            successListener,
            wrapErrorListener(errorListener));
        Serializers.registerTo(request.getGson());
        request.setRetryPolicy(new DefaultRetryPolicy(Common.REQUEST_TIMEOUT_MS_MEDIUM, 1, 1f));
        connectionDetails.getVolley().addToRequestQueue(request);
    }

    private static class IncrementalSyncResponseType implements ParameterizedType {

        private final Type[] typeArgs;

        public IncrementalSyncResponseType(Type innerType) {
            typeArgs = new Type[] { innerType };
        }

        @Override
        public Type[] getActualTypeArguments() {
            return typeArgs;
        }

        @Override
        public Type getOwnerType() {
            return null;
        }

        @Override
        public Type getRawType() {
            return IncrementalSyncResponse.class;
        }
    }
}

package org.projectbuendia.client.sync.controllers;

import android.content.ContentProviderClient;
import android.content.ContentProviderOperation;
import android.content.ContentResolver;
import android.content.SyncResult;

import com.android.volley.toolbox.RequestFuture;
import com.google.common.base.Joiner;

import org.projectbuendia.client.App;
import org.projectbuendia.client.json.JsonChart;
import org.projectbuendia.client.json.JsonChartItem;
import org.projectbuendia.client.json.JsonChartSection;
import org.projectbuendia.client.json.JsonChartsResponse;
import org.projectbuendia.client.net.OpenMrsChartServer;
import org.projectbuendia.client.net.OpenMrsServer;
import org.projectbuendia.client.providers.Contracts;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.util.ArrayList;

import static java.util.concurrent.TimeUnit.SECONDS;

/**
 * Handles syncing charts. Always fetches everything. This is okay because the full set of chart
 * layouts is usually fairly small in size.
 */
public class ChartsSyncWorker implements SyncWorker {
    private static final Logger LOG = Logger.create();

    @Override public boolean sync(
        ContentResolver resolver, SyncResult result, ContentProviderClient client
    ) throws Throwable {
        OpenMrsChartServer chartServer = new OpenMrsChartServer(App.getConnectionDetails());
        RequestFuture<JsonChartsResponse> future = RequestFuture.newFuture();
        // errors handled by caller
        chartServer.getChartStructures(future, future);
        final JsonChartsResponse response = future.get(OpenMrsServer.TIMEOUT_SECONDS, SECONDS);

        // When we do a chart update, delete everything first, then insert all the new rows.
        result.stats.numDeletes += client.delete(Contracts.ChartItems.URI, null, null);
        client.applyBatch(getInsertOps(response, result));

        return true;
    }

    /** Converts a JsonChart response into appropriate inserts in the chart table. */
    private static ArrayList<ContentProviderOperation> getInsertOps(
            JsonChartsResponse response, SyncResult result) {

        ArrayList<ContentProviderOperation> ops = new ArrayList<>();
        int nextId = 1;
        int nextWeight = 1;
        for (JsonChart chart : response.results) {
            for (JsonChartSection section : chart.sections) {
                int parentId = nextId;
                ops.add(ContentProviderOperation.newInsert(Contracts.ChartItems.URI)
                    .withValue("rowid", nextId++)
                    .withValue(Contracts.ChartItems.CHART_UUID, chart.uuid)
                    .withValue(Contracts.ChartItems.WEIGHT, nextWeight++)
                    .withValue(Contracts.ChartItems.SECTION_TYPE, section.type != null ? section.type.name() : null)
                    .withValue(Contracts.ChartItems.LABEL, section.label)
                    .build());
                result.stats.numInserts++;

                for (JsonChartItem item : section.items) {
                    Object[] conceptUuids = new Object[item.concepts.length];
                    for (int i = 0; i < conceptUuids.length; i++) {
                        conceptUuids[i] = Utils.expandUuid(item.concepts[i]);
                    }
                    ops.add(ContentProviderOperation.newInsert(Contracts.ChartItems.URI)
                        .withValue("rowid", nextId++)
                        .withValue(Contracts.ChartItems.CHART_UUID, chart.uuid)
                        .withValue(Contracts.ChartItems.WEIGHT, nextWeight++)
                        .withValue(Contracts.ChartItems.PARENT_ROWID, parentId)
                        .withValue(Contracts.ChartItems.LABEL, item.label)
                        .withValue(Contracts.ChartItems.TYPE, item.type)
                        .withValue(Contracts.ChartItems.REQUIRED, item.required ? 1 : 0)
                        .withValue(Contracts.ChartItems.CONCEPT_UUIDS, Joiner.on(",").join(conceptUuids))
                        .withValue(Contracts.ChartItems.FORMAT, item.format)
                        .withValue(Contracts.ChartItems.CAPTION_FORMAT, item.caption_format)
                        .withValue(Contracts.ChartItems.CSS_CLASS, item.css_class)
                        .withValue(Contracts.ChartItems.CSS_STYLE, item.css_style)
                        .withValue(Contracts.ChartItems.SCRIPT, item.script)
                        .build());
                    result.stats.numInserts++;
                }
            }
        }
        return ops;
    }
}

package org.projectbuendia.client.sync.controllers;

import android.content.ContentProviderClient;
import android.content.ContentResolver;
import android.content.OperationApplicationException;
import android.content.SyncResult;
import android.os.RemoteException;

import org.projectbuendia.client.App;
import org.projectbuendia.client.user.UserManager;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

/**
 * Handles syncing users. This logic always fetches all users, which is okay because the set of
 * users is fairly small.
 */
public class UsersSyncWorker implements SyncWorker {
    @Override public boolean sync(
        ContentResolver resolver, SyncResult result, ContentProviderClient client
    ) throws InterruptedException, ExecutionException, TimeoutException,
        UserManager.UserSyncException, RemoteException, OperationApplicationException {
        App.getUserManager().syncKnownUsersSynchronously();
        return true;
    }
}

package org.projectbuendia.client.sync.controllers;

import android.content.ContentProviderClient;
import android.content.ContentProviderOperation;
import android.content.ContentResolver;
import android.content.SyncResult;
import android.net.Uri;

import org.projectbuendia.client.json.JsonOrder;
import org.projectbuendia.client.providers.Contracts;
import org.projectbuendia.client.providers.Contracts.Orders;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.util.ArrayList;

/**
 * Handles syncing orders. Currently we always fetch all orders. This won't scale; incremental
 * fetch would help a lot.
 */
public class OrdersSyncWorker extends IncrementalSyncWorker<JsonOrder> {
    private static final Logger LOG = Logger.create();

    public OrdersSyncWorker() {
        super("orders", Contracts.Table.ORDERS, JsonOrder.class);
    }

    @Override
    protected ArrayList<ContentProviderOperation> getUpdateOps(
            JsonOrder[] orders, SyncResult syncResult) {
        int numInserts = 0;
        int numDeletes = 0;
        ArrayList<ContentProviderOperation> ops = new ArrayList<>(orders.length);
        for (JsonOrder order : orders) {
            if (order.voided) {
                ops.add(deleteOrderWithUuid(order.uuid));
                numDeletes++;
            } else {
                ops.add(insertOrReplaceOrder(order));
                numInserts++;
            }
        }
        LOG.d("Orders: %d inserts, %d deletes", numInserts, numDeletes);
        syncResult.stats.numInserts += numInserts;
        syncResult.stats.numDeletes += numDeletes;
        return ops;
    }

    private static ContentProviderOperation insertOrReplaceOrder(JsonOrder order) {
        return ContentProviderOperation.newInsert(Orders.URI)
                .withValue(Orders.UUID, order.uuid)
                .withValue(Orders.PATIENT_UUID, order.patient_uuid)
                .withValue(Orders.PROVIDER_UUID, order.provider_uuid)
                .withValue(Orders.INSTRUCTIONS, order.instructions)
                .withValue(Orders.START_MILLIS, Utils.toNullableMillis(order.start_time))
                .withValue(Orders.STOP_MILLIS, Utils.toNullableMillis(order.stop_time))
                .build();
    }

    private static ContentProviderOperation deleteOrderWithUuid(String uuid) {
        Uri uri = Orders.URI.buildUpon().appendPath(uuid).build();
        return ContentProviderOperation.newDelete(uri).build();
    }

    @Override public void finalize(
        ContentResolver resolver, SyncResult result, ContentProviderClient client) {
        if (result.stats.numInserts + result.stats.numDeletes > 0) {
            resolver.notifyChange(Orders.URI, null, false);
        }
    }
}

package org.projectbuendia.client.sync.controllers;

import android.content.ContentProviderClient;
import android.content.ContentProviderOperation;
import android.content.ContentResolver;
import android.content.SyncResult;
import android.database.Cursor;
import android.net.Uri;

import com.android.volley.toolbox.RequestFuture;

import org.projectbuendia.client.App;
import org.projectbuendia.client.json.JsonLocation;
import org.projectbuendia.client.net.OpenMrsServer;
import org.projectbuendia.client.providers.Contracts.Locations;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import static org.projectbuendia.client.utils.Utils.eq;

/**
 * Handles syncing locations. All locations are always fetched, which is ok because the full set of
 * locations is fairly smaller.
 */
public class LocationsSyncWorker implements SyncWorker {
    private static final Logger LOG = Logger.create();

    @Override public boolean sync(
        ContentResolver resolver, SyncResult result, ContentProviderClient client
    ) throws Throwable {
        ArrayList<ContentProviderOperation> ops = getLocationUpdateOps(result);
        client.applyBatch(ops);
        if (ops.size() > 0) {
            resolver.notifyChange(Locations.URI, null, false);
        }
        return true;
    }

    /**
     * Requests locations from the server and transforms the response into an {@link ArrayList} of
     * {@link ContentProviderOperation}s for updating the database.
     */
    private static ArrayList<ContentProviderOperation> getLocationUpdateOps(SyncResult syncResult)
            throws ExecutionException, InterruptedException, TimeoutException {
        final ContentResolver contentResolver = App.getResolver();

        final String[] projection = new String[] {
            Locations.UUID,
            Locations.NAME,
            Locations.PARENT_UUID
        };

        LOG.d("Before network call");
        RequestFuture<List<JsonLocation>> future = RequestFuture.newFuture();
        App.getServer().listLocations(future, future);

        List<JsonLocation> locations = future.get(OpenMrsServer.TIMEOUT_SECONDS, TimeUnit.SECONDS);
        LOG.d("After network call");
        ArrayList<ContentProviderOperation> batch = new ArrayList<>();

        Map<String, JsonLocation> locationsByUuid = new HashMap<>();
        for (JsonLocation location : locations) {
            locationsByUuid.put(location.uuid, location);
        }

        // Iterate through the locations currently in the local database.
        Uri uri = Locations.URI;
        Cursor c = contentResolver.query(uri, projection, null, null, null);
        assert c != null;
        LOG.i("Examining locations: %d local, %d from server", c.getCount(), locations.size());

        while (c.moveToNext()) {
            syncResult.stats.numEntries++;

            String uuid = Utils.getString(c, Locations.UUID);
            String name = Utils.getString(c, Locations.NAME);
            String parentUuid = Utils.getString(c, Locations.PARENT_UUID);

            JsonLocation location = locationsByUuid.get(uuid);
            if (location != null) {
                // Update locations from the server that also exist locally.
                if (!eq(location.name, name) || !eq(location.parent_uuid, parentUuid)) {
                    LOG.i("  - will update location " + uuid);
                    Uri existingUri = uri.buildUpon().appendPath(String.valueOf(uuid)).build();
                    batch.add(ContentProviderOperation.newUpdate(existingUri)
                        .withValue(Locations.UUID, uuid)
                        .withValue(Locations.NAME, location.name)
                        .withValue(Locations.PARENT_UUID, location.parent_uuid)
                        .build());
                    syncResult.stats.numUpdates++;
                }
                locationsByUuid.remove(uuid);  // remove to prevent insertion later

            } else {
                // Delete locations that exist locally but not on the server.
                LOG.i("  - will delete location " + uuid);
                Uri deleteUri = uri.buildUpon().appendPath(uuid).build();
                batch.add(ContentProviderOperation.newDelete(deleteUri).build());
                syncResult.stats.numDeletes++;
            }
        }
        c.close();

        // Insert all the locations we received that don't exist locally.
        for (JsonLocation location : locationsByUuid.values()) {
            LOG.i("  - will insert location " + location.uuid);
            batch.add(ContentProviderOperation.newInsert(Locations.URI)
                .withValue(Locations.UUID, location.uuid)
                .withValue(Locations.NAME, location.name)
                .withValue(Locations.PARENT_UUID, location.parent_uuid)
                .build());
            syncResult.stats.numInserts++;
        }

        return batch;
    }
}

package org.projectbuendia.client.sync.controllers;

import android.content.ContentProviderClient;
import android.content.ContentProviderOperation;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.SyncResult;
import android.database.Cursor;
import android.net.Uri;

import com.android.volley.toolbox.RequestFuture;

import org.projectbuendia.client.App;
import org.projectbuendia.client.json.JsonForm;
import org.projectbuendia.models.Form;
import org.projectbuendia.client.net.OpenMrsServer;
import org.projectbuendia.client.providers.Contracts;
import org.projectbuendia.client.ui.OdkActivityLauncher;
import org.projectbuendia.client.utils.Logger;
import org.projectbuendia.client.utils.Utils;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * Handles syncing forms. All forms are always fetched, which is okay because there are only a few
 * forms; usually less than 10.
 */
public class FormsSyncWorker implements SyncWorker {
    private static final Logger LOG = Logger.create();
    private static boolean isDisabled = false;
    private static final Object lock = new Object();

    @Override public boolean sync(
        ContentResolver resolver, SyncResult result, ContentProviderClient client
    ) throws Throwable {
        synchronized (lock) {
            if (isDisabled) {
                LOG.w("Form sync is temporarily disabled; skipping this phase");
                return true;
            }

            ArrayList<ContentProviderOperation> ops = new ArrayList<>();
            ops.addAll(getFormUpdateOps(result));
            client.applyBatch(ops);
            LOG.i("Finished updating forms (" + ops.size() + " db ops)");
            if (ops.size() > 0) resolver.notifyChange(Contracts.Forms.URI, null, false);

            // TODO(ping): Make this next step synchronous; it should run on the
            // sync thread like everything else so it doesn't overlap with other
            // operations, and so that it can be suspended during form entry.
            OdkActivityLauncher.fetchAndCacheAllXforms();
            return true;
        }
    }

    public static void setDisabled(boolean newValue) {
        LOG.i("Received a request to %s form sync", newValue ? "disable" : "enable");
        synchronized (lock) {
            isDisabled = newValue;
            LOG.w("Form sync is now %s", isDisabled ? "disabled" : "enabled");
        }
    }

    private static List<ContentProviderOperation> getFormUpdateOps(SyncResult syncResult)
            throws ExecutionException, InterruptedException, TimeoutException {
        LOG.i("Listing all forms on server");
        RequestFuture<List<JsonForm>> future = RequestFuture.newFuture();
        App.getServer().listForms(future, future);
        Map<String, ContentValues> cvs = new HashMap<>();
        for (JsonForm form : future.get(OpenMrsServer.TIMEOUT_SECONDS, TimeUnit.SECONDS)) {
            cvs.put(form.id, Form.fromJson(form).toContentValues());
        }

        ArrayList<ContentProviderOperation> ops = new ArrayList<>();
        final ContentResolver resolver = App.getResolver();
        Cursor c = resolver.query(Contracts.Forms.URI, new String[] {Contracts.Forms.UUID},
                null, null, null);
        LOG.i("Examining forms: " + c.getCount() + " local, " + cvs.size() + " from server");
        try {
            while (c.moveToNext()) {
                String uuid = Utils.getString(c, Contracts.Forms.UUID);
                Uri uri = Contracts.Forms.URI.buildUpon().appendPath(uuid).build();
                LOG.i("  - will delete form " + uuid);
                ops.add(ContentProviderOperation.newDelete(uri).build());
            }
        } finally {
            c.close();
        }

        for (ContentValues values : cvs.values()) {  // server has a new record
            LOG.i("  - will insert form " + values.getAsString(Contracts.Forms.UUID));
            ops.add(ContentProviderOperation.newInsert(Contracts.Forms.URI).withValues(values).build());
            syncResult.stats.numInserts++;
        }
        return ops;
    }
}

/*
 * Copyright 2015 The Project Buendia Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at: http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distrib-
 * uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
 * OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
 * specific language governing permissions and limitations under the License.
 */

package org.projectbuendia.client.sync.controllers;

import android.content.ContentProviderClient;
import android.content.ContentProviderOperation;
import android.content.ContentResolver;
import android.content.SyncResult;
import android.net.Uri;

import org.projectbuendia.client.App;
import org.projectbuendia.client.json.JsonPatient;
import org.projectbuendia.models.Patient;
import org.projectbuendia.client.providers.Contracts;
import org.projectbuendia.client.utils.Logger;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

/**
 * Handles syncing patients. Uses an incremental sync mechanism - see
 * {@link IncrementalSyncWorker} for details.
 */
public class PatientsSyncWorker extends IncrementalSyncWorker<JsonPatient> {
    private static final Logger LOG = Logger.create();
    private Set<String> patientUuidsToUpdate = new HashSet<>();

    public PatientsSyncWorker() {
        super("patients", Contracts.Table.PATIENTS, JsonPatient.class);
    }

    @Override public void initialize(
        ContentResolver resolver, SyncResult result, ContentProviderClient client) {
        patientUuidsToUpdate.clear();
    }

    @Override protected ArrayList<ContentProviderOperation> getUpdateOps(
        JsonPatient[] patients, SyncResult syncResult) {
        ArrayList<ContentProviderOperation> ops = new ArrayList<>();
        int numInserts = 0;
        int numDeletes = 0;
        for (JsonPatient patient : patients) {
            if (patient.voided) {
                numDeletes++;
                ops.add(makeDeleteOpForPatientUuid(patient.uuid));
            } else {
                numInserts++;
                ops.add(makeInsertOpForPatient(patient));
            }
            patientUuidsToUpdate.add(patient.uuid);
        }
        LOG.d("Patients: %d inserts, %d deletes", numInserts, numDeletes);
        syncResult.stats.numInserts += numInserts;
        syncResult.stats.numDeletes += numDeletes;
        return ops;
    }

    private static ContentProviderOperation makeInsertOpForPatient(JsonPatient patient) {
        return ContentProviderOperation.newInsert(Contracts.Patients.URI)
                .withValues(Patient.fromJson(patient).toContentValues()).build();
    }

    private static ContentProviderOperation makeDeleteOpForPatientUuid(String uuid) {
        Uri uri = Contracts.Patients.URI.buildUpon().appendPath(uuid).build();
        return ContentProviderOperation.newDelete(uri).build();
    }

    @Override public void finalize(
        ContentResolver resolver, SyncResult result, ContentProviderClient client) {
        for (String uuid : patientUuidsToUpdate) {
            App.getModel().denormalizeObservations(App.getCrudEventBus(), uuid);
        }
        if (result.stats.numInserts + result.stats.numDeletes > 0) {
            resolver.notifyChange(Contracts.Patients.URI, null, false);
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events;

/** An event bus event indicating that submitting an Xform succeeded. */
public class SubmitXformSucceededEvent {
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events;

/** An event bus event indicating that fetching an Xform succeeded. */
public class FetchXformSucceededEvent {
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events;

import org.projectbuendia.client.events.data.TypedCursorLoadedEvent;

import de.greenrobot.event.EventBus;
import de.greenrobot.event.NoSubscriberEvent;

/** An {@link EventBus} wrapper to be used by asynchronous CRUD operations on the data model. */
public final class DefaultCrudEventBus implements CrudEventBus {
    private final EventBus mBus;

    /** Creates a new {@link DefaultCrudEventBus} that wraps the specified {@link EventBus}. */
    DefaultCrudEventBus(EventBus bus) {
        mBus = bus;
        bus.register(this);
    }

    @Override public void register(Object subscriber) {
        mBus.register(subscriber);
    }

    @Override public void unregister(Object subscriber) {
        mBus.unregister(subscriber);
    }

    @Override public void post(Object event) {
        mBus.post(event);
    }

    @SuppressWarnings("unused") // Called by reflection from event bus.
    public void onEvent(NoSubscriberEvent event) {
        if (event.originalEvent instanceof TypedCursorLoadedEvent<?>) {
            // If no subscribers were registered for a DataFetchedEvent, then the TypedCursor in
            // the event won't be managed by anyone else; therefore, we close it ourselves.
            ((TypedCursorLoadedEvent<?>) event.originalEvent).cursor.close();
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events;

import org.projectbuendia.client.updater.DownloadedUpdateInfo;

/**
 * A sticky event that indicates that an update has been downloaded and is ready to be
 * installed.  An update is considered suitable for installation if it has a version number
 * higher than the currently running app and at least as high as the highest version
 * available on the package server.
 */
public class UpdateReadyToInstallEvent {

    public final DownloadedUpdateInfo updateInfo;

    public UpdateReadyToInstallEvent(DownloadedUpdateInfo downloadedUpdateInfo) {
        updateInfo = downloadedUpdateInfo;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events;

import android.support.annotation.Nullable;

/** An event bus event indicating that submitting an Xform failed. */
public class SubmitXformFailedEvent {
    public final Reason reason;
    @Nullable
    public final Exception exception;

    public enum Reason {
        UNKNOWN,
        SERVER_AUTH,
        SERVER_BAD_ENDPOINT,
        SERVER_TIMEOUT,
        SERVER_ERROR,
        CLIENT_ERROR
    }

    public SubmitXformFailedEvent(Reason reason, @Nullable Exception exception) {
        this.reason = reason;
        this.exception = exception;
    }

    public SubmitXformFailedEvent(Reason reason) {
        this.reason = reason;
        this.exception = null;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events;

import android.support.annotation.Nullable;

/** An event bus event indicating that fetching an Xform failed. */
public class FetchXformFailedEvent {
    public final Reason reason;
    @Nullable public final Exception exception;

    public enum Reason {
        UNKNOWN,
        NO_FORMS_FOUND,
        SERVER_AUTH,
        SERVER_BAD_ENDPOINT,
        SERVER_FAILED_TO_FETCH,
        SERVER_UNKNOWN
    }

    public FetchXformFailedEvent(Reason reason, @Nullable Exception exception) {
        this.reason = reason;
        this.exception = exception;
    }

    public FetchXformFailedEvent(Reason reason) {
        this.reason = reason;
        this.exception = null;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events;

import org.projectbuendia.client.updater.AvailableUpdateInfo;

/**
 * A sticky event indicating that an .apk update is available on the server
 * with a version number higher than the currently running version of the app.
 */
public final class UpdateAvailableEvent {

    public final AvailableUpdateInfo updateInfo;

    public UpdateAvailableEvent(AvailableUpdateInfo updateInfo) {
        this.updateInfo = updateInfo;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events;

/**
 * An event bus event indicating that a check for updates has completed and no update
 * is available.
 */
public final class UpdateNotAvailableEvent {
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events;

/**
 * An interface for an event bus that handles CRUD operations on the data model.
 * <p/>
 * <p>In addition to providing support for subscribing to and posting events, this interface
 * provides a mechanism to clean up after itself if all registered subscribers are unregistered or
 * if an event is posted for which there are no listeners.
 */
public interface CrudEventBus {
    void register(Object subscriber);

    void unregister(Object subscriber);

    void post(Object event);
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events;

import org.projectbuendia.client.inject.Qualifiers;
import org.projectbuendia.client.utils.EventBusInterface;
import org.projectbuendia.client.utils.EventBusWrapper;

import javax.inject.Singleton;

import dagger.Module;
import dagger.Provides;
import de.greenrobot.event.EventBus;
import de.greenrobot.event.EventBusBuilder;

/** A Dagger module that provides bindings for events. */
@Module(
    complete = false,
    library = true)
public class EventsModule {

    @Provides
    @Singleton EventBus provideEventBus() {
        return EventBus.getDefault();
    }

    @Provides
    @Singleton EventBusInterface provideEventBusInterface(EventBus eventBus) {
        return new EventBusWrapper(eventBus);
    }

    @Provides
    @Singleton
    @Qualifiers.CrudEventBusBuilder
    EventBusBuilder provideCrudEventBusBuilder() {
        return EventBus.builder();
    }

    @Provides
    @Singleton CrudEventBus provideCrudEventBus(
        @Qualifiers.CrudEventBusBuilder EventBusBuilder crudEventBusBuilder) {
        return new DefaultCrudEventBus(crudEventBusBuilder.build());
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.user;

import com.google.common.collect.ImmutableSet;

import org.projectbuendia.client.json.JsonUser;

/** An event bus event indicating that a user was successfully added, both locally and on the server. */
public class UserAddedEvent extends KnownUsersChangedEvent {

    public final JsonUser addedUser;

    public UserAddedEvent(JsonUser addedUser) {
        super(ImmutableSet.of(addedUser), ImmutableSet.of());
        this.addedUser = addedUser;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.user;

import org.projectbuendia.client.json.JsonUser;

/** An event bus event that indicates that the active user has been unset. */
public class ActiveUserUnsetEvent {

    /**
     * Indicates that the reason is unknown.
     * <p/>
     * <p>This value should not generally be used.
     */
    public static final int REASON_UNKNOWN = 0;

    /** Indicates that the active user was unset because the unset method was invoked. */
    public static final int REASON_UNSET_INVOKED = 1;

    /** Indicates that the active user was unset because the active user was deleted from the server. */
    public static final int REASON_USER_DELETED = 2;

    /**
     * The previous active user. If the reason why the active user was unset is because the user was
     * deleted from the server, this object will no longer be known to
     * {@link org.projectbuendia.client.user.UserManager}.
     */
    public final JsonUser previousActiveUser;

    /** The reason why the active user was unset. */
    public final int reason;

    /**
     * Creates a new {@link ActiveUserUnsetEvent}.
     * @param previousActiveUser the previous active user
     * @param reason             the reason why the active user was unset
     */
    public ActiveUserUnsetEvent(JsonUser previousActiveUser, int reason) {
        this.previousActiveUser = previousActiveUser;
        this.reason = reason;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.user;

import com.google.common.collect.ImmutableSet;

import org.projectbuendia.client.json.JsonUser;

/** Indicates that a list of users has been fetched from the server. */
public final class UsersFetchedEvent {
    public final String server;
    public final String username;
    public final String password;
    public final ImmutableSet<JsonUser> users;

    public UsersFetchedEvent(String server, String username, String password, ImmutableSet<JsonUser> users) {
        this.server = server;
        this.username = username;
        this.password = password;
        this.users = users;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.user;

/** An event bus event indicating that the set of known users failed to be synced from the server. */
public class KnownUsersSyncFailedEvent {

    public static final int REASON_UNKNOWN = 0;

    public final int reason;

    public KnownUsersSyncFailedEvent(int reason) {
        this.reason = reason;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.user;

import com.google.common.collect.ImmutableSet;

import org.projectbuendia.client.json.JsonUser;

import java.util.Set;

/** An event bus event indicating that the set of known users has changed. */
public class KnownUsersChangedEvent {

    public final ImmutableSet<JsonUser> addedUsers;
    public final ImmutableSet<JsonUser> deletedUsers;

    public KnownUsersChangedEvent(Set<JsonUser> addedUsers, Set<JsonUser> deletedUsers) {
        this.addedUsers = ImmutableSet.copyOf(addedUsers);
        this.deletedUsers = ImmutableSet.copyOf(deletedUsers);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.user;

import com.google.common.collect.ImmutableSet;

import org.projectbuendia.client.json.JsonUser;

import java.util.Set;

/** An event bus event indicating that the set of known users has been loaded from local cache. */
public final class KnownUsersLoadedEvent {

    public final ImmutableSet<JsonUser> knownUsers;

    public KnownUsersLoadedEvent(Set<JsonUser> knownUsers) {
        this.knownUsers = ImmutableSet.copyOf(knownUsers);
    }

    @Override public boolean equals(Object obj) {
        if (!(obj instanceof KnownUsersLoadedEvent)) {
            return false;
        }

        KnownUsersLoadedEvent other = (KnownUsersLoadedEvent) obj;
        return knownUsers.equals(other.knownUsers);
    }

    @Override public int hashCode() {
        return knownUsers.hashCode();
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.user;

import org.projectbuendia.client.json.JsonUser;

/** An event bus event that indicates that the active user has been set. */
public class ActiveUserSetEvent {

    /** The previous active user. */
    public final JsonUser previousActiveUser;

    /** The current active user. */
    public final JsonUser activeUser;

    /** Creates a new {@link ActiveUserSetEvent}. */
    public ActiveUserSetEvent(JsonUser previousActiveUser, JsonUser activeUser) {
        this.previousActiveUser = previousActiveUser;
        this.activeUser = activeUser;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.user;

/** Indicates that the list of users could not be fetched from the server. */
public final class FetchUsersTaskFailedEvent {
    public FetchUsersTaskFailedEvent() { }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.user;

import org.projectbuendia.client.json.JsonUser;

import java.util.Set;

/** An event bus event indicating that the set of known users was synced from the server. */
public class KnownUsersSyncedEvent extends KnownUsersChangedEvent {

    public KnownUsersSyncedEvent(Set<JsonUser> addedUsers, Set<JsonUser> deletedUsers) {
        super(addedUsers, deletedUsers);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.user;

/** An event bus event indicating that the set of known users failed to be loaded from local cache. */
public final class KnownUsersLoadFailedEvent {

    public static final int REASON_UNKNOWN = 0;
    public static final int REASON_CANCELLED = 2;

    public final int reason;

    public KnownUsersLoadFailedEvent(int reason) {
        this.reason = reason;
    }

    @Override public boolean equals(Object obj) {
        if (!(obj instanceof KnownUsersLoadFailedEvent)) {
            return false;
        }

        KnownUsersLoadFailedEvent other = (KnownUsersLoadFailedEvent) obj;
        return other.reason == reason;
    }

    @Override public int hashCode() {
        return reason;
    }

    @Override public String toString() {
        return KnownUsersLoadFailedEvent.class.getSimpleName() + "(" + reason + ")";
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.user;

import org.projectbuendia.client.json.JsonNewUser;

/** An event bus event indicating that a user could not be successfully added. */
public class UserAddFailedEvent {

    public static final int REASON_UNKNOWN = 0;
    public static final int REASON_INVALID_USER = 1;
    public static final int REASON_USER_EXISTS_LOCALLY = 2;
    public static final int REASON_USER_EXISTS_ON_SERVER = 3;
    public static final int REASON_CONNECTION_ERROR = 4;

    public final JsonNewUser user;
    public final int reason;

    public UserAddFailedEvent(JsonNewUser user, int reason) {
        this.user = user;
        this.reason = reason;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.diagnostics;

import com.google.common.collect.ImmutableSet;

import org.projectbuendia.client.diagnostics.HealthIssue;
import org.projectbuendia.client.diagnostics.TroubleshootingAction;

/** An event bus event indicating that the set of troubleshooting actions required has changed. */
public class TroubleshootingActionsChangedEvent {

    public final ImmutableSet<TroubleshootingAction> actions;
    public final HealthIssue solvedIssue;

    public TroubleshootingActionsChangedEvent(ImmutableSet<TroubleshootingAction> actions,
                                              HealthIssue solvedIssue) {
        this.actions = actions;
        this.solvedIssue = solvedIssue;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.actions;

/** Event indicating that the user has requested to delete an order. */
public class OrderStopRequestedEvent {
    public final String orderUuid;

    public OrderStopRequestedEvent(String orderUuid) {
        this.orderUuid = orderUuid;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.actions;

/** Event indicating that the user has requested to delete an order. */
public class OrderDeleteRequestedEvent {
    public final String orderUuid;

    public OrderDeleteRequestedEvent(String orderUuid) {
        this.orderUuid = orderUuid;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.actions;

import android.support.annotation.Nullable;

import org.joda.time.DateTime;
import org.projectbuendia.models.Order;

/**
 * Event indicating that the user has entered a new order that needs to be
 * submitted to the server and then saved locally on the client.
 */
public class OrderAddRequestedEvent {
    // If orderUuid is set, the event indicates a revision of an existing
    // order; otherwise, the event indicates a creation of a new order.
    public final String orderUuid;
    public final String patientUuid;
    public final String providerUuid;
    public final Order.Instructions instructions;
    public final DateTime start;
    public final Integer durationDays;

    public OrderAddRequestedEvent(
        @Nullable String orderUuid, String patientUuid, String providerUuid,
        Order.Instructions instructions, DateTime start, @Nullable Integer durationDays) {
        this.orderUuid = orderUuid;
        this.patientUuid = patientUuid;
        this.providerUuid = providerUuid;
        this.instructions = instructions;
        this.start = start;
        this.durationDays = durationDays;
    }
}

package org.projectbuendia.client.events.actions;

import org.projectbuendia.models.Obs;

import java.util.Collection;

public class ObsDeleteRequestedEvent {
    public final Collection<Obs> observations;

    public ObsDeleteRequestedEvent(Collection<Obs> observations) {
        this.observations = observations;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.actions;

/** An event bus event indicating that the user has requested that the current sync be canceled. */
public class SyncCancelRequestedEvent {
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.actions;

/** Event indicating that the user has requested to open the order dialog. */
public class OrderDialogRequestedEvent { }


// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.actions;

import org.joda.time.DateTime;

/**
 * Event indicating that the user has entered an order execution count that needs to be saved
 * (both stored locally on the client and posted to the server's order API).
 */
public class OrderExecutionAddRequestedEvent {
    public final String orderUuid;
    public final DateTime executionTime;

    public OrderExecutionAddRequestedEvent(String orderUuid, DateTime executionTime) {
        this.orderUuid = orderUuid;
        this.executionTime = executionTime;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.actions;

/** Event indicating that the user has requested to open a patient's chart. */
public class PatientChartRequestedEvent {
    public final String uuid;  // patient's uuid

    public PatientChartRequestedEvent(String uuid) {
        this.uuid = uuid;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.sync;

/** Indicates that a sync has stopped running.  Subclasses distinguish success and failure. */
public abstract class SyncStoppedEvent extends SyncEvent { }

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.sync;

/** An event bus event indicating that a sync has failed. */
public class SyncFailedEvent extends SyncStoppedEvent { }

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.sync;

/** Indicates that a sync is running and describes its progress. */
public class SyncProgressEvent extends SyncEvent {
    /** The progress completed so far, as a fraction. */
    public final int numerator;
    public final int denominator;

    /** The resource ID of a string message to show the user. */
    public final int messageId;

    public SyncProgressEvent(int numerator, int denominator, int messageId) {
        this.numerator = numerator;
        this.denominator = denominator;
        this.messageId = messageId;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.sync;

/** An event bus event indicating that a sync has completed. */
public class SyncSucceededEvent extends SyncStoppedEvent { }

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.sync;

/** Base class for events reporting sync status. */
public abstract class SyncEvent { }

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.sync;

/** An event bus event indicating that a sync was canceled. */
public class SyncCancelledEvent extends SyncStoppedEvent { }

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.data;

import org.projectbuendia.client.events.DefaultCrudEventBus;

/**
 * An event bus event indicating that updating a patient failed.
 * <p/>
 * <p>This event should only be posted on a {@link DefaultCrudEventBus}.
 */
public class PatientUpdateFailedEvent {

    public static final int REASON_INTERRUPTED = 0;
    public static final int REASON_NETWORK = 1;
    public static final int REASON_CLIENT = 2;
    public static final int REASON_SERVER = 3;
    public static final int REASON_NO_SUCH_PATIENT = 4;
    public static final int REASON_TIMEOUT = 5;

    public final int reason;
    public final Exception exception;

    public PatientUpdateFailedEvent(int reason, Exception exception) {
        this.reason = reason;
        this.exception = exception;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.data;

import org.projectbuendia.client.events.DefaultCrudEventBus;

/**
 * Indicates that a single item has been deleted on the server.  Should
 * only be posted on a {@link DefaultCrudEventBus}.
 */
public class ItemDeletedEvent {
    public final String uuid;

    public ItemDeletedEvent(String uuid) {
        this.uuid = uuid;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.data;

import org.projectbuendia.client.events.DefaultCrudEventBus;

/**
 * Indicates that a single item has been created on the server.  Should
 * only be posted on a {@link DefaultCrudEventBus}.
 */
public class ItemCreatedEvent<T> {
    public final T item;

    public ItemCreatedEvent(T item) {
        this.item = item;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.data;

/** Indicates that an attempt to submit a new order to the server failed. */
public class OrderAddFailedEvent {
    public final Reason reason;
    public final Exception exception;

    public enum Reason {
        UNKNOWN,
        UNKNOWN_SERVER_ERROR,
        CLIENT_ERROR,
        INTERRUPTED,
        TIMEOUT
    }

    public OrderAddFailedEvent(Reason reason, Exception exception) {
        this.reason = reason;
        this.exception = exception;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.data;

import org.projectbuendia.client.events.DefaultCrudEventBus;

/**
 * An event bus event indicating that adding a patient failed.
 * <p/>
 * <p>This event should only be posted on a {@link DefaultCrudEventBus}.
 */
public class PatientAddFailedEvent {

    public static final int REASON_UNKNOWN = 0;
    public static final int REASON_INTERRUPTED = 1;
    public static final int REASON_NETWORK = 2;
    public static final int REASON_CLIENT = 3;
    public static final int REASON_SERVER = 4;
    public static final int REASON_INVALID_ID = 5;
    public static final int REASON_DUPLICATE_ID = 6;
    public static final int REASON_INVALID_GIVEN_NAME = 7;
    public static final int REASON_INVALID_FAMILY_NAME = 8;
    public static final int REASON_TIMEOUT = 9;

    public final int reason;
    public final Exception exception;

    public PatientAddFailedEvent(int reason, Exception exception) {
        this.reason = reason;
        this.exception = exception;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.data;

import org.projectbuendia.client.events.DefaultCrudEventBus;
import org.projectbuendia.models.TypedCursor;

/**
 * An abstract event bus event indicating that a {@link TypedCursor} has been fetched from the data
 * store.
 * <p/>
 * <p>Subclasses of this event should only be posted on a {@link DefaultCrudEventBus}.
 */
public abstract class TypedCursorLoadedEvent<T> {

    public final TypedCursor<T> cursor;

    TypedCursorLoadedEvent(TypedCursor<T> cursor) {
        this.cursor = cursor;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.data;

import org.projectbuendia.client.events.DefaultCrudEventBus;
import org.projectbuendia.models.Patient;
import org.projectbuendia.models.TypedCursor;

/**
 * An event bus event indicating that {@link Patient}s have been fetched from the data store.
 * <p/>
 * <p>This event should only be posted on a {@link DefaultCrudEventBus}.
 */
public class AppPatientsLoadedEvent extends TypedCursorLoadedEvent<Patient> {

    AppPatientsLoadedEvent(TypedCursor<Patient> cursor) {
        super(cursor);
    }
}


// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.data;

import org.projectbuendia.client.events.DefaultCrudEventBus;

/**
 * Indicates that an item has been updated on the server.
 * Should only be posted on a {@link DefaultCrudEventBus}.
 */
public class ItemUpdatedEvent<T> {
    public final String uuid;
    public final T newItem;

    public ItemUpdatedEvent(String uuid, T newItem) {
        this.uuid = uuid;
        this.newItem = newItem;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.data;

import org.projectbuendia.client.events.DefaultCrudEventBus;

/**
 * Indicates that an item fetch failed.
 * Should only be posted on a {@link DefaultCrudEventBus}.
 */
public class ItemLoadFailedEvent {
    public final String error;
    public final String id;
    public final Throwable cause;

    public ItemLoadFailedEvent(String error) {
        this.error = error;
        this.id = null;
        this.cause = null;
    }

    public ItemLoadFailedEvent(String error, String id) {
        this.error = error;
        this.id = id;
        this.cause = null;
    }

    public ItemLoadFailedEvent(String error, String id, Throwable cause) {
        this.error = error;
        this.id = id;
        this.cause = cause;
    }
}

package org.projectbuendia.client.events.data;

public class ObsDeleteFailedEvent {

    public final Reason reason;
    public final Exception exception;

    public enum Reason {
        UNKNOWN,
        UNKNOWN_SERVER_ERROR,
        CLIENT_ERROR,
        INTERRUPTED,
        TIMEOUT
    }

    public ObsDeleteFailedEvent(Reason reason, Exception exception) {
        this.reason = reason;
        this.exception = exception;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.data;

import org.projectbuendia.models.Patient;
import org.projectbuendia.models.TypedCursor;

/** A factory that creates instances of subclasses of {@link TypedCursorLoadedEvent}. */
public class TypedCursorLoadedEventFactory {

    /**
     * Creates a {@link TypedCursorLoadedEvent} for the specified data type and cursor.
     * @throws IllegalArgumentException if {@code clazz} is unknown
     */
    @SuppressWarnings("unchecked") // Types checked by code.
    public static <T> TypedCursorLoadedEvent<?> createEvent(
        Class<T> clazz,
        TypedCursor<T> cursor) {
        if (clazz.equals(Patient.class)) {
            return new AppPatientsLoadedEvent((TypedCursor<Patient>) cursor);
        } else {
            throw new IllegalArgumentException(
                "Unable to create an event for unknown type " + clazz.getName());
        }
    }

    private TypedCursorLoadedEventFactory() { }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.data;

import org.projectbuendia.client.events.DefaultCrudEventBus;
import org.projectbuendia.models.TypedCursor;

/**
 * Indicates that a single item has been fetched from the data store.
 * Should only be posted on a {@link DefaultCrudEventBus}.
 * <p/>
 * <p>Unlike {@link TypedCursorLoadedEvent}, this provides the fetched item
 * (rather than providing a {@link TypedCursor} to lazy-load fetched items).
 */
public class ItemLoadedEvent<T> {
    public final T item;

    public ItemLoadedEvent(T item) {
        this.item = item;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.data;

import org.projectbuendia.client.events.DefaultCrudEventBus;

/**
 * An event bus event indicating that adding an encounter failed.
 * <p/>
 * <p>This event should only be posted on a {@link DefaultCrudEventBus}.
 */
public class EncounterAddFailedEvent {
    public final Reason reason;
    public final Exception exception;

    public enum Reason {
        UNKNOWN,
        UNKNOWN_SERVER_ERROR,
        INTERRUPTED,
        TIMEOUT,
        FAILED_TO_VALIDATE,
        FAILED_TO_AUTHENTICATE,
        FAILED_TO_SAVE_ON_SERVER,
        INVALID_NUMBER_OF_OBSERVATIONS_SAVED,
        FAILED_TO_FETCH_SAVED_OBSERVATION
    }

    public EncounterAddFailedEvent(Reason reason, Exception exception) {
        this.reason = reason;
        this.exception = exception;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.events.data;

import org.projectbuendia.client.events.DefaultCrudEventBus;

/**
 * An event bus event indicating that deleting an order failed.
 * <p/>
 * <p>This event should only be posted on a {@link DefaultCrudEventBus}.
 */
public class OrderDeleteFailedEvent {
    public final Reason reason;
    public final Exception exception;

    public enum Reason {
        UNKNOWN,
        UNKNOWN_SERVER_ERROR,
        CLIENT_ERROR,
        INTERRUPTED,
        TIMEOUT
    }

    public OrderDeleteFailedEvent(Reason reason, Exception exception) {
        this.reason = reason;
        this.exception = exception;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.exception;

/**
 * The base class for all validation exceptions.
 *
 * @author Vinicius Boson
 */
public class ValidationException extends Exception {
    public ValidationException(String message) {
        super( message );
    }

    public ValidationException() {
        super();
    }

    public ValidationException(String message, Throwable cause) {
        super( message, cause );
    }

    public ValidationException(Throwable cause) {
        super( cause );
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.widgets;

import android.content.Context;
import android.database.DataSetObserver;
import android.util.AttributeSet;
import android.widget.ExpandableListAdapter;
import android.widget.ExpandableListView;

import org.projectbuendia.client.utils.Logger;

/**
 * GroupedListView is a list view split up by category, where each category has a heading.
 * <p/>
 * <p>It acts like an expandable list view that:
 * <ul>
 * <li>Always shows groups as expanded
 * <li>Has no expand/collapse chevron
 * <li>Disables group collapse
 * </ul>
 */
public class GroupedListView extends ExpandableListView {
    private static final Logger LOG = Logger.create();

    /**
     * Instantiates a {@link GroupedListView}.
     * {@see ExpandableListView(Context, AttributeSet)}
     */
    public GroupedListView(Context context, AttributeSet attrs) {
        super(context, attrs);

        // Disable expand/collapse chevron.
        setGroupIndicator(null);

        // Ignore clicks on groups by default.
        setOnGroupClickListener((parent, v, groupPosition, id) -> true);
    }

    // Everything is expanded all the time.
    @Override public boolean isGroupExpanded(int groupPosition) {
        return true;
    }

    // Expand all groups when an adapter is set or when any data changes (which may involve adding
    // a group).
    @Override public void setAdapter(final ExpandableListAdapter adapter) {
        super.setAdapter(adapter);
        expandAllGroups(adapter);
        adapter.registerDataSetObserver(new DataSetObserver() {
            @Override public void onChanged() {
                expandAllGroups(adapter);
            }
        });
    }

    private void expandAllGroups(ExpandableListAdapter adapter) {
        LOG.i("expandAllGroups(%s) with group count = %d", adapter, adapter.getGroupCount());
        for (int i = 0; i < adapter.getGroupCount(); i++) {
            LOG.i("expandGroup(%d)", i);
            expandGroup(i);
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.widgets;

import android.content.Context;
import android.content.SharedPreferences;
import android.preference.EditTextPreference;
import android.preference.PreferenceManager;
import android.text.InputType;
import android.util.AttributeSet;

import org.projectbuendia.client.utils.Utils;

/**
 * Custom Android preference widget for editing an Integer value. The majority of code modifies
 * the storage type to be an Integer rather than a String.
 */
public class EditIntegerPreference extends EditTextPreference {

    private Integer mInteger;

    public EditIntegerPreference(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        init();
    }

    private void init() {
        getEditText().setInputType(InputType.TYPE_CLASS_NUMBER);
    }

    public EditIntegerPreference(Context context, AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    public EditIntegerPreference(Context context) {
        super(context);
        init();
    }

    @Override public String getText() {
        return mInteger != null ? mInteger.toString() : null;
    }

    @Override public void setText(String text) {
        boolean wasBlocking = shouldDisableDependents();
        mInteger = Utils.toIntOrNull(text);
        if (mInteger == null) {
            SharedPreferences.Editor editor = getEditor();
            editor.remove(getKey());
            editor.commit();
        } else {
            persistInt(mInteger);
        }
        boolean isBlocking = shouldDisableDependents();
        if (isBlocking != wasBlocking) {
            notifyDependencyChange(isBlocking);
        }
    }

    @Override
    protected void onSetInitialValue(boolean restoreValue, Object defaultValue) {
        Integer newValue;
        if (restoreValue) {
            if (!shouldPersist()) {
                newValue = mInteger;
            } else {
                PreferenceManager preferenceManager = getPreferenceManager();
                SharedPreferences sharedPreferences = preferenceManager.getSharedPreferences();
                String key = getKey();
                // We have to do the contains check, as we can't do getInt(x, null) to get null.
                newValue = sharedPreferences.contains(key)
                    ? sharedPreferences.getInt(key, 0) : mInteger;
            }
        } else {
            if (defaultValue instanceof Integer) {
                newValue = (Integer) defaultValue;
            } else {
                newValue = defaultValue != null ? Utils.toIntOrNull(defaultValue.toString()) : null;
            }
        }
        this.setText(newValue != null ? newValue.toString() : null);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.widgets;

import android.content.Context;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.drawable.Drawable;
import android.util.AttributeSet;
import android.view.LayoutInflater;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;

import org.projectbuendia.client.R;

import butterknife.ButterKnife;
import butterknife.InjectView;

/** A compound view that displays a patient attribute name and value with optional icon. */
public class PatientAttributeView extends LinearLayout {

    @InjectView(R.id.view_attribute_name) TextView mNameView;
    @InjectView(R.id.view_attribute_value) TextView mValueView;
    @InjectView(R.id.view_attribute_icon) ImageView mImageView;

    public PatientAttributeView(Context context) {
        this(context, null);
    }

    public PatientAttributeView(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    /** Constructs a {@link PatientAttributeView} with custom style parameters. */
    public PatientAttributeView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);

        LayoutInflater.from(context).inflate(
            R.layout.view_patient_attribute, this, true /*attachToRoot*/);
        ButterKnife.inject(this);

        Resources resources = getResources();
        int defaultTextColor = resources.getColor(R.color.view_patient_attribute_text_color);

        TypedArray a = context.obtainStyledAttributes(
            attrs, R.styleable.PatientAttributeView, defStyleAttr, 0 /*defStyleRes*/);
        String value;
        String name;
        int textColor;
        int iconResource;
        try {
            textColor = a.getColor(
                R.styleable.PatientAttributeView_attributeTextColor, defaultTextColor);
            name = a.getString(R.styleable.PatientAttributeView_attributeName);
            value = a.getString(R.styleable.PatientAttributeView_attributeValue);
            iconResource = a.getInt(R.styleable.PatientAttributeView_attributeIconResource, 0);
        } finally {
            a.recycle();
        }

        mNameView.setTextColor(textColor);
        mNameView.setText(name);
        mValueView.setTextColor(textColor);
        mValueView.setText(value);
        if (iconResource == 0) {
            mImageView.setVisibility(GONE);
        } else {
            mImageView.setImageResource(iconResource);
        }
    }

    /** Sets the text in the name view. */
    public PatientAttributeView setName(CharSequence name) {
        mNameView.setText(name);

        return this;
    }

    /** Sets the text in the value view. */
    public PatientAttributeView setValue(CharSequence value) {
        mValueView.setText(value);

        return this;
    }

    /** Sets the text color of both the name and the value. */
    public PatientAttributeView setTextColor(int color) {
        mNameView.setTextColor(color);
        mValueView.setTextColor(color);

        return this;
    }

    /** Sets a {@link Drawable} for use as an icon. */
    public PatientAttributeView setIcon(Drawable drawable) {
        mImageView.setVisibility(VISIBLE);
        mImageView.setImageDrawable(drawable);
        return this;
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.widgets;

import android.content.Context;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.util.AttributeSet;
import android.view.LayoutInflater;
import android.widget.LinearLayout;
import android.widget.TextView;

import org.projectbuendia.client.R;

import butterknife.ButterKnife;
import butterknife.InjectView;

/** A button with a subtitle. */
public class SubtitledButtonView extends LinearLayout {

    @InjectView(R.id.view_subtitled_button_subtitle)
    TextView mSubtitleView;
    @InjectView(R.id.view_subtitled_button_title)
    TextView mTitleView;

    private boolean mIsSquare;

    public SubtitledButtonView(Context context) {
        this(context, null);
    }

    public SubtitledButtonView(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    /**
     * Instantiates and inflates a {@link SubtitledButtonView}.
     * {@see LinearLayout(Context, AttributeSet, int)}
     */
    public SubtitledButtonView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        // TODO: Find a way to maintain the border even when setting a bgcolor.
        setBackgroundResource(R.drawable.border_grey_1dp);

        LayoutInflater.from(context).inflate(
            R.layout.view_subtitled_button, this, true /*attachToRoot*/);
        ButterKnife.inject(this);

        Resources resources = getResources();
        int defaultTextColor = resources.getColor(R.color.view_subtitled_button_text_color);
        int defaultSubtitleTextColor = resources.getColor(
            R.color.view_subtitled_button_subtitle_text_color);
        boolean defaultIsSquare = resources.getBoolean(
            R.bool.view_subtitled_button_is_square);
        TypedArray a = context.obtainStyledAttributes(
            attrs, R.styleable.SubtitledButtonView, defStyleAttr, 0 /*defStyleRes*/);
        String subtitle;
        String title;
        int subtitleTextColor;
        int textColor;
        try {
            textColor = a.getColor(
                R.styleable.SubtitledButtonView_subtitledButtonTextColor, defaultTextColor);
            subtitleTextColor = a.getColor(
                R.styleable.SubtitledButtonView_subtitledButtonSubtitleTextColor,
                defaultSubtitleTextColor);
            title = a.getString(R.styleable.SubtitledButtonView_subtitledButtonTitle);
            subtitle = a.getString(R.styleable.SubtitledButtonView_subtitledButtonSubtitle);
            mIsSquare = a.getBoolean(R.styleable.SubtitledButtonView_subtitledButtonIsSquare,
                defaultIsSquare);
        } finally {
            a.recycle();
        }

        mTitleView.setTextColor(textColor);
        mTitleView.setText(title);
        mSubtitleView.setTextColor(subtitleTextColor);
        mSubtitleView.setText(subtitle);
    }

    /** Sets the text color of both the title and the subtitle. */
    public SubtitledButtonView setTextColor(int color) {
        mTitleView.setTextColor(color);
        mSubtitleView.setTextColor(color);
        return this;
    }

    /** Sets the text color of the subtitle. */
    public SubtitledButtonView setSubtitleColor(int color) {
        mSubtitleView.setTextColor(color);
        return this;
    }

    /**
     * Sets the title of the button, using the builder pattern.
     * @param title the title text
     * @return the button with the specified title
     */
    public SubtitledButtonView setTitle(CharSequence title) {
        mTitleView.setText(title);

        return this;
    }

    /**
     * Sets the subtitle of the button, using the builder pattern.
     * @param subtitle the subtitle text
     * @return the button with the specified subtitle
     */
    public SubtitledButtonView setSubtitle(CharSequence subtitle) {
        mSubtitleView.setText(subtitle);

        return this;
    }

    @Override public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        if (!mIsSquare) {
            super.onMeasure(widthMeasureSpec, heightMeasureSpec);
            return;
        }

        int width = MeasureSpec.getSize(widthMeasureSpec);
        int height = MeasureSpec.getSize(heightMeasureSpec);
        int size = width > height ? height : width;
        setMeasuredDimension(size, size);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.widgets;

import android.content.Context;
import android.support.v7.widget.AppCompatTextView;
import android.text.TextUtils;
import android.util.AttributeSet;
import android.util.TypedValue;

import org.projectbuendia.client.utils.Logger;

public class ShrinkFitTextView extends AppCompatTextView {
    private static final Logger LOG = Logger.create();
    private static final float MIN_SIZE_SP = 6;
    private static final float STEP_SP = 4;
    private float defaultTextSize = -1;
    private int fixedHeight = -1;

    public ShrinkFitTextView(Context context) {
        this(context, null);
    }

    public ShrinkFitTextView(Context context, AttributeSet attrs) {
        this(context, attrs, android.R.attr.textViewStyle);
    }

    public ShrinkFitTextView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        setSingleLine();
        setEllipsize(TextUtils.TruncateAt.END);
    }

    @Override protected void onMeasure(int widthSpec, int heightSpec) {
        if (defaultTextSize < 0) {
            defaultTextSize = getTextSize()/getResources().getDisplayMetrics().scaledDensity;
            CharSequence seq = getText();
            setText("8");
            super.onMeasure(widthSpec, heightSpec);
            fixedHeight = getMeasuredHeight();
            setText(seq);
        }
        // Start at the default size, and keep shrinking the text if it doesn't fit.
        for (float size = defaultTextSize; size > MIN_SIZE_SP; size -= STEP_SP) {
            setTextSize(TypedValue.COMPLEX_UNIT_SP, size);
            super.onMeasure(widthSpec, heightSpec);
            if (getLayout().getEllipsisCount(0) == 0) break;
        }
        // Maintain the height that this view had when the text was the default size.
        setHeight(fixedHeight);
    }

    public void setTextAndResize(String text) {
        super.setText(text);
        measure(0, 0);
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.widgets;

import android.app.ProgressDialog;
import android.content.Context;
import android.preference.EditTextPreference;
import android.util.AttributeSet;

import org.projectbuendia.client.App;
import org.projectbuendia.client.R;
import org.projectbuendia.client.utils.Logger;

/** Custom Android preference widget that clears the database if new text is entered. */
public class EditAndClearDataPreference extends EditTextPreference {
    private static Logger LOG = Logger.create();
    private ProgressDialog dialog = null;

    public EditAndClearDataPreference(Context context, AttributeSet attrs) {
        super(context, attrs);
        setPositiveButtonText(R.string.clear_data_button);
    }

    public void onDialogClosed(boolean positive) {
        super.onDialogClosed(positive);
        if (positive) {
            dialog = ProgressDialog.show(getContext(), "Clearing data", "Clearing all local data...");
            App.reset(dialog::dismiss);
        }
    }
}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client.widgets;

import android.content.Context;
import android.util.AttributeSet;
import android.widget.GridView;

/**
 * A {@link GridView} that shows all its children when given unbounded space, so it can exist
 * sensibly in a {@link android.widget.ScrollView}.
 */
public class ScrollViewCompatibleGridView extends GridView {

    public ScrollViewCompatibleGridView(Context context) {
        super(context);
    }

    public ScrollViewCompatibleGridView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public ScrollViewCompatibleGridView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        if (MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
            // This number would normally be negative, but because makeMeasureSpec masks off the
            // most significant bits to store the mode, it ends up being the largest possible number
            // that we can provide
            heightMeasureSpec =
                MeasureSpec.makeMeasureSpec(0xFFFFFFFF, MeasureSpec.AT_MOST);
        }
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    }
}

/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Circle Internet Financial
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package com.circle.android.api;

import com.android.volley.AuthFailureError;
import com.android.volley.Request;
import com.android.volley.toolbox.HttpStack;
import com.squareup.okhttp.Call;
import com.squareup.okhttp.Headers;
import com.squareup.okhttp.MediaType;
import com.squareup.okhttp.OkHttpClient;
import com.squareup.okhttp.Protocol;
import com.squareup.okhttp.RequestBody;
import com.squareup.okhttp.Response;
import com.squareup.okhttp.ResponseBody;

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.ProtocolVersion;
import org.apache.http.StatusLine;
import org.apache.http.entity.BasicHttpEntity;
import org.apache.http.message.BasicHeader;
import org.apache.http.message.BasicHttpResponse;
import org.apache.http.message.BasicStatusLine;

import java.io.IOException;
import java.util.Map;
import java.util.concurrent.TimeUnit;


/**
 * OkHttp backed {@link com.android.volley.toolbox.HttpStack HttpStack} that does not
 * use okhttp-urlconnection
 */
public class OkHttpStack implements HttpStack {

    private final OkHttpClient mClient;

    public OkHttpStack(OkHttpClient client) {
        this.mClient = client;
    }

    @Override
    public HttpResponse performRequest(Request<?> request, Map<String, String> additionalHeaders)
            throws IOException, AuthFailureError {

        OkHttpClient client = mClient.clone();
        int timeoutMs = request.getTimeoutMs();
        client.setConnectTimeout(timeoutMs, TimeUnit.MILLISECONDS);
        client.setReadTimeout(timeoutMs, TimeUnit.MILLISECONDS);
        client.setWriteTimeout(timeoutMs, TimeUnit.MILLISECONDS);

        com.squareup.okhttp.Request.Builder okHttpRequestBuilder = new com.squareup.okhttp.Request.Builder();
        okHttpRequestBuilder.url(request.getUrl());

        Map<String, String> headers = request.getHeaders();
        for (final String name : headers.keySet()) {
            okHttpRequestBuilder.addHeader(name, headers.get(name));
        }
        for (final String name : additionalHeaders.keySet()) {
            okHttpRequestBuilder.addHeader(name, additionalHeaders.get(name));
        }

        setConnectionParametersForRequest(okHttpRequestBuilder, request);

        com.squareup.okhttp.Request okHttpRequest = okHttpRequestBuilder.build();
        Call okHttpCall = client.newCall(okHttpRequest);
        Response okHttpResponse = okHttpCall.execute();

        StatusLine responseStatus = new BasicStatusLine(parseProtocol(okHttpResponse.protocol()), okHttpResponse.code(), okHttpResponse.message());
        BasicHttpResponse response = new BasicHttpResponse(responseStatus);
        response.setEntity(entityFromOkHttpResponse(okHttpResponse));

        Headers responseHeaders = okHttpResponse.headers();
        for (int i = 0, len = responseHeaders.size(); i < len; i++) {
            final String name = responseHeaders.name(i), value = responseHeaders.value(i);
            if (name != null) {
                response.addHeader(new BasicHeader(name, value));
            }
        }

        return response;
    }

    private static HttpEntity entityFromOkHttpResponse(Response r) throws IOException {
        BasicHttpEntity entity = new BasicHttpEntity();
        ResponseBody body = r.body();

        entity.setContent(body.byteStream());
        entity.setContentLength(body.contentLength());
        entity.setContentEncoding(r.header("Content-Encoding"));

        if (body.contentType() != null) {
            entity.setContentType(body.contentType().type());
        }
        return entity;
    }

    @SuppressWarnings("deprecation")
    private static void setConnectionParametersForRequest(com.squareup.okhttp.Request.Builder builder, Request<?> request)
            throws IOException, AuthFailureError {
        switch (request.getMethod()) {
            case Request.Method.DEPRECATED_GET_OR_POST:
                // Ensure backwards compatibility.  Volley assumes a request with a null body is a GET.
                byte[] postBody = request.getPostBody();
                if (postBody != null) {
                    builder.post(RequestBody.create(MediaType.parse(request.getPostBodyContentType()), postBody));
                }
                break;
            case Request.Method.GET:
                builder.get();
                break;
            case Request.Method.DELETE:
                builder.delete();
                break;
            case Request.Method.POST:
                builder.post(createRequestBody(request));
                break;
            case Request.Method.PUT:
                builder.put(createRequestBody(request));
                break;
            case Request.Method.HEAD:
                builder.head();
                break;
            case Request.Method.OPTIONS:
                builder.method("OPTIONS", null);
                break;
            case Request.Method.TRACE:
                builder.method("TRACE", null);
                break;
            case Request.Method.PATCH:
                builder.patch(createRequestBody(request));
                break;
            default:
                throw new IllegalStateException("Unknown method type.");
        }
    }

    private static ProtocolVersion parseProtocol(final Protocol p) {
        switch (p) {
            case HTTP_1_0:
                return new ProtocolVersion("HTTP", 1, 0);
            case HTTP_1_1:
                return new ProtocolVersion("HTTP", 1, 1);
            case SPDY_3:
                return new ProtocolVersion("SPDY", 3, 1);
            case HTTP_2:
                return new ProtocolVersion("HTTP", 2, 0);
        }

        throw new IllegalAccessError("Unkwown protocol");
    }

    private static RequestBody createRequestBody(Request r) throws AuthFailureError {
        final byte[] body = r.getBody();
        if (body == null) return null;

        return RequestBody.create(MediaType.parse(r.getBodyContentType()), body);
    }
}
// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.projectbuendia.client;

/**
 * The modules used for injection in a debug build. Currently identical to a normal build, but
 * can be used to add debug-specific modules.
 */
final class Modules {

    private Modules() {
    }

    static Object[] list(App app) {
        return new Object[] {
            new AppModule(app)
        };
    }
}

package org.odk.collect.android.widgets2;

import android.content.Context;
import android.util.SparseArray;

import org.javarosa.core.model.Constants;
import org.javarosa.form.api.FormEntryCaption;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.widgets2.common.Appearance;
import org.odk.collect.android.widgets2.common.TypedWidget;
import org.odk.collect.android.widgets2.common.TypedWidgetFactory;
import org.odk.collect.android.widgets2.date.DateWidgetFactory;
import org.odk.collect.android.widgets2.group.WidgetGroupBuilder;
import org.odk.collect.android.widgets2.group.WidgetGroupBuilderFactory;
import org.odk.collect.android.widgets2.selectone.SelectOneWidgetFactory;
import org.odk.collect.android.widgets2.string.StringWidgetFactory;

/**
 * A factory that creates {@link TypedWidget}s.
 */
public class Widget2Factory {

    private static final String TAG = Widget2Factory.class.getName();

    private static final WidgetGroupBuilderFactory sWidgetGroupFactory;
    private static final SparseArray<SparseArray<TypedWidgetFactory<?>>> sWidgetFactoryRegistry;

    static {
        sWidgetGroupFactory = new WidgetGroupBuilderFactory();
        sWidgetFactoryRegistry = new SparseArray<SparseArray<TypedWidgetFactory<?>>>();
        register(Constants.CONTROL_SELECT_ONE, new SelectOneWidgetFactory());
        register(Constants.CONTROL_INPUT, Constants.DATATYPE_DATE, new DateWidgetFactory());
        register(Constants.CONTROL_INPUT, Constants.DATATYPE_TEXT, new StringWidgetFactory());
    }

    public static final Widget2Factory INSTANCE = new Widget2Factory();

    /**
     * Creates a {@link WidgetGroupBuilder} for a given group or returns {@code null} if unable to
     * create a builder.
     */
    public WidgetGroupBuilder createGroupBuilder(Context context, FormEntryCaption group) {
        return sWidgetGroupFactory.create(context, group);
    }

    /**
     * Creates a widget for a given field or returns {@code null} if unable to create a widget for
     * that field.
     */
    public TypedWidget<?> create(
            Context context, FormEntryPrompt prompt, boolean forceReadOnly) {
        SparseArray<TypedWidgetFactory<?>> dataTypeArray =
                sWidgetFactoryRegistry.get(prompt.getControlType());
        if (dataTypeArray == null) {
//            Log.e(
//                    TAG,
//                    "No TypedWidgetFactory registered for control type "
//                            + prompt.getControlType() + ".");
            return null;
        }

        // First, try to find the factory specifically for the current data type; if none exists,
        // try to find the one for any data type.
        TypedWidgetFactory<?> factory = dataTypeArray.get(prompt.getDataType());
        if (factory == null) {
            factory = dataTypeArray.get(-1);
            if (factory == null) {
//                Log.e(
//                        TAG,
//                        "No TypedWidgetFactory registered for control type "
//                                + prompt.getControlType() + " and data type "
//                                + prompt.getDataType() + " (and no default TypedWidgetFactory for "
//                                + "that control type is registered).");
                return null;
            }
        }

        if (factory == null) {
            return null;
        }

        return factory.create(
                context, prompt, Appearance.fromString(prompt.getAppearanceHint()), forceReadOnly);
    }

    private static void register(int controlType, TypedWidgetFactory<?> factory) {
        register(controlType, -1 /*dataType*/, factory);
    }

    private static void register(int controlType, int dataType, TypedWidgetFactory<?> factory) {
        SparseArray<TypedWidgetFactory<?>> dataTypeArray = sWidgetFactoryRegistry.get(controlType);
        if (dataTypeArray == null) {
            dataTypeArray = new SparseArray<TypedWidgetFactory<?>>();
            sWidgetFactoryRegistry.put(controlType, dataTypeArray);
        }

        dataTypeArray.put(dataType, factory);
    }

    private Widget2Factory() {}
}

package org.odk.collect.android.widgets2.selectone;

import android.app.Activity;
import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.inputmethod.InputMethodManager;
import android.widget.RadioButton;

import org.javarosa.core.model.SelectChoice;
import org.javarosa.core.model.data.SelectOneData;
import org.javarosa.core.model.data.helper.Selection;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.R;
import org.odk.collect.android.activities.FormEntryActivity;
import org.odk.collect.android.utilities.Utils;
import org.odk.collect.android.views.WrappingRadioGroup;
import org.odk.collect.android.widgets.QuestionWidget;
import org.odk.collect.android.widgets2.common.Appearance;
import org.odk.collect.android.widgets2.common.TypedWidget;

import java.util.List;

/**
 * A {@link SelectOneData} {@link TypedWidget} that displays choices as a flow layout of buttons.
 */
public class ButtonsSelectOneWidget extends TypedWidget<SelectOneData> {

    private class OnRadioButtonClickListener implements OnClickListener {

        private View mLastPressedView;

        @Override
        public void onClick(View view) {
            int i = (Integer) view.getTag();

            if (mLastPressedView == view) {
                mGroup.clearCheck();
            }

            mLastPressedView = mGroup.findViewById(mGroup.getCheckedRadioButtonId());

            // Unfocus any currently-focused view and hide the soft keyboard.
            View currentFocus = ((Activity) view.getContext()).getCurrentFocus();
            if (currentFocus != null) {
                currentFocus.clearFocus();
            }

            FormEntryActivity.hideKeyboard(view.getContext(), view);
        }
    }

    private final List<SelectChoice> mChoices;
    private final WrappingRadioGroup mGroup;

    public ButtonsSelectOneWidget(
            Context context, FormEntryPrompt prompt, Appearance appearance, boolean forceReadOnly) {
        // TODO: Handle initial values.

        super(context, prompt, appearance, forceReadOnly);
        LayoutInflater inflater = LayoutInflater.from(getContext());

        mGroup = (WrappingRadioGroup) inflater.inflate(R.layout.template_segmented_group, null);

        mChoices = prompt.getSelectChoices();
        String defaultAnswer = prompt.getAnswerValue() == null
                ? null
                : ((Selection) prompt.getAnswerValue().getValue()).getValue();

        boolean isReadOnly = forceReadOnly || prompt.isReadOnly();

        OnClickListener onClickListener = new OnRadioButtonClickListener();

        for (int i = 0; i < mChoices.size(); i++) {
            SelectChoice choice = mChoices.get(i);

            RadioButton radioButton =
                    (RadioButton) inflater.inflate(R.layout.template_radio_button_segmented, null);

            // TODO: Un-unscreamify once server work is done.

            radioButton.setText(Utils.localize(prompt.getSelectChoiceText(choice), context));
            radioButton.setTag(i);
            radioButton.setId(QuestionWidget.newUniqueId());
            radioButton.setEnabled(!isReadOnly);
            radioButton.setFocusable(!isReadOnly);
            radioButton.setOnClickListener(onClickListener);

            if (choice.getValue().equals(defaultAnswer)) {
                mGroup.check(i);
            }

            mGroup.addView(radioButton);
        }

        addView(mGroup);
    }

    @Override
    public boolean forceSetAnswer(Object answer) {
        if (!(answer instanceof String)) {
            return false;
        }

        String typedAnswer = (String) answer;
        for (int i = 0; i < mChoices.size(); i++) {
            if (mChoices.get(i).getLabelInnerText().equals(typedAnswer)) {
                mGroup.check(mGroup.getChildAt(i).getId());
                return true;
            }
        }

        return false;
    }

    @Override
    public SelectOneData getAnswer() {
        int checkedId = mGroup.getCheckedRadioButtonId();
        if (checkedId < 0) {
            return null;
        }

        View checkedRadioButton = mGroup.findViewById(checkedId);
        if (checkedRadioButton == null) {
            return null;
        }

        return new SelectOneData(
                new Selection(mChoices.get(mGroup.indexOfChild(checkedRadioButton))));
    }

    @Override
    public void clearAnswer() {
        mGroup.clearCheck();
    }

    @Override
    public void setFocus(Context context) {
        InputMethodManager inputManager = (InputMethodManager) context
                .getSystemService(Context.INPUT_METHOD_SERVICE);
        inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
    }
}

package org.odk.collect.android.widgets2.selectone;

import android.content.Context;

import org.javarosa.core.model.data.SelectOneData;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.widgets2.common.Appearance;
import org.odk.collect.android.widgets2.common.TypedWidget;
import org.odk.collect.android.widgets2.common.TypedWidgetFactory;

/**
 * A {@link TypedWidgetFactory} that creates {@link SelectOneData} widgets.
 */
public class SelectOneWidgetFactory extends TypedWidgetFactory<SelectOneData> {

    public TypedWidget<SelectOneData> create(
            Context context, FormEntryPrompt prompt, Appearance appearance, boolean forceReadOnly) {
        // TODO: Uncomment this when ready!
//
//        if (appearance == null) {
//            return null;
//        }

//        if (appearance.mPrimaryAppearance.equals("minimal")
//                && appearance.hasQualifier("buttons")) {
            return new ButtonsSelectOneWidget(context, prompt, appearance, forceReadOnly);
//        }
//
//        return null;
    }
}

package org.odk.collect.android.widgets2.selectone;

import android.app.Activity;
import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.inputmethod.InputMethodManager;
import android.widget.CheckBox;

import org.javarosa.core.model.SelectChoice;
import org.javarosa.core.model.data.SelectOneData;
import org.javarosa.core.model.data.helper.Selection;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.R;
import org.odk.collect.android.activities.FormEntryActivity;
import org.odk.collect.android.model.Preset;
import org.odk.collect.android.utilities.Utils;
import org.odk.collect.android.widgets.QuestionWidget;
import org.odk.collect.android.widgets2.common.Appearance;
import org.odk.collect.android.widgets2.common.TypedWidget;

import java.util.ArrayList;
import java.util.List;

/**
 * A {@link SelectOneData} {@link TypedWidget} that displays a binary choice
 * as a single button with a "yes" state, a "no" state, and an "unanswered" state.
 * Tapping the button toggles the state between "yes" and "unanswered"; the
 * setState() method allows setting the state to "yes", "unanswered", or "no".
 */
public class BinarySelectWidget extends TypedWidget<SelectOneData> implements View.OnClickListener {

    private SelectChoice mYesChoice;
    private SelectChoice mNoChoice;
    private CheckBox mCheckBox;
    private OnClickListener mOnClickCallback = null;
    private Boolean mState = null;  // true, false, or null (null means "unanswered")

    private static final int OFF_TEXT_COLOR = 0xff999999;
    private static final int DEFAULT_TEXT_COLOR = 0xff000000;

    public BinarySelectWidget(
            Context context, FormEntryPrompt prompt, Appearance appearance, boolean forceReadOnly) {
        super(context, prompt, appearance, forceReadOnly);

        mCheckBox = (CheckBox) LayoutInflater.from(getContext()).inflate(
            R.layout.template_check_box_button, null);
        mCheckBox.setText(Utils.localize(prompt.getQuestionText(), context));
        mCheckBox.setId(QuestionWidget.newUniqueId());
        boolean isReadOnly = forceReadOnly || prompt.isReadOnly();
        mCheckBox.setEnabled(!isReadOnly);
        mCheckBox.setFocusable(!isReadOnly);
        mCheckBox.setOnClickListener(this);

        findYesNoChoices(prompt);
        String defaultAnswer = prompt.getAnswerValue() == null ? null
            : ((Selection) prompt.getAnswerValue().getValue()).getValue();
        setState(Utils.eq(defaultAnswer, mYesChoice.getValue()) ? true : null);

        removeAllViews();  // remove views added by the base class
        addView(mCheckBox);
    }

    public void setOnClickCallback(OnClickListener callback) {
        mOnClickCallback = callback;
    }

    @Override public void onClick(View view) {
        clearActivityFocus((Activity) view.getContext());
        FormEntryActivity.hideKeyboard(view.getContext(), view);
        mState = mCheckBox.isChecked() ? true : null;

        if (mOnClickCallback != null) {
            mOnClickCallback.onClick(this);
        }
    }

    public Boolean getState() {
        return mState;
    }

    public void setState(Boolean state) {
        mState = state;
        mCheckBox.setChecked(mState == Boolean.TRUE);
        mCheckBox.setTextColor(mState == Boolean.FALSE ? OFF_TEXT_COLOR : DEFAULT_TEXT_COLOR);
    }

    @Override public boolean forceSetAnswer(Object answer) {
        if (answer instanceof Integer) {
            int preset = (Integer) answer;
            setState(preset == Preset.YES ? true : preset == Preset.NO ? false : null);
        }
        return false;
    }

    @Override public SelectOneData getAnswer() {
        if (mState == Boolean.TRUE) return new SelectOneData(new Selection(mYesChoice));
        if (mState == Boolean.FALSE) return new SelectOneData(new Selection(mNoChoice));
        return null;
    }

    @Override public void clearAnswer() {
        setState(null);
    }

    @Override public void setFocus(Context context) {
        InputMethodManager inputManager = (InputMethodManager) context
            .getSystemService(Context.INPUT_METHOD_SERVICE);
        inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
    }

    public void clearActivityFocus(Activity activity) {
        View currentFocus = activity.getCurrentFocus();
        if (currentFocus != null) {
            currentFocus.clearFocus();
        }
    }

    private void findYesNoChoices(FormEntryPrompt prompt) {
        List<SelectChoice> choices = prompt.getSelectChoices();
        if (choices.size() != 2) {
            throw new IllegalArgumentException(String.format(
                "Question \"%s\" has %d choices, but expected 2",
                mPrompt.getLongText(), choices.size()));
        }

        List<Integer> yesChoices = new ArrayList<>();
        for (int i = 0; i < choices.size(); i++) {
            if (isYesChoice(choices.get(i))) {
                yesChoices.add(i);
            }
        }
        if (yesChoices.size() != 1) {
            throw new IllegalArgumentException(String.format(
                "Question \"%s\" has %d \"yes\" choices, but expected 1",
                mPrompt.getLongText(), yesChoices.size()));
        }

        int yesIndex = yesChoices.get(0);
        mYesChoice = choices.get(yesIndex);
        mNoChoice = choices.get(1 - yesIndex);
    }

    /** Guesses whether a choice represents "yes". */
    private boolean isYesChoice(SelectChoice choice) {
        return choice.getValue().startsWith("1065^") ||
            choice.getLabelInnerText().trim().toLowerCase().startsWith("yes");
    }
}

package org.odk.collect.android.widgets2.group;

import android.view.ViewManager;
import android.view.ViewParent;

import org.odk.collect.android.widgets2.common.TypedWidget;

import java.util.List;

/**
 * A group of {@link org.odk.collect.android.widgets2.common.TypedWidget}s that should be displayed
 * together.
 *
 * <p>Classes that implement {@link WidgetGroup} must also extend {@link android.view.ViewGroup},
 * though this is only loosely enforced by {@link WidgetGroup} extending {@link ViewParent} and
 * {@link ViewManager}.
 */
public interface WidgetGroup extends ViewParent, ViewManager {

    List<TypedWidget<?>> getWidgets();
}

package org.odk.collect.android.widgets2.group;

import android.content.Context;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewGroup.MarginLayoutParams;
import android.widget.CheckBox;

import org.javarosa.core.model.Constants;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.R;
import org.odk.collect.android.model.Preset;
import org.odk.collect.android.widgets2.common.Appearance;
import org.odk.collect.android.widgets2.selectone.BinarySelectWidget;

import java.util.ArrayList;
import java.util.List;

/**
 * A {@link WidgetGroupBuilder} that builds a {@link TableWidgetGroup}
 * containing several {@link BinarySelectWidget}s.  In Buendia, this how we
 * present a set of choices that allows any number of choices to be selected.
 * Each choice can be in a "yes" state, "no" state, or unanswered state.
 * This builder is triggered by the appearance "binary-select-one" on the
 * group; see {@link WidgetGroupBuilderFactory}.
 *
 * We don't want to assume a "no" for choices that the user may have skipped
 * over; we wnat to require an explicit action to set the choices to "no".
 * So, in addition to the choices in the group, we offer a "None of the above"
 * button that can be tapped to explicitly specify "no" for all the choices.
 *
 * The group maintains the following invariant: either
 *
 * 1.  "None of the above" is selected and all choices are set to "no"; or
 *
 * 2.  "None of the above" is not selected and all the choices are either
 *     "yes" or "unanswered".
 *
 * For now, we hope to keep the UX simple by not providing a way to set
 * individual choices to "no" without setting them all to "no".  We also
 * don't provide a button to clear the entire group to "unanswered"; the same
 * effect can be achieved selecting and then deselecting "None of the above".
 */
public class BinarySelectTableBuilder implements
        WidgetGroupBuilder<TableWidgetGroup, BinarySelectTableBuilder>, View.OnClickListener {

    private static final String TAG = BinarySelectTableBuilder.class.getName();

    private final Appearance mAppearance;
    private final List<BinarySelectWidget> mWidgets;
    private CheckBox mNoneButton;

    public BinarySelectTableBuilder(Appearance appearance) {
        mAppearance = appearance;
        mWidgets = new ArrayList<BinarySelectWidget>();
    }

    @Override
    public BinarySelectTableBuilder createAndAddWidget(
            Context context,
            FormEntryPrompt prompt,
            Appearance appearance,
            boolean forceReadOnly,
            int id,
            Preset preset) {
        if (prompt.getControlType() != Constants.CONTROL_SELECT_ONE) {
            Log.w(
                    TAG,
                    "A non-select-one field was found under a binary select-one group. It has not "
                            + "been added.");
            return this;
        }

        BinarySelectWidget widget;
        try {
            widget = new BinarySelectWidget(context, prompt, appearance, forceReadOnly);
        } catch (IllegalArgumentException e) {
            Log.w(
                    TAG,
                    "A select-one field that is not binary was found under a binary select-one "
                            + "group. It has not been added.",
                    e);
            return this;
        }

        // TODO: Remove this workaround.
        String questionText = prompt.getQuestionText().toLowerCase();
        if (questionText.equals("pregnant")) {
            widget.forceSetAnswer(preset.pregnancy);
        }
        if (questionText.equals("iv access present")) {
            widget.forceSetAnswer(preset.ivAccess);
        }

        widget.setId(id);
        mWidgets.add(widget);

        return this;
    }

    @Override
    public TableWidgetGroup build(Context context) {
        TableWidgetGroup group = (TableWidgetGroup) LayoutInflater.from(context)
                .inflate(R.layout.template_binary_select_one_widget_group, null /*parent*/);

        for (BinarySelectWidget widget : mWidgets) {
            widget.setOnClickCallback(this);
            group.addView(widget);
        }

        mNoneButton = createNoneButton(context, context.getString(R.string.none_of_the_above), group);
        group.addRow(mNoneButton);
        setTopMargin(context, mNoneButton, 12);
        return group;
    }

    /** Invoked after any choice is clicked. */
    @Override public void onClick(View view) {
        if (view instanceof BinarySelectWidget) {
            BinarySelectWidget widget = (BinarySelectWidget) view;
            // When any choices are set to "yes", all other choices revert to
            // the "unanswered" state instead of the "no" state.
            if (widget.getState() == Boolean.TRUE && mNoneButton.isChecked()) {
                mNoneButton.setChecked(false);
                setAllChoices(null);
                widget.setState(true);
            }
        }
    }

    private CheckBox createNoneButton(Context context, String label, ViewGroup parent) {
        CheckBox cb = (CheckBox) LayoutInflater.from(context).inflate(
            R.layout.template_check_box_button, parent, false);
        cb.setText(label);
        cb.setOnClickListener(new View.OnClickListener() {
            @Override public void onClick(View v) {
                setAllChoices(((CheckBox) v).isChecked() ? false : null);
            }
        });
        return cb;
    }

    private void setAllChoices(Boolean state) {
        for (BinarySelectWidget widget : mWidgets) {
            widget.setState(state);
        }
    }

    private void setTopMargin(Context context, View view, int marginSp) {
        MarginLayoutParams params = (MarginLayoutParams) view.getLayoutParams();
        params.topMargin = (int) (marginSp * context.getResources().getDisplayMetrics().scaledDensity);
        view.setLayoutParams(params);
    }
}

package org.odk.collect.android.widgets2.group;

import android.content.Context;
import android.view.ViewGroup;

import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.model.Preset;
import org.odk.collect.android.widgets2.common.Appearance;

/**
 * A builder that builds widget groups.
 *
 * @param <T> the type of {@link WidgetGroup} being built
 * @param <U> a self-referential type parameter
 */
public interface WidgetGroupBuilder<
        T extends ViewGroup & WidgetGroup,
        U extends WidgetGroupBuilder<T, U>> {

    // TODO: Consider adding an onError callback to be invoked on add error.

    /**
     * Creates and adds a widget for the given prompt to the widget group.
     *
     * <p>If the widget cannot be added, a message will be logged but execution will continue.
     */
    U createAndAddWidget(
            Context context,
            FormEntryPrompt prompt,
            Appearance appearance,
            boolean forceReadOnly,
            int id,
            Preset fields);

    /**
     * Builds the widget group.
     */
    T build(Context context);
}

package org.odk.collect.android.widgets2.group;

import android.content.Context;
import android.util.AttributeSet;
import android.view.View;
import android.widget.TableLayout;
import android.widget.TableRow;

import org.odk.collect.android.widgets2.common.TypedWidget;

import java.util.ArrayList;
import java.util.List;

/**
 * A {@link WidgetGroup} that displays widgets in a table with a configurable number of columns.
 */
public class TableWidgetGroup extends TableLayout implements WidgetGroup {

    private int mNumColumns = 2;
    private int mColumnsFilled = 0;

    private TableRow mCurrentRow = null;
    private List<TypedWidget<?>> mWidgets = new ArrayList<TypedWidget<?>>();

    public TableWidgetGroup(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public TableWidgetGroup setNumColumns(int numColumns) {
        mNumColumns = numColumns;
        return this;
    }

    public void addCell(View child, int span) {
        if (mCurrentRow == null || mColumnsFilled + span > mNumColumns) {
            mCurrentRow = new TableRow(getContext());
            mColumnsFilled = 0;
            super.addView(mCurrentRow);
        }

        TableRow.LayoutParams params =
            new TableRow.LayoutParams(0, LayoutParams.WRAP_CONTENT);
        params.span = span;
        child.setLayoutParams(params);

        mCurrentRow.addView(child);
        mColumnsFilled += span;

        if (child instanceof TypedWidget<?>) {
            mWidgets.add((TypedWidget<?>) child);
        }
    }

    @Override public void addView(View child) {
        addCell(child, 1);
    }

    void addRow(View child) {
        addCell(child, mNumColumns);
    }

    @Override public List<TypedWidget<?>> getWidgets() {
        return mWidgets;
    }

    @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        // If there are any columns, set all columns to be stretchable. This works around bug
        // https://code.google.com/p/android/issues/detail?id=19343.
        if (getChildCount() > 1 || (mCurrentRow != null && mCurrentRow.getChildCount() > 0)) {
            setStretchAllColumns(true);
        }

        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    }
}

package org.odk.collect.android.widgets2.group;

import android.content.Context;

import org.javarosa.form.api.FormEntryCaption;
import org.odk.collect.android.widgets2.common.Appearance;

/**
 * A factory that creates {@link WidgetGroupBuilder}s.
 */
public class WidgetGroupBuilderFactory {

    public WidgetGroupBuilder create(Context context, FormEntryCaption group) {
        Appearance appearance = Appearance.fromString(group.getAppearanceHint());

        if (appearance.hasQualifier("binary-select-one")) {
            return new BinarySelectTableBuilder(appearance);
        }

        return null;
    }
}

package org.odk.collect.android.widgets2.date;

import android.content.Context;

import org.javarosa.core.model.data.DateData;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.widgets2.common.Appearance;
import org.odk.collect.android.widgets2.common.TypedWidget;
import org.odk.collect.android.widgets2.common.TypedWidgetFactory;

/**
 * A {@link TypedWidgetFactory} that creates {@link DateData} widgets.
 */
public class DateWidgetFactory extends TypedWidgetFactory<DateData> {

    @Override
    public TypedWidget<DateData> create(
            Context context, FormEntryPrompt prompt, Appearance appearance, boolean forceReadOnly) {
        if (appearance == null) {
            return null;
        }

        if ("minimal".equals(appearance.primaryAppearance)) {
            return new TimeElapsedDateWidget(context, prompt, appearance, forceReadOnly);
        }

        return null;
    }
}

package org.odk.collect.android.widgets2.date;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.RadioButton;
import android.widget.RadioGroup;

import org.javarosa.core.model.data.DateData;
import org.javarosa.form.api.FormEntryPrompt;
import org.joda.time.DateTime;
import org.odk.collect.android.R;
import org.odk.collect.android.widgets2.common.Appearance;
import org.odk.collect.android.widgets2.common.TypedWidget;

import java.util.ArrayList;
import java.util.List;

/**
 * A {@link DateData} {@link TypedWidget} that allows you to specify the amount of time elapsed to
 * determine a date.
 *
 * <p>For example, if you want to specify an age, you can specify the time elapsed in years, which
 * will then be subtracted from the current time to determine the (approximate) date of birth.
 */
public class TimeElapsedDateWidget extends TypedWidget<DateData> {

    private static final String YEARS_TAG = "years";
    private static final String MONTHS_TAG = "months";
    private static final String DAYS_TAG = "days";

    private final LinearLayout mLayout;
    private final EditText mValue;
    private final RadioGroup mUnits;
    private final RadioButton mYears;
    private final RadioButton mMonths;
    private final RadioButton mDays;
    private final List<RadioButton> mVisibleUnits;

    private final DateTime mStartDateTime;

    public TimeElapsedDateWidget(
            Context context, FormEntryPrompt prompt, Appearance appearance, boolean forceReadOnly) {
        // TODO: Handle initial values.

        super(context, prompt, appearance, forceReadOnly);
        LayoutInflater inflater = LayoutInflater.from(getContext());

        mLayout = (LinearLayout) inflater.inflate(R.layout.template_time_elapsed_date_widget, null);
        mValue = (EditText) mLayout.findViewById(R.id.value);
        mUnits = (RadioGroup) mLayout.findViewById(R.id.units);
        mYears = (RadioButton) mLayout.findViewById(R.id.years);
        mMonths = (RadioButton) mLayout.findViewById(R.id.months);
        mDays = (RadioButton) mLayout.findViewById(R.id.days);
        mVisibleUnits = new ArrayList<RadioButton>();

        boolean showYears = appearance.hasQualifier("show_years");
        boolean showMonths = appearance.hasQualifier("show_months");
        boolean showDays = appearance.hasQualifier("show_days");
        boolean showAll = !(showYears || showMonths || showYears);

        if (showAll || showYears) {
            mYears.setVisibility(View.VISIBLE);
            mVisibleUnits.add(mYears);
        }
        if (showAll || showMonths) {
            mMonths.setVisibility(View.VISIBLE);
            mVisibleUnits.add(mMonths);
        }
        if (showAll || showDays) {
            mDays.setVisibility(View.VISIBLE);
            mVisibleUnits.add(mDays);
        }

        mVisibleUnits.get(0).setChecked(true);

        addView(mLayout);

        mStartDateTime = DateTime.now();
    }

    @Override
    public DateData getAnswer() {
        String valueString = mValue.getText().toString();
        if ("".equals(valueString)) {
            return null;
        }
        int value = Integer.valueOf(valueString);

        RadioButton checkedButton =
                (RadioButton) mUnits.findViewById(mUnits.getCheckedRadioButtonId());

        if (YEARS_TAG.equals(checkedButton.getTag())) {
            return new DateData(mStartDateTime.minusYears(value).toDate());
        } else if (MONTHS_TAG.equals(checkedButton.getTag())) {
            return new DateData(mStartDateTime.minusMonths(value).toDate());
        } else {
            return new DateData(mStartDateTime.minusDays(value).toDate());
        }
    }

    @Override
    public void clearAnswer() {
        mValue.setText("");
        mVisibleUnits.get(0).setChecked(true);
    }
}

package org.odk.collect.android.widgets2.common;

import java.util.HashSet;
import java.util.Set;

/**
 * An object that represents the desired appearance of a widget.
 */
public class Appearance {

    private static final Appearance EMPTY = new Appearance("", new HashSet<String>());

    public final String primaryAppearance;

    private final Set<String> mQualifiers;

    public static Appearance fromString(String appearanceString) {
        if (appearanceString == null) {
            return EMPTY;
        }

        String[] appearanceParts = appearanceString.split("\\|");
        if (appearanceParts.length == 0) {
            return EMPTY;
        }

        String primaryAppearance = appearanceParts[0];

        Set<String> qualifiers = new HashSet<String>();
        for (int i = 1; i < appearanceParts.length; i++) {
            qualifiers.add(appearanceParts[i]);
        }

        return new Appearance(primaryAppearance, qualifiers);
    }

    public Appearance(String primaryAppearance, Set<String> qualifiers) {
        this.primaryAppearance = primaryAppearance;
        mQualifiers = qualifiers;
    }

    public boolean isEmpty() {
        return this == EMPTY;
    }

    public boolean hasQualifier(String qualifier) {
        return mQualifiers.contains(qualifier);
    }
}

package org.odk.collect.android.widgets2.common;

import android.content.Context;

import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.form.api.FormEntryPrompt;

/**
 * A factory that creates {@link TypedWidget}s.
 */
public abstract class TypedWidgetFactory<T extends IAnswerData> {

    public abstract TypedWidget<T> create(
            Context context, FormEntryPrompt prompt, Appearance appearance, boolean forceReadOnly);
}

package org.odk.collect.android.widgets2.common;

import android.content.Context;

import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.widgets.QuestionWidget;

/**
 * A {@link QuestionWidget} with a typed answer.
 */
public abstract class TypedWidget<T extends IAnswerData> extends QuestionWidget {

    protected final Appearance mAppearance;

    protected TypedWidget(
            Context context, FormEntryPrompt prompt, Appearance appearance, boolean forceReadOnly) {
        super(context, prompt);

        mAppearance = appearance;
    }

    @Override
    public abstract T getAnswer();

    @Override
    public void setFocus(Context context) {}

    @Override
    public void setOnLongClickListener(OnLongClickListener l) {}
}

package org.odk.collect.android.widgets2.string;

import android.content.Context;

import org.javarosa.core.model.data.StringData;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.widgets2.common.Appearance;
import org.odk.collect.android.widgets2.common.TypedWidget;
import org.odk.collect.android.widgets2.common.TypedWidgetFactory;

/**
 * A {@link TypedWidgetFactory} that creates {@link StringData} widgets.
 */
public class StringWidgetFactory extends TypedWidgetFactory<StringData> {

    public TypedWidget<StringData> create(
            Context context, FormEntryPrompt prompt, Appearance appearance, boolean forceReadOnly) {

        // Currently, there are no typed string widgets.

        return null;
    }
}

/*
 * Copyright (C) 2007 The Android Open Source Project
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.database;

import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteDatabase.CursorFactory;
import android.database.sqlite.SQLiteException;
import android.os.Environment;
import android.util.Log;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;

import java.io.File;


/**
 * We've taken this from Android's SQLiteOpenHelper. However, we can't appropriately lock the
 * database so there may be issues if a thread opens the database read-only and another thread tries
 * to open the database read/write. I don't think this will ever happen in ODK, though. (fingers
 * crossed).
 */

/**
 * A helper class to manage database creation and version management. You create a subclass
 * implementing {@link #onCreate}, {@link #onUpgrade} and optionally {@link #onOpen}, and this class
 * takes care of opening the database if it exists, creating it if it does not, and upgrading it as
 * necessary. Transactions are used to make sure the database is always in a sensible state.
 * <p>
 * For an example, see the NotePadProvider class in the NotePad sample application, in the
 * <em>samples/</em> directory of the SDK.
 * </p>
 */
public abstract class ODKSQLiteOpenHelper {
    private static final String t = ODKSQLiteOpenHelper.class.getSimpleName();

    private final String mPath;
    private final String mName;
    private final CursorFactory mFactory;
    private final int mNewVersion;

    private SQLiteDatabase mDatabase = null;
    private boolean mIsInitializing = false;


    /**
     * Create a helper object to create, open, and/or manage a database. The database is not
     * actually created or opened until one of {@link #getWritableDatabase} or
     * {@link #getReadableDatabase} is called.
     * 
     * @param path to the file
     * @param name of the database file, or null for an in-memory database
     * @param factory to use for creating cursor objects, or null for the default
     * @param version number of the database (starting at 1); if the database is older,
     *            {@link #onUpgrade} will be used to upgrade the database
     */
    public ODKSQLiteOpenHelper(String path, String name, CursorFactory factory, int version) {
        if (version < 1)
            throw new IllegalArgumentException("Version must be >= 1, was " + version);

        mPath = path;
        mName = name;
        mFactory = factory;
        mNewVersion = version;
    }


    /**
     * Create and/or open a database that will be used for reading and writing. Once opened
     * successfully, the database is cached, so you can call this method every time you need to
     * write to the database. Make sure to call {@link #close} when you no longer need it.
     * <p>
     * Errors such as bad permissions or a full disk may cause this operation to fail, but future
     * attempts may succeed if the problem is fixed.
     * </p>
     * 
     * @throws SQLiteException if the database cannot be opened for writing
     * @return a read/write database object valid until {@link #close} is called
     */
    public synchronized SQLiteDatabase getWritableDatabase() {
        if (mDatabase != null && mDatabase.isOpen() && !mDatabase.isReadOnly()) {
            return mDatabase; // The database is already open for business
        }

        if (mIsInitializing) {
            throw new IllegalStateException("getWritableDatabase called recursively");
        }

        // If we have a read-only database open, someone could be using it
        // (though they shouldn't), which would cause a lock to be held on
        // the file, and our attempts to open the database read-write would
        // fail waiting for the file lock. To prevent that, we acquire the
        // lock on the read-only database, which shuts out other users.

        boolean success = false;
        SQLiteDatabase db = null;
        // if (mDatabase != null) mDatabase.lock();
        try {
            mIsInitializing = true;
            if (mName == null) {
                db = SQLiteDatabase.create(null);
            } else {
                db = SQLiteDatabase.openOrCreateDatabase(mPath + File.separator + mName, mFactory);
                // db = mContext.openOrCreateDatabase(mName, 0, mFactory);
            }

            int version = db.getVersion();
            if (version != mNewVersion) {
                db.beginTransaction();
                try {
                    if (version == 0) {
                        onCreate(db);
                    } else {
                        onUpgrade(db, version, mNewVersion);
                    }
                    db.setVersion(mNewVersion);
                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                }
            }

            onOpen(db);
            success = true;
            return db;
        } finally {
            mIsInitializing = false;
            if (success) {
                if (mDatabase != null) {
                    try {
                        mDatabase.close();
                    } catch (Exception e) {
                    }
                    // mDatabase.unlock();
                }
                mDatabase = db;
            } else {
                // if (mDatabase != null) mDatabase.unlock();
                if (db != null)
                    db.close();
            }
        }
    }


    /**
     * Create and/or open a database. This will be the same object returned by
     * {@link #getWritableDatabase} unless some problem, such as a full disk, requires the database
     * to be opened read-only. In that case, a read-only database object will be returned. If the
     * problem is fixed, a future call to {@link #getWritableDatabase} may succeed, in which case
     * the read-only database object will be closed and the read/write object will be returned in
     * the future.
     * 
     * @throws SQLiteException if the database cannot be opened
     * @return a database object valid until {@link #getWritableDatabase} or {@link #close} is
     *         called.
     */
    public synchronized SQLiteDatabase getReadableDatabase() {
        if (mDatabase != null && mDatabase.isOpen()) {
            return mDatabase; // The database is already open for business
        }

        if (mIsInitializing) {
            throw new IllegalStateException("getReadableDatabase called recursively");
        }

        try {
            return getWritableDatabase();
        } catch (SQLiteException e) {
            if (mName == null)
                throw e; // Can't open a temp database read-only!
            Log.e(t, "Couldn't open " + mName + " for writing (will try read-only):", e);
        }

        SQLiteDatabase db = null;
        try {
            mIsInitializing = true;
            String path = mPath + File.separator + mName;
            // mContext.getDatabasePath(mName).getPath();
            try {
                db = SQLiteDatabase.openDatabase(path, mFactory, SQLiteDatabase.OPEN_READONLY);
            } catch (RuntimeException e) {
                Log.e(t, e.getMessage(), e);
                String cardstatus = Environment.getExternalStorageState();
                if (!cardstatus.equals(Environment.MEDIA_MOUNTED)) {
                    throw new RuntimeException(Collect.getInstance().getApplication().getString(R.string.sdcard_unmounted, cardstatus));
                } else {
                    throw e;
                }
            }

            if (db.getVersion() != mNewVersion) {
                throw new SQLiteException("Can't upgrade read-only database from version "
                        + db.getVersion() + " to " + mNewVersion + ": " + path);
            }

            onOpen(db);
            Log.w(t, "Opened " + mName + " in read-only mode");
            mDatabase = db;
            return mDatabase;
        } finally {
            mIsInitializing = false;
            if (db != null && db != mDatabase)
                db.close();
        }
    }


    /**
     * Close any open database object.
     */
    public synchronized void close() {
        if (mIsInitializing)
            throw new IllegalStateException("Closed during initialization");

        if (mDatabase != null && mDatabase.isOpen()) {
            mDatabase.close();
            mDatabase = null;
        }
    }


    /**
     * Called when the database is created for the first time. This is where the creation of tables
     * and the initial population of the tables should happen.
     * 
     * @param db The database.
     */
    public abstract void onCreate(SQLiteDatabase db);


    /**
     * Called when the database needs to be upgraded. The implementation should use this method to
     * drop tables, add tables, or do anything else it needs to upgrade to the new schema version.
     * <p>
     * The SQLite ALTER TABLE documentation can be found <a
     * href="http://sqlite.org/lang_altertable.html">here</a>. If you add new columns you can use
     * ALTER TABLE to insert them into a live table. If you rename or remove columns you can use
     * ALTER TABLE to rename the old table, then create the new table and then populate the new
     * table with the contents of the old table.
     * 
     * @param db The database.
     * @param oldVersion The old database version.
     * @param newVersion The new database version.
     */
    public abstract void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion);


    /**
     * Called when the database has been opened. Override method should check
     * {@link SQLiteDatabase#isReadOnly} before updating the database.
     * 
     * @param db The database.
     */
    public void onOpen(SQLiteDatabase db) {
    }
}


package org.odk.collect.android.database;

import android.content.ContentValues;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.util.Log;

import org.odk.collect.android.application.Collect;

import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class ItemsetDbAdapter {

    public static final String KEY_ID = "_id";

    private static final String TAG = "ItemsetDbAdapter";
    private DatabaseHelper mDbHelper;
    private SQLiteDatabase mDb;

    private static final String DATABASE_NAME = "itemsets.db";
    private static final String DATABASE_TABLE = "itemset_";
    private static final int DATABASE_VERSION = 2;

    private static final String ITEMSET_TABLE = "itemsets";
    private static final String KEY_ITEMSET_HASH = "hash";
    private static final String KEY_PATH = "path";

    private static final String CREATE_ITEMSET_TABLE =
            "create table " + ITEMSET_TABLE + " (_id integer primary key autoincrement, "
                    + KEY_ITEMSET_HASH + " text, "
                    + KEY_PATH + " text "
                    + ");";

    /**
     * This class helps open, create, and upgrade the database file.
     */
    private static class DatabaseHelper extends ODKSQLiteOpenHelper {
        DatabaseHelper() {
            super(Collect.getInstance().getMetadataPath(), DATABASE_NAME, null, DATABASE_VERSION);
        }

        @Override
        public void onCreate(SQLiteDatabase db) {
            // create table to keep track of the itemsets
            db.execSQL(CREATE_ITEMSET_TABLE);

        }

        @Override
        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
            Log.w(TAG, "Upgrading database from version " + oldVersion + " to "
                    + newVersion + ", which will destroy all old data");
            // first drop all of our generated itemset tables
            Cursor c = db.query(ITEMSET_TABLE, null, null, null, null, null, null);
            if (c != null) {
                c.move(-1);
                while (c.moveToNext()) {
                    String table = c.getString(c.getColumnIndex(KEY_ITEMSET_HASH));
                    db.execSQL("DROP TABLE IF EXISTS " + DATABASE_TABLE + table);
                }
                c.close();
            }

            // then drop the table tracking itemsets itself
            db.execSQL("DROP TABLE IF EXISTS " + ITEMSET_TABLE);
            onCreate(db);
        }
    }

    public ItemsetDbAdapter() {
    }

    /**
     * Open the database. If it cannot be opened, try to create a new instance
     * of the database. If it cannot be created, throw an exception to signal
     * the failure
     * 
     * @return this (self reference, allowing this to be chained in an
     *         initialization call)
     * @throws SQLException if the database could be neither opened or created
     */
    public ItemsetDbAdapter open() throws SQLException {
        mDbHelper = new DatabaseHelper();
        mDb = mDbHelper.getWritableDatabase();
        return this;
    }

    public void close() {
        mDbHelper.close();
    }

    public boolean createTable(String formHash, String pathHash, String[] columns, String path) {
        StringBuilder sb = new StringBuilder();
        
        // get md5 of the path to itemset.csv, which is unique per form
        // the md5 is easier to use because it doesn't have chars like '/'
                
        sb.append("create table " + DATABASE_TABLE + pathHash
                + " (_id integer primary key autoincrement ");
        for (int j = 0; j < columns.length; j++) {
            // add double quotes in case the column is of label:lang
            sb.append(" , \"" + columns[j] + "\" text ");
            // create database with first line
        }
        sb.append(");");

        String tableCreate = sb.toString();
        Log.i(TAG, "create string: " + tableCreate);
        mDb.execSQL(tableCreate);

        ContentValues cv = new ContentValues();
        cv.put(KEY_ITEMSET_HASH, formHash);
        cv.put(KEY_PATH, path);
        mDb.insert(ITEMSET_TABLE, null, cv);

        return true;
    }

    public boolean addRow(String tableName, String[] columns, String[] newRow) {
        ContentValues cv = new ContentValues();

        // rows don't necessarily use all the columns
        // but a column is guaranteed to exist for a row (or else blow up)
        for (int i = 0; i < newRow.length; i++) {
            cv.put("\"" + columns[i] + "\"", newRow[i]);
        }
        mDb.insert(DATABASE_TABLE + tableName, null, cv);
        return true;
    }

    public boolean tableExists(String tableName) {
        // select name from sqlite_master where type = 'table'
        String selection = "type=? and name=?";
        String selectionArgs[] = {
                "table", DATABASE_TABLE + tableName
        };
        Cursor c = mDb.query("sqlite_master", null, selection, selectionArgs,
                null, null, null);
        boolean exists = false;
        if (c.getCount() == 1) {
            exists = true;
        }
        c.close();
        return exists;

    }

    public void beginTransaction() {
        mDb.execSQL("BEGIN");
    }

    public void commit() {
        mDb.execSQL("COMMIT");
    }

    public Cursor query(String hash, String selection, String[] selectionArgs) throws SQLException {
        Cursor mCursor = mDb.query(true, DATABASE_TABLE + hash, null, selection, selectionArgs,
                null, null, null, null);
        return mCursor;
    }

    public void dropTable(String pathHash, String path) {
        // drop the table
        mDb.execSQL("DROP TABLE IF EXISTS " + DATABASE_TABLE + pathHash);

        // and remove the entry from the itemsets table
        String where = KEY_PATH + "=?";
        String[] whereArgs = {
            path
        };
        mDb.delete(ITEMSET_TABLE, where, whereArgs);
    }

    public Cursor getItemsets(String path) {
        String selection = KEY_PATH + "=?";
        String[] selectionArgs = {
            path
        };
        Cursor c = mDb.query(ITEMSET_TABLE, null, selection, selectionArgs, null, null, null);
        return c;
    }

    public void delete(String path) {
        Cursor c = getItemsets(path);
        if (c != null) {
            if (c.getCount() == 1) {
                c.moveToFirst();
                String table = getMd5FromString(c.getString(c.getColumnIndex(KEY_PATH)));
                mDb.execSQL("DROP TABLE IF EXISTS " + DATABASE_TABLE + table);
            }
            c.close();
        }

        String where = KEY_PATH + "=?";
        String[] whereArgs = {
            path
        };
        mDb.delete(ITEMSET_TABLE, where, whereArgs);
    }
    
    public static String getMd5FromString(String toEncode) {
        MessageDigest md = null;
        try {
            md = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            Log.e("MD5", e.getMessage());
        }
        md.update(toEncode.getBytes());
        byte[] digest = md.digest();
        BigInteger bigInt = new BigInteger(1,digest);
        String hashtext = bigInt.toString(16);
        return hashtext;
    }

}

/*
 * Copyright (C) 2012 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.database;

import android.app.Activity;
import android.content.ContentValues;
import android.database.SQLException;
import android.database.sqlite.SQLiteConstraintException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;

import org.javarosa.core.model.FormIndex;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.logic.FormController;

import java.io.File;
import java.util.Calendar;
import java.util.LinkedList;

/**
 * Log all user interface activity into a SQLite database. Logging is disabled by default.
 *
 * The logging database will be "/sdcard/odk/log/activityLog.db"
 *
 * Logging is enabled if the file "/sdcard/odk/log/enabled" exists.
 *
 * @author mitchellsundt@gmail.com
 * @author Carl Hartung (carlhartung@gmail.com)
 *
 */
public final class ActivityLogger {

    private static class DatabaseHelper extends ODKSQLiteOpenHelper {

		DatabaseHelper() {
			super(Collect.getInstance().getLogPath(), DATABASE_NAME, null, DATABASE_VERSION);
			new File(Collect.getInstance().getLogPath()).mkdirs();
		}

		@Override
		public void onCreate(SQLiteDatabase db) {
			db.execSQL(DATABASE_CREATE);
		}

		@Override
		public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
			db.execSQL("DROP TABLE IF EXISTS " + DATABASE_TABLE);
			onCreate(db);
		}
	}

	/**
	 * The minimum delay, in milliseconds, for a scroll action to be considered new.
	 */
	private static final long MIN_SCROLL_DELAY = 400L;
	/**
	 * The maximum size of the scroll action buffer.  After it reaches this size,
	 * it will be flushed.
	 */
	private static final int MAX_SCROLL_ACTION_BUFFER_SIZE = 8;

	private static final String DATABASE_TABLE = "log";
	private static final String ENABLE_LOGGING = "enabled";
	private static final int DATABASE_VERSION = 1;
	private static final String DATABASE_NAME = "activityLog.db";
	// Database columns
	private static final String ID = "_id";
	private static final String TIMESTAMP = "timestamp";
	private static final String DEVICEID = "device_id";
	private static final String CLASS = "class";
	private static final String CONTEXT = "context";
	private static final String ACTION = "action";
	private static final String INSTANCE_PATH = "instance_path";
	private static final String QUESTION = "question";
	private static final String PARAM1 = "param1";
	private static final String PARAM2 = "param2";

	private static final String DATABASE_CREATE =
			"create table " + DATABASE_TABLE + " (" +
			ID + " integer primary key autoincrement, " +
			TIMESTAMP + " integer not null, " +
			DEVICEID + " text not null, " +
			CLASS + " text not null, " +
			CONTEXT + " text not null, " +
			ACTION + " text, " +
			INSTANCE_PATH + " text, " +
			QUESTION + " text, " +
			PARAM1 + " text, " +
			PARAM2 + " text);";

	private final boolean mLoggingEnabled;
	private final String mDeviceId;
	private DatabaseHelper mDbHelper = null;
	private SQLiteDatabase mDb = null;
	private boolean mIsOpen = false;
	// We buffer scroll actions to make sure there aren't too many pauses
	// during scrolling.  This list is flushed every time any other type of
	// action is logged.
	private final LinkedList<ContentValues> mScrollActions = new LinkedList<ContentValues>();

	public ActivityLogger(String deviceId) {
		this.mDeviceId = deviceId;
		mLoggingEnabled = new File(Collect.getInstance().getLogPath(), ENABLE_LOGGING).exists();
        open();
	}

	public boolean isOpen() {
		return mLoggingEnabled && mIsOpen;
	}

    public void open() throws SQLException {
    	if (!mLoggingEnabled || mIsOpen) return;
        try {
            mDbHelper = new DatabaseHelper();
            mDb = mDbHelper.getWritableDatabase();
            mIsOpen = true;
        } catch (SQLiteException e) {
        	System.err.println("Error: " + e.getMessage());
        	mIsOpen = false;
        }
    }

    // cached to improve logging performance...
    // only access these through getXPath(FormIndex index);
    private FormIndex cachedXPathIndex = null;
    private String cachedXPathValue = null;

    // DO NOT CALL THIS OUTSIDE OF synchronized(mScrollActions) !!!!
    // DO NOT CALL THIS OUTSIDE OF synchronized(mScrollActions) !!!!
    // DO NOT CALL THIS OUTSIDE OF synchronized(mScrollActions) !!!!
    // DO NOT CALL THIS OUTSIDE OF synchronized(mScrollActions) !!!!
    private String getXPath(FormIndex index) {
    	if ( index == cachedXPathIndex ) return cachedXPathValue;

    	cachedXPathIndex = index;
    	cachedXPathValue = Collect.getInstance().getFormController().getXPath(index);
    	return cachedXPathValue;
    }


    private void log(String object, String context, String action, String instancePath, FormIndex index, String param1, String param2) {
		if (!isOpen()) return;

        ContentValues cv = new ContentValues();
        cv.put(DEVICEID, mDeviceId);
        cv.put(CLASS, object);
        cv.put(CONTEXT, context);
        cv.put(ACTION, action);
        cv.put(INSTANCE_PATH, instancePath);
        cv.put(PARAM1, param1);
        cv.put(PARAM2, param2);
        cv.put(TIMESTAMP, Calendar.getInstance().getTimeInMillis());

        insertContentValues(cv, index);
    }

    public void logScrollAction(Object t, int distance) {
    	if (!isOpen()) return;

    	synchronized(mScrollActions) {
	    	long timeStamp = Calendar.getInstance().getTimeInMillis();

	    	// Check to see if we can add this scroll action to the previous action.
	    	if (!mScrollActions.isEmpty()) {
	    		ContentValues lastCv = mScrollActions.get(mScrollActions.size() - 1);
		    	long oldTimeStamp = lastCv.getAsLong(TIMESTAMP);
		    	int oldDistance = Integer.parseInt(lastCv.getAsString(PARAM1));
		    	if (Integer.signum(distance) == Integer.signum(oldDistance) &&
		    			timeStamp - oldTimeStamp < MIN_SCROLL_DELAY) {
		    		lastCv.put(PARAM1, oldDistance + distance);
		    		lastCv.put(TIMESTAMP, timeStamp);
		    		return;
		    	}
	    	}

	    	if (mScrollActions.size() >= MAX_SCROLL_ACTION_BUFFER_SIZE) {
	    		insertContentValues(null, null); // flush scroll list...
	    	}

	    	String idx = "";
	    	String instancePath = "";
	    	FormController formController = Collect.getInstance().getFormController();
	    	if ( formController != null ) {
	    		idx = getXPath(formController.getFormIndex());
	    		instancePath = formController.getInstancePath().getAbsolutePath();
	    	}

	    	// Add a new scroll action to the buffer.
	    	ContentValues cv = new ContentValues();
	    	cv.put(DEVICEID, mDeviceId);
	    	cv.put(CLASS, t.getClass().getName());
	    	cv.put(CONTEXT, "scroll");
	    	cv.put(ACTION, "");
	    	cv.put(PARAM1, distance);
	    	cv.put(QUESTION, idx);
	    	cv.put(INSTANCE_PATH, instancePath);
	        cv.put(TIMESTAMP, timeStamp);
	    	cv.put(PARAM2, timeStamp);
	    	mScrollActions.add(cv);
    	}
    }

    private void insertContentValues(ContentValues cv, FormIndex index) {
    	synchronized(mScrollActions) {
	        try {
	        	while ( !mScrollActions.isEmpty() ) {
	        		ContentValues scv = mScrollActions.removeFirst();
	        		mDb.insert(DATABASE_TABLE, null, scv);
	        	}

	        	if ( cv != null ) {
	    	    	String idx = "";
	    	    	if ( index != null ) {
	    	    		idx = getXPath(index);
	    	    	}
	    	    	cv.put(QUESTION,idx);
	        		mDb.insert(DATABASE_TABLE, null, cv);
	        	}
	        } catch (SQLiteConstraintException e) {
	            System.err.println("Error: " + e.getMessage());
	        }
    	}
    }

    // Convenience methods

    public void logOnStart(Activity a) {
		log( a.getClass().getName(), "onStart", null, null, null, null, null);
    }

    public void logOnStop(Activity a) {
		log( a.getClass().getName(), "onStop", null, null, null, null, null);
    }

    public void logAction(Object t, String context, String action) {
		log( t.getClass().getName(), context, action, null, null, null, null);
    }

    public void logActionParam(Object t, String context, String action, String param1) {
		log( t.getClass().getName(), context, action, null, null, param1, null);
    }

    public void logInstanceAction(Object t, String context, String action) {
    	FormIndex index = null;
    	String instancePath = null;
    	FormController formController = Collect.getInstance().getFormController();
    	if ( formController != null ) {
    		index = formController.getFormIndex();
    		File instanceFile = formController.getInstancePath();
    		if ( instanceFile != null ) {
    			instancePath = instanceFile.getAbsolutePath();
    		}
    	}
    	log( t.getClass().getName(), context, action, instancePath, index, null, null);
    }

    public void logInstanceAction(Object t, String context, String action, FormIndex index) {
    	String instancePath = null;
    	FormController formController = Collect.getInstance().getFormController();
    	if ( formController != null ) {
    		index = formController.getFormIndex();
	    	instancePath = formController.getInstancePath().getAbsolutePath();
    	}
    	log( t.getClass().getName(), context, action, instancePath, index, null, null);
    }
}

/*
 * Copyright (C) 2011 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.preferences;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.preference.PreferenceActivity;
import android.preference.PreferenceManager;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.Toast;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.utilities.CompatibilityUtils;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;

/**
 * Handles admin preferences, which are password-protectable and govern which app features and
 * general preferences the end user of the app will be able to see.
 *
 * @author Thomas Smyth, Sassafras Tech Collective (tom@sassafrastech.com; constraint behavior option)
 */
public class AdminPreferencesActivity extends PreferenceActivity {

    public static String ADMIN_PREFERENCES = "admin_prefs";

    // key for this preference screen
    public static String KEY_ADMIN_PW = "admin_pw";

    // keys for each preference
    // main menu
    public static String KEY_EDIT_SAVED = "edit_saved";
    public static String KEY_SEND_FINALIZED = "send_finalized";
    public static String KEY_GET_BLANK = "get_blank";
    public static String KEY_DELETE_SAVED = "delete_saved";
    // server
    public static String KEY_CHANGE_SERVER = "change_server";
    public static String KEY_CHANGE_USERNAME = "change_username";
    public static String KEY_CHANGE_PASSWORD = "change_password";
    public static String KEY_CHANGE_GOOGLE_ACCOUNT = "change_google_account";
    public static String KEY_CHANGE_PROTOCOL_SETTINGS = "change_protocol_settings";
    // client
    public static String KEY_CHANGE_FONT_SIZE = "change_font_size";
    public static String KEY_DEFAULT_TO_FINALIZED = "default_to_finalized";
    public static String KEY_HIGH_RESOLUTION = "high_resolution";
    public static String KEY_SHOW_SPLASH_SCREEN = "show_splash_screen";
    public static String KEY_SELECT_SPLASH_SCREEN = "select_splash_screen";
    public static String KEY_DELETE_AFTER_SEND = "delete_after_send";
    // form entry
    public static String KEY_SAVE_MID = "save_mid";
    public static String KEY_JUMP_TO = "jump_to";
    public static String KEY_CHANGE_LANGUAGE = "change_language";
    public static String KEY_ACCESS_SETTINGS = "access_settings";
    public static String KEY_SAVE_AS = "save_as";
    public static String KEY_MARK_AS_FINALIZED = "mark_as_finalized";

    public static String KEY_AUTOSEND_WIFI = "autosend_wifi";
    public static String KEY_AUTOSEND_NETWORK = "autosend_network";

    public static String KEY_NAVIGATION = "navigation";
    public static String KEY_CONSTRAINT_BEHAVIOR = "constraint_behavior";

    private static final int SAVE_PREFS_MENU = Menu.FIRST;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setTitle(getString(R.string.app_name) + " > "
                + getString(R.string.admin_preferences));

        PreferenceManager prefMgr = getPreferenceManager();
        prefMgr.setSharedPreferencesName(ADMIN_PREFERENCES);
        prefMgr.setSharedPreferencesMode(MODE_WORLD_READABLE);

        addPreferencesFromResource(R.xml.admin_preferences);
    }

    @Override
	public boolean onCreateOptionsMenu(Menu menu) {
		Collect.getInstance().getActivityLogger()
			.logAction(this, "onCreateOptionsMenu", "show");
		super.onCreateOptionsMenu(menu);

		CompatibilityUtils.setShowAsAction(
    		menu.add(0, SAVE_PREFS_MENU, 0, R.string.save_preferences)
				.setIcon(R.drawable.ic_menu_save),
			MenuItem.SHOW_AS_ACTION_NEVER);
		return true;
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch (item.getItemId()) {
		case SAVE_PREFS_MENU:
			File writeDir = new File(Collect.getInstance().getOdkRoot() + "/settings");
			if (!writeDir.exists()) {
				if (!writeDir.mkdirs()) {
					Toast.makeText(
							this,
							"Error creating directory "
									+ writeDir.getAbsolutePath(),
							Toast.LENGTH_SHORT).show();
					return false;
				}
			}

			File dst = new File(writeDir.getAbsolutePath()
					+ "/collect.settings");
			boolean success = AdminPreferencesActivity.saveSharedPreferencesToFile(dst, this);
			if (success) {
				Toast.makeText(
						this,
						"Settings successfully written to "
								+ dst.getAbsolutePath(), Toast.LENGTH_LONG)
						.show();
			} else {
				Toast.makeText(this,
						"Error writing settings to " + dst.getAbsolutePath(),
						Toast.LENGTH_LONG).show();
			}
			return true;

		}
		return super.onOptionsItemSelected(item);
	}


	public static boolean saveSharedPreferencesToFile(File dst, Context context) {
		// this should be in a thread if it gets big, but for now it's tiny
		boolean res = false;
		ObjectOutputStream output = null;
		try {
			output = new ObjectOutputStream(new FileOutputStream(dst));
			SharedPreferences pref = PreferenceManager
					.getDefaultSharedPreferences(context);
			SharedPreferences adminPreferences = context.getSharedPreferences(
					AdminPreferencesActivity.ADMIN_PREFERENCES, 0);

			output.writeObject(pref.getAll());
			output.writeObject(adminPreferences.getAll());

			res = true;
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				if (output != null) {
					output.flush();
					output.close();
				}
			} catch (IOException ex) {
				ex.printStackTrace();
			}
		}
		return res;
	}

}


package org.odk.collect.android.preferences;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface.OnClickListener;
import android.preference.DialogPreference;
import android.util.AttributeSet;
import android.view.View;
import android.view.WindowManager;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;

public class PasswordDialogPreference extends DialogPreference implements
        OnClickListener {

    private EditText passwordEditText;
    private EditText verifyEditText;

    public PasswordDialogPreference(Context context, AttributeSet attrs) {
        super(context, attrs);
        setDialogLayoutResource(R.layout.password_dialog_layout);
    }

    @Override
    public void onBindDialogView(View view) {
        passwordEditText = (EditText) view.findViewById(R.id.pwd_field);
        verifyEditText = (EditText) view.findViewById(R.id.verify_field);

        final String adminPW = getPersistedString("");
        // populate the fields if a pw exists
        if (!adminPW.equalsIgnoreCase("")) {
            passwordEditText.setText(adminPW);
            passwordEditText.setSelection(passwordEditText.getText().length());
            verifyEditText.setText(adminPW);
        }

        Button positiveButton = (Button) view
                .findViewById(R.id.positive_button);
        positiveButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {

                String pw = passwordEditText.getText().toString();
                String ver = verifyEditText.getText().toString();

                if (!pw.equalsIgnoreCase("") && !ver.equalsIgnoreCase("") && pw.equals(ver)) {
                    // passwords are the same
                    persistString(pw);
                    Toast.makeText(PasswordDialogPreference.this.getContext(),
                            R.string.admin_password_changed, Toast.LENGTH_SHORT).show();
                    PasswordDialogPreference.this.getDialog().dismiss();
                    Collect.getInstance().getActivityLogger()
                            .logAction(this, "AdminPasswordDialog", "CHANGED");
                } else if (pw.equalsIgnoreCase("") && ver.equalsIgnoreCase("")) {
                    persistString("");
                    Toast.makeText(PasswordDialogPreference.this.getContext(),
                            R.string.admin_password_disabled, Toast.LENGTH_SHORT).show();
                    PasswordDialogPreference.this.getDialog().dismiss();
                    Collect.getInstance().getActivityLogger()
                            .logAction(this, "AdminPasswordDialog", "DISABLED");
                } else {
                    Toast.makeText(PasswordDialogPreference.this.getContext(),
                            R.string.admin_password_mismatch, Toast.LENGTH_SHORT).show();
                    Collect.getInstance().getActivityLogger()
                            .logAction(this, "AdminPasswordDialog", "MISMATCH");
                }
            }
        });

        Button negativeButton = (Button) view.findViewById(R.id.negative_button);
        negativeButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                PasswordDialogPreference.this.getDialog().dismiss();
                Collect.getInstance().getActivityLogger()
                        .logAction(this, "AdminPasswordDialog", "CANCELLED");
            }

        });

        super.onBindDialogView(view);
    }

    @Override
    protected void onClick() {
        super.onClick();
        // this seems to work to pop the keyboard when the dialog appears
        // i hope this isn't a race condition
        getDialog().getWindow().setSoftInputMode(
                WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);
    }

    @Override
    protected void onPrepareDialogBuilder(AlertDialog.Builder builder) {
        // we get rid of the default buttons (that close the dialog every time)
        builder.setPositiveButton(null, null);
        builder.setNegativeButton(null, null);
        super.onPrepareDialogBuilder(builder);
    }

}

/*
 * Copyright (C) 2014 Nafundi
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.preferences;

import android.content.SharedPreferences;
import android.net.Uri;
import android.os.Bundle;
import android.preference.EditTextPreference;
import android.preference.Preference;
import android.preference.Preference.OnPreferenceChangeListener;
import android.preference.PreferenceActivity;
import android.preference.PreferenceCategory;
import android.preference.PreferenceManager;
import android.text.InputFilter;
import android.text.Spanned;
import android.widget.Toast;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.utilities.UrlUtils;
import org.odk.collect.android.utilities.WebUtils;

/**
 * Handles aggregate specific preferences.
 * 
 * @author Carl Hartung (chartung@nafundi.com)
 */
public class AggregatePreferencesActivity extends PreferenceActivity {

	protected EditTextPreference mServerUrlPreference;
	protected EditTextPreference mUsernamePreference;
	protected EditTextPreference mPasswordPreference;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);

		addPreferencesFromResource(R.xml.aggregate_preferences);

		mServerUrlPreference = (EditTextPreference) findPreference(PreferencesActivity.KEY_SERVER_URL);
		mUsernamePreference = (EditTextPreference) findPreference(PreferencesActivity.KEY_USERNAME);
		mPasswordPreference = (EditTextPreference) findPreference(PreferencesActivity.KEY_PASSWORD);

		PreferenceCategory aggregatePreferences = (PreferenceCategory) findPreference(getString(R.string.aggregate_preferences));

		mServerUrlPreference
				.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {
					@Override
					public boolean onPreferenceChange(Preference preference,
							Object newValue) {
						String url = newValue.toString();

						// remove all trailing "/"s
						while (url.endsWith("/")) {
							url = url.substring(0, url.length() - 1);
						}

						if (UrlUtils.isValidUrl(url)) {
							preference.setSummary(newValue.toString());
							return true;
						} else {
							Toast.makeText(getApplicationContext(),
									R.string.url_error, Toast.LENGTH_SHORT)
									.show();
							return false;
						}
					}
				});
		mServerUrlPreference.setSummary(mServerUrlPreference.getText());
		mServerUrlPreference.getEditText().setFilters(
				new InputFilter[] { getReturnFilter() });

		mUsernamePreference.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {
            @Override
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                preference.setSummary((CharSequence) newValue);

                SharedPreferences settings = PreferenceManager.getDefaultSharedPreferences(getBaseContext());
                String server = settings.getString(PreferencesActivity.KEY_SERVER_URL, getString(R.string.default_server_url));
                Uri u = Uri.parse(server);
                WebUtils.clearHostCredentials(u.getHost());
                Collect.getInstance().getCookieStore().clear();

                return true;
            }
        });
		mUsernamePreference.setSummary(mUsernamePreference.getText());
		mUsernamePreference.getEditText().setFilters(
				new InputFilter[] { getReturnFilter() });

		mPasswordPreference
				.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {
					@Override
					public boolean onPreferenceChange(Preference preference,
							Object newValue) {
						String pw = newValue.toString();

						if (pw.length() > 0) {
							mPasswordPreference.setSummary("********");
						} else {
							mPasswordPreference.setSummary("");
						}

		                SharedPreferences settings = PreferenceManager.getDefaultSharedPreferences(getBaseContext());
		                String server = settings.getString(PreferencesActivity.KEY_SERVER_URL, getString(R.string.default_server_url));
		                Uri u = Uri.parse(server);
		                WebUtils.clearHostCredentials(u.getHost());
		                Collect.getInstance().getCookieStore().clear();

						return true;
					}
				});
		if (mPasswordPreference.getText() != null
				&& mPasswordPreference.getText().length() > 0) {
			mPasswordPreference.setSummary("********");
		}
		mPasswordPreference.getEditText().setFilters(
				new InputFilter[] { getReturnFilter() });
	}

	/**
	 * Disallows carriage returns from user entry
	 * 
	 * @return
	 */
	protected InputFilter getReturnFilter() {
		InputFilter returnFilter = new InputFilter() {
			public CharSequence filter(CharSequence source, int start, int end,
					Spanned dest, int dstart, int dend) {
				for (int i = start; i < end; i++) {
					if (Character.getType((source.charAt(i))) == Character.CONTROL) {
						return "";
					}
				}
				return null;
			}
		};
		return returnFilter;
	}

	protected InputFilter getWhitespaceFilter() {
		InputFilter whitespaceFilter = new InputFilter() {
			public CharSequence filter(CharSequence source, int start, int end,
					Spanned dest, int dstart, int dend) {
				for (int i = start; i < end; i++) {
					if (Character.isWhitespace(source.charAt(i))) {
						return "";
					}
				}
				return null;
			}
		};
		return whitespaceFilter;
	}

}

/*
 * Copyright (C) 2011 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.preferences;

import android.accounts.Account;
import android.accounts.AccountManager;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.preference.CheckBoxPreference;
import android.preference.EditTextPreference;
import android.preference.ListPreference;
import android.preference.Preference;
import android.preference.Preference.OnPreferenceChangeListener;
import android.preference.Preference.OnPreferenceClickListener;
import android.preference.PreferenceActivity;
import android.preference.PreferenceCategory;
import android.preference.PreferenceManager;
import android.preference.PreferenceScreen;
import android.provider.MediaStore.Images;
import android.text.InputFilter;
import android.text.Spanned;

import org.odk.collect.android.R;
import org.odk.collect.android.logic.FormController;
import org.odk.collect.android.logic.PropertyManager;

import java.util.ArrayList;

/**
 * Handles general preferences.
 *
 * @author Thomas Smyth, Sassafras Tech Collective (tom@sassafrastech.com; constraint behavior option)
 */
public class PreferencesActivity extends PreferenceActivity implements
		OnPreferenceChangeListener {

	public static final String INTENT_KEY_ADMIN_MODE = "adminMode";
	protected static final int IMAGE_CHOOSER = 0;

	// PUT ALL PREFERENCE KEYS HERE
	public static final String KEY_INFO = "info";
	public static final String KEY_LAST_VERSION = "lastVersion";
	public static final String KEY_FIRST_RUN = "firstRun";
	public static final String KEY_SHOW_SPLASH = "showSplash";
	public static final String KEY_SPLASH_PATH = "splashPath";
	public static final String KEY_FONT_SIZE = "font_size";
	public static final String KEY_DELETE_AFTER_SEND = "delete_send";

	public static final String KEY_PROTOCOL = "protocol";
	public static final String KEY_PROTOCOL_SETTINGS = "protocol_settings";

	// leaving these in the main screen because username can be used as a
	// pre-fill
	// value in a form
	public static final String KEY_SELECTED_GOOGLE_ACCOUNT = "selected_google_account";
	public static final String KEY_USERNAME = "username";
	public static final String KEY_PASSWORD = "password";

	// AGGREGATE SPECIFIC
	public static final String KEY_SERVER_URL = "server_url";

	// GME SPECIFIC
	public static final String KEY_GME_PROJECT_ID = "gme_project_id";
	public static final String KEY_GME_ID_HASHMAP = "gme_id_hashmap";

	// OTHER SPECIFIC
	public static final String KEY_FORMLIST_URL = "formlist_url";
	public static final String KEY_SUBMISSION_URL = "submission_url";

	public static final String NAVIGATION_SWIPE = "swipe";
	public static final String NAVIGATION_BUTTONS = "buttons";
	public static final String NAVIGATION_SWIPE_BUTTONS = "swipe_buttons";

	public static final String CONSTRAINT_BEHAVIOR_ON_SWIPE = "on_swipe";
	public static final String CONSTRAINT_BEHAVIOR_ON_FINALIZE = "on_finalize";
	public static final String CONSTRAINT_BEHAVIOR_DEFAULT = "on_swipe";

	public static final String KEY_COMPLETED_DEFAULT = "default_completed";

	public static final String KEY_HIGH_RESOLUTION = "high_resolution";

	public static final String KEY_AUTH = "auth";

	public static final String KEY_AUTOSEND_WIFI = "autosend_wifi";
	public static final String KEY_AUTOSEND_NETWORK = "autosend_network";

	public static final String KEY_NAVIGATION = "navigation";
	public static final String KEY_CONSTRAINT_BEHAVIOR = "constraint_behavior";

	private PreferenceScreen mSplashPathPreference;

	private ListPreference mSelectedGoogleAccountPreference;
	private ListPreference mFontSizePreference;
	private ListPreference mNavigationPreference;
	private ListPreference mConstraintBehaviorPreference;

	private CheckBoxPreference mAutosendWifiPreference;
	private CheckBoxPreference mAutosendNetworkPreference;
	private ListPreference mProtocolPreference;

	private PreferenceScreen mProtocolSettings;

	protected EditTextPreference mUsernamePreference;
	protected EditTextPreference mPasswordPreference;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		addPreferencesFromResource(R.xml.preferences);

		setTitle(getString(R.string.app_name) + " > "
				+ getString(R.string.general_preferences));

		// not super safe, but we're just putting in this mode to help
		// administrate
		// would require code to access it
		final boolean adminMode = getIntent().getBooleanExtra(INTENT_KEY_ADMIN_MODE, false);

		SharedPreferences adminPreferences = getSharedPreferences(
				AdminPreferencesActivity.ADMIN_PREFERENCES, 0);

		// assign all the preferences in advance because changing one often
		// affects another
		// also avoids npe
		PreferenceCategory autosendCategory = (PreferenceCategory) findPreference(getString(R.string.autosend));
		mAutosendWifiPreference = (CheckBoxPreference) findPreference(KEY_AUTOSEND_WIFI);
		mAutosendNetworkPreference = (CheckBoxPreference) findPreference(KEY_AUTOSEND_NETWORK);
		PreferenceCategory serverCategory = (PreferenceCategory) findPreference(getString(R.string.server_preferences));

		mProtocolPreference = (ListPreference) findPreference(KEY_PROTOCOL);

		mSelectedGoogleAccountPreference = (ListPreference) findPreference(KEY_SELECTED_GOOGLE_ACCOUNT);
		PreferenceCategory clientCategory = (PreferenceCategory) findPreference(getString(R.string.client));
		mNavigationPreference = (ListPreference) findPreference(KEY_NAVIGATION);
		mFontSizePreference = (ListPreference) findPreference(KEY_FONT_SIZE);
		Preference defaultFinalized = findPreference(KEY_COMPLETED_DEFAULT);
		Preference deleteAfterSend = findPreference(KEY_DELETE_AFTER_SEND);
		mSplashPathPreference = (PreferenceScreen) findPreference(KEY_SPLASH_PATH);
		mConstraintBehaviorPreference = (ListPreference) findPreference(KEY_CONSTRAINT_BEHAVIOR);

		mUsernamePreference = (EditTextPreference) findPreference(PreferencesActivity.KEY_USERNAME);
		mPasswordPreference = (EditTextPreference) findPreference(PreferencesActivity.KEY_PASSWORD);

		mProtocolSettings = (PreferenceScreen) findPreference(KEY_PROTOCOL_SETTINGS);

		boolean autosendWifiAvailable = adminPreferences.getBoolean(
				AdminPreferencesActivity.KEY_AUTOSEND_WIFI, true);
		if (!(autosendWifiAvailable || adminMode)) {
			autosendCategory.removePreference(mAutosendWifiPreference);
		}

		boolean autosendNetworkAvailable = adminPreferences.getBoolean(
				AdminPreferencesActivity.KEY_AUTOSEND_NETWORK, true);
		if (!(autosendNetworkAvailable || adminMode)) {
			autosendCategory.removePreference(mAutosendNetworkPreference);
		}

		if (!(autosendNetworkAvailable || autosendWifiAvailable || adminMode)) {
			getPreferenceScreen().removePreference(autosendCategory);
		}

		mProtocolPreference = (ListPreference) findPreference(KEY_PROTOCOL);
		mProtocolPreference.setSummary(mProtocolPreference.getEntry());
		Intent prefIntent = null;

		if (mProtocolPreference.getValue().equals(getString(R.string.protocol_odk_default))) {
			setDefaultAggregatePaths();
			prefIntent = new Intent(this, AggregatePreferencesActivity.class);
		} else {
			// other
			prefIntent = new Intent(this, OtherPreferencesActivity.class);
		}
		prefIntent.putExtra(INTENT_KEY_ADMIN_MODE, adminMode);
		mProtocolSettings.setIntent(prefIntent);

		mProtocolPreference.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {

			@Override
			public boolean onPreferenceChange(Preference preference,
					Object newValue) {
				String oldValue = ((ListPreference) preference).getValue();
				int index = ((ListPreference) preference)
						.findIndexOfValue(newValue.toString());
				String entry = (String) ((ListPreference) preference)
						.getEntries()[index];
				String value = (String) ((ListPreference) preference)
						.getEntryValues()[index];
				((ListPreference) preference).setSummary(entry);

				Intent prefIntent = null;
				if (value.equals(getString(R.string.protocol_odk_default))) {
					setDefaultAggregatePaths();
					prefIntent = new Intent(PreferencesActivity.this, AggregatePreferencesActivity.class);
				} else {
					// other
					prefIntent = new Intent(PreferencesActivity.this, OtherPreferencesActivity.class);
				}
				prefIntent.putExtra(INTENT_KEY_ADMIN_MODE, adminMode);
				mProtocolSettings.setIntent(prefIntent);

				if (!((String) newValue).equals(oldValue)) {
					startActivity(prefIntent);
				}

				return true;
			}
		});

		boolean changeProtocol = adminPreferences.getBoolean(
				AdminPreferencesActivity.KEY_CHANGE_SERVER, true);
		if (!(changeProtocol || adminMode)) {
			serverCategory.removePreference(mProtocolPreference);
		}
		boolean changeProtocolSettings = adminPreferences.getBoolean(
				AdminPreferencesActivity.KEY_CHANGE_PROTOCOL_SETTINGS, true);
		if (!(changeProtocolSettings || adminMode)) {
			serverCategory.removePreference(mProtocolSettings);
		}

		// get list of google accounts
		final Account[] accounts = AccountManager.get(getApplicationContext())
				.getAccountsByType("com.google");
		ArrayList<String> accountEntries = new ArrayList<String>();
		ArrayList<String> accountValues = new ArrayList<String>();

		for (int i = 0; i < accounts.length; i++) {
			accountEntries.add(accounts[i].name);
			accountValues.add(accounts[i].name);
		}
		accountEntries.add(getString(R.string.no_account));
		accountValues.add("");

		mSelectedGoogleAccountPreference.setEntries(accountEntries
				.toArray(new String[accountEntries.size()]));
		mSelectedGoogleAccountPreference.setEntryValues(accountValues
				.toArray(new String[accountValues.size()]));
		mSelectedGoogleAccountPreference
				.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {

					@Override
					public boolean onPreferenceChange(Preference preference,
							Object newValue) {
						int index = ((ListPreference) preference)
								.findIndexOfValue(newValue.toString());
						String value = (String) ((ListPreference) preference)
								.getEntryValues()[index];
						((ListPreference) preference).setSummary(value);
						return true;
					}
				});
		mSelectedGoogleAccountPreference
				.setSummary(mSelectedGoogleAccountPreference.getValue());

		boolean googleAccountAvailable = adminPreferences.getBoolean(
				AdminPreferencesActivity.KEY_CHANGE_GOOGLE_ACCOUNT, true);
		if (!(googleAccountAvailable || adminMode)) {
			serverCategory.removePreference(mSelectedGoogleAccountPreference);
		}

		mUsernamePreference.setOnPreferenceChangeListener(this);
		mUsernamePreference.setSummary(mUsernamePreference.getText());
		mUsernamePreference.getEditText().setFilters(
				new InputFilter[] { getReturnFilter() });

		boolean usernameAvailable = adminPreferences.getBoolean(
				AdminPreferencesActivity.KEY_CHANGE_USERNAME, true);
		if (!(usernameAvailable || adminMode)) {
			serverCategory.removePreference(mUsernamePreference);
		}

		mPasswordPreference
				.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {
					@Override
					public boolean onPreferenceChange(Preference preference,
							Object newValue) {
						String pw = newValue.toString();

						if (pw.length() > 0) {
							mPasswordPreference.setSummary("********");
						} else {
							mPasswordPreference.setSummary("");
						}
						return true;
					}
				});
		if (mPasswordPreference.getText() != null
				&& mPasswordPreference.getText().length() > 0) {
			mPasswordPreference.setSummary("********");
		}
		mPasswordPreference.getEditText().setFilters(
				new InputFilter[] { getReturnFilter() });

		boolean passwordAvailable = adminPreferences.getBoolean(
				AdminPreferencesActivity.KEY_CHANGE_PASSWORD, true);
		if (!(passwordAvailable || adminMode)) {
			serverCategory.removePreference(mPasswordPreference);
		}

		boolean navigationAvailable = adminPreferences.getBoolean(
				AdminPreferencesActivity.KEY_NAVIGATION, true);
		mNavigationPreference.setSummary(mNavigationPreference.getEntry());
		mNavigationPreference
				.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {

					@Override
					public boolean onPreferenceChange(Preference preference,
							Object newValue) {
						int index = ((ListPreference) preference)
								.findIndexOfValue(newValue.toString());
						String entry = (String) ((ListPreference) preference)
								.getEntries()[index];
						((ListPreference) preference).setSummary(entry);
						return true;
					}
				});
		if (!(navigationAvailable || adminMode)) {
			clientCategory.removePreference(mNavigationPreference);
		}

		boolean constraintBehaviorAvailable = adminPreferences.getBoolean(
				AdminPreferencesActivity.KEY_CONSTRAINT_BEHAVIOR, true);
		mConstraintBehaviorPreference.setSummary(mConstraintBehaviorPreference.getEntry());
		mConstraintBehaviorPreference
				.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {

					@Override
					public boolean onPreferenceChange(Preference preference,
							Object newValue) {
						int index = ((ListPreference) preference)
								.findIndexOfValue(newValue.toString());
						String entry = (String) ((ListPreference) preference)
								.getEntries()[index];
						((ListPreference) preference).setSummary(entry);
						return true;
					}
				});
		if (!(constraintBehaviorAvailable || adminMode)) {
			clientCategory.removePreference(mConstraintBehaviorPreference);
		}

		boolean fontAvailable = adminPreferences.getBoolean(
				AdminPreferencesActivity.KEY_CHANGE_FONT_SIZE, true);
		mFontSizePreference.setSummary(mFontSizePreference.getEntry());
		mFontSizePreference
				.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {

					@Override
					public boolean onPreferenceChange(Preference preference,
							Object newValue) {
						int index = ((ListPreference) preference)
								.findIndexOfValue(newValue.toString());
						String entry = (String) ((ListPreference) preference)
								.getEntries()[index];
						((ListPreference) preference).setSummary(entry);
						return true;
					}
				});
		if (!(fontAvailable || adminMode)) {
			clientCategory.removePreference(mFontSizePreference);
		}

		boolean defaultAvailable = adminPreferences.getBoolean(
				AdminPreferencesActivity.KEY_DEFAULT_TO_FINALIZED, true);

		if (!(defaultAvailable || adminMode)) {
			clientCategory.removePreference(defaultFinalized);
		}
		
		boolean deleteAfterAvailable = adminPreferences.getBoolean(
                AdminPreferencesActivity.KEY_DELETE_AFTER_SEND, true);
		if(!(deleteAfterAvailable || adminMode)) {
		    clientCategory.removePreference(deleteAfterSend);
		}
		

		boolean resolutionAvailable = adminPreferences.getBoolean(
				AdminPreferencesActivity.KEY_HIGH_RESOLUTION, true);

		Preference highResolution = findPreference(KEY_HIGH_RESOLUTION);
		if (!(resolutionAvailable || adminMode)) {
			clientCategory.removePreference(highResolution);
		}

		mSplashPathPreference
				.setOnPreferenceClickListener(new OnPreferenceClickListener() {

					private void launchImageChooser() {
						Intent i = new Intent(Intent.ACTION_GET_CONTENT);
						i.setType("image/*");
						startActivityForResult(i,
								PreferencesActivity.IMAGE_CHOOSER);
					}

					@Override
					public boolean onPreferenceClick(Preference preference) {
						// if you have a value, you can clear it or select new.
						CharSequence cs = mSplashPathPreference.getSummary();
						if (cs != null && cs.toString().contains("/")) {

							final CharSequence[] items = {
									getString(R.string.select_another_image),
									getString(R.string.use_odk_default) };

							AlertDialog.Builder builder = new AlertDialog.Builder(
									PreferencesActivity.this);
							builder.setTitle(getString(R.string.change_splash_path));
							builder.setNeutralButton(
									getString(R.string.cancel),
									new DialogInterface.OnClickListener() {
										@Override
										public void onClick(
												DialogInterface dialog, int id) {
											dialog.dismiss();
										}
									});
							builder.setItems(items,
									new DialogInterface.OnClickListener() {
										@Override
										public void onClick(
												DialogInterface dialog, int item) {
											if (items[item]
													.equals(getString(R.string.select_another_image))) {
												launchImageChooser();
											} else {
												setSplashPath(getString(R.string.default_splash_path));
											}
										}
									});
							AlertDialog alert = builder.create();
							alert.show();

						} else {
							launchImageChooser();
						}

						return true;
					}
				});

		mSplashPathPreference.setSummary(mSplashPathPreference
				.getSharedPreferences().getString(KEY_SPLASH_PATH,
						getString(R.string.default_splash_path)));

		boolean showSplashAvailable = adminPreferences.getBoolean(
				AdminPreferencesActivity.KEY_SHOW_SPLASH_SCREEN, true);

		CheckBoxPreference showSplashPreference = (CheckBoxPreference) findPreference(KEY_SHOW_SPLASH);

		if (!(showSplashAvailable || adminMode)) {
			clientCategory.removePreference(showSplashPreference);
			clientCategory.removePreference(mSplashPathPreference);
		}

		if (!(fontAvailable || defaultAvailable
				|| showSplashAvailable || navigationAvailable || adminMode || resolutionAvailable)) {
			getPreferenceScreen().removePreference(clientCategory);
		}

	}

	@Override
	protected void onPause() {
		super.onPause();
		
		// the property manager should be re-assigned, as properties 
		// may have changed.
        PropertyManager mgr = new PropertyManager(this);
        FormController.initializeJavaRosa(mgr);
	}

	@Override
	protected void onResume() {
		super.onResume();

		// has to go in onResume because it may get updated by
		// a sub-preference screen
		// this just keeps the widgets in sync
		SharedPreferences sp = PreferenceManager
				.getDefaultSharedPreferences(this);
		String account = sp.getString(KEY_SELECTED_GOOGLE_ACCOUNT, "");
		mSelectedGoogleAccountPreference.setSummary(account);
		mSelectedGoogleAccountPreference.setValue(account);

		String user = sp.getString(KEY_USERNAME, "");
		String pw = sp.getString(KEY_PASSWORD, "");
		mUsernamePreference.setSummary(user);
		mUsernamePreference.setText(user);
		if (pw != null && pw.length() > 0) {
			mPasswordPreference.setSummary("********");
			mPasswordPreference.setText(pw);
		}

	}

	private void setSplashPath(String path) {
		SharedPreferences sharedPreferences = PreferenceManager
				.getDefaultSharedPreferences(this);
		Editor editor = sharedPreferences.edit();
		editor.putString(KEY_SPLASH_PATH, path);
		editor.commit();

		mSplashPathPreference = (PreferenceScreen) findPreference(KEY_SPLASH_PATH);
		mSplashPathPreference.setSummary(mSplashPathPreference
				.getSharedPreferences().getString(KEY_SPLASH_PATH,
						getString(R.string.default_splash_path)));
	}

	@Override
	protected void onActivityResult(int requestCode, int resultCode,
			Intent intent) {
		super.onActivityResult(requestCode, resultCode, intent);
		if (resultCode == RESULT_CANCELED) {
			// request was canceled, so do nothing
			return;
		}

		switch (requestCode) {
		case IMAGE_CHOOSER:
			String sourceImagePath = null;

			// get gp of chosen file
			Uri uri = intent.getData();
			if (uri.toString().startsWith("file")) {
				sourceImagePath = uri.toString().substring(6);
			} else {
				String[] projection = { Images.Media.DATA };
				Cursor c = null;
				try {
					c = getContentResolver().query(uri, projection, null, null,
							null);
					int i = c.getColumnIndexOrThrow(Images.Media.DATA);
					c.moveToFirst();
					sourceImagePath = c.getString(i);
				} finally {
					if (c != null) {
						c.close();
					}
				}
			}

			// setting image path
			setSplashPath(sourceImagePath);
			break;
		}
	}

	private void setDefaultAggregatePaths() {
		SharedPreferences sp = PreferenceManager
				.getDefaultSharedPreferences(this);
		Editor editor = sp.edit();
		editor.putString(KEY_FORMLIST_URL,
				getString(R.string.default_odk_formlist));
		editor.putString(KEY_SUBMISSION_URL,
				getString(R.string.default_odk_submission));
		editor.commit();
	}

	/**
	 * Disallows carriage returns from user entry
	 *
	 * @return
	 */
	protected InputFilter getReturnFilter() {
		InputFilter returnFilter = new InputFilter() {
			public CharSequence filter(CharSequence source, int start, int end,
					Spanned dest, int dstart, int dend) {
				for (int i = start; i < end; i++) {
					if (Character.getType((source.charAt(i))) == Character.CONTROL) {
						return "";
					}
				}
				return null;
			}
		};
		return returnFilter;
	}

	/**
	 * Generic listener that sets the summary to the newly selected/entered
	 * value
	 */
	@Override
	public boolean onPreferenceChange(Preference preference, Object newValue) {
		preference.setSummary((CharSequence) newValue);
		return true;
	}

}

/*
 * Copyright (C) 2014 Nafundi
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.preferences;

import android.content.SharedPreferences;
import android.os.Bundle;
import android.preference.EditTextPreference;
import android.preference.Preference;
import android.preference.Preference.OnPreferenceChangeListener;
import android.preference.PreferenceCategory;
import android.text.InputFilter;

import org.odk.collect.android.R;

/**
 * Handles 'other' specific preferences.
 * 
 * @author Carl Hartung (chartung@nafundi.com)
 */
public class OtherPreferencesActivity extends AggregatePreferencesActivity
		implements OnPreferenceChangeListener {

	protected EditTextPreference mSubmissionUrlPreference;
	protected EditTextPreference mFormListUrlPreference;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);

		addPreferencesFromResource(R.xml.other_preferences);

		SharedPreferences adminPreferences = getSharedPreferences(
				AdminPreferencesActivity.ADMIN_PREFERENCES, 0);

		mFormListUrlPreference = (EditTextPreference) findPreference(PreferencesActivity.KEY_FORMLIST_URL);
		mSubmissionUrlPreference = (EditTextPreference) findPreference(PreferencesActivity.KEY_SUBMISSION_URL);

		PreferenceCategory otherPreferences = (PreferenceCategory) findPreference(getString(R.string.other_preferences));

		mFormListUrlPreference.setOnPreferenceChangeListener(this);
		mFormListUrlPreference.setSummary(mFormListUrlPreference.getText());
		mServerUrlPreference.getEditText().setFilters(
				new InputFilter[] { getReturnFilter(), getWhitespaceFilter() });

		mSubmissionUrlPreference.setOnPreferenceChangeListener(this);
		mSubmissionUrlPreference.setSummary(mSubmissionUrlPreference.getText());
		mServerUrlPreference.getEditText().setFilters(
				new InputFilter[] { getReturnFilter(), getWhitespaceFilter() });
	}

	/**
	 * Generic listener that sets the summary to the newly selected/entered
	 * value
	 */
	@Override
	public boolean onPreferenceChange(Preference preference, Object newValue) {
		preference.setSummary((CharSequence) newValue);
		return true;
	}

}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.tasks;

import android.content.ContentValues;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.net.Uri;
import android.os.AsyncTask;
import android.preference.PreferenceManager;
import android.util.Log;
import android.webkit.MimeTypeMap;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.listeners.InstanceUploaderListener;
import org.odk.collect.android.logic.PropertyManager;
import org.odk.collect.android.preferences.PreferencesActivity;
import org.odk.collect.android.provider.InstanceProviderAPI;
import org.odk.collect.android.provider.InstanceProviderAPI.InstanceColumns;
import org.odk.collect.android.utilities.WebUtils;
import org.opendatakit.httpclientandroidlib.Header;
import org.opendatakit.httpclientandroidlib.HttpResponse;
import org.opendatakit.httpclientandroidlib.HttpStatus;
import org.opendatakit.httpclientandroidlib.client.ClientProtocolException;
import org.opendatakit.httpclientandroidlib.client.HttpClient;
import org.opendatakit.httpclientandroidlib.client.methods.HttpHead;
import org.opendatakit.httpclientandroidlib.client.methods.HttpPost;
import org.opendatakit.httpclientandroidlib.conn.ConnectTimeoutException;
import org.opendatakit.httpclientandroidlib.conn.HttpHostConnectException;
import org.opendatakit.httpclientandroidlib.entity.mime.MultipartEntity;
import org.opendatakit.httpclientandroidlib.entity.mime.content.FileBody;
import org.opendatakit.httpclientandroidlib.entity.mime.content.StringBody;
import org.opendatakit.httpclientandroidlib.protocol.HttpContext;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.SocketTimeoutException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.net.UnknownHostException;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Background task for uploading completed forms.
 *
 * @author Carl Hartung (carlhartung@gmail.com)
 */
public class InstanceUploaderTask extends AsyncTask<Long, Integer, InstanceUploaderTask.Outcome> {

    private static final String t = "InstanceUploaderTask";
    // it can take up to 27 seconds to spin up Aggregate
    private static final int CONNECTION_TIMEOUT = 60000;
    private static final String fail = "Error: ";

    private InstanceUploaderListener mStateListener;

    public static class Outcome {
        public Uri authRequestingServer = null;
        public HashMap<String, String> results = new HashMap<String,String>();
    }

    /**
     * Uploads to urlString the submission identified by id with filepath of instance
     * @param urlString destination URL
     * @param id
     * @param instanceFilePath
     * @param toUpdate - Instance URL for recording status update.
     * @param localContext - context (e.g., credentials, cookies) for client connection
     * @param uriRemap - mapping of Uris to avoid redirects on subsequent invocations
     * @return false if credentials are required and we should terminate immediately.
     */
    private boolean uploadOneSubmission(String urlString, String id, String instanceFilePath,
    			Uri toUpdate, HttpContext localContext, Map<Uri, Uri> uriRemap, Outcome outcome) {

    	Collect.getInstance().getActivityLogger().logAction(this, urlString, instanceFilePath);

        File instanceFile = new File(instanceFilePath);
        ContentValues cv = new ContentValues();
        Uri u = Uri.parse(urlString);
        HttpClient httpclient = WebUtils.createHttpClient(CONNECTION_TIMEOUT);

        boolean openRosaServer = false;
        if (uriRemap.containsKey(u)) {
            // we already issued a head request and got a response,
            // so we know the proper URL to send the submission to
            // and the proper scheme. We also know that it was an
            // OpenRosa compliant server.
            openRosaServer = true;
            u = uriRemap.get(u);

            // if https then enable preemptive basic auth...
            if ( u.getScheme().equals("https") ) {
            	WebUtils.enablePreemptiveBasicAuth(localContext, u.getHost());
            }

            Log.i(t, "Using Uri remap for submission " + id + ". Now: " + u.toString());
        } else {

            // if https then enable preemptive basic auth...
            if ( u.getScheme() != null && u.getScheme().equals("https") ) {
            	WebUtils.enablePreemptiveBasicAuth(localContext, u.getHost());
            }

            // we need to issue a head request
            HttpHead httpHead = WebUtils.createOpenRosaHttpHead(u);

            // prepare response
            HttpResponse response = null;
            try {
                Log.i(t, "Issuing HEAD request for " + id + " to: " + u.toString());

                response = httpclient.execute(httpHead, localContext);
                int statusCode = response.getStatusLine().getStatusCode();
                if (statusCode == HttpStatus.SC_UNAUTHORIZED) {
            		// clear the cookies -- should not be necessary?
            		Collect.getInstance().getCookieStore().clear();

                	WebUtils.discardEntityBytes(response);
            		// we need authentication, so stop and return what we've
                    // done so far.
                	outcome.authRequestingServer = u;
                    return false;
                } else if (statusCode == 204) {
                	Header[] locations = response.getHeaders("Location");
                	WebUtils.discardEntityBytes(response);
                    if (locations != null && locations.length == 1) {
                        try {
                            Uri uNew = Uri.parse(URLDecoder.decode(locations[0].getValue(), "utf-8"));
                            if (u.getHost().equalsIgnoreCase(uNew.getHost())) {
                                openRosaServer = true;
                                // trust the server to tell us a new location
                                // ... and possibly to use https instead.
                                uriRemap.put(u, uNew);
                                u = uNew;
                            } else {
                                // Don't follow a redirection attempt to a different host.
                                // We can't tell if this is a spoof or not.
                            	outcome.results.put(
                                        id,
                                        fail
                                                + "Unexpected redirection attempt to a different host: "
                                                + uNew.toString());
                                cv.put(InstanceColumns.STATUS,
                                    InstanceProviderAPI.STATUS_SUBMISSION_FAILED);
                                Collect.getInstance().getApplication().getContentResolver()
                                        .update(toUpdate, cv, null, null);
                                return true;
                            }
                        } catch (Exception e) {
                            e.printStackTrace();
                            outcome.results.put(id, fail + urlString + " " + e.toString());
                            cv.put(InstanceColumns.STATUS,
                                InstanceProviderAPI.STATUS_SUBMISSION_FAILED);
                            Collect.getInstance().getApplication().getContentResolver()
                                    .update(toUpdate, cv, null, null);
                            return true;
                        }
                    }
                } else {
                    // may be a server that does not handle
                	WebUtils.discardEntityBytes(response);

                    Log.w(t, "Status code on Head request: " + statusCode);
                    if (statusCode >= HttpStatus.SC_OK && statusCode < HttpStatus.SC_MULTIPLE_CHOICES) {
                    	outcome.results.put(
                                id,
                                fail
                                        + "Invalid status code on Head request.  If you have a web proxy, you may need to login to your network. ");
                        cv.put(InstanceColumns.STATUS,
                            InstanceProviderAPI.STATUS_SUBMISSION_FAILED);
                        Collect.getInstance().getApplication().getContentResolver()
                                .update(toUpdate, cv, null, null);
                        return true;
                    }
                }
            } catch (ClientProtocolException e) {
                e.printStackTrace();
                Log.e(t, e.toString());
                WebUtils.clearHttpConnectionManager();
                outcome.results.put(id, fail + "Client Protocol Exception");
                cv.put(InstanceColumns.STATUS, InstanceProviderAPI.STATUS_SUBMISSION_FAILED);
                Collect.getInstance().getApplication().getContentResolver().update(toUpdate, cv, null, null);
                return true;
            } catch (ConnectTimeoutException e) {
                e.printStackTrace();
                Log.e(t, e.toString());
                WebUtils.clearHttpConnectionManager();
                outcome.results.put(id, fail + "Connection Timeout");
                cv.put(InstanceColumns.STATUS, InstanceProviderAPI.STATUS_SUBMISSION_FAILED);
                Collect.getInstance().getApplication().getContentResolver().update(toUpdate, cv, null, null);
                return true;
            } catch (UnknownHostException e) {
                e.printStackTrace();
                Log.e(t, e.toString());
                WebUtils.clearHttpConnectionManager();
                outcome.results.put(id, fail + e.toString() + " :: Network Connection Failed");
                cv.put(InstanceColumns.STATUS, InstanceProviderAPI.STATUS_SUBMISSION_FAILED);
                Collect.getInstance().getApplication().getContentResolver().update(toUpdate, cv, null, null);
                return true;
            } catch (SocketTimeoutException e) {
                e.printStackTrace();
                Log.e(t, e.toString());
                WebUtils.clearHttpConnectionManager();
                outcome.results.put(id, fail + "Connection Timeout");
                cv.put(InstanceColumns.STATUS, InstanceProviderAPI.STATUS_SUBMISSION_FAILED);
                Collect.getInstance().getApplication().getContentResolver().update(toUpdate, cv, null, null);
                return true;
            } catch (HttpHostConnectException e) {
                e.printStackTrace();
                Log.e(t, e.toString());
                WebUtils.clearHttpConnectionManager();
                outcome.results.put(id, fail + "Network Connection Refused");
                cv.put(InstanceColumns.STATUS, InstanceProviderAPI.STATUS_SUBMISSION_FAILED);
                Collect.getInstance().getApplication().getContentResolver().update(toUpdate, cv, null, null);
                return true;
            } catch (Exception e) {
                e.printStackTrace();
                Log.e(t, e.toString());
                WebUtils.clearHttpConnectionManager();
                String msg = e.getMessage();
                if (msg == null) {
                    msg = e.toString();
                }
                outcome.results.put(id, fail + "Generic Exception: " + msg);
                cv.put(InstanceColumns.STATUS, InstanceProviderAPI.STATUS_SUBMISSION_FAILED);
                Collect.getInstance().getApplication().getContentResolver().update(toUpdate, cv, null, null);
                return true;
            }
        }

        // At this point, we may have updated the uri to use https.
        // This occurs only if the Location header keeps the host name
        // the same. If it specifies a different host name, we error
        // out.
        //
        // And we may have set authentication cookies in our
        // cookiestore (referenced by localContext) that will enable
        // authenticated publication to the server.
        //
        // get instance file

        // Under normal operations, we upload the instanceFile to
        // the server.  However, during the save, there is a failure
        // window that may mark the submission as complete but leave
        // the file-to-be-uploaded with the name "submission.xml" and
        // the plaintext submission files on disk.  In this case,
        // upload the submission.xml and all the files in the directory.
        // This means the plaintext files and the encrypted files
        // will be sent to the server and the server will have to
        // figure out what to do with them.
        File submissionFile = new File(instanceFile.getParentFile(), "submission.xml");
        if ( submissionFile.exists() ) {
            Log.w(t, "submission.xml will be uploaded instead of " + instanceFile.getAbsolutePath());
        } else {
            submissionFile = instanceFile;
        }

        if (!instanceFile.exists() && !submissionFile.exists()) {
        	outcome.results.put(id, fail + "instance XML file does not exist!");
            cv.put(InstanceColumns.STATUS, InstanceProviderAPI.STATUS_SUBMISSION_FAILED);
            Collect.getInstance().getApplication().getContentResolver().update(toUpdate, cv, null, null);
            return true;
        }

        // find all files in parent directory
        File[] allFiles = instanceFile.getParentFile().listFiles();

        // add media files
        List<File> files = new ArrayList<File>();
        for (File f : allFiles) {
            String fileName = f.getName();

            int dotIndex = fileName.lastIndexOf(".");
            String extension = "";
            if (dotIndex != -1) {
                extension = fileName.substring(dotIndex + 1);
            }

            if (fileName.startsWith(".")) {
                // ignore invisible files
                continue;
            }
            if (fileName.equals(instanceFile.getName())) {
                continue; // the xml file has already been added
            } else if (fileName.equals(submissionFile.getName())) {
                continue; // the xml file has already been added
            } else if (openRosaServer) {
                files.add(f);
            } else if (extension.equals("jpg")) { // legacy 0.9x
                files.add(f);
            } else if (extension.equals("3gpp")) { // legacy 0.9x
                files.add(f);
            } else if (extension.equals("3gp")) { // legacy 0.9x
                files.add(f);
            } else if (extension.equals("mp4")) { // legacy 0.9x
                files.add(f);
            } else {
                Log.w(t, "unrecognized file type " + f.getName());
            }
        }

        boolean first = true;
        int j = 0;
        int lastJ;
        while (j < files.size() || first) {
        	lastJ = j;
            first = false;

            HttpPost httppost = WebUtils.createOpenRosaHttpPost(u);

            MimeTypeMap m = MimeTypeMap.getSingleton();

            long byteCount = 0L;

            // mime post
            MultipartEntity entity = new MultipartEntity();

            // add the submission file first...
            FileBody fb = new FileBody(submissionFile, "text/xml");
            entity.addPart("xml_submission_file", fb);
            Log.i(t, "added xml_submission_file: " + submissionFile.getName());
            byteCount += submissionFile.length();

            for (; j < files.size(); j++) {
                File f = files.get(j);
                String fileName = f.getName();
                int idx = fileName.lastIndexOf(".");
                String extension = "";
                if (idx != -1) {
                    extension = fileName.substring(idx + 1);
                }
                String contentType = m.getMimeTypeFromExtension(extension);

                // we will be processing every one of these, so
                // we only need to deal with the content type determination...
                if (extension.equals("xml")) {
                    fb = new FileBody(f, "text/xml");
                    entity.addPart(f.getName(), fb);
                    byteCount += f.length();
                    Log.i(t, "added xml file " + f.getName());
                } else if (extension.equals("jpg")) {
                    fb = new FileBody(f, "image/jpeg");
                    entity.addPart(f.getName(), fb);
                    byteCount += f.length();
                    Log.i(t, "added image file " + f.getName());
                } else if (extension.equals("3gpp")) {
                    fb = new FileBody(f, "audio/3gpp");
                    entity.addPart(f.getName(), fb);
                    byteCount += f.length();
                    Log.i(t, "added audio file " + f.getName());
                } else if (extension.equals("3gp")) {
                    fb = new FileBody(f, "video/3gpp");
                    entity.addPart(f.getName(), fb);
                    byteCount += f.length();
                    Log.i(t, "added video file " + f.getName());
                } else if (extension.equals("mp4")) {
                    fb = new FileBody(f, "video/mp4");
                    entity.addPart(f.getName(), fb);
                    byteCount += f.length();
                    Log.i(t, "added video file " + f.getName());
                } else if (extension.equals("csv")) {
                    fb = new FileBody(f, "text/csv");
                    entity.addPart(f.getName(), fb);
                    byteCount += f.length();
                    Log.i(t, "added csv file " + f.getName());
                } else if (f.getName().endsWith(".amr")) {
                    fb = new FileBody(f, "audio/amr");
                    entity.addPart(f.getName(), fb);
                    Log.i(t, "added audio file " + f.getName());
                } else if (extension.equals("xls")) {
                    fb = new FileBody(f, "application/vnd.ms-excel");
                    entity.addPart(f.getName(), fb);
                    byteCount += f.length();
                    Log.i(t, "added xls file " + f.getName());
                } else if (contentType != null) {
                    fb = new FileBody(f, contentType);
                    entity.addPart(f.getName(), fb);
                    byteCount += f.length();
                    Log.i(t,
                        "added recognized filetype (" + contentType + ") " + f.getName());
                } else {
                    contentType = "application/octet-stream";
                    fb = new FileBody(f, contentType);
                    entity.addPart(f.getName(), fb);
                    byteCount += f.length();
                    Log.w(t, "added unrecognized file (" + contentType + ") " + f.getName());
                }

                // we've added at least one attachment to the request...
                if (j + 1 < files.size()) {
                    if ((j-lastJ+1 > 100) || (byteCount + files.get(j + 1).length() > 10000000L)) {
                        // the next file would exceed the 10MB threshold...
                        Log.i(t, "Extremely long post is being split into multiple posts");
                        try {
                            StringBody sb = new StringBody("yes", Charset.forName("UTF-8"));
                            entity.addPart("*isIncomplete*", sb);
                        } catch (Exception e) {
                            e.printStackTrace(); // never happens...
                        }
                        ++j; // advance over the last attachment added...
                        break;
                    }
                }
            }

            httppost.setEntity(entity);

            // prepare response and return uploaded
            HttpResponse response = null;
            try {
                Log.i(t, "Issuing POST request for " + id + " to: " + u.toString());
                response = httpclient.execute(httppost, localContext);
                int responseCode = response.getStatusLine().getStatusCode();
                WebUtils.discardEntityBytes(response);

                Log.i(t, "Response code:" + responseCode);
                // verify that the response was a 201 or 202.
                // If it wasn't, the submission has failed.
                if (responseCode != HttpStatus.SC_CREATED && responseCode != HttpStatus.SC_ACCEPTED) {
                    if (responseCode == HttpStatus.SC_OK) {
                    	outcome.results.put(id, fail + "Network login failure? Again?");
                    } else if (responseCode == HttpStatus.SC_UNAUTHORIZED) {
                		// clear the cookies -- should not be necessary?
                    	Collect.getInstance().getCookieStore().clear();
                    	outcome.results.put(id, fail + response.getStatusLine().getReasonPhrase()
                                + " (" + responseCode + ") at " + urlString);
                    } else {
                    	outcome.results.put(id, fail + response.getStatusLine().getReasonPhrase()
                                + " (" + responseCode + ") at " + urlString);
                    }
                    cv.put(InstanceColumns.STATUS,
                        InstanceProviderAPI.STATUS_SUBMISSION_FAILED);
                    Collect.getInstance().getApplication().getContentResolver()
                            .update(toUpdate, cv, null, null);
                    return true;
                }
            } catch (Exception e) {
                e.printStackTrace();
                Log.e(t, e.toString());
                WebUtils.clearHttpConnectionManager();
                String msg = e.getMessage();
                if (msg == null) {
                    msg = e.toString();
                }
                outcome.results.put(id, fail + "Generic Exception: " + msg);
                cv.put(InstanceColumns.STATUS, InstanceProviderAPI.STATUS_SUBMISSION_FAILED);
                Collect.getInstance().getApplication().getContentResolver().update(toUpdate, cv, null, null);
                return true;
            }
        }

        // if it got here, it must have worked
        outcome.results.put(id, Collect.getInstance().getApplication().getString(R.string.success));
        cv.put(InstanceColumns.STATUS, InstanceProviderAPI.STATUS_SUBMITTED);
        Collect.getInstance().getApplication().getContentResolver().update(toUpdate, cv, null, null);
        return true;
    }

    // TODO: This method is like 350 lines long, down from 400.
    // still. ridiculous. make it smaller.
    protected Outcome doInBackground(Long... values) {
    	Outcome outcome = new Outcome();

        String selection = InstanceColumns._ID + "=?";
        String[] selectionArgs = new String[(values == null) ? 0 : values.length];
        if ( values != null ) {
	        for (int i = 0; i < values.length; i++) {
	            if (i != values.length - 1) {
	                selection += " or " + InstanceColumns._ID + "=?";
	            }
	            selectionArgs[i] = values[i].toString();
	        }
        }

        String deviceId = new PropertyManager(
                Collect.getInstance().getApplication().getApplicationContext())
                .getSingularProperty(PropertyManager.OR_DEVICE_ID_PROPERTY);

        // get shared HttpContext so that authentication and cookies are retained.
        HttpContext localContext = Collect.getInstance().getHttpContext();

        Map<Uri, Uri> uriRemap = new HashMap<Uri, Uri>();

        Cursor c = null;
        try {
        	c = Collect.getInstance().getApplication().getContentResolver()
                    .query(InstanceColumns.CONTENT_URI, null, selection, selectionArgs, null);

	        if (c.getCount() > 0) {
	            c.moveToPosition(-1);
	            while (c.moveToNext()) {
	                if (isCancelled()) {
	                    return outcome;
	                }
	                publishProgress(c.getPosition() + 1, c.getCount());
	                String instance = c.getString(c.getColumnIndex(InstanceColumns.INSTANCE_FILE_PATH));
	                String id = c.getString(c.getColumnIndex(InstanceColumns._ID));
	                Uri toUpdate = Uri.withAppendedPath(InstanceColumns.CONTENT_URI, id);

	                int subIdx = c.getColumnIndex(InstanceColumns.SUBMISSION_URI);
	                String urlString = c.isNull(subIdx) ? null : c.getString(subIdx);
	                if (urlString == null) {
	                    SharedPreferences settings =
	                        PreferenceManager.getDefaultSharedPreferences(
                                    Collect.getInstance().getApplication());
	                    urlString = settings.getString(PreferencesActivity.KEY_SERVER_URL,
	                    				Collect.getInstance().getApplication().getString(R.string.default_server_url));
	                    if ( urlString.charAt(urlString.length()-1) == '/') {
	                    	urlString = urlString.substring(0, urlString.length()-1);
	                    }
	                    // NOTE: /submission must not be translated! It is the well-known path on the server.
	                    String submissionUrl =
	                        settings.getString(PreferencesActivity.KEY_SUBMISSION_URL,
	                        		Collect.getInstance().getApplication().getString(R.string.default_odk_submission));
	                    if ( submissionUrl.charAt(0) != '/') {
	                    	submissionUrl = "/" + submissionUrl;
	                    }

	                    urlString = urlString + submissionUrl;
	                }

	                // add the deviceID to the request...
	                try {
						urlString += "?deviceID=" + URLEncoder.encode(deviceId, "UTF-8");
					} catch (UnsupportedEncodingException e) {
						// unreachable...
					}

	                if ( !uploadOneSubmission(urlString, id, instance, toUpdate, localContext, uriRemap, outcome) ) {
	                	return outcome; // get credentials...
	                }
	            }
	        }
        } finally {
            if (c != null) {
                c.close();
            }
        }

        return outcome;
    }


    @Override
    protected void onPostExecute(Outcome outcome) {
        synchronized (this) {
            if (mStateListener != null) {
                if (outcome.authRequestingServer != null) {
                    mStateListener.authRequest(outcome.authRequestingServer, outcome.results);
                } else {
                    mStateListener.uploadingComplete(outcome.results);
                    
                    StringBuilder selection = new StringBuilder();
                    Set<String> keys = outcome.results.keySet();
                    Iterator<String> it = keys.iterator();

                    String[] selectionArgs = new String[keys.size()+1];
                    int i = 0;
                    selection.append("(");
                    while (it.hasNext()) {
                        String id = it.next();
                        selection.append(InstanceColumns._ID + "=?");
                        selectionArgs[i++] = id;
                        if (i != keys.size()) {
                            selection.append(" or ");
                        }
                    }
                    selection.append(") and status=?");
                    selectionArgs[i] = InstanceProviderAPI.STATUS_SUBMITTED;

                    Cursor results = null;
                    try {
                        results = Collect
                                .getInstance()
                                .getApplication()
                                .getContentResolver()
                                .query(InstanceColumns.CONTENT_URI, null, selection.toString(),
                                        selectionArgs, null);
                        if (results.getCount() > 0) {
                            Long[] toDelete = new Long[results.getCount()];
                            results.moveToPosition(-1);

                            int cnt = 0;
                            while (results.moveToNext()) {
                                toDelete[cnt] = results.getLong(results
                                        .getColumnIndex(InstanceColumns._ID));
                                cnt++;
                            }

                            boolean deleteFlag = PreferenceManager.getDefaultSharedPreferences(
                                    Collect.getInstance().getApplication().getApplicationContext()).getBoolean(
                                    PreferencesActivity.KEY_DELETE_AFTER_SEND, false);
                            if (deleteFlag) {
                                DeleteInstancesTask dit = new DeleteInstancesTask();
                                dit.setContentResolver(Collect.getInstance().getApplication().getContentResolver());
                                dit.execute(toDelete);
                            }

                        }
                    } finally {
                        if (results != null) {
                            results.close();
                        }
                    }
                }
            }
        }
    }


    @Override
    protected void onProgressUpdate(Integer... values) {
        synchronized (this) {
            if (mStateListener != null) {
                // update progress and total
                mStateListener.progressUpdate(values[0].intValue(), values[1].intValue());
            }
        }
    }


    public void setUploaderListener(InstanceUploaderListener sl) {
        synchronized (this) {
            mStateListener = sl;
        }
    }
    
    
    public static void copyToBytes(InputStream input, OutputStream output,
            int bufferSize) throws IOException {
        byte[] buf = new byte[bufferSize];
        int bytesRead = input.read(buf);
        while (bytesRead != -1) {
            output.write(buf, 0, bytesRead);
            bytesRead = input.read(buf);
        }
        output.flush();
    }
    
}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.tasks;

import android.content.ContentValues;
import android.database.Cursor;
import android.net.Uri;
import android.os.AsyncTask;
import android.util.Log;

import org.javarosa.xform.parse.XFormParser;
import org.kxml2.kdom.Element;
import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.exception.TaskCancelledException;
import org.odk.collect.android.listeners.FormDownloaderListener;
import org.odk.collect.android.logic.FormDetails;
import org.odk.collect.android.provider.FormsProviderAPI.FormsColumns;
import org.odk.collect.android.utilities.DocumentFetchResult;
import org.odk.collect.android.utilities.FileUtils;
import org.odk.collect.android.utilities.WebUtils;
import org.opendatakit.httpclientandroidlib.Header;
import org.opendatakit.httpclientandroidlib.HttpEntity;
import org.opendatakit.httpclientandroidlib.HttpResponse;
import org.opendatakit.httpclientandroidlib.HttpStatus;
import org.opendatakit.httpclientandroidlib.client.HttpClient;
import org.opendatakit.httpclientandroidlib.client.methods.HttpGet;
import org.opendatakit.httpclientandroidlib.protocol.HttpContext;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.zip.GZIPInputStream;

/**
 * Background task for downloading a given list of forms. We assume right now that the forms are
 * coming from the same server that presented the form list, but theoretically that won't always be
 * true.
 *
 * @author msundt
 * @author carlhartung
 */
public class DownloadFormsTask extends
        AsyncTask<ArrayList<FormDetails>, String, HashMap<FormDetails, String>> {

    private static final String t = "DownloadFormsTask";

    private static final String MD5_COLON_PREFIX = "md5:";
    private static final String TEMP_DOWNLOAD_EXTENSION = ".tempDownload";

    private FormDownloaderListener mStateListener;

    private static final String NAMESPACE_OPENROSA_ORG_XFORMS_XFORMS_MANIFEST =
        "http://openrosa.org/xforms/xformsManifest";

    private boolean isXformsManifestNamespacedElement(Element e) {
        return e.getNamespace().equalsIgnoreCase(NAMESPACE_OPENROSA_ORG_XFORMS_XFORMS_MANIFEST);
    }


    @Override
    protected HashMap<FormDetails, String> doInBackground(ArrayList<FormDetails>... values) {
        ArrayList<FormDetails> toDownload = values[0];

        int total = toDownload.size();
        int count = 1;
    	Collect.getInstance().getActivityLogger().logAction(this, "downloadForms", String.valueOf(total));

        HashMap<FormDetails, String> result = new HashMap<FormDetails, String>();

        for (FormDetails fd : toDownload) {
            publishProgress(fd.formName, Integer.valueOf(count).toString(), Integer.valueOf(total)
                    .toString());

            String message = "";

            if (isCancelled()) {
                break;
            }

            String tempMediaPath = null;
            String finalMediaPath = null;
            FileResult fileResult = null;
            try {
                // get the xml file
                // if we've downloaded a duplicate, this gives us the file
                fileResult = downloadXform(fd.formName, fd.downloadUrl);

                if (fd.manifestUrl != null) {
                    // use a temporary media path until everything is ok.
                    tempMediaPath = new File(
                            Collect.getInstance().getCachePath(),
                            String.valueOf(System.currentTimeMillis())).getAbsolutePath();
                    finalMediaPath = FileUtils.constructMediaPath(fileResult.getFile().getAbsolutePath());
                    String error = downloadManifestAndMediaFiles(tempMediaPath, finalMediaPath, fd, count, total);
                    if (error != null) {
                        message += error;
                    }
                } else {
                    Log.i(t, "No Manifest for: " + fd.formName);
                }
            } catch (TaskCancelledException e) {
                Log.e(t, e.getMessage());

                cleanUp(fileResult, e.getFile(), tempMediaPath);

                // do not download additional forms.
                break;
            } catch (Exception e) {
                Log.e(t, e.getMessage());

                if (e.getCause() != null) {
                    message += e.getCause().getMessage();
                } else {
                    message += e.getMessage();
                }
            }

            if (!isCancelled() && message.length() == 0 && fileResult != null) {
                // install everything
                UriResult uriResult = null;
                try {
                    uriResult = findExistingOrCreateNewUri(fileResult.getFile());
                    Log.w(t, "Form uri = " + uriResult.getUri() + ", isNew = " + uriResult.isNew());

                    // move the media files in the media folder
                    if (tempMediaPath != null) {
                        File formMediaPath = new File(uriResult.getMediaPath());

                        FileUtils.moveMediaFiles(tempMediaPath, formMediaPath);
                    }
                } catch (IOException e) {
                    Log.e(t, e.getMessage());

                    if (uriResult.isNew() && fileResult.isNew())  {
                        // this means we should delete the entire form together with the metadata
                        Uri uri = uriResult.getUri();
                        Log.w(t, "The form is new. We should delete the entire form.");
                        int deletedCount = Collect.getInstance().getApplication().getContentResolver().delete(uri, null, null);
                        Log.w(t, "Deleted " + deletedCount + " rows using uri " + uri);
                    }

                    cleanUp(fileResult, null, tempMediaPath);
                } catch (TaskCancelledException e) {
                    Log.e(t, e.getMessage());

                    cleanUp(fileResult, e.getFile(), tempMediaPath);
                }
            } else {
                cleanUp(fileResult, null, tempMediaPath);
            }

            count++;
            saveResult(result, fd, message);
        }

        return result;
    }

    private void saveResult(HashMap<FormDetails, String> result, FormDetails fd, String message) {
        if (message.equalsIgnoreCase("")) {
            message = Collect.getInstance().getApplication().getString(R.string.success);
        }
        result.put(fd, message);
    }

    /**
     * Some clean up
     *
     * @param fileResult
     * @param fileOnCancel
     * @param tempMediaPath
     */
    private void cleanUp(FileResult fileResult, File fileOnCancel, String tempMediaPath) {
        if (fileResult == null) {
            Log.w(t, "The user cancelled (or an exception happened) the download of a form at the very beginning.");
        } else {
            if (fileResult.getFile() != null) {
                FileUtils.deleteAndReport(fileResult.getFile());
            }
        }

        if (fileOnCancel != null) {
            FileUtils.deleteAndReport(fileOnCancel);
        }

        if ( tempMediaPath != null ) {
        	FileUtils.purgeMediaPath(tempMediaPath);
        }
    }

    /**
     * Checks a form file whether it is a new one or if it matches an old one.
     *
     * @param formFile the form definition file
     * @return a {@link org.odk.collect.android.tasks.DownloadFormsTask.UriResult} object
     * @throws TaskCancelledException if the user cancels the task during the download.
     */
    private UriResult findExistingOrCreateNewUri(File formFile) throws TaskCancelledException {
        Cursor cursor = null;
        Uri uri = null;
        String mediaPath;
        boolean isNew;

        String formFilePath = formFile.getAbsolutePath();
        mediaPath = FileUtils.constructMediaPath(formFilePath);
        FileUtils.checkMediaPath(new File(mediaPath));

        try {
            String[] selectionArgs = {
                    formFile.getAbsolutePath()
            };
            String selection = FormsColumns.FORM_FILE_PATH + "=?";
            cursor = Collect.getInstance()
                    .getApplication()
                    .getContentResolver()
                    .query(FormsColumns.CONTENT_URI, null, selection, selectionArgs,
                            null);

            isNew = cursor.getCount() <= 0;

            if (isNew) {
                // doesn't exist, so insert it
                ContentValues v = new ContentValues();

                v.put(FormsColumns.FORM_FILE_PATH, formFilePath);
                v.put(FormsColumns.FORM_MEDIA_PATH, mediaPath);

                Log.w(t, "Parsing document " + formFile.getAbsolutePath());

                HashMap<String, String> formInfo = FileUtils.parseXML(formFile);

                if (isCancelled()) {
                    throw new TaskCancelledException(formFile, "Form " + formFile.getName() + " was cancelled while it was being parsed.");
                }

                v.put(FormsColumns.DISPLAY_NAME, formInfo.get(FileUtils.TITLE));
                v.put(FormsColumns.JR_VERSION, formInfo.get(FileUtils.VERSION));
                v.put(FormsColumns.JR_FORM_ID, formInfo.get(FileUtils.FORMID));
                v.put(FormsColumns.SUBMISSION_URI, formInfo.get(FileUtils.SUBMISSIONURI));
                v.put(FormsColumns.BASE64_RSA_PUBLIC_KEY, formInfo.get(FileUtils.BASE64_RSA_PUBLIC_KEY));
                uri =
                        Collect.getInstance().getApplication().getContentResolver()
                                .insert(FormsColumns.CONTENT_URI, v);
                Collect.getInstance().getActivityLogger().logAction(this, "insert", formFile.getAbsolutePath());

            } else {
                cursor.moveToFirst();
                uri =
                        Uri.withAppendedPath(FormsColumns.CONTENT_URI,
                                cursor.getString(cursor.getColumnIndex(FormsColumns._ID)));
                mediaPath = cursor.getString(cursor.getColumnIndex(FormsColumns.FORM_MEDIA_PATH));
                Collect.getInstance().getActivityLogger().logAction(this, "refresh", formFile.getAbsolutePath());
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }

        return new UriResult(uri, mediaPath, isNew);
    }

    /**
     * Takes the formName and the URL and attempts to download the specified file. Returns a file
     * object representing the downloaded file.
     *
     * @param formName
     * @param url
     * @return
     * @throws Exception
     */
    private FileResult downloadXform(String formName, String url) throws Exception {
        // clean up friendly form name...
        String rootName = formName.replaceAll("[^\\p{L}\\p{Digit}]", " ");
        rootName = rootName.replaceAll("\\p{javaWhitespace}+", " ");
        rootName = rootName.trim();

        // proposed name of xml file...
        String path = Collect.getInstance().getFormsPath() + File.separator + rootName + ".xml";
        int i = 2;
        File f = new File(path);
        while (f.exists()) {
            path = Collect.getInstance().getFormsPath() + File.separator + rootName + "_" + i + ".xml";
            f = new File(path);
            i++;
        }

        downloadFile(f, url);

        boolean isNew = true;

        // we've downloaded the file, and we may have renamed it
        // make sure it's not the same as a file we already have
        String[] projection = {
                FormsColumns.FORM_FILE_PATH
        };
        String[] selectionArgs = {
                FileUtils.getMd5Hash(f)
        };
        String selection = FormsColumns.MD5_HASH + "=?";

        Cursor c = null;
        try {
        	c = Collect.getInstance().getApplication().getContentResolver()
                    .query(FormsColumns.CONTENT_URI, projection, selection, selectionArgs, null);
	        if (c.getCount() > 0) {
	            // Should be at most, 1
	            c.moveToFirst();

                isNew = false;

                // delete the file we just downloaded, because it's a duplicate
                Log.w(t, "A duplicate file has been found, we need to remove the downloaded file and return the other one.");
                FileUtils.deleteAndReport(f);

                // set the file returned to the file we already had
                String existingPath = c.getString(c.getColumnIndex(FormsColumns.FORM_FILE_PATH));
                f = new File(existingPath);
                Log.w(t, "Will use " + existingPath);
            }
        } finally {
            if (c != null) {
                c.close();
            }
        }

        return new FileResult(f, isNew);
    }


    /**
     * Common routine to download a document from the downloadUrl and save the contents in the file
     * 'file'. Shared by media file download and form file download.
     *
     * SurveyCTO: The file is saved into a temp folder and is moved to the final place if everything is okay,
     * so that garbage is not left over on cancel.
     * 
     * @param file        the final file
     * @param downloadUrl the url to get the contents from.
     * @throws Exception
     */
    private void downloadFile(File file, String downloadUrl) throws Exception {
        File tempFile = File.createTempFile(
                file.getName(),
                TEMP_DOWNLOAD_EXTENSION,
                new File(Collect.getInstance().getCachePath()));

        URI uri;
        try {
            // assume the downloadUrl is escaped properly
            URL url = new URL(downloadUrl);
            uri = url.toURI();
        } catch (MalformedURLException e) {
            e.printStackTrace();
            throw e;
        } catch (URISyntaxException e) {
            e.printStackTrace();
            throw e;
        }

        // WiFi network connections can be renegotiated during a large form download sequence.
        // This will cause intermittent download failures.  Silently retry once after each
        // failure.  Only if there are two consecutive failures, do we abort.
        boolean success = false;
        int attemptCount = 0;
        final int MAX_ATTEMPT_COUNT = 2;
        while ( !success && ++attemptCount <= MAX_ATTEMPT_COUNT ) {

            if (isCancelled()) {
                throw new TaskCancelledException(tempFile, "Cancelled before requesting " + tempFile.getAbsolutePath());
            } else {
                Log.i(t, "Started downloading to " + tempFile.getAbsolutePath() + " from " + downloadUrl);
            }

            // get shared HttpContext so that authentication and cookies are retained.
	        HttpContext localContext = Collect.getInstance().getHttpContext();

	        HttpClient httpclient = WebUtils.createHttpClient(WebUtils.CONNECTION_TIMEOUT);

	        // set up request...
	        HttpGet req = WebUtils.createOpenRosaHttpGet(uri);
	        req.addHeader(WebUtils.ACCEPT_ENCODING_HEADER, WebUtils.GZIP_CONTENT_ENCODING);

	        HttpResponse response;
	        try {
	            response = httpclient.execute(req, localContext);
	            int statusCode = response.getStatusLine().getStatusCode();

	            if (statusCode != HttpStatus.SC_OK) {
	            	WebUtils.discardEntityBytes(response);
	            	if (statusCode == HttpStatus.SC_UNAUTHORIZED) {
	            		// clear the cookies -- should not be necessary?
	            		Collect.getInstance().getCookieStore().clear();
	            	}
	                String errMsg =
	                    Collect.getInstance().getApplication().getString(R.string.file_fetch_failed, downloadUrl,
	                        response.getStatusLine().getReasonPhrase(), statusCode);
	                Log.e(t, errMsg);
	                throw new Exception(errMsg);
	            }

	            // write connection to file
	            InputStream is = null;
	            OutputStream os = null;
	            try {
	            	HttpEntity entity = response.getEntity();
	                is = entity.getContent();
	                Header contentEncoding = entity.getContentEncoding();
	                if ( contentEncoding != null && contentEncoding.getValue().equalsIgnoreCase(WebUtils.GZIP_CONTENT_ENCODING) ) {
	                	is = new GZIPInputStream(is);
	                }
	                os = new FileOutputStream(tempFile);
	                byte buf[] = new byte[4096];
	                int len;
	                while ((len = is.read(buf)) > 0 && !isCancelled()) {
	                    os.write(buf, 0, len);
	                }
	                os.flush();
	                success = true;
	            } finally {
	                if (os != null) {
	                    try {
	                        os.close();
	                    } catch (Exception e) {
	                    }
	                }
	                if (is != null) {
	                	try {
	                		// ensure stream is consumed...
	                        final long count = 1024L;
	                        while (is.skip(count) == count)
	                            ;
	                	} catch (Exception e) {
	                		// no-op
	                	}
	                    try {
	                        is.close();
	                    } catch (Exception e) {
	                    }
	                }
	            }
	        } catch (Exception e) {
	        	Log.e(t, e.toString());
	            // silently retry unless this is the last attempt,
	            // in which case we rethrow the exception.

                FileUtils.deleteAndReport(tempFile);

	            if ( attemptCount == MAX_ATTEMPT_COUNT ) {
	            	throw e;
	            }
	        }

            if (isCancelled()) {
                FileUtils.deleteAndReport(tempFile);
                throw new TaskCancelledException(tempFile, "Cancelled downloading of " + tempFile.getAbsolutePath());
            }
        }

        Log.d(t, "Completed downloading of " + tempFile.getAbsolutePath() + ". It will be moved to the proper path...");

        FileUtils.deleteAndReport(file);

        String errorMessage = FileUtils.copyFile(tempFile, file);

        if (file.exists()) {
            Log.w(t, "Copied " + tempFile.getAbsolutePath() + " over " + file.getAbsolutePath());
            FileUtils.deleteAndReport(tempFile);
        } else {
            String msg = Collect.getInstance().getApplication().getString(R.string.fs_file_copy_error, tempFile.getAbsolutePath(), file.getAbsolutePath(), errorMessage);
            Log.w(t, msg);
            throw new RuntimeException(msg);
        }
    }

    private static class UriResult {

        private final Uri uri;
        private final String mediaPath;
        private final boolean isNew;

        private UriResult(Uri uri, String mediaPath, boolean aNew) {
            this.uri = uri;
            this.mediaPath = mediaPath;
            this.isNew = aNew;
        }

        private Uri getUri() {
            return uri;
        }

        private String getMediaPath() {
            return mediaPath;
        }

        private boolean isNew() {
            return isNew;
        }
    }

    private static class FileResult {

        private final File file;
        private final boolean isNew;

        private FileResult(File file, boolean aNew) {
            this.file = file;
            isNew = aNew;
        }

        private File getFile() {
            return file;
        }

        private boolean isNew() {
            return isNew;
        }
    }

    private static class MediaFile {
        final String filename;
        final String hash;
        final String downloadUrl;


        MediaFile(String filename, String hash, String downloadUrl) {
            this.filename = filename;
            this.hash = hash;
            this.downloadUrl = downloadUrl;
        }
    }


    private String downloadManifestAndMediaFiles(String tempMediaPath, String finalMediaPath, FormDetails fd, int count,
            int total) throws Exception {
        if (fd.manifestUrl == null)
            return null;

        publishProgress(Collect.getInstance().getApplication().getString(R.string.fetching_manifest, fd.formName),
            Integer.valueOf(count).toString(), Integer.valueOf(total).toString());

        List<MediaFile> files = new ArrayList<MediaFile>();
        // get shared HttpContext so that authentication and cookies are retained.
        HttpContext localContext = Collect.getInstance().getHttpContext();

        HttpClient httpclient = WebUtils.createHttpClient(WebUtils.CONNECTION_TIMEOUT);

        DocumentFetchResult result =
            WebUtils.getXmlDocument(fd.manifestUrl, localContext, httpclient);

        if (result.errorMessage != null) {
            return result.errorMessage;
        }

        String errMessage = Collect.getInstance().getApplication().getString(R.string.access_error, fd.manifestUrl);

        if (!result.isOpenRosaResponse) {
            errMessage += Collect.getInstance().getApplication().getString(R.string.manifest_server_error);
            Log.e(t, errMessage);
            return errMessage;
        }

        // Attempt OpenRosa 1.0 parsing
        Element manifestElement = result.doc.getRootElement();
        if (!manifestElement.getName().equals("manifest")) {
            errMessage +=
                Collect.getInstance().getApplication().getString(R.string.root_element_error,
                    manifestElement.getName());
            Log.e(t, errMessage);
            return errMessage;
        }
        String namespace = manifestElement.getNamespace();
        if (!isXformsManifestNamespacedElement(manifestElement)) {
            errMessage += Collect.getInstance().getApplication().getString(R.string.root_namespace_error, namespace);
            Log.e(t, errMessage);
            return errMessage;
        }
        int nElements = manifestElement.getChildCount();
        for (int i = 0; i < nElements; ++i) {
            if (manifestElement.getType(i) != Element.ELEMENT) {
                // e.g., whitespace (text)
                continue;
            }
            Element mediaFileElement = manifestElement.getElement(i);
            if (!isXformsManifestNamespacedElement(mediaFileElement)) {
                // someone else's extension?
                continue;
            }
            String name = mediaFileElement.getName();
            if (name.equalsIgnoreCase("mediaFile")) {
                String filename = null;
                String hash = null;
                String downloadUrl = null;
                // don't process descriptionUrl
                int childCount = mediaFileElement.getChildCount();
                for (int j = 0; j < childCount; ++j) {
                    if (mediaFileElement.getType(j) != Element.ELEMENT) {
                        // e.g., whitespace (text)
                        continue;
                    }
                    Element child = mediaFileElement.getElement(j);
                    if (!isXformsManifestNamespacedElement(child)) {
                        // someone else's extension?
                        continue;
                    }
                    String tag = child.getName();
                    if (tag.equals("filename")) {
                        filename = XFormParser.getXMLText(child, true);
                        if (filename != null && filename.length() == 0) {
                            filename = null;
                        }
                    } else if (tag.equals("hash")) {
                        hash = XFormParser.getXMLText(child, true);
                        if (hash != null && hash.length() == 0) {
                            hash = null;
                        }
                    } else if (tag.equals("downloadUrl")) {
                        downloadUrl = XFormParser.getXMLText(child, true);
                        if (downloadUrl != null && downloadUrl.length() == 0) {
                            downloadUrl = null;
                        }
                    }
                }
                if (filename == null || downloadUrl == null || hash == null) {
                    errMessage +=
                        Collect.getInstance().getApplication().getString(R.string.manifest_tag_error,
                            Integer.toString(i));
                    Log.e(t, errMessage);
                    return errMessage;
                }
                files.add(new MediaFile(filename, hash, downloadUrl));
            }
        }

        // OK we now have the full set of files to download...
        Log.i(t, "Downloading " + files.size() + " media files.");
        int mediaCount = 0;
        if (files.size() > 0) {
            File tempMediaDir = new File(tempMediaPath);
            File finalMediaDir = new File(finalMediaPath);

            FileUtils.checkMediaPath(tempMediaDir);
            FileUtils.checkMediaPath(finalMediaDir);

            for (MediaFile toDownload : files) {
                ++mediaCount;
                publishProgress(
                    Collect.getInstance().getApplication().getString(R.string.form_download_progress, fd.formName,
                        mediaCount, files.size()), Integer.valueOf(count).toString(), Integer
                            .valueOf(total).toString());
//                try {
                    File finalMediaFile = new File(finalMediaDir, toDownload.filename);
                    File tempMediaFile = new File(tempMediaDir, toDownload.filename);

                    if (!finalMediaFile.exists()) {
                        downloadFile(tempMediaFile, toDownload.downloadUrl);
                    } else {
                        String currentFileHash = FileUtils.getMd5Hash(finalMediaFile);
                        String downloadFileHash = toDownload.hash.substring(MD5_COLON_PREFIX.length());

                        if (!currentFileHash.contentEquals(downloadFileHash)) {
                            // if the hashes match, it's the same file
                            // otherwise delete our current one and replace it with the new one
                            FileUtils.deleteAndReport(finalMediaFile);
                            downloadFile(tempMediaFile, toDownload.downloadUrl);
                        } else {
                            // exists, and the hash is the same
                            // no need to download it again
                        	Log.i(t, "Skipping media file fetch -- file hashes identical: " + finalMediaFile.getAbsolutePath());
                        }
                    }
//                } catch (Exception e) {
//                    return e.getLocalizedMessage();
//                }
            }
        }
        return null;
    }


    @Override
    protected void onPostExecute(HashMap<FormDetails, String> value) {
        synchronized (this) {
            if (mStateListener != null) {
                mStateListener.formsDownloadingComplete(value);
            }
        }
    }


    @Override
    protected void onProgressUpdate(String... values) {
        synchronized (this) {
            if (mStateListener != null) {
                // update progress and total
                mStateListener.progressUpdate(values[0],
                	Integer.valueOf(values[1]),
                    Integer.valueOf(values[2]));
            }
        }

    }


    public void setDownloaderListener(FormDownloaderListener sl) {
        synchronized (this) {
            mStateListener = sl;
        }
    }

}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.tasks;

import android.content.Intent;
import android.database.Cursor;
import android.os.AsyncTask;
import android.util.Log;

import org.apache.commons.io.IOUtils;
import org.javarosa.core.model.FormDef;
import org.javarosa.core.model.FormIndex;
import org.javarosa.core.model.condition.EvaluationContext;
import org.javarosa.core.model.instance.InstanceInitializationFactory;
import org.javarosa.core.model.instance.TreeElement;
import org.javarosa.core.model.instance.TreeReference;
import org.javarosa.core.model.instance.utils.DefaultAnswerResolver;
import org.javarosa.core.reference.ReferenceManager;
import org.javarosa.core.reference.RootTranslator;
import org.javarosa.core.util.externalizable.DeserializationException;
import org.javarosa.core.util.externalizable.ExtUtil;
import org.javarosa.form.api.FormEntryController;
import org.javarosa.form.api.FormEntryModel;
import org.javarosa.xform.parse.XFormParseException;
import org.javarosa.xform.parse.XFormParser;
import org.javarosa.xform.util.XFormUtils;
import org.javarosa.xpath.XPathTypeMismatchException;
import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.database.ItemsetDbAdapter;
import org.odk.collect.android.external.ExternalAnswerResolver;
import org.odk.collect.android.external.ExternalDataHandler;
import org.odk.collect.android.external.ExternalDataManager;
import org.odk.collect.android.external.ExternalDataManagerImpl;
import org.odk.collect.android.external.ExternalDataReader;
import org.odk.collect.android.external.ExternalDataReaderImpl;
import org.odk.collect.android.external.handler.ExternalDataHandlerPull;
import org.odk.collect.android.listeners.FormLoaderListener;
import org.odk.collect.android.logic.FileReferenceFactory;
import org.odk.collect.android.logic.FormController;
import org.odk.collect.android.utilities.FileUtils;
import org.odk.collect.android.utilities.ZipUtils;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import au.com.bytecode.opencsv.CSVReader;

/**
 * Background task for loading a form.
 *
 * @author Carl Hartung (carlhartung@gmail.com)
 * @author Yaw Anokwa (yanokwa@gmail.com)
 */
public class FormLoaderTask extends AsyncTask<String, String, FormLoaderTask.FECWrapper> {
    private final static String t = "FormLoaderTask";
    private static final String ITEMSETS_CSV = "itemsets.csv";

    private FormLoaderListener mStateListener;
    private String mErrorMsg;
    private String mInstancePath;
    private final String mXPath;
    private final String mWaitingXPath;
    private boolean pendingActivityResult = false;
    private int requestCode = 0;
    private int resultCode = 0;
    private Intent intent = null;
    private ExternalDataManager externalDataManager;

    protected class FECWrapper {
        FormController controller;
        boolean usedSavepoint;


        protected FECWrapper(FormController controller, boolean usedSavepoint) {
            this.controller = controller;
            this.usedSavepoint = usedSavepoint;
        }


        protected FormController getController() {
            return controller;
        }

        protected boolean hasUsedSavepoint() {
        	return usedSavepoint;
        }

        protected void free() {
            controller = null;
        }
    }

    FECWrapper data;

    public FormLoaderTask(String instancePath, String XPath, String waitingXPath) {
    	mInstancePath = instancePath;
    	mXPath = XPath;
    	mWaitingXPath = waitingXPath;
    }

    /**
     * Initialize {@link FormEntryController} with {@link FormDef} from binary or from XML. If given
     * an instance, it will be used to fill the {@link FormDef}.
     */
    @Override
    protected FECWrapper doInBackground(String... path) {
        FormEntryController fec = null;
        FormDef fd = null;
        FileInputStream fis = null;
        mErrorMsg = null;

        String formPath = path[0];

        File formXml = new File(formPath);
        String formHash = FileUtils.getMd5Hash(formXml);
        File formBin = new File(Collect.getInstance().getCachePath() + File.separator + formHash + ".formdef");

        publishProgress(Collect.getInstance().getApplication().getString(R.string.survey_loading_reading_form_message));

        if (formBin.exists()) {
            // if we have binary, deserialize binary
            Log.i(
                t,
                "Attempting to load " + formXml.getName() + " from cached file: "
                        + formBin.getAbsolutePath());
            fd = deserializeFormDef(formBin);
            if (fd == null) {
                // some error occured with deserialization. Remove the file, and make a new .formdef
                // from xml
                Log.w(t,
                    "Deserialization FAILED!  Deleting cache file: " + formBin.getAbsolutePath());
                formBin.delete();
            }
        }
        if (fd == null) {
            // no binary, read from xml
            try {
                Log.i(t, "Attempting to load from: " + formXml.getAbsolutePath());
                fis = new FileInputStream(formXml);
                fd = XFormUtils.getFormFromInputStream(fis);
                if (fd == null) {
                    mErrorMsg = "Error reading XForm file";
                } else {
                    serializeFormDef(fd, formPath);
                }
            } catch (FileNotFoundException e) {
                e.printStackTrace();
                mErrorMsg = e.getMessage();
            } catch (XFormParseException e) {
                mErrorMsg = e.getMessage();
                e.printStackTrace();
            } catch (Exception e) {
                mErrorMsg = e.getMessage();
                e.printStackTrace();
            } finally {
                IOUtils.closeQuietly(fis);
            }
        }

        if (mErrorMsg != null || fd == null) {
            return null;
        }

        // set paths to /sdcard/odk/forms/formfilename-media/
        String formFileName = formXml.getName().substring(0, formXml.getName().lastIndexOf("."));
        File formMediaDir = new File( formXml.getParent(), formFileName + "-media");

        externalDataManager = new ExternalDataManagerImpl(formMediaDir);

        // new evaluation context for function handlers
        EvaluationContext ec = new EvaluationContext(null);
        ExternalDataHandler externalDataHandlerPull = new ExternalDataHandlerPull(externalDataManager);
        ec.addFunctionHandler(externalDataHandlerPull);

        fd.setEvaluationContext(ec);

        try {
            loadExternalData(formMediaDir);
        } catch (Exception e) {
            mErrorMsg = e.getMessage();
            e.printStackTrace();
            return null;
        }

        if (isCancelled()) {
            // that means that the user has cancelled, so no need to go further
            return null;
        }

		// create FormEntryController from formdef
        FormEntryModel fem = new FormEntryModel(fd);
        fec = new FormEntryController(fem);

        boolean usedSavepoint = false;

        try {
            // import existing data into formdef
            if (mInstancePath != null) {
            	File instance = new File(mInstancePath);
            	File shadowInstance = SaveToDiskTask.savepointFile(instance);
            	if ( shadowInstance.exists() &&
            		 ( shadowInstance.lastModified() > instance.lastModified()) ) {
            		// the savepoint is newer than the saved value of the instance.
            		// use it.
            		usedSavepoint = true;
            		instance = shadowInstance;
           			Log.w(t,"Loading instance from shadow file: " + shadowInstance.getAbsolutePath());
            	}
            	if ( instance.exists() ) {
	                // This order is important. Import data, then initialize.
                    try {
                        importData(instance, fec);
                        fd.initialize(false, new InstanceInitializationFactory());
                    } catch (RuntimeException e) {
                        Log.e(t, e.getMessage(), e);

                        // SCTO-633
                        if (usedSavepoint && !(e.getCause() instanceof XPathTypeMismatchException)) {
                            // this means that the .save file is corrupted or 0-sized, so don't use it.
                            usedSavepoint = false;
                            mInstancePath = null;
                            fd.initialize(true, new InstanceInitializationFactory());
                        } else {
                            // this means that the saved instance is corrupted.
                            throw e;
                        }
                    }
                } else {
            		fd.initialize(true, new InstanceInitializationFactory());
            	}
            } else {
                fd.initialize(true, new InstanceInitializationFactory());
            }
        } catch (RuntimeException e) {
            Log.e(t, e.getMessage(), e);
            if (e.getCause() instanceof XPathTypeMismatchException) {
                // this is a case of https://bitbucket.org/m.sundt/javarosa/commits/e5d344783e7968877402bcee11828fa55fac69de
                // the data are imported, the survey will be unusable
                // but we should give the option to the user to edit the form
                // otherwise the survey will be TOTALLY inaccessible.
                Log.w(t, "We have a syntactically correct instance, but the data threw an exception inside JR. We should allow editing.");
            } else {
                mErrorMsg = e.getMessage();
                return null;
            }
        }

        // Remove previous forms
        ReferenceManager._().clearSession();

        // for itemsets.csv, we only check to see if the itemset file has been
        // updated
        File csv = new File(formMediaDir.getAbsolutePath() + "/" + ITEMSETS_CSV);
        String csvmd5 = null;
        if (csv.exists()) {
            csvmd5 = FileUtils.getMd5Hash(csv);
            boolean readFile = false;
            ItemsetDbAdapter ida = new ItemsetDbAdapter();
            ida.open();
            // get the database entry (if exists) for this itemsets.csv, based
            // on the path
            Cursor c = ida.getItemsets(csv.getAbsolutePath());
            if (c != null) {
                if (c.getCount() == 1) {
                    c.moveToFirst(); // should be only one, ever, if any
                    String oldmd5 = c.getString(c.getColumnIndex("hash"));
                    if (oldmd5.equals(csvmd5)) {
                        // they're equal, do nothing
                    } else {
                        // the csv has been updated, delete the old entries
                        ida.dropTable(ItemsetDbAdapter.getMd5FromString(csv.getAbsolutePath()), csv.getAbsolutePath());
                        // and read the new
                        readFile = true;
                    }
                } else {
                    // new csv, add it
                    readFile = true;
                }
                c.close();
            }
            ida.close();
            if (readFile) {
                readCSV(csv, csvmd5, ItemsetDbAdapter.getMd5FromString(csv.getAbsolutePath()));
            }
        }

        // This should get moved to the Application Class
        if (ReferenceManager._().getFactories().length == 0) {
            // this is /sdcard/odk
            ReferenceManager._().addReferenceFactory(
                new FileReferenceFactory(Collect.getInstance().getOdkRoot()));
        }

        // Set jr://... to point to /sdcard/odk/forms/filename-media/
        ReferenceManager._().addSessionRootTranslator(
            new RootTranslator("jr://images/", "jr://file/forms/" + formFileName + "-media/"));
        ReferenceManager._().addSessionRootTranslator(
                new RootTranslator("jr://image/", "jr://file/forms/" + formFileName + "-media/"));
        ReferenceManager._().addSessionRootTranslator(
            new RootTranslator("jr://audio/", "jr://file/forms/" + formFileName + "-media/"));
        ReferenceManager._().addSessionRootTranslator(
            new RootTranslator("jr://video/", "jr://file/forms/" + formFileName + "-media/"));

        // clean up vars
        fis = null;
        fd = null;
        formBin = null;
        formXml = null;
        formPath = null;

        FormController fc = new FormController(formMediaDir, fec, mInstancePath == null ? null : new File(mInstancePath));
        if ( mXPath != null ) {
        	// we are resuming after having terminated -- set index to this position...
        	FormIndex idx = fc.getIndexFromXPath(mXPath);
    		fc.jumpToIndex(idx);
        }
        if ( mWaitingXPath != null ) {
        	FormIndex idx = fc.getIndexFromXPath(mWaitingXPath);
        	fc.setIndexWaitingForData(idx);
        }
        data = new FECWrapper(fc, usedSavepoint);
        return data;

    }

    @SuppressWarnings("unchecked")
    private void loadExternalData(File mediaFolder) {
        //SCTO-594
        File[] zipFiles = mediaFolder.listFiles(new FileFilter() {
            @Override
            public boolean accept(File file) {
                return file.getName().toLowerCase().endsWith(".zip");
            }
        });

        if (zipFiles != null) {
            ZipUtils.unzip(zipFiles);
            for (File zipFile : zipFiles) {
                boolean deleted = zipFile.delete();
                if (!deleted) {
                    Log.w(t, "Cannot delete " + zipFile + ". It will be re-unzipped next time. :(");
                }
            }
        }

        File[] csvFiles = mediaFolder.listFiles(new FileFilter() {
            @Override
            public boolean accept(File file) {
                String lowerCaseName = file.getName().toLowerCase();
                return lowerCaseName.endsWith(".csv") && !lowerCaseName.equalsIgnoreCase(ITEMSETS_CSV);
            }
        });

        Map<String, File> externalDataMap = new HashMap<String, File>();

        if (csvFiles != null) {

            for (File csvFile : csvFiles) {
                String dataSetName = csvFile.getName().substring(0, csvFile.getName().lastIndexOf("."));
                externalDataMap.put(dataSetName, csvFile);
            }

            if (externalDataMap.size() > 0) {

                publishProgress(Collect.getInstance().getApplication().getString(R.string.survey_loading_reading_csv_message));

                ExternalDataReader externalDataReader = new ExternalDataReaderImpl(this);
                externalDataReader.doImport(externalDataMap);
            }
        }
    }

    public void publishExternalDataLoadingProgress(String message) {
        publishProgress(message);
    }

    @Override
    protected void onProgressUpdate(String... values) {
        synchronized (this) {
            if (mStateListener != null && values != null) {
                if (values.length == 1) {
                    mStateListener.onProgressStep(values[0]);
                }
            }
        }
    }

    public boolean importData(File instanceFile, FormEntryController fec) {
        publishProgress(Collect.getInstance().getApplication().getString(R.string.survey_loading_reading_data_message));

        // convert files into a byte array
        byte[] fileBytes = FileUtils.getFileAsBytes(instanceFile);

        // get the root of the saved and template instances
        TreeElement savedRoot = XFormParser.restoreDataModel(fileBytes, null).getRoot();
        TreeElement templateRoot = fec.getModel().getForm().getInstance().getRoot().deepCopy(true);

        // weak check for matching forms
        if (!savedRoot.getName().equals(templateRoot.getName()) || savedRoot.getMult() != 0) {
            Log.e(t, "Saved form instance does not match template form definition");
            return false;
        } else {
            // populate the data model
            TreeReference tr = TreeReference.rootRef();
            tr.add(templateRoot.getName(), TreeReference.INDEX_UNBOUND);

            // Here we set the Collect's implementation of the IAnswerResolver.
            // We set it back to the default after select choices have been populated.
            XFormParser.setAnswerResolver(new ExternalAnswerResolver());
            templateRoot.populate(savedRoot, fec.getModel().getForm());
            XFormParser.setAnswerResolver(new DefaultAnswerResolver());

            // populated model to current form
            fec.getModel().getForm().getInstance().setRoot(templateRoot);

            // fix any language issues
            // : http://bitbucket.org/javarosa/main/issue/5/itext-n-appearing-in-restored-instances
            if (fec.getModel().getLanguages() != null) {
                fec.getModel()
                        .getForm()
                        .localeChanged(fec.getModel().getLanguage(),
                            fec.getModel().getForm().getLocalizer());
            }

            return true;

        }
    }

    /**
     * Read serialized {@link FormDef} from file and recreate as object.
     *
     * @param formDef serialized FormDef file
     * @return {@link FormDef} object
     */
    public FormDef deserializeFormDef(File formDef) {

        // TODO: any way to remove reliance on jrsp?
        FileInputStream fis = null;
        FormDef fd = null;
        try {
            // create new form def
            fd = new FormDef();
            fis = new FileInputStream(formDef);
            DataInputStream dis = new DataInputStream(fis);

            // read serialized formdef into new formdef
            fd.readExternal(dis, ExtUtil.defaultPrototypes());
            dis.close();

        } catch (FileNotFoundException e) {
            e.printStackTrace();
            fd = null;
        } catch (IOException e) {
            e.printStackTrace();
            fd = null;
        } catch (DeserializationException e) {
            e.printStackTrace();
            fd = null;
        } catch (Exception e) {
            e.printStackTrace();
            fd = null;
        }

        return fd;
    }


    /**
     * Write the FormDef to the file system as a binary blog.
     *
     * @param filepath path to the form file
     */
    public void serializeFormDef(FormDef fd, String filepath) {
        // calculate unique md5 identifier
        String hash = FileUtils.getMd5Hash(new File(filepath));
        File formDef = new File(Collect.getInstance().getCachePath() + File.separator + hash + ".formdef");

        // formdef does not exist, create one.
        if (!formDef.exists()) {
            FileOutputStream fos;
            try {
                fos = new FileOutputStream(formDef);
                DataOutputStream dos = new DataOutputStream(fos);
                fd.writeExternal(dos);
                dos.flush();
                dos.close();
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    @Override
    protected void onCancelled() {
        super.onCancelled();

        if (externalDataManager != null) {
            externalDataManager.close();
        }
    }

    @Override
    protected void onPostExecute(FECWrapper wrapper) {
        synchronized (this) {
        	try {
	            if (mStateListener != null) {
	                if (wrapper == null) {
	                    mStateListener.loadingError(mErrorMsg);
	                } else {
	                    mStateListener.loadingComplete(this);
	                }
	            }
        	} catch (Exception e) {
        		e.printStackTrace();
        	}
        }
    }


    public void setFormLoaderListener(FormLoaderListener sl) {
        synchronized (this) {
            mStateListener = sl;
        }
    }

    public FormController getFormController() {
    	return ( data != null ) ? data.getController() : null;
    }

    public ExternalDataManager getExternalDataManager() {
        return externalDataManager;
    }

    public boolean hasUsedSavepoint() {
    	return (data != null ) ? data.hasUsedSavepoint() : false;
    }

    public void destroy() {
        if (data != null) {
            data.free();
            data = null;
        }
    }

    public boolean hasPendingActivityResult() {
    	return pendingActivityResult;
    }

    public int getRequestCode() {
    	return requestCode;
    }

    public int getResultCode() {
    	return resultCode;
    }

    public Intent getIntent() {
    	return intent;
    }

	public void setActivityResult(int requestCode, int resultCode, Intent intent) {
		this.pendingActivityResult = true;
		this.requestCode = requestCode;
		this.resultCode = resultCode;
		this.intent = intent;
	}

	private void readCSV(File csv, String formHash, String pathHash) {

        CSVReader reader;
        ItemsetDbAdapter ida = new ItemsetDbAdapter();
        ida.open();

        try {
            reader = new CSVReader(new FileReader(csv));

            String[] nextLine;
            String[] columnHeaders = null;
            int lineNumber = 0;
            while ((nextLine = reader.readNext()) != null) {
                lineNumber++;
                if (lineNumber == 1) {
                    // first line of csv is column headers
                    columnHeaders = nextLine;
                    ida.createTable(formHash, pathHash, columnHeaders,
                            csv.getAbsolutePath());
                    continue;
                }
                // add the rest of the lines to the specified database
                // nextLine[] is an array of values from the line
                // System.out.println(nextLine[4] + "etc...");
                if (lineNumber == 2) {
                    // start a transaction for the inserts
                    ida.beginTransaction();
                }
                ida.addRow(pathHash, columnHeaders, nextLine);

            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            ida.commit();
            ida.close();
        }
    }

}

/*
 * Copyright (C) 2012 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.tasks;

import android.content.ContentResolver;
import android.net.Uri;
import android.os.AsyncTask;
import android.util.Log;

import org.odk.collect.android.application.Collect;
import org.odk.collect.android.listeners.DeleteFormsListener;
import org.odk.collect.android.provider.FormsProviderAPI.FormsColumns;

/**
 * Task responsible for deleting selected forms.
 * @author norman86@gmail.com
 * @author mitchellsundt@gmail.com
 *
 */
public class DeleteFormsTask extends AsyncTask<Long, Void, Integer> {
	private static final String t = "DeleteFormsTask";
	
	private ContentResolver cr;
	private DeleteFormsListener dl;
	
	private int successCount = 0;
	
	@Override
	protected Integer doInBackground(Long... params) {
		int deleted = 0;

		if (params == null ||cr == null || dl == null) {
			return deleted;
		}
		
		// delete files from database and then from file system
		for (int i = 0; i < params.length; i++) {
			if ( isCancelled() ) {
				break;
			}
			try {
	            Uri deleteForm =
	                Uri.withAppendedPath(FormsColumns.CONTENT_URI, params[i].toString());
	            
	            int wasDeleted = cr.delete(deleteForm, null, null); 
	            deleted += wasDeleted;
	            
	            if (wasDeleted > 0) {
	            	Collect.getInstance().getActivityLogger().logAction(this, "delete", deleteForm.toString());
	            }
			} catch ( Exception ex ) {
				Log.e(t,"Exception during delete of: " + params[i].toString() + " exception: "  + ex.toString());
			}
	    } 
		successCount = deleted;
		return deleted;
	}
	
	@Override
	protected void onPostExecute(Integer result) {
      	cr = null;
        if (dl != null) {
            dl.deleteComplete(result);
        }
        super.onPostExecute(result);
	}
	
	@Override
	protected void onCancelled() {
		cr = null;
		if (dl != null) {
			dl.deleteComplete(successCount);
		}
	}
	
    public void setDeleteListener(DeleteFormsListener listener) {
        dl = listener;
    }
    
    public void setContentResolver(ContentResolver resolver){
    	cr = resolver;
    }

    public int getDeleteCount() {
    	return successCount;
    }
}

/*
 * Copyright (C) 2012 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.tasks;

import android.content.ContentResolver;
import android.net.Uri;
import android.os.AsyncTask;
import android.util.Log;

import org.odk.collect.android.application.Collect;
import org.odk.collect.android.listeners.DeleteInstancesListener;
import org.odk.collect.android.provider.InstanceProviderAPI.InstanceColumns;

/**
 * Task responsible for deleting selected instances.
 * @author norman86@gmail.com
 * @author mitchellsundt@gmail.com
 *
 */
public class DeleteInstancesTask extends AsyncTask<Long, Void, Integer> {
	private static final String t = "DeleteInstancesTask";
	
	private ContentResolver cr;
	private DeleteInstancesListener dl;
	
	private int successCount = 0;
	
	@Override
	protected Integer doInBackground(Long... params) {
		int deleted = 0;

		if (params == null ||cr == null || dl == null) {
			return deleted;
		}
		
		// delete files from database and then from file system
		for (int i = 0; i < params.length; i++) {
			if ( isCancelled() ) {
				break;
			}
			try {
	            Uri deleteForm =
	                Uri.withAppendedPath(InstanceColumns.CONTENT_URI, params[i].toString());
	            
	            int wasDeleted = cr.delete(deleteForm, null, null); 
	            deleted += wasDeleted;
	            
	            if (wasDeleted > 0) {
	            	Collect.getInstance().getActivityLogger().logAction(this, "delete", deleteForm.toString());
	            }
			} catch ( Exception ex ) {
				Log.e(t,"Exception during delete of: " + params[i].toString() + " exception: "  + ex.toString());
			}
	    } 
		successCount = deleted;
		return deleted;
	}
	
	@Override
	protected void onPostExecute(Integer result) {
	  	cr = null;
        if (dl != null) {
            dl.deleteComplete(result);
        }
        super.onPostExecute(result);
	}
	
	@Override
	protected void onCancelled() {
		cr = null;
		if (dl != null) {
			dl.deleteComplete(successCount);
		}
	}

    public void setDeleteListener(DeleteInstancesListener listener) {
        dl = listener;
    }
    
    public void setContentResolver(ContentResolver resolver){
       	cr = resolver;
    }

    public int getDeleteCount() {
    	return successCount;
    }
}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.tasks;

/**
 *
 * Author: Meletis Margaritis
 * Date: 19/10/2013
 * Time: 12:17 
 */
public interface ProgressNotifier {

    void onProgressStep(String stepMessage);
}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.tasks;

import android.os.AsyncTask;
import android.util.Log;

import org.javarosa.core.services.transport.payload.ByteArrayPayload;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.listeners.SavePointListener;
import org.odk.collect.android.logic.FormController;

import java.io.File;

/**
 * Author: Meletis Margaritis
 * Date: 27/6/2013
 * Time: 6:46 
 */
public class SavePointTask extends AsyncTask<Void, Void, String> {

    private final static String t = "SavePointTask";
    private static final Object lock = new Object();
    private static int lastPriorityUsed = 0;

    private final SavePointListener listener;
    private int priority;

    public SavePointTask(SavePointListener listener) {
        this.listener = listener;
        this.priority = ++lastPriorityUsed;
    }

    @Override
    protected String doInBackground(Void... params) {
        synchronized (lock) {
            if (priority < lastPriorityUsed) {
                Log.w(t, "Savepoint thread (p=" + priority + ") was cancelled (a) because another one is waiting (p=" + lastPriorityUsed + ")");
                return null;
            }

            long start = System.currentTimeMillis();

            try {
                FormController formController = Collect.getInstance().getFormController();
                File temp = SaveToDiskTask.savepointFile(formController.getInstancePath());
                ByteArrayPayload payload = formController.getFilledInFormXml();

                if (priority < lastPriorityUsed) {
                    Log.w(t, "Savepoint thread (p=" + priority + ") was cancelled (b) because another one is waiting (p=" + lastPriorityUsed + ")");
                    return null;
                }

                // write out xml
                SaveToDiskTask.exportXmlFile(payload, temp.getAbsolutePath());

                long end = System.currentTimeMillis();
                Log.i(t, "Savepoint ms: " + Long.toString(end - start) + " to " + temp);

                return null;
            } catch (Exception e) {
                String msg = e.getMessage();
                Log.e(t, msg, e);
                return msg;
            }
        }
    }

    @Override
    protected void onPostExecute(String errorMessage) {
        super.onPostExecute(errorMessage);

        if (listener != null && errorMessage != null) {
            listener.onSavePointError(errorMessage);
        }
    }
}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.tasks;

/**
 *
 * Author: Meletis Margaritis
 * Date: 15/3/2013
 * Time: 2:53 
 */
public class SaveResult {

    private int saveResult;
    private String saveErrorMessage;

    public int getSaveResult() {
        return saveResult;
    }

    public void setSaveResult(int saveResult) {
        this.saveResult = saveResult;
    }

    public void setSaveErrorMessage(String saveErrorMessage) {
        this.saveErrorMessage = saveErrorMessage;
    }

    public String getSaveErrorMessage() {
        return saveErrorMessage;
    }
}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.tasks;

import android.content.SharedPreferences;
import android.os.AsyncTask;
import android.preference.PreferenceManager;
import android.util.Log;

import org.javarosa.xform.parse.XFormParser;
import org.kxml2.kdom.Element;
import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.listeners.FormListDownloaderListener;
import org.odk.collect.android.logic.FormDetails;
import org.odk.collect.android.preferences.PreferencesActivity;
import org.odk.collect.android.utilities.DocumentFetchResult;
import org.odk.collect.android.utilities.WebUtils;
import org.opendatakit.httpclientandroidlib.client.HttpClient;
import org.opendatakit.httpclientandroidlib.protocol.HttpContext;

import java.util.HashMap;

/**
 * Background task for downloading forms from urls or a formlist from a url. We overload this task a
 * bit so that we don't have to keep track of two separate downloading tasks and it simplifies
 * interfaces. If LIST_URL is passed to doInBackground(), we fetch a form list. If a hashmap
 * containing form/url pairs is passed, we download those forms.
 *
 * @author carlhartung
 */
public class DownloadFormListTask extends AsyncTask<Void, String, HashMap<String, FormDetails>> {
    private static final String t = "DownloadFormsTask";

    // used to store error message if one occurs
    public static final String DL_ERROR_MSG = "dlerrormessage";
    public static final String DL_AUTH_REQUIRED = "dlauthrequired";

    private FormListDownloaderListener mStateListener;

    private static final String NAMESPACE_OPENROSA_ORG_XFORMS_XFORMS_LIST =
        "http://openrosa.org/xforms/xformsList";


    private boolean isXformsListNamespacedElement(Element e) {
        return e.getNamespace().equalsIgnoreCase(NAMESPACE_OPENROSA_ORG_XFORMS_XFORMS_LIST);
    }


    @Override
    protected HashMap<String, FormDetails> doInBackground(Void... values) {
        SharedPreferences settings =
            PreferenceManager.getDefaultSharedPreferences(Collect.getInstance().getApplication().getBaseContext());
        String downloadListUrl =
            settings.getString(PreferencesActivity.KEY_SERVER_URL,
                Collect.getInstance().getApplication().getString(R.string.default_server_url));
        // NOTE: /formlist must not be translated! It is the well-known path on the server.
        String formListUrl = Collect.getInstance().getApplication().getApplicationContext().getString(R.string.default_odk_formlist);
        String downloadPath = settings.getString(PreferencesActivity.KEY_FORMLIST_URL, formListUrl);
        downloadListUrl += downloadPath;

    	Collect.getInstance().getActivityLogger().logAction(this, formListUrl, downloadListUrl);

        // We populate this with available forms from the specified server.
        // <formname, details>
        HashMap<String, FormDetails> formList = new HashMap<String, FormDetails>();

        // get shared HttpContext so that authentication and cookies are retained.
        HttpContext localContext = Collect.getInstance().getHttpContext();
        HttpClient httpclient = WebUtils.createHttpClient(WebUtils.CONNECTION_TIMEOUT);

        DocumentFetchResult result =
            WebUtils.getXmlDocument(downloadListUrl, localContext, httpclient);

        // If we can't get the document, return the error, cancel the task
        if (result.errorMessage != null) {
            if (result.responseCode == 401) {
                formList.put(DL_AUTH_REQUIRED, new FormDetails(result.errorMessage));
            } else {
                formList.put(DL_ERROR_MSG, new FormDetails(result.errorMessage));
            }
            return formList;
        }

        if (result.isOpenRosaResponse) {
            // Attempt OpenRosa 1.0 parsing
            Element xformsElement = result.doc.getRootElement();
            if (!xformsElement.getName().equals("xforms")) {
                String error = "root element is not <xforms> : " + xformsElement.getName();
                Log.e(t, "Parsing OpenRosa reply -- " + error);
                formList.put(
                    DL_ERROR_MSG,
                    new FormDetails(Collect.getInstance().getApplication().getString(
                        R.string.parse_openrosa_formlist_failed, error)));
                return formList;
            }
            String namespace = xformsElement.getNamespace();
            if (!isXformsListNamespacedElement(xformsElement)) {
                String error = "root element namespace is incorrect:" + namespace;
                Log.e(t, "Parsing OpenRosa reply -- " + error);
                formList.put(
                    DL_ERROR_MSG,
                    new FormDetails(Collect.getInstance().getApplication().getString(
                        R.string.parse_openrosa_formlist_failed, error)));
                return formList;
            }
            int nElements = xformsElement.getChildCount();
            for (int i = 0; i < nElements; ++i) {
                if (xformsElement.getType(i) != Element.ELEMENT) {
                    // e.g., whitespace (text)
                    continue;
                }
                Element xformElement = (Element) xformsElement.getElement(i);
                if (!isXformsListNamespacedElement(xformElement)) {
                    // someone else's extension?
                    continue;
                }
                String name = xformElement.getName();
                if (!name.equalsIgnoreCase("xform")) {
                    // someone else's extension?
                    continue;
                }

                // this is something we know how to interpret
                String formId = null;
                String formName = null;
                String version = null;
                String majorMinorVersion = null;
                String description = null;
                String downloadUrl = null;
                String manifestUrl = null;
                // don't process descriptionUrl
                int fieldCount = xformElement.getChildCount();
                for (int j = 0; j < fieldCount; ++j) {
                    if (xformElement.getType(j) != Element.ELEMENT) {
                        // whitespace
                        continue;
                    }
                    Element child = xformElement.getElement(j);
                    if (!isXformsListNamespacedElement(child)) {
                        // someone else's extension?
                        continue;
                    }
                    String tag = child.getName();
                    if (tag.equals("formID")) {
                        formId = XFormParser.getXMLText(child, true);
                        if (formId != null && formId.length() == 0) {
                            formId = null;
                        }
                    } else if (tag.equals("name")) {
                        formName = XFormParser.getXMLText(child, true);
                        if (formName != null && formName.length() == 0) {
                            formName = null;
                        }
                    } else if (tag.equals("version")) {
                        version = XFormParser.getXMLText(child, true);
                        if (version != null && version.length() == 0) {
                        	version = null;
                        }
                    } else if (tag.equals("majorMinorVersion")) {
                        majorMinorVersion = XFormParser.getXMLText(child, true);
                        if (majorMinorVersion != null && majorMinorVersion.length() == 0) {
                            majorMinorVersion = null;
                        }
                    } else if (tag.equals("descriptionText")) {
                        description = XFormParser.getXMLText(child, true);
                        if (description != null && description.length() == 0) {
                            description = null;
                        }
                    } else if (tag.equals("downloadUrl")) {
                        downloadUrl = XFormParser.getXMLText(child, true);
                        if (downloadUrl != null && downloadUrl.length() == 0) {
                            downloadUrl = null;
                        }
                    } else if (tag.equals("manifestUrl")) {
                        manifestUrl = XFormParser.getXMLText(child, true);
                        if (manifestUrl != null && manifestUrl.length() == 0) {
                            manifestUrl = null;
                        }
                    }
                }
                if (formId == null || downloadUrl == null || formName == null) {
                    String error =
                        "Forms list entry " + Integer.toString(i)
                                + " is missing one or more tags: formId, name, or downloadUrl";
                    Log.e(t, "Parsing OpenRosa reply -- " + error);
                    formList.clear();
                    formList.put(
                        DL_ERROR_MSG,
                        new FormDetails(Collect.getInstance().getApplication().getString(
                            R.string.parse_openrosa_formlist_failed, error)));
                    return formList;
                }
                formList.put(formId, new FormDetails(formName, downloadUrl, manifestUrl, formId, (version != null) ? version : majorMinorVersion));
            }
        } else {
            // Aggregate 0.9.x mode...
            // populate HashMap with form names and urls
            Element formsElement = result.doc.getRootElement();
            int formsCount = formsElement.getChildCount();
            String formId = null;
            for (int i = 0; i < formsCount; ++i) {
                if (formsElement.getType(i) != Element.ELEMENT) {
                    // whitespace
                    continue;
                }
                Element child = formsElement.getElement(i);
                String tag = child.getName();
                if (tag.equals("formID")) {
                    formId = XFormParser.getXMLText(child, true);
                    if (formId != null && formId.length() == 0) {
                        formId = null;
                    }
                }
                if (tag.equalsIgnoreCase("form")) {
                    String formName = XFormParser.getXMLText(child, true);
                    if (formName != null && formName.length() == 0) {
                        formName = null;
                    }
                    String downloadUrl = child.getAttributeValue(null, "url");
                    downloadUrl = downloadUrl.trim();
                    if (downloadUrl != null && downloadUrl.length() == 0) {
                        downloadUrl = null;
                    }
                    if (downloadUrl == null || formName == null) {
                        String error =
                            "Forms list entry " + Integer.toString(i)
                                    + " is missing form name or url attribute";
                        Log.e(t, "Parsing OpenRosa reply -- " + error);
                        formList.clear();
                        formList.put(
                            DL_ERROR_MSG,
                            new FormDetails(Collect.getInstance().getApplication().getString(
                                R.string.parse_legacy_formlist_failed, error)));
                        return formList;
                    }
                    formList.put(formName, new FormDetails(formName, downloadUrl, null, formId, null));

                    formId = null;
                }
            }
        }
        return formList;
    }


    @Override
    protected void onPostExecute(HashMap<String, FormDetails> value) {
        synchronized (this) {
            if (mStateListener != null) {
                mStateListener.formListDownloadingComplete(value);
            }
        }
    }


    public void setDownloaderListener(FormListDownloaderListener sl) {
        synchronized (this) {
            mStateListener = sl;
        }
    }

}

/*
 * Copyright (C) 2009 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.tasks;

import android.content.ContentValues;
import android.database.Cursor;
import android.database.SQLException;
import android.net.Uri;
import android.os.AsyncTask;
import android.util.Log;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.listeners.DiskSyncListener;
import org.odk.collect.android.provider.FormsProviderAPI.FormsColumns;
import org.odk.collect.android.utilities.FileUtils;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;

/**
 * Background task for adding to the forms content provider, any forms that have been added to the
 * sdcard manually. Returns immediately if it detects an error.
 * 
 * @author Carl Hartung (carlhartung@gmail.com)
 */
public class DiskSyncTask extends AsyncTask<Void, String, String> {
    private final static String t = "DiskSyncTask";

    private static int counter = 0;

    int instance;
    
    DiskSyncListener mListener;

    String statusMessage;

    private static class UriFile {
    	public final Uri uri;
    	public final File file;
    	
    	UriFile(Uri uri, File file) {
    		this.uri = uri;
    		this.file = file;
    	}
    }
    
    @Override
    protected String doInBackground(Void... params) {
    	
    	instance = ++counter; // roughly track the scan # we're on... logging use only
    	Log.i(t, "["+instance+"] doInBackground begins!");
    	
    	try {
	    	// Process everything then report what didn't work.
	    	StringBuffer errors = new StringBuffer();
	    	
	        File formDir = new File(Collect.getInstance().getFormsPath());
	        if (formDir.exists() && formDir.isDirectory()) {
	            // Get all the files in the /odk/foms directory
	            List<File> xFormsToAdd = new LinkedList<File>();
	            
	            // Step 1: assemble the candidate form files
	            //         discard files beginning with "." 
	            //         discard files not ending with ".xml" or ".xhtml"
	            {
	            	File[] formDefs = formDir.listFiles();
	            	for ( File addMe: formDefs ) {
	                    // Ignore invisible files that start with periods.
	                    if (!addMe.getName().startsWith(".")
	                            && (addMe.getName().endsWith(".xml") || addMe.getName().endsWith(".xhtml"))) {
	                    	xFormsToAdd.add(addMe);
	                    } else { 
	                    	Log.i(t, "["+instance+"] Ignoring: " + addMe.getAbsolutePath());
	                    }
	            	}
	            }
	
	            // Step 2: quickly run through and figure out what files we need to 
	            // parse and update; this is quick, as we only calculate the md5
	            // and see if it has changed.
	            List<UriFile> uriToUpdate = new ArrayList<UriFile>();
		        Cursor mCursor = null;
		        // open the cursor within a try-catch block so it can always be closed. 
		        try {
		            mCursor = Collect.getInstance().getApplication().getContentResolver()
		                    .query(FormsColumns.CONTENT_URI, null, null, null, null);
			        if (mCursor == null) {
			            Log.e(t, "["+instance+"] Forms Content Provider returned NULL");
			            errors.append("Internal Error: Unable to access Forms content provider").append("\r\n");
			            return errors.toString();
			        }
		
			        mCursor.moveToPosition(-1);
		
		            while (mCursor.moveToNext()) {
		                // For each element in the provider, see if the file already exists
		                String sqlFilename =
		                    mCursor.getString(mCursor.getColumnIndex(FormsColumns.FORM_FILE_PATH));
		                String md5 = mCursor.getString(mCursor.getColumnIndex(FormsColumns.MD5_HASH));
		                File sqlFile = new File(sqlFilename);
		                if (sqlFile.exists()) {
		                    // remove it from the list of forms (we only want forms 
		                	// we haven't added at the end)
		                    xFormsToAdd.remove(sqlFile);
		                    if (!FileUtils.getMd5Hash(sqlFile).contentEquals(md5)) {
		                        // Probably someone overwrite the file on the sdcard
		                        // So re-parse it and update it's information
		                        String id = mCursor.getString(mCursor.getColumnIndex(FormsColumns._ID));
		                        Uri updateUri = Uri.withAppendedPath(FormsColumns.CONTENT_URI, id);
		                        uriToUpdate.add(new UriFile(updateUri, sqlFile));
		                    }
		                } else {
		                	Log.w(t, "["+instance+"] file referenced by content provider does not exist " + sqlFile);
		                }
		            }
		        } finally {
		        	if ( mCursor != null ) {
		        		mCursor.close();
		        	}
		        }
	            
		        // Step3: go through uriToUpdate to parse and update each in turn.
		        // This is slow because buildContentValues(...) is slow.
		        Collections.shuffle(uriToUpdate); // Big win if multiple DiskSyncTasks running
		        for ( UriFile entry : uriToUpdate ) {
		        	Uri updateUri = entry.uri;
		        	File formDefFile = entry.file;
	                // Probably someone overwrite the file on the sdcard
	                // So re-parse it and update it's information
		        	ContentValues values;
		        	
		        	try {
		        		values = buildContentValues(formDefFile);
		        	} catch ( IllegalArgumentException e) {
		        		errors.append(e.getMessage()).append("\r\n");
		        		File badFile = new File(formDefFile.getParentFile(), formDefFile.getName() + ".bad");
		        		badFile.delete();
		        		formDefFile.renameTo(badFile);
		        		continue;
		        	}
	                
	                // update in content provider
	                int count =
	                        Collect.getInstance().getApplication().getContentResolver()
	                                .update(updateUri, values, null, null);
	                    Log.i(t, "["+instance+"] " + count + " records successfully updated");
		        }
		        uriToUpdate.clear();
		        
		        // Step 4: go through the newly-discovered files in xFormsToAdd and add them.
		        // This is slow because buildContentValues(...) is slow.
		        //
		        Collections.shuffle(xFormsToAdd); // Big win if multiple DiskSyncTasks running
		        while ( !xFormsToAdd.isEmpty() ) {
		        	File formDefFile = xFormsToAdd.remove(0);
		        	
		        	// Since parsing is so slow, if there are multiple tasks, 
		        	// they may have already updated the database.  
		        	// Skip this file if that is the case.
		        	if ( isAlreadyDefined(formDefFile) ) {
		        		Log.i(t, "["+instance+"] skipping -- definition already recorded: " + formDefFile.getAbsolutePath());
		        		continue;
		        	}
		        	
	                // Parse it for the first time...
	                ContentValues values;
		        	
		        	try {
		        		values = buildContentValues(formDefFile);
		        	} catch ( IllegalArgumentException e) {
		        		errors.append(e.getMessage()).append("\r\n");
		        		File badFile = new File(formDefFile.getParentFile(), formDefFile.getName() + ".bad");
		        		badFile.delete();
		        		formDefFile.renameTo(badFile);
		        		continue;
		        	}
	                
	                // insert into content provider
		        	try {
		        		// insert failures are OK and expected if multiple 
		        		// DiskSync scanners are active.
		        		Collect.getInstance().getApplication().getContentResolver()
		            				.insert(FormsColumns.CONTENT_URI, values);
		        	} catch ( SQLException e ) {
		        		Log.i(t, "["+instance+"] " + e.toString());
		        	}
	            }
	        }
	        if ( errors.length() != 0 ) {
	        	statusMessage = errors.toString();
	        } else {
	        	statusMessage = Collect.getInstance().getApplication().getString(R.string.finished_disk_scan);
	        }
	        return statusMessage;
    	} finally {
    		Log.i(t, "["+instance+"] doInBackground ends!");
    	}
    }

    private boolean isAlreadyDefined(File formDefFile) {
        // first try to see if a record with this filename already exists...
        String[] projection = {
                FormsColumns._ID, FormsColumns.FORM_FILE_PATH
        };
        String[] selectionArgs = { formDefFile.getAbsolutePath() };
        String selection = FormsColumns.FORM_FILE_PATH + "=?";
        Cursor c = null;
        try {
        	c = Collect.getInstance().getApplication().getContentResolver()
    				.query(FormsColumns.CONTENT_URI, projection, selection, selectionArgs, null);
        	return ( c.getCount() > 0 );
        } finally {
        	if ( c != null ) {
        		c.close();
        	}
        }
    }
    
    public String getStatusMessage() {
    	return statusMessage;
    }
    
    /**
     * Attempts to parse the formDefFile as an XForm.
	 * This is slow because FileUtils.parseXML is slow
     * 
     * @param formDefFile
     * @return key-value list to update or insert into the content provider
     * @throws IllegalArgumentException if the file failed to parse or was missing fields
     */
    public static ContentValues buildContentValues(File formDefFile) throws IllegalArgumentException {
        // Probably someone overwrite the file on the sdcard
        // So re-parse it and update it's information
        ContentValues updateValues = new ContentValues();

        HashMap<String, String> fields = null;
        try {
            fields = FileUtils.parseXML(formDefFile);
        } catch (RuntimeException e) {
        	throw new IllegalArgumentException(formDefFile.getName() + " :: " + e.toString());
        }

        String title = fields.get(FileUtils.TITLE);
        String version = fields.get(FileUtils.VERSION);
        String formid = fields.get(FileUtils.FORMID);
        String submission = fields.get(FileUtils.SUBMISSIONURI);
        String base64RsaPublicKey = fields.get(FileUtils.BASE64_RSA_PUBLIC_KEY);

        // update date
        Long now = Long.valueOf(System.currentTimeMillis());
        updateValues.put(FormsColumns.DATE, now);

        if (title != null) {
            updateValues.put(FormsColumns.DISPLAY_NAME, title);
        } else {
        	throw new IllegalArgumentException(Collect.getInstance().getApplication().getString(R.string.xform_parse_error,
        			formDefFile.getName(), "title"));
        }
        if (formid != null) {
            updateValues.put(FormsColumns.JR_FORM_ID, formid);
        } else {
        	throw new IllegalArgumentException(Collect.getInstance().getApplication().getString(R.string.xform_parse_error,
        			formDefFile.getName(), "id"));
        }
        if (version != null) {
            updateValues.put(FormsColumns.JR_VERSION, version);
        }
        if (submission != null) {
            updateValues.put(FormsColumns.SUBMISSION_URI, submission);
        }
        if (base64RsaPublicKey != null) {
        	updateValues.put(FormsColumns.BASE64_RSA_PUBLIC_KEY, base64RsaPublicKey);
        }
        // Note, the path doesn't change here, but it needs to be included so the
        // update will automatically update the .md5 and the cache path.
        updateValues.put(FormsColumns.FORM_FILE_PATH, formDefFile.getAbsolutePath());
        
        return updateValues;
    }

    public void setDiskSyncListener(DiskSyncListener l) {
        mListener = l;
    }


    @Override
    protected void onPostExecute(String result) {
        super.onPostExecute(result);
        if (mListener != null) {
            mListener.SyncComplete(result);
        }
    }

}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.tasks;

import android.content.ContentValues;
import android.database.Cursor;
import android.net.Uri;
import android.os.AsyncTask;
import android.util.Log;

import org.javarosa.core.model.FormDef;
import org.javarosa.core.services.transport.payload.ByteArrayPayload;
import org.javarosa.form.api.FormEntryController;
import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.exception.EncryptionException;
import org.odk.collect.android.listeners.FormSavedListener;
import org.odk.collect.android.logic.FormController;
import org.odk.collect.android.provider.FormsProviderAPI.FormsColumns;
import org.odk.collect.android.provider.InstanceProviderAPI;
import org.odk.collect.android.provider.InstanceProviderAPI.InstanceColumns;
import org.odk.collect.android.utilities.EncryptionUtils;
import org.odk.collect.android.utilities.EncryptionUtils.EncryptedFormInformation;
import org.odk.collect.android.utilities.FileUtils;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;

/**
 * Background task for savig a form to disk.
 *
 * @author Carl Hartung (carlhartung@gmail.com)
 * @author Yaw Anokwa (yanokwa@gmail.com)
 */
public class SaveToDiskTask extends AsyncTask<Void, String, SaveResult> {
    private final static String t = "SaveToDiskTask";

    private FormSavedListener mSavedListener;
    private Boolean mSave;
    private Boolean mMarkCompleted;
    private Uri mUri;
    private String mInstanceName;

    public static final int SAVED = 500;
    public static final int SAVE_ERROR = 501;
    public static final int VALIDATE_ERROR = 502;
    public static final int VALIDATED = 503;
    public static final int SAVED_AND_EXIT = 504;


    public SaveToDiskTask(Uri uri, Boolean saveAndExit, Boolean markCompleted, String updatedName) {
        mUri = uri;
        mSave = saveAndExit;
        mMarkCompleted = markCompleted;
        mInstanceName = updatedName;
    }


    /**
     * Initialize {@link FormEntryController} with {@link FormDef} from binary or from XML. If given
     * an instance, it will be used to fill the {@link FormDef}.
     */
    @Override
    protected SaveResult doInBackground(Void... nothing) {
        SaveResult saveResult = new SaveResult();

        FormController formController = Collect.getInstance().getFormController();

        publishProgress(Collect.getInstance().getApplication().getString(R.string.survey_saving_validating_message));

        try {
            int validateStatus = formController.validateAnswers(mMarkCompleted);
            if (validateStatus != FormEntryController.ANSWER_OK) {
                // validation failed, pass specific failure
                saveResult.setSaveResult(validateStatus);
                return saveResult;
            }
        } catch (Exception e) {
            Log.e(t, e.getMessage(), e);

            // SCTO-825
            // that means that we have a bad design
            // save the exception to be used in the error dialog.
            saveResult.setSaveErrorMessage(e.getMessage());
            saveResult.setSaveResult(SAVE_ERROR);
            return saveResult;
        }

        // check if the "Cancel" was hit and exit.
        if (isCancelled()) {
            return null;
        }

        if (mMarkCompleted) {
        	formController.postProcessInstance();
        }

    	Collect.getInstance().getActivityLogger().logInstanceAction(this, "save", Boolean.toString(mMarkCompleted));

        // close all open databases of external data.
        Collect.getInstance().getExternalDataManager().close();

    	// if there is a meta/instanceName field, be sure we are using the latest value
    	// just in case the validate somehow triggered an update.
    	String updatedSaveName = formController.getSubmissionMetadata().instanceName;
    	if ( updatedSaveName != null ) {
    		mInstanceName = updatedSaveName;
    	}

        try {
    	    exportData(mMarkCompleted);

            // attempt to remove any scratch file
            File shadowInstance = savepointFile(formController.getInstancePath());
            if (shadowInstance.exists()) {
                FileUtils.deleteAndReport(shadowInstance);
            }

            saveResult.setSaveResult(mSave ? SAVED_AND_EXIT : SAVED);
        } catch (Exception e) {
            Log.e(t, e.getMessage(), e);

            saveResult.setSaveErrorMessage(e.getMessage());
            saveResult.setSaveResult(SAVE_ERROR);
        }

        return saveResult;
    }

    private void updateInstanceDatabase(boolean incomplete, boolean canEditAfterCompleted) {

        FormController formController = Collect.getInstance().getFormController();

        // Update the instance database...
        ContentValues values = new ContentValues();
        if (mInstanceName != null) {
            values.put(InstanceColumns.DISPLAY_NAME, mInstanceName);
        }
        if (incomplete || !mMarkCompleted) {
            values.put(InstanceColumns.STATUS, InstanceProviderAPI.STATUS_INCOMPLETE);
        } else {
            values.put(InstanceColumns.STATUS, InstanceProviderAPI.STATUS_COMPLETE);
        }
        // update this whether or not the status is complete...
        values.put(InstanceColumns.CAN_EDIT_WHEN_COMPLETE, Boolean.toString(canEditAfterCompleted));

        // If FormEntryActivity was started with an Instance, just update that instance
        if (Collect.getInstance().getApplication().getContentResolver().getType(mUri).equals(InstanceColumns.CONTENT_ITEM_TYPE)) {
            int updated = Collect.getInstance().getApplication().getContentResolver().update(mUri, values, null, null);
            if (updated > 1) {
                Log.w(t, "Updated more than one entry, that's not good: " + mUri.toString());
            } else if (updated == 1) {
                Log.i(t, "Instance successfully updated");
            } else {
                Log.e(t, "Instance doesn't exist but we have its Uri!! " + mUri.toString());
            }
        } else if (Collect.getInstance().getApplication().getContentResolver().getType(mUri).equals(FormsColumns.CONTENT_ITEM_TYPE)) {
            // If FormEntryActivity was started with a form, then it's likely the first time we're
            // saving.
            // However, it could be a not-first time saving if the user has been using the manual
            // 'save data' option from the menu. So try to update first, then make a new one if that
            // fails.
            String instancePath = formController.getInstancePath().getAbsolutePath();
            String where = InstanceColumns.INSTANCE_FILE_PATH + "=?";
            String[] whereArgs = {
            		instancePath
            };
            int updated =
                Collect.getInstance().getApplication().getContentResolver()
                        .update(InstanceColumns.CONTENT_URI, values, where, whereArgs);
            if (updated > 1) {
                Log.w(t, "Updated more than one entry, that's not good: " + instancePath);
            } else if (updated == 1) {
                Log.i(t, "Instance found and successfully updated: " + instancePath);
                // already existed and updated just fine
            } else {
                Log.i(t, "No instance found, creating");
                // Entry didn't exist, so create it.
                Cursor c = null;
                try {
                	// retrieve the form definition...
                	c = Collect.getInstance().getApplication().getContentResolver().query(mUri, null, null, null, null);
	                c.moveToFirst();
	                String jrformid = c.getString(c.getColumnIndex(FormsColumns.JR_FORM_ID));
	                String jrversion = c.getString(c.getColumnIndex(FormsColumns.JR_VERSION));
	                String formname = c.getString(c.getColumnIndex(FormsColumns.DISPLAY_NAME));
	                String submissionUri = null;
	                if ( !c.isNull(c.getColumnIndex(FormsColumns.SUBMISSION_URI)) ) {
	                	submissionUri = c.getString(c.getColumnIndex(FormsColumns.SUBMISSION_URI));
	                }

	                // add missing fields into values
	                values.put(InstanceColumns.INSTANCE_FILE_PATH, instancePath);
	                values.put(InstanceColumns.SUBMISSION_URI, submissionUri);
	                if (mInstanceName != null) {
	                    values.put(InstanceColumns.DISPLAY_NAME, mInstanceName);
	                } else {
	                    values.put(InstanceColumns.DISPLAY_NAME, formname);
	                }
	                values.put(InstanceColumns.JR_FORM_ID, jrformid);
	                values.put(InstanceColumns.JR_VERSION, jrversion);
                } finally {
                    if ( c != null ) {
                        c.close();
                    }
                }
                mUri = Collect.getInstance().getApplication().getContentResolver()
                			.insert(InstanceColumns.CONTENT_URI, values);
            }
        }
    }

    /**
     * Return the name of the savepoint file for a given instance.
     *
     * @param instancePath
     * @return
     */
    public static File savepointFile(File instancePath) {
        File tempDir = new File(Collect.getInstance().getCachePath());
        return new File(tempDir, instancePath.getName() + ".save");
    }

    /**
     * Write's the data to the sdcard, and updates the instances content provider.
     * In theory we don't have to write to disk, and this is where you'd add
     * other methods.
     *
     * @param markCompleted
     * @return
     */
    private void exportData(boolean markCompleted) throws IOException, EncryptionException {
        FormController formController = Collect.getInstance().getFormController();

        publishProgress(Collect.getInstance().getApplication().getString(R.string.survey_saving_collecting_message));

        ByteArrayPayload payload = formController.getFilledInFormXml();
        // write out xml
        String instancePath = formController.getInstancePath().getAbsolutePath();

        publishProgress(Collect.getInstance().getApplication().getString(R.string.survey_saving_saving_message));

        exportXmlFile(payload, instancePath);

        // update the mUri. We have exported the reloadable instance, so update status...
        // Since we saved a reloadable instance, it is flagged as re-openable so that if any error
        // occurs during the packaging of the data for the server fails (e.g., encryption),
        // we can still reopen the filled-out form and re-save it at a later time.
        updateInstanceDatabase(true, true);

        if ( markCompleted ) {
            // now see if the packaging of the data for the server would make it
        	// non-reopenable (e.g., encryption or send an SMS or other fraction of the form).
            boolean canEditAfterCompleted = formController.isSubmissionEntireForm();
            boolean isEncrypted = false;

            // build a submission.xml to hold the data being submitted
            // and (if appropriate) encrypt the files on the side

            // pay attention to the ref attribute of the submission profile...
            File instanceXml = formController.getInstancePath();
            File submissionXml = new File(instanceXml.getParentFile(), "submission.xml");

            payload = formController.getSubmissionXml();

            // write out submission.xml -- the data to actually submit to aggregate

            publishProgress(Collect.getInstance().getApplication().getString(R.string.survey_saving_finalizing_message));

            exportXmlFile(payload, submissionXml.getAbsolutePath());

            // see if the form is encrypted and we can encrypt it...
            EncryptedFormInformation formInfo = EncryptionUtils.getEncryptedFormInformation(mUri,
            		formController.getSubmissionMetadata());
            if ( formInfo != null ) {
                // if we are encrypting, the form cannot be reopened afterward
                canEditAfterCompleted = false;
                // and encrypt the submission (this is a one-way operation)...

                publishProgress(Collect.getInstance().getApplication().getString(R.string.survey_saving_encrypting_message));

                EncryptionUtils.generateEncryptedSubmission(instanceXml, submissionXml, formInfo);
                isEncrypted = true;
            }

            // At this point, we have:
            // 1. the saved original instanceXml,
            // 2. all the plaintext attachments
            // 2. the submission.xml that is the completed xml (whether encrypting or not)
            // 3. all the encrypted attachments if encrypting (isEncrypted = true).
            //
            // NEXT:
            // 1. Update the instance database (with status complete).
            // 2. Overwrite the instanceXml with the submission.xml
            //    and remove the plaintext attachments if encrypting

            updateInstanceDatabase(false, canEditAfterCompleted);

	        if (  !canEditAfterCompleted ) {
	            // AT THIS POINT, there is no going back.  We are committed
	            // to returning "success" (true) whether or not we can
	            // rename "submission.xml" to instanceXml and whether or
	            // not we can delete the plaintext media files.
	        	//
	        	// Handle the fall-out for a failed "submission.xml" rename
	        	// in the InstanceUploader task.  Leftover plaintext media
	        	// files are handled during form deletion.

	            // delete the restore Xml file.
	            if ( !instanceXml.delete() ) {
                    String msg = "Error deleting " + instanceXml.getAbsolutePath()
                            + " prior to renaming submission.xml";
                    Log.e(t, msg);
	                throw new IOException(msg);
	            }

	            // rename the submission.xml to be the instanceXml
	            if ( !submissionXml.renameTo(instanceXml) ) {
                    String msg = "Error renaming submission.xml to " + instanceXml.getAbsolutePath();
                    Log.e(t, msg);
	                throw new IOException(msg);
	            }
	        } else {
	        	// try to delete the submissionXml file, since it is
	        	// identical to the existing instanceXml file
	        	// (we don't need to delete and rename anything).
	            if ( !submissionXml.delete() ) {
                    String msg = "Error deleting " + submissionXml.getAbsolutePath()
                            + " (instance is re-openable)";
                    Log.w(t, msg);
	            }
	        }

            // if encrypted, delete all plaintext files
            // (anything not named instanceXml or anything not ending in .enc)
            if ( isEncrypted ) {
                if ( !EncryptionUtils.deletePlaintextFiles(instanceXml) ) {
                    Log.e(t, "Error deleting plaintext files for " + instanceXml.getAbsolutePath());
                }
            }
        }
    }


    /**
     * This method actually writes the xml to disk.
     * @param payload
     * @param path
     * @return
     */
    static void exportXmlFile(ByteArrayPayload payload, String path) throws IOException {
        File file = new File(path);
        if (file.exists() && !file.delete()) {
            throw new IOException("Cannot overwrite " + path + ". Perhaps the file is locked?");
        }

        // create data stream
        InputStream is = payload.getPayloadStream();
        int len = (int) payload.getLength();

        // read from data stream
        byte[] data = new byte[len];
//        try {
            int read = is.read(data, 0, len);
            if (read > 0) {
                // write xml file
                RandomAccessFile randomAccessFile = null;
                try {
                    // String filename = path + File.separator +
                    // path.substring(path.lastIndexOf(File.separator) + 1) + ".xml";
                    randomAccessFile = new RandomAccessFile(file, "rws");
                    randomAccessFile.write(data);
                } finally {
                    if (randomAccessFile != null) {
                        try {
                            randomAccessFile.close();
                        } catch (IOException e) {
                            Log.e(t, "Error closing RandomAccessFile: " + path, e);
                        }
                    }
                }
            }
//        } catch (IOException e) {
//            Log.e(t, "Error reading from payload data stream");
//            e.printStackTrace();
//            return false;
//        }
//
//        return false;
    }

    @Override
    protected void onProgressUpdate(String... values) {
        super.onProgressUpdate(values);

        if (mSavedListener != null && values != null) {
            if (values.length == 1) {
                mSavedListener.onProgressStep(values[0]);
            }
        }
    }

    @Override
    protected void onPostExecute(SaveResult result) {
        synchronized (this) {
            if (mSavedListener != null && result != null) {
                mSavedListener.savingComplete(result);
            }
        }
    }


    public void setFormSavedListener(FormSavedListener fsl) {
        synchronized (this) {
            mSavedListener = fsl;
        }
    }


}

package org.odk.collect.android.logic;

import org.javarosa.core.model.FormIndex;
import org.javarosa.form.api.FormEntryController;

import java.util.ArrayList;
import java.util.List;

/**
 * An object that traverses a form, calling {@link FormVisitor#visit} for each element in the form.
 */
public class FormTraverser {

    private final List<FormVisitor> mVisitors;

    private FormTraverser(List<FormVisitor> visitors) {
        mVisitors = new ArrayList<FormVisitor>(visitors);
    }

    public void traverse(FormController controller) {
        FormIndex originalFormIndex = controller.getFormIndex();

        try {
            controller.jumpToIndex(FormIndex.createBeginningOfFormIndex());

            int event = controller.getEvent();
            while (event != FormEntryController.EVENT_END_OF_FORM) {
                for (FormVisitor visitor : mVisitors) {
                    visitor.visit(event, controller);
                }
                controller.stepToNextEvent(false /*stepIntoGroup*/);
                event = controller.getEvent();
            }
        } finally {
            controller.jumpToIndex(originalFormIndex);
        }
    }

    public static class Builder {

        private List<FormVisitor> mVisitors = new ArrayList<FormVisitor>();

        public Builder addVisitor(FormVisitor visitor) {
            mVisitors.add(visitor);
            return this;
        }

        public FormTraverser build() {
            return new FormTraverser(mVisitors);
        }
    }
}

/**
 * 
 */

package org.odk.collect.android.logic;

import org.javarosa.core.reference.Reference;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

/**
 * @author ctsims
 */
public class FileReference implements Reference {
    String localPart;
    String referencePart;


    public FileReference(String localPart, String referencePart) {
        this.localPart = localPart;
        this.referencePart = referencePart;
    }


    private String getInternalURI() {
        return "/" + localPart + referencePart;
    }


    @Override
    public boolean doesBinaryExist() {
        return new File(getInternalURI()).exists();
    }


    @Override
    public InputStream getStream() throws IOException {
        return new FileInputStream(getInternalURI());
    }


    @Override
    public String getURI() {
        return "jr://file" + referencePart;
    }


    @Override
    public boolean isReadOnly() {
        return false;
    }


    @Override
    public OutputStream getOutputStream() throws IOException {
        return new FileOutputStream(getInternalURI());
    }


    @Override
    public void remove() {
        // TODO bad practice to ignore return values
        new File(getInternalURI()).delete();
    }


    @Override
    public String getLocalURI() {
        return getInternalURI();
    }


	@Override
	public Reference[] probeAlternativeReferences() {
		//We can't poll the JAR for resources, unfortunately. It's possible
		//we could try to figure out something about the file and poll alternatives
		//based on type (PNG-> JPG, etc)
		return new Reference [0];
	}

}

/*
 * Copyright (C) 2009 JavaRosa
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.logic;

import android.util.Log;

import org.javarosa.core.model.FormDef;
import org.javarosa.core.model.FormIndex;
import org.javarosa.core.model.GroupDef;
import org.javarosa.core.model.IDataReference;
import org.javarosa.core.model.IFormElement;
import org.javarosa.core.model.SubmissionProfile;
import org.javarosa.core.model.condition.EvaluationContext;
import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.StringData;
import org.javarosa.core.model.instance.FormInstance;
import org.javarosa.core.model.instance.TreeElement;
import org.javarosa.core.services.IPropertyManager;
import org.javarosa.core.services.PrototypeManager;
import org.javarosa.core.services.transport.payload.ByteArrayPayload;
import org.javarosa.form.api.FormEntryCaption;
import org.javarosa.form.api.FormEntryController;
import org.javarosa.form.api.FormEntryModel;
import org.javarosa.form.api.FormEntryPrompt;
import org.javarosa.model.xform.XFormSerializingVisitor;
import org.javarosa.model.xform.XFormsModule;
import org.javarosa.model.xform.XPathReference;
import org.javarosa.xform.parse.XFormParser;
import org.javarosa.xpath.XPathParseTool;
import org.javarosa.xpath.expr.XPathExpression;
import org.odk.collect.android.exception.JavaRosaException;
import org.odk.collect.android.serializers.XFormUtcDateAnswerDataSerializer;
import org.odk.collect.android.views.ODKView;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Vector;

/**
 * This class is a wrapper for Javarosa's FormEntryController. In theory, if you wanted to replace
 * javarosa as the form engine, you should only need to replace the methods in this file. Also, we
 * haven't wrapped every method provided by FormEntryController, only the ones we've needed so far.
 * Feel free to add more as necessary.
 *
 * @author carlhartung
 */
public class FormController {

    private static final String t = "FormController";

    public static final boolean STEP_INTO_GROUP = true;
    public static final boolean STEP_OVER_GROUP = false;

    /**
     * OpenRosa metadata tag names.
     */
    private static final String INSTANCE_ID = "instanceID";
    private static final String INSTANCE_NAME = "instanceName";

    /**
     * OpenRosa metadata of a form instance.
     *
     * Contains the values for the required metadata
     * fields and nothing else.
     *
     * @author mitchellsundt@gmail.com
     *
     */
    public static final class InstanceMetadata {
        public final String instanceId;
        public final String instanceName;

        InstanceMetadata( String instanceId, String instanceName ) {
            this.instanceId = instanceId;
            this.instanceName = instanceName;
        }
    };

    /**
     * Classes needed to serialize objects. Need to put anything from JR in here.
     */
    private final static String[] SERIALIABLE_CLASSES = {
    		"org.javarosa.core.services.locale.ResourceFileDataSource", // JavaRosaCoreModule
    		"org.javarosa.core.services.locale.TableLocaleSource", // JavaRosaCoreModule
            "org.javarosa.core.model.FormDef",
			"org.javarosa.core.model.SubmissionProfile", // CoreModelModule
			"org.javarosa.core.model.QuestionDef", // CoreModelModule
			"org.javarosa.core.model.GroupDef", // CoreModelModule
			"org.javarosa.core.model.instance.FormInstance", // CoreModelModule
			"org.javarosa.core.model.data.BooleanData", // CoreModelModule
			"org.javarosa.core.model.data.DateData", // CoreModelModule
			"org.javarosa.core.model.data.DateTimeData", // CoreModelModule
			"org.javarosa.core.model.data.DecimalData", // CoreModelModule
			"org.javarosa.core.model.data.GeoPointData", // CoreModelModule
			"org.javarosa.core.model.data.GeoShapeData", // CoreModelModule
			"org.javarosa.core.model.data.GeoTraceData", // CoreModelModule
			"org.javarosa.core.model.data.IntegerData", // CoreModelModule
			"org.javarosa.core.model.data.LongData", // CoreModelModule
			"org.javarosa.core.model.data.MultiPointerAnswerData", // CoreModelModule
			"org.javarosa.core.model.data.PointerAnswerData", // CoreModelModule
			"org.javarosa.core.model.data.SelectMultiData", // CoreModelModule
			"org.javarosa.core.model.data.SelectOneData", // CoreModelModule
			"org.javarosa.core.model.data.StringData", // CoreModelModule
			"org.javarosa.core.model.data.TimeData", // CoreModelModule
			"org.javarosa.core.model.data.UncastData", // CoreModelModule
			"org.javarosa.core.model.data.helper.BasicDataPointer", // CoreModelModule
			"org.javarosa.core.model.Action", // CoreModelModule
			"org.javarosa.core.model.actions.SetValueAction" // CoreModelModule
    };

    private static boolean isJavaRosaInitialized = false;

    /**
     * Isolate the initialization of JavaRosa into one method, called first
     * by the Collect Application.  Called subsequently whenever the Preferences
     * dialogs are exited (to potentially update username and email fields).
     *
     * @param mgr
     */
    public static synchronized void initializeJavaRosa(IPropertyManager mgr) {
		if ( !isJavaRosaInitialized ) {
            // need a list of classes that formdef uses
            // unfortunately, the JR registerModule() functions do more than this.
            // register just the classes that would have been registered by:
            // new JavaRosaCoreModule().registerModule();
            // new CoreModelModule().registerModule();
            // replace with direct call to PrototypeManager
            PrototypeManager.registerPrototypes(SERIALIABLE_CLASSES);
            new XFormsModule().registerModule();

            isJavaRosaInitialized = true;
		}

		// needed to override rms property manager
		org.javarosa.core.services.PropertyManager
				.setPropertyManager(mgr);
    }

    private File mMediaFolder;
    private File mInstancePath;
    private FormEntryController mFormEntryController;
    private FormIndex mIndexWaitingForData = null;

    public FormController(File mediaFolder, FormEntryController fec, File instancePath) {
    	mMediaFolder = mediaFolder;
        mFormEntryController = fec;
        mInstancePath = instancePath;
    }

    public FormDef getFormDef() {
        return mFormEntryController.getModel().getForm();
    }

    public File getMediaFolder() {
    	return mMediaFolder;
    }

    public File getInstancePath() {
    	return mInstancePath;
    }

    public void setInstancePath(File instancePath) {
    	mInstancePath = instancePath;
    }

    public void setIndexWaitingForData(FormIndex index) {
    	mIndexWaitingForData = index;
    }

    public FormIndex getIndexWaitingForData() {
    	return mIndexWaitingForData;
    }

    /**
     * For logging purposes...
     *
     * @param index
     * @return xpath value for this index
     */
    public String getXPath(FormIndex index) {
    	String value;
    	switch ( getEvent() ) {
    	case FormEntryController.EVENT_BEGINNING_OF_FORM:
    		value = "beginningOfForm";
    		break;
    	case FormEntryController.EVENT_END_OF_FORM:
    		value = "endOfForm";
    		break;
    	case FormEntryController.EVENT_GROUP:
    		value = "group." + index.getReference().toString();
    		break;
    	case FormEntryController.EVENT_QUESTION:
    		value = "question." + index.getReference().toString();
    		break;
    	case FormEntryController.EVENT_PROMPT_NEW_REPEAT:
    		value = "promptNewRepeat." + index.getReference().toString();
    		break;
    	case FormEntryController.EVENT_REPEAT:
    		value = "repeat." + index.getReference().toString();
    		break;
    	case FormEntryController.EVENT_REPEAT_JUNCTURE:
    		value = "repeatJuncture." + index.getReference().toString();
    		break;
		default:
			value = "unexpected";
    		break;
    	}
    	return value;
    }

    public FormIndex getIndexFromXPath(String xPath) {
    	if ( xPath.equals("beginningOfForm") ) {
            return FormIndex.createBeginningOfFormIndex();
    	} else if ( xPath.equals("endOfForm") ) {
    		return FormIndex.createEndOfFormIndex();
    	} else if ( xPath.equals("unexpected") ) {
    		Log.e(t, "Unexpected string from XPath");
    		throw new IllegalArgumentException("unexpected string from XPath");
    	} else {
    		FormIndex returned = null;
			FormIndex saved = getFormIndex();
			// the only way I know how to do this is to step through the entire form
			// until the XPath of a form entry matches that of the supplied XPath
			try {
				jumpToIndex(FormIndex.createBeginningOfFormIndex());
				int event = stepToNextEvent(true);
				while ( event != FormEntryController.EVENT_END_OF_FORM ) {
					String candidateXPath = getXPath(getFormIndex());
					// Log.i(t, "xpath: " + candidateXPath);
					if ( candidateXPath.equals(xPath) ) {
						returned = getFormIndex();
						break;
					}
					event = stepToNextEvent(true);
				}
			} finally {
				jumpToIndex(saved);
			}
			return returned;
    	}
    }

    /**
     * returns the event for the current FormIndex.
     *
     * @return
     */
    public int getEvent() {
        return mFormEntryController.getModel().getEvent();
    }


    /**
     * returns the event for the given FormIndex.
     *
     * @param index
     * @return
     */
    public int getEvent(FormIndex index) {
        return mFormEntryController.getModel().getEvent(index);
    }


    /**
     * @return current FormIndex.
     */
    public FormIndex getFormIndex() {
        return mFormEntryController.getModel().getFormIndex();
    }


    /**
     * Return the langauges supported by the currently loaded form.
     *
     * @return Array of Strings containing the languages embedded in the XForm.
     */
    public String[] getLanguages() {
        return mFormEntryController.getModel().getLanguages();
    }


    /**
     * @return A String containing the title of the current form.
     */
    public String getFormTitle() {
        return mFormEntryController.getModel().getFormTitle();
    }


    /**
     * @return the currently selected language.
     */
    public String getLanguage() {
        return mFormEntryController.getModel().getLanguage();
    }

    public String getBindAttribute( String attributeNamespace, String attributeName) {
    	return getBindAttribute( getFormIndex(), attributeNamespace, attributeName );
    }

    public String getBindAttribute(FormIndex idx, String attributeNamespace, String attributeName) {
        return mFormEntryController.getModel().getForm().getMainInstance().resolveReference(
                idx.getReference()).getBindAttributeValue(attributeNamespace, attributeName);
    }

    /**
     * @return an array of FormEntryCaptions for the current FormIndex. This is how we get group
     *         information Group 1 > Group 2> etc... The element at [size-1] is the current question
     *         text, with group names decreasing in hierarchy until array element at [0] is the root
     */
    private FormEntryCaption[] getCaptionHierarchy() {
        return mFormEntryController.getModel().getCaptionHierarchy();
    }

    /**
     * @param index
     * @return an array of FormEntryCaptions for the supplied FormIndex. This is how we get group
     *         information Group 1 > Group 2> etc... The element at [size-1] is the current question
     *         text, with group names decreasing in hierarchy until array element at [0] is the root
     */
    private FormEntryCaption[] getCaptionHierarchy(FormIndex index) {
        return mFormEntryController.getModel().getCaptionHierarchy(index);
    }

    /**
     * Returns a caption prompt for the given index. This is used to create a multi-question per
     * screen view.
     *
     * @param index
     * @return
     */
    public FormEntryCaption getCaptionPrompt(FormIndex index) {
        return mFormEntryController.getModel().getCaptionPrompt(index);
    }


    /**
     * Return the caption for the current FormIndex. This is usually used for a repeat prompt.
     *
     * @return
     */
    public FormEntryCaption getCaptionPrompt() {
        return mFormEntryController.getModel().getCaptionPrompt();
    }


    /**
     * This fires off the jr:preload actions and events to save values like the
     * end time of a form.
     *
     * @return
     */
    public boolean postProcessInstance() {
        return mFormEntryController.getModel().getForm().postProcessInstance();
    }


    /**
     * TODO: We need a good description of what this does, exactly, and why.
     *
     * @return
     */
    private FormInstance getInstance() {
        return mFormEntryController.getModel().getForm().getInstance();
    }


    /**
     * A convenience method for determining if the current FormIndex is in a group that is/should be
     * displayed as a multi-question view. This is useful for returning from the formhierarchy view
     * to a selected index.
     *
     * @param index
     * @return
     */
    private boolean groupIsFieldList(FormIndex index) {
        // if this isn't a group, return right away
    	IFormElement element = mFormEntryController.getModel().getForm().getChild(index);
        return element instanceof GroupDef;
//        if (!(element instanceof GroupDef)) {
//            return false;
//        }
//
//        GroupDef gd = (GroupDef) element; // exceptions?
//        return (ODKView.FIELD_LIST.equalsIgnoreCase(gd.getAppearanceAttr()));
    }

    private boolean repeatIsFieldList(FormIndex index) {
        // if this isn't a group, return right away
    	IFormElement element = mFormEntryController.getModel().getForm().getChild(index);
        return element instanceof GroupDef;
//        if (!(element instanceof GroupDef)) {
//            return false;
//        }
//
//        GroupDef gd = (GroupDef) element; // exceptions?
//        return (ODKView.FIELD_LIST.equalsIgnoreCase(gd.getAppearanceAttr()));
    }

    /**
     * Tests if the FormIndex 'index' is located inside a group that is marked as a "field-list"
     *
     * @param index
     * @return true if index is in a "field-list". False otherwise.
     */
    private boolean indexIsInFieldList(FormIndex index) {
        int event = getEvent(index);
        if (event == FormEntryController.EVENT_QUESTION) {
            // caption[0..len-1]
            // caption[len-1] == the question itself
            // caption[len-2] == the first group it is contained in.
            FormEntryCaption[] captions = getCaptionHierarchy(index);
            if (captions.length < 2) {
                // no group
                return false;
            }
            FormEntryCaption grp = captions[captions.length - 2];
            return groupIsFieldList(grp.getIndex());
        } else if (event == FormEntryController.EVENT_GROUP) {
            return groupIsFieldList(index);
        } else if (event == FormEntryController.EVENT_REPEAT) {
        	return repeatIsFieldList(index);
        } else {
            // right now we only test Questions and Groups. Should we also handle
            // repeats?
            return false;
        }

    }

    public boolean currentPromptIsQuestion() {
        return (getEvent() == FormEntryController.EVENT_QUESTION
        		|| ((getEvent() == FormEntryController.EVENT_GROUP ||
        			 getEvent() == FormEntryController.EVENT_REPEAT)
        				&& indexIsInFieldList()));
    }

    /**
     * Tests if the current FormIndex is located inside a group that is marked as a "field-list"
     *
     * @return true if index is in a "field-list". False otherwise.
     */
    public boolean indexIsInFieldList() {
        return true;
        //return indexIsInFieldList(getFormIndex());
    }


    /**
     * Attempts to save answer at the current FormIndex into the data model.
     *
     * @param data
     * @return
     */
    private int answerQuestion(IAnswerData data) {
        return mFormEntryController.answerQuestion(data);
    }


    /**
     * Attempts to save answer into the given FormIndex into the data model.
     *
     * @param index
     * @param data
     * @return
     */
    public int answerQuestion(FormIndex index, IAnswerData data) throws JavaRosaException {
        try {
            return mFormEntryController.answerQuestion(index, data);
        } catch (Exception e) {
           throw new JavaRosaException(e);
        }
    }

    /**
     * Goes through the entire form to make sure all entered answers comply with their constraints.
     * Constraints are ignored on 'jump to', so answers can be outside of constraints. We don't
     * allow saving to disk, though, until all answers conform to their constraints/requirements.
     *
     *
     * @param markCompleted
     * @return ANSWER_OK and leave index unchanged or change index to bad value and return error type.
     */
    public int validateAnswers(Boolean markCompleted) {
        FormEntryController formEntryController = this.mFormEntryController;
        FormEntryModel formEntryModel = formEntryController.getModel();

        FormEntryModel formEntryModelToBeValidated = new FormEntryModel(formEntryModel.getForm());
        FormEntryController formEntryControllerToBeValidated = new FormEntryController(formEntryModelToBeValidated);
        FormController formControllerToBeValidated = new FormController(this.getMediaFolder(), formEntryControllerToBeValidated, this.getInstancePath());

        formControllerToBeValidated.jumpToIndex(FormIndex.createBeginningOfFormIndex());

        int event;
        while ((event =
                formControllerToBeValidated.stepToNextEvent(FormController.STEP_INTO_GROUP)) != FormEntryController.EVENT_END_OF_FORM) {
            if (event != FormEntryController.EVENT_QUESTION) {
                continue;
            } else {
                FormIndex formControllerToBeValidatedFormIndex = formControllerToBeValidated.getFormIndex();

                int saveStatus = formControllerToBeValidated.answerQuestion(formControllerToBeValidated.getQuestionPrompt().getAnswerValue());
                if (markCompleted && saveStatus != FormEntryController.ANSWER_OK) {
                    // jump to the error
                    this.jumpToIndex(formControllerToBeValidatedFormIndex);
                    return saveStatus;
                }
            }
        }

        return FormEntryController.ANSWER_OK;
    }


    /**
     * saveAnswer attempts to save the current answer into the data model without doing any
     * constraint checking. Only use this if you know what you're doing. For normal form filling you
     * should always use answerQuestion or answerCurrentQuestion.
     *
     * @param index
     * @param data
     * @return true if saved successfully, false otherwise.
     */
    public boolean saveAnswer(FormIndex index, IAnswerData data) throws JavaRosaException {
        try {
            return mFormEntryController.saveAnswer(index, data);
        } catch (Exception e) {
            throw new JavaRosaException(e);
        }
    }


    /**
     * saveAnswer attempts to save the current answer into the data model without doing any
     * constraint checking. Only use this if you know what you're doing. For normal form filling you
     * should always use answerQuestion().
     *
     * @param data
     * @return true if saved successfully, false otherwise.
     */
    public boolean saveAnswer(IAnswerData data) throws JavaRosaException {
        try {
            return mFormEntryController.saveAnswer(data);
        } catch (Exception e) {
            throw new JavaRosaException(e);
        }
    }


    /**
     * Navigates forward in the form.
     *
     * @return the next event that should be handled by a view.
     */
    public int stepToNextEvent(boolean stepIntoGroup) {
        if ((getEvent() == FormEntryController.EVENT_GROUP ||
        	 getEvent() == FormEntryController.EVENT_REPEAT)
                && indexIsInFieldList() && !stepIntoGroup) {
            return stepOverGroup();
        } else {
            return mFormEntryController.stepToNextEvent();
        }
    }


    /**
     * If using a view like HierarchyView that doesn't support multi-question per screen, step over
     * the group represented by the FormIndex.
     *
     * @return
     */
    private int stepOverGroup() {
        ArrayList<FormIndex> indicies = new ArrayList<FormIndex>();
        GroupDef gd =
            (GroupDef) mFormEntryController.getModel().getForm()
                    .getChild(getFormIndex());
        FormIndex idxChild =
            mFormEntryController.getModel().incrementIndex(
                getFormIndex(), true); // descend into group
        for (int i = 0; i < gd.getChildren().size(); i++) {
            indicies.add(idxChild);
            // don't descend
            idxChild = mFormEntryController.getModel().incrementIndex(idxChild, false);
        }

        // jump to the end of the group
        mFormEntryController.jumpToIndex(indicies.get(indicies.size() - 1));
        return stepToNextEvent(STEP_OVER_GROUP);
    }

    /**
     * used to go up one level in the formIndex. That is, if you're at 5_0, 1 (the second question
     * in a repeating group), this method will return a FormInex of 5_0 (the start of the repeating
     * group). If your at index 16 or 5_0, this will return null;
     *
     * @param index
     * @return index
     */
    public FormIndex stepIndexOut(FormIndex index) {
        if (index.isTerminal()) {
            return null;
        } else {
            return new FormIndex(stepIndexOut(index.getNextLevel()), index);
        }
    }

    /**
     * Move the current form index to the index of the previous question in the form.
     * Step backward out of repeats and groups as needed. If the resulting question
     * is itself within a field-list, move upward to the group or repeat defining that
     * field-list.
     *
     * @return
     */
    public int stepToPreviousScreenEvent() throws JavaRosaException {
        try {
            if (getEvent() != FormEntryController.EVENT_BEGINNING_OF_FORM) {
                int event = stepToPreviousEvent();

                while (event == FormEntryController.EVENT_REPEAT_JUNCTURE ||
                       event == FormEntryController.EVENT_PROMPT_NEW_REPEAT ||
                       (event == FormEntryController.EVENT_QUESTION && indexIsInFieldList()) ||
                       ((event == FormEntryController.EVENT_GROUP
                         || event == FormEntryController.EVENT_REPEAT) && !indexIsInFieldList())) {
                    event = stepToPreviousEvent();
                }

                // Work-around for broken field-list handling from 1.1.7 which breaks either
                // build-generated forms or XLSForm-generated forms.  If the current group
                // is a GROUP with field-list and it is nested within a group or repeat with just
                // this containing group, and that is also a field-list, then return the parent group.
                if ( getEvent() == FormEntryController.EVENT_GROUP ) {
                    FormIndex currentIndex = getFormIndex();
                    IFormElement element = mFormEntryController.getModel().getForm().getChild(currentIndex);
                    if (element instanceof GroupDef) {
                        GroupDef gd = (GroupDef) element;
                        if ( ODKView.FIELD_LIST.equalsIgnoreCase(gd.getAppearanceAttr()) ) {
                            // OK this group is a field-list... see what the parent is...
                            FormEntryCaption[] fclist = this.getCaptionHierarchy(currentIndex);
                            if ( fclist.length > 1) {
                                FormEntryCaption fc = fclist[fclist.length-2];
                                GroupDef pd = (GroupDef) fc.getFormElement();
                                if ( pd.getChildren().size() == 1 &&
                                     ODKView.FIELD_LIST.equalsIgnoreCase(pd.getAppearanceAttr()) ) {
                                    mFormEntryController.jumpToIndex(fc.getIndex());
                                }
                            }
                        }
                    }
                }
            }
            return getEvent();
        } catch (RuntimeException e) {
            throw new JavaRosaException(e);
        }
    }

    /**
     * Move the current form index to the index of the next question in the form.
     * Stop if we should ask to create a new repeat group or if we reach the end of the form.
     * If we enter a group or repeat, return that if it is a field-list definition.
     * Otherwise, descend into the group or repeat searching for the first question.
     *
     * @return
     */
    public int stepToNextScreenEvent() throws JavaRosaException {
        try {
            if (getEvent() != FormEntryController.EVENT_END_OF_FORM) {
                int event;
                group_skip: do {
                    event = stepToNextEvent(FormController.STEP_OVER_GROUP);
                    switch (event) {
                        case FormEntryController.EVENT_QUESTION:
                            break group_skip;
                        case FormEntryController.EVENT_END_OF_FORM:
                            break;
                        case FormEntryController.EVENT_PROMPT_NEW_REPEAT:
                            break group_skip;
                        case FormEntryController.EVENT_GROUP:
                        case FormEntryController.EVENT_REPEAT:
                            if (indexIsInFieldList()
                                    && getQuestionPrompts().length != 0) {
                                break group_skip;
                            }
                            // otherwise it's not a field-list group, so just skip it
                            break;
                        case FormEntryController.EVENT_REPEAT_JUNCTURE:
                            Log.i(t, "repeat juncture: "
                                    + getFormIndex().getReference());
                            // skip repeat junctures until we implement them
                            break;
                        default:
                            Log.w(t,
                                "JavaRosa added a new EVENT type and didn't tell us... shame on them.");
                            break;
                    }
                } while (event != FormEntryController.EVENT_END_OF_FORM);
            }
            return getEvent();
        } catch (RuntimeException e) {
            throw new JavaRosaException(e);
        }
    }


    /**
     * Move the current form index to the index of the first enclosing repeat
     * or to the start of the form.
     *
     * @return
     */
    public int stepToOuterScreenEvent() {
        FormIndex index = stepIndexOut(getFormIndex());
        int currentEvent = getEvent();

        // Step out of any group indexes that are present.
        while (index != null
                && getEvent(index) == FormEntryController.EVENT_GROUP) {
            index = stepIndexOut(index);
        }

        if (index == null) {
            jumpToIndex(FormIndex.createBeginningOfFormIndex());
        } else {
            if (currentEvent == FormEntryController.EVENT_REPEAT) {
                // We were at a repeat, so stepping back brought us to then previous level
                jumpToIndex(index);
            } else {
                // We were at a question, so stepping back brought us to either:
                // The beginning. or The start of a repeat. So we need to step
                // out again to go passed the repeat.
                index = stepIndexOut(index);
                if (index == null) {
                    jumpToIndex(FormIndex.createBeginningOfFormIndex());
                } else {
                    jumpToIndex(index);
                }
            }
        }
        return getEvent();
    }


    public static class FailedConstraint {
    	public final FormIndex index;
    	public final int status;

    	FailedConstraint(FormIndex index, int status) {
    		this.index = index;
    		this.status = status;
    	}
    }
    /**
     *
     * @param answers
     * @param evaluateConstraints
     * @return FailedConstraint of first failed constraint or null if all questions were saved.
     */
    public FailedConstraint saveAnswers(LinkedHashMap<FormIndex, IAnswerData> answers, boolean evaluateConstraints) throws JavaRosaException {
        Iterator<FormIndex> it = answers.keySet().iterator();
        while (it.hasNext()) {
            FormIndex index = it.next();
            // Within a group, you can only save for question events
            if (getEvent(index) == FormEntryController.EVENT_QUESTION) {
                int saveStatus;
                IAnswerData answer = answers.get(index);
                if (evaluateConstraints) {
                    saveStatus = answerQuestion(index, answer);
                    if (saveStatus != FormEntryController.ANSWER_OK) {
                        return new FailedConstraint(index, saveStatus);
                    }
                } else {
                    saveAnswer(index, answer);
                }
            } else {
                Log.w(t,
                    "Attempted to save an index referencing something other than a question: "
                            + index.getReference());
            }
        }

        return null;
    }


    /**
     * Navigates backward in the form.
     *
     * @return the event that should be handled by a view.
     */
    public int stepToPreviousEvent() {
        /*
         * Right now this will always skip to the beginning of a group if that group is represented
         * as a 'field-list'. Should a need ever arise to step backwards by only one step in a
         * 'field-list', this method will have to be updated.
         */

        mFormEntryController.stepToPreviousEvent();

        // If after we've stepped, we're in a field-list, jump back to the beginning of the group
        //

        if (indexIsInFieldList()
                && getEvent() == FormEntryController.EVENT_QUESTION) {
            // caption[0..len-1]
            // caption[len-1] == the question itself
            // caption[len-2] == the first group it is contained in.
            FormEntryCaption[] captions = getCaptionHierarchy();
            FormEntryCaption grp = captions[captions.length - 2];
            int event = mFormEntryController.jumpToIndex(grp.getIndex());
            // and test if this group or at least one of its children is relevant...
            FormIndex idx = grp.getIndex();
            if ( !mFormEntryController.getModel().isIndexRelevant(idx) ) {
            	return stepToPreviousEvent();
            }
            idx = mFormEntryController.getModel().incrementIndex(idx, true);
            while ( FormIndex.isSubElement(grp.getIndex(), idx) ) {
            	if ( mFormEntryController.getModel().isIndexRelevant(idx) ) {
            		return event;
            	}
                idx = mFormEntryController.getModel().incrementIndex(idx, true);
            }
            return stepToPreviousEvent();
        } else if ( indexIsInFieldList() && getEvent() == FormEntryController.EVENT_GROUP) {
            FormIndex grpidx = mFormEntryController.getModel().getFormIndex();
            int event = mFormEntryController.getModel().getEvent();
            // and test if this group or at least one of its children is relevant...
            if ( !mFormEntryController.getModel().isIndexRelevant(grpidx) ) {
            	return stepToPreviousEvent(); // shouldn't happen?
            }
            FormIndex idx = mFormEntryController.getModel().incrementIndex(grpidx, true);
            while ( FormIndex.isSubElement(grpidx, idx) ) {
            	if ( mFormEntryController.getModel().isIndexRelevant(idx) ) {
            		return event;
            	}
                idx = mFormEntryController.getModel().incrementIndex(idx, true);
            }
            return stepToPreviousEvent();
        }

        return getEvent();

    }


    /**
     * Jumps to a given FormIndex.
     *
     * @param index
     * @return EVENT for the specified Index.
     */
    public int jumpToIndex(FormIndex index) {
        return mFormEntryController.jumpToIndex(index);
    }


    /**
     * Creates a new repeated instance of the group referenced by the current FormIndex.
     *
     * @param questionIndex
     */
    public void newRepeat() {
        mFormEntryController.newRepeat();
    }


    /**
     * If the current FormIndex is within a repeated group, will find the innermost repeat, delete
     * it, and jump the FormEntryController to the previous valid index. That is, if you have group1
     * (2) > group2 (3) and you call deleteRepeat, it will delete the 3rd instance of group2.
     */
    public void deleteRepeat() {
        FormIndex fi = mFormEntryController.deleteRepeat();
        mFormEntryController.jumpToIndex(fi);
    }


    /**
     * Sets the current language.
     *
     * @param language
     */
    public void setLanguage(String language) {
        mFormEntryController.setLanguage(language);
    }


    /**
     * Returns an array of question promps.
     *
     * @return
     */
    public FormEntryPrompt[] getQuestionPrompts() throws RuntimeException {

        ArrayList<FormIndex> indicies = new ArrayList<FormIndex>();
        FormIndex currentIndex = getFormIndex();

        // For questions, there is only one.
        // For groups, there could be many, but we set that below
        FormEntryPrompt[] questions = new FormEntryPrompt[1];

        // TODO(ping): Maybe this is where we can associate the FormEntryPrompts
        // with their openmrs_concept attributes, so that each widget can find
        // which preset to apply?

    	IFormElement element = mFormEntryController.getModel().getForm().getChild(currentIndex);
        if (element instanceof GroupDef) {
            GroupDef gd = (GroupDef) element;
            // descend into group
            FormIndex idxChild = mFormEntryController.getModel().incrementIndex(currentIndex, true);

            if ( gd.getChildren().size() == 1 && getEvent(idxChild) == FormEntryController.EVENT_GROUP ) {
            	// if we have a group definition within a field-list attribute group, and this is the
            	// only child in the group, check to see if it is also a field-list appearance.
            	// If it is, then silently recurse into it to pick up its elements.
            	// Work-around for the inconsistent treatment of field-list groups and repeats in 1.1.7 that
            	// either breaks forms generated by build or breaks forms generated by XLSForm.
            	IFormElement nestedElement = mFormEntryController.getModel().getForm().getChild(idxChild);
                if (nestedElement instanceof GroupDef) {
                    GroupDef nestedGd = (GroupDef) nestedElement;
                    if ( ODKView.FIELD_LIST.equalsIgnoreCase(nestedGd.getAppearanceAttr()) ) {
                    	gd = nestedGd;
                    	idxChild = mFormEntryController.getModel().incrementIndex(idxChild, true);
                    }
                }
            }

            for (int i = 0; i < gd.getChildren().size(); i++) {
                indicies.add(idxChild);
                // don't descend
                idxChild = mFormEntryController.getModel().incrementIndex(idxChild, false);
            }

            // we only display relevant questions
            ArrayList<FormEntryPrompt> questionList = new ArrayList<FormEntryPrompt>();
            for (int i = 0; i < indicies.size(); i++) {
                FormIndex index = indicies.get(i);

                if (getEvent(index) != FormEntryController.EVENT_QUESTION) {
                    String errorMsg =
                        "Only questions are allowed in 'field-list'.  Bad node is: "
                                + index.getReference().toString(false);
                    RuntimeException e = new RuntimeException(errorMsg);
                    Log.e(t, errorMsg);
                    throw e;
                }

                // we only display relevant questions
                if (mFormEntryController.getModel().isIndexRelevant(index)) {
                    questionList.add(getQuestionPrompt(index));
                }
                questions = new FormEntryPrompt[questionList.size()];
                questionList.toArray(questions);
            }
        } else {
            // We have a quesion, so just get the one prompt
            questions[0] = getQuestionPrompt();
        }

        return questions;
    }


    public FormEntryPrompt getQuestionPrompt(FormIndex index) {
        return mFormEntryController.getModel().getQuestionPrompt(index);
    }


    public FormEntryPrompt getQuestionPrompt() {
        return mFormEntryController.getModel().getQuestionPrompt();
    }

    public String getQuestionPromptConstraintText(FormIndex index) {
    	return mFormEntryController.getModel().getQuestionPrompt(index).getConstraintText();
    }

    public String getQuestionPromptRequiredText(FormIndex index) {
    	// look for the text under the requiredMsg bind attribute
		String constraintText = getBindAttribute(index, XFormParser.NAMESPACE_JAVAROSA, "requiredMsg");
		if (constraintText != null) {
	    	XPathExpression xPathRequiredMsg;
			try {
				xPathRequiredMsg = XPathParseTool.parseXPath("string(" + constraintText + ")");
			} catch(Exception e) {
				// Expected in probably most cases.
                // This is a string literal, so no need to evaluate anything.
                return constraintText;
			}

			if(xPathRequiredMsg != null) {
				try{
					FormDef form = mFormEntryController.getModel().getForm();
					TreeElement mTreeElement = form.getMainInstance().resolveReference(index.getReference());
					EvaluationContext ec = new EvaluationContext(form.exprEvalContext, mTreeElement.getRef());
					Object value = xPathRequiredMsg.eval(form.getMainInstance(), ec);
					if(value != "") {
						return (String)value;
					}
					return null;
				} catch(Exception e) {
					Log.e(t,"Error evaluating a valid-looking required xpath ", e);
					return constraintText;
				}
			} else {
				return constraintText;
			}
		}
		return null;
    }

    /**
     * Returns an array of FormEntryCaptions for current FormIndex.
     *
     * @return
     */
    public FormEntryCaption[] getGroupsForCurrentIndex() {
        // return an empty array if you ask for something impossible
        if (!(getEvent() == FormEntryController.EVENT_QUESTION
                || getEvent() == FormEntryController.EVENT_PROMPT_NEW_REPEAT
                || getEvent() == FormEntryController.EVENT_GROUP
                || getEvent() == FormEntryController.EVENT_REPEAT)) {
            return new FormEntryCaption[0];
        }

        // the first caption is the question, so we skip it if it's an EVENT_QUESTION
        // otherwise, the first caption is a group so we start at index 0
        int lastquestion = 1;
        if (getEvent() == FormEntryController.EVENT_PROMPT_NEW_REPEAT
                || getEvent() == FormEntryController.EVENT_GROUP
                || getEvent() == FormEntryController.EVENT_REPEAT) {
            lastquestion = 0;
        }

        FormEntryCaption[] v = getCaptionHierarchy();
        FormEntryCaption[] groups = new FormEntryCaption[v.length - lastquestion];
        for (int i = 0; i < v.length - lastquestion; i++) {
            groups[i] = v[i];
        }
        return groups;
    }


    /**
     * This is used to enable/disable the "Delete Repeat" menu option.
     *
     * @return
     */
    public boolean indexContainsRepeatableGroup() {
        FormEntryCaption[] groups = getCaptionHierarchy();
        if (groups.length == 0) {
            return false;
        }
        for (int i = 0; i < groups.length; i++) {
            if (groups[i].repeats())
                return true;
        }
        return false;
    }


    /**
     * The count of the closest group that repeats or -1.
     */
    public int getLastRepeatedGroupRepeatCount() {
        FormEntryCaption[] groups = getCaptionHierarchy();
        if (groups.length > 0) {
            for (int i = groups.length - 1; i > -1; i--) {
                if (groups[i].repeats()) {
                    return groups[i].getMultiplicity();

                }
            }
        }
        return -1;
    }


    /**
     * The name of the closest group that repeats or null.
     */
    public String getLastRepeatedGroupName() {
        FormEntryCaption[] groups = getCaptionHierarchy();
        // no change
        if (groups.length > 0) {
            for (int i = groups.length - 1; i > -1; i--) {
                if (groups[i].repeats()) {
                    return groups[i].getLongText();
                }
            }
        }
        return null;
    }


    /**
     * The closest group the prompt belongs to.
     *
     * @return FormEntryCaption
     */
    private FormEntryCaption getLastGroup() {
        FormEntryCaption[] groups = getCaptionHierarchy();
        if (groups == null || groups.length == 0)
            return null;
        else
            return groups[groups.length - 1];
    }


    /**
     * The repeat count of closest group the prompt belongs to.
     */
    public int getLastRepeatCount() {
        if (getLastGroup() != null) {
            return getLastGroup().getMultiplicity();
        }
        return -1;

    }


    /**
     * The text of closest group the prompt belongs to.
     */
    public String getLastGroupText() {
        if (getLastGroup() != null) {
            return getLastGroup().getLongText();
        }
        return null;
    }

    /**
     * Find the portion of the form that is to be submitted
     *
     * @return
     */
    private IDataReference getSubmissionDataReference() {
        FormDef formDef = mFormEntryController.getModel().getForm();
        // Determine the information about the submission...
        SubmissionProfile p = formDef.getSubmissionProfile();
        if (p == null || p.getRef() == null) {
            return new XPathReference("/");
        } else {
            return p.getRef();
        }
    }

    /**
     * Once a submission is marked as complete, it is saved in the
     * submission format, which might be a fragment of the original
     * form or might be a SMS text string, etc.
     *
     * @return true if the submission is the entire form.  If it is,
     *              then the submission can be re-opened for editing
     *              after it was marked-as-complete (provided it has
     *              not been encrypted).
     */
    public boolean isSubmissionEntireForm() {
        IDataReference sub = getSubmissionDataReference();
        return ( getInstance().resolveReference(sub) == null );
    }

    /**
     * Constructs the XML payload for a filled-in form instance. This payload
     * enables a filled-in form to be re-opened and edited.
     *
     * @return
     * @throws IOException
     */
    public ByteArrayPayload getFilledInFormXml() throws IOException {
        // assume no binary data inside the model.
        FormInstance datamodel = getInstance();
        XFormSerializingVisitor serializer = new XFormSerializingVisitor();
        serializer.setAnswerDataSerializer(new XFormUtcDateAnswerDataSerializer());
        ByteArrayPayload payload =
        		(ByteArrayPayload) serializer.createSerializedPayload(datamodel);

        return payload;
    }

    /**
     * Extract the portion of the form that should be uploaded to the server.
     *
     * @return
     * @throws IOException
     */
    public ByteArrayPayload getSubmissionXml() throws IOException {
        FormInstance instance = getInstance();
        XFormSerializingVisitor serializer = new XFormSerializingVisitor();
        ByteArrayPayload payload =
                (ByteArrayPayload) serializer.createSerializedPayload(instance,
                                                   getSubmissionDataReference());
        return payload;
    }

    /**
     * Traverse the submission looking for the first matching tag in depth-first order.
     *
     * @param parent
     * @param name
     * @return
     */
    private TreeElement findDepthFirst(TreeElement parent, String name) {
        int len = parent.getNumChildren();
        for ( int i = 0; i < len ; ++i ) {
            TreeElement e = parent.getChildAt(i);
            if ( name.equals(e.getName()) ) {
                return e;
            } else if ( e.getNumChildren() != 0 ) {
                TreeElement v = findDepthFirst(e, name);
                if ( v != null ) return v;
            }
        }
        return null;
    }

    /**
     * Get the OpenRosa required metadata of the portion of the form beng submitted
     * @return
     */
    public InstanceMetadata getSubmissionMetadata() {
        FormDef formDef = mFormEntryController.getModel().getForm();
        TreeElement rootElement = formDef.getInstance().getRoot();

        TreeElement trueSubmissionElement;
        // Determine the information about the submission...
        SubmissionProfile p = formDef.getSubmissionProfile();
        if ( p == null || p.getRef() == null ) {
            trueSubmissionElement = rootElement;
        } else {
            IDataReference ref = p.getRef();
            trueSubmissionElement = formDef.getInstance().resolveReference(ref);
            // resolveReference returns null if the reference is to the root element...
            if ( trueSubmissionElement == null ) {
                trueSubmissionElement = rootElement;
            }
        }

        // and find the depth-first meta block in this...
        TreeElement e = findDepthFirst(trueSubmissionElement, "meta");

        String instanceId = null;
        String instanceName = null;

        if ( e != null ) {
            Vector<TreeElement> v;

            // instance id...
            v = e.getChildrenWithName(INSTANCE_ID);
            if ( v.size() == 1 ) {
                StringData sa = (StringData) v.get(0).getValue();
                if ( sa != null ) {
                	instanceId = (String) sa.getValue();
                }
            }

            // instance name...
            v = e.getChildrenWithName(INSTANCE_NAME);
            if ( v.size() == 1 ) {
                StringData sa = (StringData) v.get(0).getValue();
                if ( sa != null ) {
                    instanceName = (String) sa.getValue();
                }
            }
        }

        return new InstanceMetadata(instanceId,instanceName);
    }

}

/*
 * Copyright (C) 2009 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.logic;

import android.graphics.drawable.Drawable;

import org.javarosa.core.model.FormIndex;

import java.util.ArrayList;

public class HierarchyElement {
    private String mPrimaryText = "";
    private String mSecondaryText = "";
    private Drawable mIcon;
    private int mColor;
    int mType;
    FormIndex mFormIndex;
    ArrayList<HierarchyElement> mChildren;


    public HierarchyElement(String text1, String text2, Drawable bullet, int color, int type,
            FormIndex f) {
        mIcon = bullet;
        mPrimaryText = text1;
        mSecondaryText = text2;
        mColor = color;
        mFormIndex = f;
        mType = type;
        mChildren = new ArrayList<HierarchyElement>();
    }


    public String getPrimaryText() {
        return mPrimaryText;
    }


    public String getSecondaryText() {
        return mSecondaryText;
    }


    public void setPrimaryText(String text) {
        mPrimaryText = text;
    }


    public void setSecondaryText(String text) {
        mSecondaryText = text;
    }


    public void setIcon(Drawable icon) {
        mIcon = icon;
    }


    public Drawable getIcon() {
        return mIcon;
    }


    public FormIndex getFormIndex() {
        return mFormIndex;
    }


    public int getType() {
        return mType;
    }


    public void setType(int newType) {
        mType = newType;
    }


    public ArrayList<HierarchyElement> getChildren() {
        return mChildren;
    }


    public void addChild(HierarchyElement h) {
        mChildren.add(h);
    }


    public void setChildren(ArrayList<HierarchyElement> children) {
        mChildren = children;
    }


    public void setColor(int color) {
        mColor = color;
    }


    public int getColor() {
        return mColor;
    }

}

/**
 * 
 */

package org.odk.collect.android.logic;

import org.javarosa.core.reference.PrefixedRootFactory;
import org.javarosa.core.reference.Reference;

/**
 * @author ctsims
 */
public class FileReferenceFactory extends PrefixedRootFactory {

    String localRoot;


    public FileReferenceFactory(String localRoot) {
        super(new String[] {
            "file"
        });
        this.localRoot = localRoot;
    }


    @Override
    protected Reference factory(String terminal, String URI) {
        return new FileReference(localRoot, terminal);
    }

}

/*
 * Copyright (C) 2011 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.logic;

import java.io.Serializable;

public class FormDetails implements Serializable {
    /**
     * 
     */
    private static final long serialVersionUID = 1L;

    public final String errorStr;

    public final String formName;
    public final String downloadUrl;
    public final String manifestUrl;
    public final String formID;
    public final String formVersion;


    public FormDetails(String error) {
        manifestUrl = null;
        downloadUrl = null;
        formName = null;
        formID = null;
        formVersion = null;
        errorStr = error;
    }


    public FormDetails(String name, String url, String manifest, String id, String version) {
        manifestUrl = manifest;
        downloadUrl = url;
        formName = name;
        formID = id;
        formVersion = version;
        errorStr = null;
    }

}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.logic;

import android.content.Context;
import android.content.SharedPreferences;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.preference.PreferenceManager;
import android.provider.Settings;
import android.telephony.TelephonyManager;
import android.util.Log;

import org.javarosa.core.services.IPropertyManager;
import org.javarosa.core.services.properties.IPropertyRules;
import org.odk.collect.android.preferences.PreferencesActivity;

import java.util.HashMap;
import java.util.Locale;
import java.util.Vector;

/**
 * Used to return device properties to JavaRosa
 *
 * @author Yaw Anokwa (yanokwa@gmail.com)
 */

public class PropertyManager implements IPropertyManager {

    private String t = "PropertyManager";

    private Context mContext;

    private TelephonyManager mTelephonyManager;
    private HashMap<String, String> mProperties;

    public final static String DEVICE_ID_PROPERTY = "deviceid"; // imei
    private final static String SUBSCRIBER_ID_PROPERTY = "subscriberid"; // imsi
    private final static String SIM_SERIAL_PROPERTY = "simserial";
    private final static String PHONE_NUMBER_PROPERTY = "phonenumber";
    private final static String USERNAME = "username";
    private final static String EMAIL = "email";

    public final static String OR_DEVICE_ID_PROPERTY = "uri:deviceid"; // imei
    public final static String OR_SUBSCRIBER_ID_PROPERTY = "uri:subscriberid"; // imsi
    public final static String OR_SIM_SERIAL_PROPERTY = "uri:simserial";
    public final static String OR_PHONE_NUMBER_PROPERTY = "uri:phonenumber";
    public final static String OR_USERNAME = "uri:username";
    public final static String OR_EMAIL = "uri:email";


    public String getName() {
        return "Property Manager";
    }


    public PropertyManager(Context context) {
        Log.i(t, "calling constructor");

        mContext = context;

        mProperties = new HashMap<String, String>();
        mTelephonyManager = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);

        String deviceId = mTelephonyManager.getDeviceId();
        String orDeviceId = null;
        if (deviceId != null ) {
        	if ((deviceId.contains("*") || deviceId.contains("000000000000000"))) {
        		deviceId =
        				Settings.Secure
                        	.getString(mContext.getContentResolver(), Settings.Secure.ANDROID_ID);
        		orDeviceId = Settings.Secure.ANDROID_ID + ":" + deviceId;
        	} else {
        		orDeviceId = "imei:" + deviceId;
        	}
        }

        if ( deviceId == null ) {
        	// no SIM -- WiFi only
        	// Retrieve WiFiManager
        	WifiManager wifi = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);

    		// Get WiFi status
    		WifiInfo info = wifi.getConnectionInfo();
    		if ( info != null ) {
    			deviceId = info.getMacAddress();
    			orDeviceId = "mac:" + deviceId;
    		}
        }

        // if it is still null, use ANDROID_ID
        if ( deviceId == null ) {
            deviceId =
                    Settings.Secure
                            .getString(mContext.getContentResolver(), Settings.Secure.ANDROID_ID);
    		orDeviceId = Settings.Secure.ANDROID_ID + ":" + deviceId;
        }

        mProperties.put(DEVICE_ID_PROPERTY, deviceId);
        mProperties.put(OR_DEVICE_ID_PROPERTY, orDeviceId);

        String value;

        value = mTelephonyManager.getSubscriberId();
        if ( value != null ) {
        	mProperties.put(SUBSCRIBER_ID_PROPERTY, value);
        	mProperties.put(OR_SUBSCRIBER_ID_PROPERTY, "imsi:" + value);
        }
        value = mTelephonyManager.getSimSerialNumber();
        if ( value != null ) {
        	mProperties.put(SIM_SERIAL_PROPERTY, value);
        	mProperties.put(OR_SIM_SERIAL_PROPERTY, "simserial:" + value);
        }
        value = mTelephonyManager.getLine1Number();
        if ( value != null ) {
        	mProperties.put(PHONE_NUMBER_PROPERTY, value);
        	mProperties.put(OR_PHONE_NUMBER_PROPERTY, "tel:" + value);
        }

        // Get the username from the settings
        SharedPreferences settings = PreferenceManager.getDefaultSharedPreferences(mContext);
        value = settings.getString(PreferencesActivity.KEY_USERNAME, null);
        if ( value != null ) {
        	mProperties.put(USERNAME, value);
        	mProperties.put(OR_USERNAME, "username:" + value);
        }
        value = settings.getString(PreferencesActivity.KEY_SELECTED_GOOGLE_ACCOUNT, null);
        if ( value != null ) {
        	mProperties.put(EMAIL, value);
        	mProperties.put(OR_EMAIL, "mailto:" + value);
        }
    }

    @Override
    public Vector<String> getProperty(String propertyName) {
        return null;
    }


    @Override
    public String getSingularProperty(String propertyName) {
    	// for now, all property names are in english...
        return mProperties.get(propertyName.toLowerCase(Locale.ENGLISH));
    }


    @Override
    public void setProperty(String propertyName, String propertyValue) {
    }


    @Override
    public void setProperty(String propertyName, @SuppressWarnings("rawtypes") Vector propertyValue) {

    }


    @Override
    public void addRules(IPropertyRules rules) {

    }


    @Override
    public Vector<IPropertyRules> getRules() {
        return null;
    }

}

package org.odk.collect.android.logic;

/**
 * A visitor of forms traversed by {@link FormTraverser}.
 */
public interface FormVisitor {

    void visit(int event, FormController formController);
}

/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.provider;

import android.content.ContentProvider;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.UriMatcher;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteQueryBuilder;
import android.net.Uri;
import android.text.TextUtils;
import android.util.Log;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.database.ODKSQLiteOpenHelper;
import org.odk.collect.android.provider.InstanceProviderAPI.InstanceColumns;
import org.odk.collect.android.utilities.MediaUtils;

import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;

/**
 *
 */
public class InstanceProvider extends ContentProvider {

    private static final String t = "InstancesProvider";

    private static final String DATABASE_NAME = "instances.db";
    private static final int DATABASE_VERSION = 3;
    private static final String INSTANCES_TABLE_NAME = "instances";

    private static HashMap<String, String> sInstancesProjectionMap;

    private static final int INSTANCES = 1;
    private static final int INSTANCE_ID = 2;

    private static final UriMatcher sUriMatcher;

    /**
     * This class helps open, create, and upgrade the database file.
     */
    private static class DatabaseHelper extends ODKSQLiteOpenHelper {

        DatabaseHelper(String databaseName) {
            super(Collect.getInstance().getMetadataPath(), databaseName, null, DATABASE_VERSION);
        }


        @Override
        public void onCreate(SQLiteDatabase db) {
           db.execSQL("CREATE TABLE " + INSTANCES_TABLE_NAME + " ("
               + InstanceColumns._ID + " integer primary key, "
               + InstanceColumns.DISPLAY_NAME + " text not null, "
               + InstanceColumns.SUBMISSION_URI + " text, "
               + InstanceColumns.CAN_EDIT_WHEN_COMPLETE + " text, "
               + InstanceColumns.INSTANCE_FILE_PATH + " text not null, "
               + InstanceColumns.JR_FORM_ID + " text not null, "
               + InstanceColumns.JR_VERSION + " text, "
               + InstanceColumns.STATUS + " text not null, "
               + InstanceColumns.LAST_STATUS_CHANGE_DATE + " date not null, "
               + InstanceColumns.DISPLAY_SUBTEXT + " text not null );");
        }


        @Override
        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        	int initialVersion = oldVersion;
        	if ( oldVersion == 1 ) {
        		db.execSQL("ALTER TABLE " + INSTANCES_TABLE_NAME + " ADD COLUMN " +
        					InstanceColumns.CAN_EDIT_WHEN_COMPLETE + " text;");
        		db.execSQL("UPDATE " + INSTANCES_TABLE_NAME + " SET " +
        					InstanceColumns.CAN_EDIT_WHEN_COMPLETE + " = '" + Boolean.toString(true) + "' WHERE " +
        					InstanceColumns.STATUS + " IS NOT NULL AND " +
        					InstanceColumns.STATUS + " != '" + InstanceProviderAPI.STATUS_INCOMPLETE + "'");
        		oldVersion = 2;
        	}
        	if ( oldVersion == 2 ) {
        		db.execSQL("ALTER TABLE " + INSTANCES_TABLE_NAME + " ADD COLUMN " +
    					InstanceColumns.JR_VERSION + " text;");
        	}
            Log.w(t, "Successfully upgraded database from version " + initialVersion + " to " + newVersion
                    + ", without destroying all the old data");
        }
    }

    private DatabaseHelper mDbHelper;

    private DatabaseHelper getDbHelper() {
        // wrapper to test and reset/set the dbHelper based upon the attachment state of the device.
        try {
            Collect.getInstance().createODKDirs();
        } catch (RuntimeException e) {
        	mDbHelper = null;
            return null;
        }

        if (mDbHelper != null) {
            if (new File(mDbHelper.getWritableDatabase().getPath()).exists()) {
                return mDbHelper;
            }
            // If the file has been moved or deleted, we have to close this
            // database and open a new one.  Otherwise, the invalid database
            // will be reused indefinitely and all operations will fail.
            mDbHelper.close();
        }
        mDbHelper = new DatabaseHelper(DATABASE_NAME);
        return mDbHelper;
    }

    @Override
    public boolean onCreate() {
        // must be at the beginning of any activity that can be called from an external intent
        DatabaseHelper h = getDbHelper();
        if ( h == null ) {
        	return false;
        }
        return true;
    }


    @Override
    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
            String sortOrder) {
        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
        qb.setTables(INSTANCES_TABLE_NAME);

        switch (sUriMatcher.match(uri)) {
            case INSTANCES:
                qb.setProjectionMap(sInstancesProjectionMap);
                break;

            case INSTANCE_ID:
                qb.setProjectionMap(sInstancesProjectionMap);
                qb.appendWhere(InstanceColumns._ID + "=" + uri.getPathSegments().get(1));
                break;

            default:
                throw new IllegalArgumentException("Unknown URI " + uri);
        }

        // Get the database and run the query
        SQLiteDatabase db = getDbHelper().getReadableDatabase();
        Cursor c = qb.query(db, projection, selection, selectionArgs, null, null, sortOrder);

        // Tell the cursor what uri to watch, so it knows when its source data changes
        c.setNotificationUri(getContext().getContentResolver(), uri);
        return c;
    }


    @Override
    public String getType(Uri uri) {
        switch (sUriMatcher.match(uri)) {
            case INSTANCES:
                return InstanceColumns.CONTENT_TYPE;

            case INSTANCE_ID:
                return InstanceColumns.CONTENT_ITEM_TYPE;

            default:
                throw new IllegalArgumentException("Unknown URI " + uri);
        }
    }


    @Override
    public Uri insert(Uri uri, ContentValues initialValues) {
        // Validate the requested uri
        if (sUriMatcher.match(uri) != INSTANCES) {
            throw new IllegalArgumentException("Unknown URI " + uri);
        }

        ContentValues values;
        if (initialValues != null) {
            values = new ContentValues(initialValues);
        } else {
            values = new ContentValues();
        }

        Long now = Long.valueOf(System.currentTimeMillis());

        // Make sure that the fields are all set
        if (values.containsKey(InstanceColumns.LAST_STATUS_CHANGE_DATE) == false) {
            values.put(InstanceColumns.LAST_STATUS_CHANGE_DATE, now);
        }

        if (values.containsKey(InstanceColumns.DISPLAY_SUBTEXT) == false) {
            Date today = new Date();
            String text = getDisplaySubtext(InstanceProviderAPI.STATUS_INCOMPLETE, today);
            values.put(InstanceColumns.DISPLAY_SUBTEXT, text);
        }

        if (values.containsKey(InstanceColumns.STATUS) == false) {
            values.put(InstanceColumns.STATUS, InstanceProviderAPI.STATUS_INCOMPLETE);
        }

        SQLiteDatabase db = getDbHelper().getWritableDatabase();
        long rowId = db.insert(INSTANCES_TABLE_NAME, null, values);
        if (rowId > 0) {
            Uri instanceUri = ContentUris.withAppendedId(InstanceColumns.CONTENT_URI, rowId);
            getContext().getContentResolver().notifyChange(instanceUri, null);
        	Collect.getInstance().getActivityLogger().logActionParam(this, "insert",
        			instanceUri.toString(), values.getAsString(InstanceColumns.INSTANCE_FILE_PATH));
            return instanceUri;
        }

        throw new SQLException("Failed to insert row into " + uri);
    }

    private String getDisplaySubtext(String state, Date date) {
        if (state == null) {
        	return new SimpleDateFormat(getContext().getString(R.string.added_on_date_at_time), Locale.getDefault()).format(date);
        } else if (InstanceProviderAPI.STATUS_INCOMPLETE.equalsIgnoreCase(state)) {
        	return new SimpleDateFormat(getContext().getString(R.string.saved_on_date_at_time), Locale.getDefault()).format(date);
        } else if (InstanceProviderAPI.STATUS_COMPLETE.equalsIgnoreCase(state)) {
        	return new SimpleDateFormat(getContext().getString(R.string.finalized_on_date_at_time), Locale.getDefault()).format(date);
        } else if (InstanceProviderAPI.STATUS_SUBMITTED.equalsIgnoreCase(state)) {
        	return new SimpleDateFormat(getContext().getString(R.string.sent_on_date_at_time), Locale.getDefault()).format(date);
        } else if (InstanceProviderAPI.STATUS_SUBMISSION_FAILED.equalsIgnoreCase(state)) {
        	return new SimpleDateFormat(getContext().getString(R.string.sending_failed_on_date_at_time), Locale.getDefault()).format(date);
        } else {
        	return new SimpleDateFormat(getContext().getString(R.string.added_on_date_at_time), Locale.getDefault()).format(date);
        }
    }

    private void deleteAllFilesInDirectory(File directory) {
        if (directory.exists()) {
        	// do not delete the directory if it might be an
        	// ODK Tables instance data directory. Let ODK Tables
        	// manage the lifetimes of its filled-in form data
        	// media attachments.
            if (directory.isDirectory()
                    && !Collect.getInstance().isODKTablesInstanceDataDirectory(directory)) {
            	// delete any media entries for files in this directory...
                int images = MediaUtils.deleteImagesInFolderFromMediaProvider(directory);
                int audio = MediaUtils.deleteAudioInFolderFromMediaProvider(directory);
                int video = MediaUtils.deleteVideoInFolderFromMediaProvider(directory);

                Log.i(t, "removed from content providers: " + images
                        + " image files, " + audio + " audio files,"
                        + " and " + video + " video files.");

                // delete all the files in the directory
                File[] files = directory.listFiles();
                for (File f : files) {
                    // should make this recursive if we get worried about
                    // the media directory containing directories
                    f.delete();
                }
            }
            directory.delete();
        }
    }


    /**
     * This method removes the entry from the content provider, and also removes any associated files.
     * files:  form.xml, [formmd5].formdef, formname-media {directory}
     */
    @Override
    public int delete(Uri uri, String where, String[] whereArgs) {
        SQLiteDatabase db = getDbHelper().getWritableDatabase();
        int count;

        switch (sUriMatcher.match(uri)) {
            case INSTANCES:
                Cursor del = null;
                try {
                	del = this.query(uri, null, where, whereArgs, null);
                	if (del.getCount() > 0) {
                		del.moveToFirst();
                		do {
		                    String instanceFile = del.getString(del.getColumnIndex(InstanceColumns.INSTANCE_FILE_PATH));
		                    Collect.getInstance().getActivityLogger().logAction(this, "delete", instanceFile);
		                    File instanceDir = (new File(instanceFile)).getParentFile();
		                    deleteAllFilesInDirectory(instanceDir);
                		} while (del.moveToNext());
	                }
                } finally {
                	if ( del != null ) {
                		del.close();
                	}
                }
                count = db.delete(INSTANCES_TABLE_NAME, where, whereArgs);
                break;

            case INSTANCE_ID:
                String instanceId = uri.getPathSegments().get(1);

                Cursor c = null;
                try {
                	c = this.query(uri, null, where, whereArgs, null);
                	if (c.getCount() > 0) {
                		c.moveToFirst();
                		do {
		                    String instanceFile = c.getString(c.getColumnIndex(InstanceColumns.INSTANCE_FILE_PATH));
		                    Collect.getInstance().getActivityLogger().logAction(this, "delete", instanceFile);
		                    File instanceDir = (new File(instanceFile)).getParentFile();
		                    deleteAllFilesInDirectory(instanceDir);
                		} while (c.moveToNext());
	                }
                } finally {
                	if ( c != null ) {
                		c.close();
                	}
                }

                count =
                    db.delete(INSTANCES_TABLE_NAME,
                        InstanceColumns._ID + "=" + instanceId
                                + (!TextUtils.isEmpty(where) ? " AND (" + where + ')' : ""),
                        whereArgs);
                break;

            default:
                throw new IllegalArgumentException("Unknown URI " + uri);
        }

        if (count > 0) getContext().getContentResolver().notifyChange(uri, null);
        return count;
    }


    @Override
    public int update(Uri uri, ContentValues values, String where, String[] whereArgs) {
        SQLiteDatabase db = getDbHelper().getWritableDatabase();

        Long now = Long.valueOf(System.currentTimeMillis());

        // Make sure that the fields are all set
        if (values.containsKey(InstanceColumns.LAST_STATUS_CHANGE_DATE) == false) {
            values.put(InstanceColumns.LAST_STATUS_CHANGE_DATE, now);
        }

        int count;
        String status = null;
        switch (sUriMatcher.match(uri)) {
            case INSTANCES:
                if (values.containsKey(InstanceColumns.STATUS)) {
                    status = values.getAsString(InstanceColumns.STATUS);

                    if (values.containsKey(InstanceColumns.DISPLAY_SUBTEXT) == false) {
                        Date today = new Date();
                        String text = getDisplaySubtext(status, today);
                        values.put(InstanceColumns.DISPLAY_SUBTEXT, text);
                    }
                }

                count = db.update(INSTANCES_TABLE_NAME, values, where, whereArgs);
                break;

            case INSTANCE_ID:
                String instanceId = uri.getPathSegments().get(1);

                if (values.containsKey(InstanceColumns.STATUS)) {
                    status = values.getAsString(InstanceColumns.STATUS);

                    if (values.containsKey(InstanceColumns.DISPLAY_SUBTEXT) == false) {
                        Date today = new Date();
                        String text = getDisplaySubtext(status, today);
                        values.put(InstanceColumns.DISPLAY_SUBTEXT, text);
                    }
                }

                count =
                    db.update(INSTANCES_TABLE_NAME, values, InstanceColumns._ID + "=" + instanceId
                            + (!TextUtils.isEmpty(where) ? " AND (" + where + ')' : ""), whereArgs);
                break;

            default:
                throw new IllegalArgumentException("Unknown URI " + uri);
        }

        if (count > 0) getContext().getContentResolver().notifyChange(uri, null);
        return count;
    }

    static {
        sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
        sUriMatcher.addURI(InstanceProviderAPI.AUTHORITY, "instances", INSTANCES);
        sUriMatcher.addURI(InstanceProviderAPI.AUTHORITY, "instances/#", INSTANCE_ID);

        sInstancesProjectionMap = new HashMap<String, String>();
        sInstancesProjectionMap.put(InstanceColumns._ID, InstanceColumns._ID);
        sInstancesProjectionMap.put(InstanceColumns.DISPLAY_NAME, InstanceColumns.DISPLAY_NAME);
        sInstancesProjectionMap.put(InstanceColumns.SUBMISSION_URI, InstanceColumns.SUBMISSION_URI);
        sInstancesProjectionMap.put(InstanceColumns.CAN_EDIT_WHEN_COMPLETE, InstanceColumns.CAN_EDIT_WHEN_COMPLETE);
        sInstancesProjectionMap.put(InstanceColumns.INSTANCE_FILE_PATH, InstanceColumns.INSTANCE_FILE_PATH);
        sInstancesProjectionMap.put(InstanceColumns.JR_FORM_ID, InstanceColumns.JR_FORM_ID);
        sInstancesProjectionMap.put(InstanceColumns.JR_VERSION, InstanceColumns.JR_VERSION);
        sInstancesProjectionMap.put(InstanceColumns.STATUS, InstanceColumns.STATUS);
        sInstancesProjectionMap.put(InstanceColumns.LAST_STATUS_CHANGE_DATE, InstanceColumns.LAST_STATUS_CHANGE_DATE);
        sInstancesProjectionMap.put(InstanceColumns.DISPLAY_SUBTEXT, InstanceColumns.DISPLAY_SUBTEXT);
    }

}

/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.odk.collect.android.provider;

import android.net.Uri;
import android.provider.BaseColumns;

import org.odk.collect.android.BuildConfig;
import org.odk.collect.android.utilities.AppBuildConfig;

/**
 * Convenience definitions for NotePadProvider
 */
public final class InstanceProviderAPI {
    public static final String AUTHORITY =
            AppBuildConfig.APPLICATION_ID + ".odk.collect.android.provider.odk.instances";

    // This class cannot be instantiated
    private InstanceProviderAPI() {}
    
    // status for instances
    public static final String STATUS_INCOMPLETE = "incomplete";
    public static final String STATUS_COMPLETE = "complete";
    public static final String STATUS_SUBMITTED = "submitted";
    public static final String STATUS_SUBMISSION_FAILED = "submissionFailed";
    
    /**
     * Notes table
     */
    public static final class InstanceColumns implements BaseColumns {
        // This class cannot be instantiated
        private InstanceColumns() {}
        
        public static final Uri CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/instances");
        public static final String CONTENT_TYPE = "vnd.android.cursor.dir/vnd.odk.instance";
        public static final String CONTENT_ITEM_TYPE = "vnd.android.cursor.item/vnd.odk.instance";

        // These are the only things needed for an insert
        public static final String DISPLAY_NAME = "displayName";
        public static final String SUBMISSION_URI = "submissionUri";
        public static final String INSTANCE_FILE_PATH = "instanceFilePath";
        public static final String JR_FORM_ID = "jrFormId";
        public static final String JR_VERSION = "jrVersion";
        //public static final String FORM_ID = "formId";
        
        // these are generated for you (but you can insert something else if you want)
        public static final String STATUS = "status";
        public static final String CAN_EDIT_WHEN_COMPLETE = "canEditWhenComplete";
        public static final String LAST_STATUS_CHANGE_DATE = "date";
        public static final String DISPLAY_SUBTEXT = "displaySubtext";
        //public static final String DISPLAY_SUB_SUBTEXT = "displaySubSubtext";


//        public static final String DEFAULT_SORT_ORDER = "modified DESC";
//        public static final String TITLE = "title";
//        public static final String NOTE = "note";
//        public static final String CREATED_DATE = "created";
//        public static final String MODIFIED_DATE = "modified";
    }
}

/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.odk.collect.android.provider;

import android.net.Uri;
import android.provider.BaseColumns;

import org.odk.collect.android.BuildConfig;
import org.odk.collect.android.utilities.AppBuildConfig;

/**
 * Convenience definitions for NotePadProvider
 */
public final class FormsProviderAPI {
    public static final String AUTHORITY =
            AppBuildConfig.APPLICATION_ID + ".odk.collect.android.provider.odk.forms";

    // This class cannot be instantiated
    private FormsProviderAPI() {}

    /**
     * Used with ContentValues for an insert statement to specify if it should be an
     * insert or replace (true) or just an insert (false). See:
     * https://www.buzzingandroid.com/2013/01/sqlite-insert-or-replace-through-contentprovider/
     * for background. Can avoid race conditions.
     */
    public static final String SQL_INSERT_OR_REPLACE = "__sql_insert_or_replace__";

    /**
     * Notes table
     */
    public static final class FormsColumns implements BaseColumns {
        // This class cannot be instantiated
        private FormsColumns() {}


        public static final Uri CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/forms");
        public static final String CONTENT_TYPE = "vnd.android.cursor.dir/vnd.odk.form";
        public static final String CONTENT_ITEM_TYPE = "vnd.android.cursor.item/vnd.odk.form";

        // These are the only things needed for an insert
        public static final String DISPLAY_NAME = "displayName";
        public static final String DESCRIPTION = "description";  // can be null
        public static final String JR_FORM_ID = "jrFormId";
        public static final String JR_VERSION = "jrVersion"; // can be null
        public static final String FORM_FILE_PATH = "formFilePath";
        public static final String SUBMISSION_URI = "submissionUri"; // can be null
        public static final String BASE64_RSA_PUBLIC_KEY = "base64RsaPublicKey"; // can be null

        // these are generated for you (but you can insert something else if you want)
        public static final String DISPLAY_SUBTEXT = "displaySubtext";
        public static final String MD5_HASH = "md5Hash";
        public static final String DATE = "date";        
        public static final String JRCACHE_FILE_PATH = "jrcacheFilePath";
        public static final String FORM_MEDIA_PATH = "formMediaPath";      
        
        
        // this is null on create, and can only be set on an update.
        public static final String LANGUAGE = "language";
        
        
    }
}

/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.provider;

import android.content.ContentProvider;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.UriMatcher;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteQueryBuilder;
import android.net.Uri;
import android.text.TextUtils;
import android.util.Log;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.database.ItemsetDbAdapter;
import org.odk.collect.android.database.ODKSQLiteOpenHelper;
import org.odk.collect.android.provider.FormsProviderAPI.FormsColumns;
import org.odk.collect.android.utilities.FileUtils;
import org.odk.collect.android.utilities.MediaUtils;

import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;

/**
 *
 */
public class FormsProvider extends ContentProvider {

	private static final String t = "FormsProvider";

	private static final String DATABASE_NAME = "forms.db";
	private static final int DATABASE_VERSION = 4;
	private static final String FORMS_TABLE_NAME = "forms";

	private static HashMap<String, String> sFormsProjectionMap;

	private static final int FORMS = 1;
	private static final int FORM_ID = 2;

	private static final UriMatcher sUriMatcher;

	/**
	 * This class helps open, create, and upgrade the database file.
	 */
	private static class DatabaseHelper extends ODKSQLiteOpenHelper {
		// These exist in database versions 2 and 3, but not in 4...
		private static final String TEMP_FORMS_TABLE_NAME = "forms_v4";
		private static final String MODEL_VERSION = "modelVersion";

		DatabaseHelper(String databaseName) {
			super(Collect.getInstance().getMetadataPath(), databaseName, null, DATABASE_VERSION);
		}

		@Override
		public void onCreate(SQLiteDatabase db) {
			onCreateNamed(db, FORMS_TABLE_NAME);
		}

		private void onCreateNamed(SQLiteDatabase db, String tableName) {
			db.execSQL("CREATE TABLE " + tableName + " (" + FormsColumns._ID
					+ " integer primary key, " + FormsColumns.DISPLAY_NAME
					+ " text not null, " + FormsColumns.DISPLAY_SUBTEXT
					+ " text not null, " + FormsColumns.DESCRIPTION
					+ " text, "
					+ FormsColumns.JR_FORM_ID
					+ " text not null, "
					+ FormsColumns.JR_VERSION
					+ " text, "
					+ FormsColumns.MD5_HASH
					+ " text not null, "
					+ FormsColumns.DATE
					+ " integer not null, " // milliseconds
					+ FormsColumns.FORM_MEDIA_PATH + " text not null, "
					+ FormsColumns.FORM_FILE_PATH + " text not null, "
					+ FormsColumns.LANGUAGE + " text, "
					+ FormsColumns.SUBMISSION_URI + " text, "
					+ FormsColumns.BASE64_RSA_PUBLIC_KEY + " text, "
					+ FormsColumns.JRCACHE_FILE_PATH + " text not null );");
		}

		@Override
		public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
			int initialVersion = oldVersion;
			if (oldVersion < 2) {
				Log.w(t, "Upgrading database from version " + oldVersion
						+ " to " + newVersion
						+ ", which will destroy all old data");
				db.execSQL("DROP TABLE IF EXISTS " + FORMS_TABLE_NAME);
				onCreate(db);
				return;
			} else {
				// adding BASE64_RSA_PUBLIC_KEY and changing type and name of
				// integer MODEL_VERSION to text VERSION
				db.execSQL("DROP TABLE IF EXISTS " + TEMP_FORMS_TABLE_NAME);
				onCreateNamed(db, TEMP_FORMS_TABLE_NAME);
				db.execSQL("INSERT INTO "
						+ TEMP_FORMS_TABLE_NAME
						+ " ("
						+ FormsColumns._ID
						+ ", "
						+ FormsColumns.DISPLAY_NAME
						+ ", "
						+ FormsColumns.DISPLAY_SUBTEXT
						+ ", "
						+ FormsColumns.DESCRIPTION
						+ ", "
						+ FormsColumns.JR_FORM_ID
						+ ", "
						+ FormsColumns.MD5_HASH
						+ ", "
						+ FormsColumns.DATE
						+ ", " // milliseconds
						+ FormsColumns.FORM_MEDIA_PATH
						+ ", "
						+ FormsColumns.FORM_FILE_PATH
						+ ", "
						+ FormsColumns.LANGUAGE
						+ ", "
						+ FormsColumns.SUBMISSION_URI
						+ ", "
						+ FormsColumns.JR_VERSION
						+ ", "
						+ ((oldVersion != 3) ? ""
								: (FormsColumns.BASE64_RSA_PUBLIC_KEY + ", "))
						+ FormsColumns.JRCACHE_FILE_PATH
						+ ") SELECT "
						+ FormsColumns._ID
						+ ", "
						+ FormsColumns.DISPLAY_NAME
						+ ", "
						+ FormsColumns.DISPLAY_SUBTEXT
						+ ", "
						+ FormsColumns.DESCRIPTION
						+ ", "
						+ FormsColumns.JR_FORM_ID
						+ ", "
						+ FormsColumns.MD5_HASH
						+ ", "
						+ FormsColumns.DATE
						+ ", " // milliseconds
						+ FormsColumns.FORM_MEDIA_PATH
						+ ", "
						+ FormsColumns.FORM_FILE_PATH
						+ ", "
						+ FormsColumns.LANGUAGE
						+ ", "
						+ FormsColumns.SUBMISSION_URI
						+ ", "
						+ "CASE WHEN "
						+ MODEL_VERSION
						+ " IS NOT NULL THEN "
						+ "CAST("
						+ MODEL_VERSION
						+ " AS TEXT) ELSE NULL END, "
						+ ((oldVersion != 3) ? ""
								: (FormsColumns.BASE64_RSA_PUBLIC_KEY + ", "))
						+ FormsColumns.JRCACHE_FILE_PATH + " FROM "
						+ FORMS_TABLE_NAME);

				// risky failures here...
				db.execSQL("DROP TABLE IF EXISTS " + FORMS_TABLE_NAME);
				onCreateNamed(db, FORMS_TABLE_NAME);
				db.execSQL("INSERT INTO "
						+ FORMS_TABLE_NAME
						+ " ("
						+ FormsColumns._ID
						+ ", "
						+ FormsColumns.DISPLAY_NAME
						+ ", "
						+ FormsColumns.DISPLAY_SUBTEXT
						+ ", "
						+ FormsColumns.DESCRIPTION
						+ ", "
						+ FormsColumns.JR_FORM_ID
						+ ", "
						+ FormsColumns.MD5_HASH
						+ ", "
						+ FormsColumns.DATE
						+ ", " // milliseconds
						+ FormsColumns.FORM_MEDIA_PATH + ", "
						+ FormsColumns.FORM_FILE_PATH + ", "
						+ FormsColumns.LANGUAGE + ", "
						+ FormsColumns.SUBMISSION_URI + ", "
						+ FormsColumns.JR_VERSION + ", "
						+ FormsColumns.BASE64_RSA_PUBLIC_KEY + ", "
						+ FormsColumns.JRCACHE_FILE_PATH + ") SELECT "
						+ FormsColumns._ID + ", "
						+ FormsColumns.DISPLAY_NAME
						+ ", "
						+ FormsColumns.DISPLAY_SUBTEXT
						+ ", "
						+ FormsColumns.DESCRIPTION
						+ ", "
						+ FormsColumns.JR_FORM_ID
						+ ", "
						+ FormsColumns.MD5_HASH
						+ ", "
						+ FormsColumns.DATE
						+ ", " // milliseconds
						+ FormsColumns.FORM_MEDIA_PATH + ", "
						+ FormsColumns.FORM_FILE_PATH + ", "
						+ FormsColumns.LANGUAGE + ", "
						+ FormsColumns.SUBMISSION_URI + ", "
						+ FormsColumns.JR_VERSION + ", "
						+ FormsColumns.BASE64_RSA_PUBLIC_KEY + ", "
						+ FormsColumns.JRCACHE_FILE_PATH + " FROM "
						+ TEMP_FORMS_TABLE_NAME);
				db.execSQL("DROP TABLE IF EXISTS " + TEMP_FORMS_TABLE_NAME);

				Log.w(t, "Successfully upgraded database from version "
						+ initialVersion + " to " + newVersion
						+ ", without destroying all the old data");
			}
		}
	}

	private DatabaseHelper mDbHelper;

    private DatabaseHelper getDbHelper() {
        // wrapper to test and reset/set the dbHelper based upon the attachment state of the device.
        try {
            Collect.getInstance().createODKDirs();
        } catch (RuntimeException e) {
        	mDbHelper = null;
            return null;
        }

        if (mDbHelper != null) {
            if (new File(mDbHelper.getWritableDatabase().getPath()).exists()) {
                return mDbHelper;
            }
            // If the file has been moved or deleted, we have to close this
            // database and open a new one.  Otherwise, the invalid database
            // will be reused indefinitely and all operations will fail.
            mDbHelper.close();
        }
        mDbHelper = new DatabaseHelper(DATABASE_NAME);
        return mDbHelper;
    }

	@Override
	public boolean onCreate() {
        // must be at the beginning of any activity that can be called from an external intent
		DatabaseHelper h = getDbHelper();
        return h != null;
	}

	@Override
	public Cursor query(Uri uri, String[] projection, String selection,
			String[] selectionArgs, String sortOrder) {
		SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
		qb.setTables(FORMS_TABLE_NAME);

		switch (sUriMatcher.match(uri)) {
		case FORMS:
			qb.setProjectionMap(sFormsProjectionMap);
			break;

		case FORM_ID:
			qb.setProjectionMap(sFormsProjectionMap);
			qb.appendWhere(FormsColumns._ID + "="
					+ uri.getPathSegments().get(1));
			break;

		default:
			throw new IllegalArgumentException("Unknown URI " + uri);
		}

		// Get the database and run the query
		SQLiteDatabase db = getDbHelper().getReadableDatabase();
		Cursor c = qb.query(db, projection, selection, selectionArgs, null,
				null, sortOrder);

		// Tell the cursor what uri to watch, so it knows when its source data
		// changes
		c.setNotificationUri(getContext().getContentResolver(), uri);
		return c;
	}

	@Override
	public String getType(Uri uri) {
		switch (sUriMatcher.match(uri)) {
		case FORMS:
			return FormsColumns.CONTENT_TYPE;

		case FORM_ID:
			return FormsColumns.CONTENT_ITEM_TYPE;

		default:
			throw new IllegalArgumentException("Unknown URI " + uri);
		}
	}

	@Override
	public synchronized Uri insert(Uri uri, ContentValues initialValues) {
		// Validate the requested uri
		if (sUriMatcher.match(uri) != FORMS) {
			throw new IllegalArgumentException("Unknown URI " + uri);
		}

		ContentValues values;
		if (initialValues != null) {
            values = new ContentValues(initialValues);
		} else {
			values = new ContentValues();
		}

		if (!values.containsKey(FormsColumns.FORM_FILE_PATH)) {
			throw new IllegalArgumentException(FormsColumns.FORM_FILE_PATH
					+ " must be specified.");
		}

		// Normalize the file path.
		// (don't trust the requester).
		String filePath = values.getAsString(FormsColumns.FORM_FILE_PATH);
		File form = new File(filePath);
		filePath = form.getAbsolutePath(); // normalized
		values.put(FormsColumns.FORM_FILE_PATH, filePath);

		Long now = System.currentTimeMillis();

        // Decide if we should do an insert or replace.
        boolean replace = false;
        if (values.containsKey(FormsProviderAPI.SQL_INSERT_OR_REPLACE)) {
            replace = values.getAsBoolean(FormsProviderAPI.SQL_INSERT_OR_REPLACE);

            // Remove the key, so we don't pass that on to db.insert() or db.replace()
            values.remove(FormsProviderAPI.SQL_INSERT_OR_REPLACE);
        }

        // Make sure that the necessary fields are all set
		if (!values.containsKey(FormsColumns.DATE)) {
			values.put(FormsColumns.DATE, now);
		}

		if (!values.containsKey(FormsColumns.DISPLAY_SUBTEXT)) {
			Date today = new Date();
			String ts = new SimpleDateFormat(getContext().getString(
					R.string.added_on_date_at_time), Locale.getDefault())
					.format(today);
			values.put(FormsColumns.DISPLAY_SUBTEXT, ts);
		}

		if (!values.containsKey(FormsColumns.DISPLAY_NAME)) {
			values.put(FormsColumns.DISPLAY_NAME, form.getName());
		}

		// don't let users put in a manual md5 hash
		if (values.containsKey(FormsColumns.MD5_HASH)) {
			values.remove(FormsColumns.MD5_HASH);
		}
		String md5 = FileUtils.getMd5Hash(form);
		values.put(FormsColumns.MD5_HASH, md5);

		if (!values.containsKey(FormsColumns.JRCACHE_FILE_PATH)) {
			String cachePath = Collect.getInstance().getCachePath() + File.separator + md5
					+ ".formdef";
			values.put(FormsColumns.JRCACHE_FILE_PATH, cachePath);
		}
		if (!values.containsKey(FormsColumns.FORM_MEDIA_PATH)) {
			String pathNoExtension = filePath.substring(0,
					filePath.lastIndexOf("."));
			String mediaPath = pathNoExtension + "-media";
			values.put(FormsColumns.FORM_MEDIA_PATH, mediaPath);
		}

		SQLiteDatabase db = getDbHelper().getWritableDatabase();

        long rowId;
        if (replace) {
            // If we want this insert to always replace, then do a transactional delete followed
            // by an insert. The primary key is _ID, which we can't know in advance.
            try {
				db.beginTransaction();
				db.delete(
					FORMS_TABLE_NAME, FormsColumns.FORM_FILE_PATH + "=?",
					new String[] {filePath});
				rowId = db.insert(FORMS_TABLE_NAME, null, values);
				db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
        } else {
            // first try to see if a record with this filename already exists...
            String[] projection = {FormsColumns._ID, FormsColumns.FORM_FILE_PATH};
            String[] selectionArgs = {filePath};
            String selection = FormsColumns.FORM_FILE_PATH + "=?";
            Cursor c = null;
            try {
                c = db.query(FORMS_TABLE_NAME, projection, selection,
                        selectionArgs, null, null, null);
                if (c.getCount() > 0) {
                    // already exists
                    throw new SQLException("FAILED Insert into " + uri
                            + " -- row already exists for form definition file: "
                            + filePath);
                }
            } finally {
                if (c != null) {
                    c.close();
                }
            }
            rowId = db.insert(FORMS_TABLE_NAME, null, values);
        }

		if (rowId > 0) {
			Uri formUri = ContentUris.withAppendedId(FormsColumns.CONTENT_URI,
					rowId);
			getContext().getContentResolver().notifyChange(formUri, null);
			Collect.getInstance()
					.getActivityLogger()
					.logActionParam(this, "insert", formUri.toString(),
							values.getAsString(FormsColumns.FORM_FILE_PATH));
			return formUri;
		}

		throw new SQLException("Failed to insert row into " + uri);
	}

	private void deleteFileOrDir(String fileName) {
		File file = new File(fileName);
		if (file.exists()) {
			if (file.isDirectory()) {
				// delete any media entries for files in this directory...
				int images = MediaUtils
						.deleteImagesInFolderFromMediaProvider(file);
				int audio = MediaUtils
						.deleteAudioInFolderFromMediaProvider(file);
				int video = MediaUtils
						.deleteVideoInFolderFromMediaProvider(file);

				Log.i(t, "removed from content providers: " + images
						+ " image files, " + audio + " audio files," + " and "
						+ video + " video files.");

				// delete all the containing files
				File[] files = file.listFiles();
				for (File f : files) {
					// should make this recursive if we get worried about
					// the media directory containing directories
					Log.i(t,
							"attempting to delete file: " + f.getAbsolutePath());
					f.delete();
				}
			}
			file.delete();
			Log.i(t, "attempting to delete file: " + file.getAbsolutePath());
		}
	}

	/**
	 * This method removes the entry from the content provider, and also removes
	 * any associated files. files: form.xml, [formmd5].formdef, formname-media
	 * {directory}
	 */
	@Override
	public int delete(Uri uri, String where, String[] whereArgs) {
		SQLiteDatabase db = getDbHelper().getWritableDatabase();
		int count;

		switch (sUriMatcher.match(uri)) {
		case FORMS:
			Cursor del = null;
			try {
				del = this.query(uri, null, where, whereArgs, null);
				if (del.getCount() > 0) {
					del.moveToFirst();
					do {
						deleteFileOrDir(del
								.getString(del
										.getColumnIndex(FormsColumns.JRCACHE_FILE_PATH)));
						String formFilePath = del.getString(del
								.getColumnIndex(FormsColumns.FORM_FILE_PATH));
						Collect.getInstance().getActivityLogger()
								.logAction(this, "delete", formFilePath);
						deleteFileOrDir(formFilePath);
						deleteFileOrDir(del.getString(del
								.getColumnIndex(FormsColumns.FORM_MEDIA_PATH)));
					} while (del.moveToNext());
				}
			} finally {
				if (del != null) {
					del.close();
				}
			}
			count = db.delete(FORMS_TABLE_NAME, where, whereArgs);
			break;

		case FORM_ID:
			String formId = uri.getPathSegments().get(1);

			Cursor c = null;
			try {
				c = this.query(uri, null, where, whereArgs, null);
				// This should only ever return 1 record.
				if (c.getCount() > 0) {
					c.moveToFirst();
					do {
						deleteFileOrDir(c.getString(c
								.getColumnIndex(FormsColumns.JRCACHE_FILE_PATH)));
						String formFilePath = c.getString(c
								.getColumnIndex(FormsColumns.FORM_FILE_PATH));
						Collect.getInstance().getActivityLogger()
								.logAction(this, "delete", formFilePath);
						deleteFileOrDir(formFilePath);
						deleteFileOrDir(c.getString(c
							.getColumnIndex(FormsColumns.FORM_MEDIA_PATH)));

						try {
                            // get rid of the old tables
                            ItemsetDbAdapter ida = new ItemsetDbAdapter();
                            ida.open();
                            ida.delete(c.getString(c
                                    .getColumnIndex(FormsColumns.FORM_MEDIA_PATH))
                                    + "/itemsets.csv");
                            ida.close();
                        } catch (Exception e) {
                            // if something else is accessing the provider this may not exist
                            // so catch it and move on.
                        }

					} while (c.moveToNext());
				}
			} finally {
				if (c != null) {
					c.close();
				}
			}

			count = db.delete(
					FORMS_TABLE_NAME,
					FormsColumns._ID
							+ "="
							+ formId
							+ (!TextUtils.isEmpty(where) ? " AND (" + where
									+ ')' : ""), whereArgs);
			break;

		default:
			throw new IllegalArgumentException("Unknown URI " + uri);
		}

		if (count > 0) getContext().getContentResolver().notifyChange(uri, null);
		return count;
	}

	@Override
	public int update(Uri uri, ContentValues values, String where,
			String[] whereArgs) {
		SQLiteDatabase db = getDbHelper().getWritableDatabase();
		int count = 0;
		switch (sUriMatcher.match(uri)) {
		case FORMS:
			// don't let users manually update md5
			if (values.containsKey(FormsColumns.MD5_HASH)) {
				values.remove(FormsColumns.MD5_HASH);
			}
			// if values contains path, then all filepaths and md5s will get
			// updated
			// this probably isn't a great thing to do.
			if (values.containsKey(FormsColumns.FORM_FILE_PATH)) {
				String formFile = values
						.getAsString(FormsColumns.FORM_FILE_PATH);
				values.put(FormsColumns.MD5_HASH,
						FileUtils.getMd5Hash(new File(formFile)));
			}

			Cursor c = null;
			try {
				c = this.query(uri, null, where, whereArgs, null);

				if (c.getCount() > 0) {
					c.moveToPosition(-1);
					while (c.moveToNext()) {
						// before updating the paths, delete all the files
						if (values.containsKey(FormsColumns.FORM_FILE_PATH)) {
							String newFile = values
									.getAsString(FormsColumns.FORM_FILE_PATH);
							String delFile = c
									.getString(c
											.getColumnIndex(FormsColumns.FORM_FILE_PATH));
							if (newFile.equalsIgnoreCase(delFile)) {
								// same file, so don't delete anything
							} else {
								// different files, delete the old one
								deleteFileOrDir(delFile);
							}

							// either way, delete the old cache because we'll
							// calculate a new one.
							deleteFileOrDir(c
									.getString(c
											.getColumnIndex(FormsColumns.JRCACHE_FILE_PATH)));
						}
					}
				}
			} finally {
				if (c != null) {
					c.close();
				}
			}

			// Make sure that the necessary fields are all set
			if (values.containsKey(FormsColumns.DATE)) {
				Date today = new Date();
				String ts = new SimpleDateFormat(getContext().getString(
						R.string.added_on_date_at_time), Locale.getDefault())
						.format(today);
				values.put(FormsColumns.DISPLAY_SUBTEXT, ts);
			}

			count = db.update(FORMS_TABLE_NAME, values, where, whereArgs);
			break;

		case FORM_ID:
			String formId = uri.getPathSegments().get(1);
			// Whenever file paths are updated, delete the old files.

			Cursor update = null;
			try {
				update = this.query(uri, null, where, whereArgs, null);

				// This should only ever return 1 record.
				if (update.getCount() > 0) {
					update.moveToFirst();

					// don't let users manually update md5
					if (values.containsKey(FormsColumns.MD5_HASH)) {
						values.remove(FormsColumns.MD5_HASH);
					}

					// the order here is important (jrcache needs to be before
					// form file)
					// because we update the jrcache file if there's a new form
					// file
					if (values.containsKey(FormsColumns.JRCACHE_FILE_PATH)) {
						deleteFileOrDir(update
								.getString(update
										.getColumnIndex(FormsColumns.JRCACHE_FILE_PATH)));
					}

					if (values.containsKey(FormsColumns.FORM_FILE_PATH)) {
						String formFile = values
								.getAsString(FormsColumns.FORM_FILE_PATH);
						String oldFile = update.getString(update
								.getColumnIndex(FormsColumns.FORM_FILE_PATH));
                        assert formFile != null;
						if (formFile.equalsIgnoreCase(oldFile)) {
							// Files are the same, so we may have just copied
							// over something we had
							// already
						} else {
							// New file name. This probably won't ever happen,
							// though.
							deleteFileOrDir(oldFile);
						}

						// we're updating our file, so update the md5
						// and get rid of the cache (doesn't harm anything)
						deleteFileOrDir(update
								.getString(update
										.getColumnIndex(FormsColumns.JRCACHE_FILE_PATH)));
						String newMd5 = FileUtils
								.getMd5Hash(new File(formFile));
						values.put(FormsColumns.MD5_HASH, newMd5);
						values.put(FormsColumns.JRCACHE_FILE_PATH,
								Collect.getInstance().getCachePath() + File.separator + newMd5
										+ ".formdef");
					}

					// Make sure that the necessary fields are all set
					if (values.containsKey(FormsColumns.DATE)) {
						Date today = new Date();
						String ts = new SimpleDateFormat(getContext()
								.getString(R.string.added_on_date_at_time),
								Locale.getDefault()).format(today);
						values.put(FormsColumns.DISPLAY_SUBTEXT, ts);
					}

					count = db.update(
							FORMS_TABLE_NAME,
							values,
							FormsColumns._ID
									+ "="
									+ formId
									+ (!TextUtils.isEmpty(where) ? " AND ("
											+ where + ')' : ""), whereArgs);
				} else {
					Log.e(t, "Attempting to update row that does not exist");
				}
			} finally {
				if (update != null) {
					update.close();
				}
			}
			break;

		default:
			throw new IllegalArgumentException("Unknown URI " + uri);
		}

		if (count > 0) getContext().getContentResolver().notifyChange(uri, null);
		return count;
	}

	static {
		sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
		sUriMatcher.addURI(FormsProviderAPI.AUTHORITY, "forms", FORMS);
		sUriMatcher.addURI(FormsProviderAPI.AUTHORITY, "forms/#", FORM_ID);

		sFormsProjectionMap = new HashMap<>();
		sFormsProjectionMap.put(FormsColumns._ID, FormsColumns._ID);
		sFormsProjectionMap.put(FormsColumns.DISPLAY_NAME,
				FormsColumns.DISPLAY_NAME);
		sFormsProjectionMap.put(FormsColumns.DISPLAY_SUBTEXT,
				FormsColumns.DISPLAY_SUBTEXT);
		sFormsProjectionMap.put(FormsColumns.DESCRIPTION,
				FormsColumns.DESCRIPTION);
		sFormsProjectionMap.put(FormsColumns.JR_FORM_ID,
				FormsColumns.JR_FORM_ID);
		sFormsProjectionMap.put(FormsColumns.JR_VERSION,
				FormsColumns.JR_VERSION);
		sFormsProjectionMap.put(FormsColumns.SUBMISSION_URI,
				FormsColumns.SUBMISSION_URI);
		sFormsProjectionMap.put(FormsColumns.BASE64_RSA_PUBLIC_KEY,
				FormsColumns.BASE64_RSA_PUBLIC_KEY);
		sFormsProjectionMap.put(FormsColumns.MD5_HASH, FormsColumns.MD5_HASH);
		sFormsProjectionMap.put(FormsColumns.DATE, FormsColumns.DATE);
		sFormsProjectionMap.put(FormsColumns.FORM_MEDIA_PATH,
				FormsColumns.FORM_MEDIA_PATH);
		sFormsProjectionMap.put(FormsColumns.FORM_FILE_PATH,
				FormsColumns.FORM_FILE_PATH);
		sFormsProjectionMap.put(FormsColumns.JRCACHE_FILE_PATH,
				FormsColumns.JRCACHE_FILE_PATH);
		sFormsProjectionMap.put(FormsColumns.LANGUAGE, FormsColumns.LANGUAGE);
	}

}


package org.odk.collect.android.receivers;

import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.graphics.BitmapFactory;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.Uri;
import android.os.Environment;
import android.preference.PreferenceManager;
import android.support.v4.app.NotificationCompat;

import org.odk.collect.android.R;
import org.odk.collect.android.activities.NotificationActivity;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.listeners.InstanceUploaderListener;
import org.odk.collect.android.preferences.PreferencesActivity;
import org.odk.collect.android.provider.InstanceProviderAPI;
import org.odk.collect.android.provider.InstanceProviderAPI.InstanceColumns;
import org.odk.collect.android.tasks.InstanceUploaderTask;
import org.odk.collect.android.utilities.WebUtils;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;

public class NetworkReceiver extends BroadcastReceiver implements InstanceUploaderListener {

    // turning on wifi often gets two CONNECTED events. we only want to run one thread at a time
    public static boolean running = false;
    InstanceUploaderTask mInstanceUploaderTask;

   @Override
	public void onReceive(Context context, Intent intent) {
        // make sure sd card is ready, if not don't try to send
        if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
            return;
        }

		String action = intent.getAction();
		ConnectivityManager manager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
		NetworkInfo currentNetworkInfo = manager.getActiveNetworkInfo();

		if (action.equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
			if (currentNetworkInfo != null && currentNetworkInfo.getState() == NetworkInfo.State.CONNECTED) {
				if (interfaceIsEnabled(context, currentNetworkInfo)) {
					uploadForms(context);
				}
			}
		} else if (action.equals("org.odk.collect.android.FormSaved")) {
			ConnectivityManager connectivityManager = (ConnectivityManager) context
					.getSystemService(Context.CONNECTIVITY_SERVICE);
			NetworkInfo ni = connectivityManager.getActiveNetworkInfo();

			if (ni == null || !ni.isConnected()) {
				// not connected, do nothing
			} else {
				if (interfaceIsEnabled(context, ni)) {
					uploadForms(context);
				}
			}
		}
	}

	private boolean interfaceIsEnabled(Context context,
			NetworkInfo currentNetworkInfo) {
		// make sure autosend is enabled on the given connected interface
		SharedPreferences sharedPreferences = PreferenceManager
				.getDefaultSharedPreferences(context);
		boolean sendwifi = sharedPreferences.getBoolean(
				PreferencesActivity.KEY_AUTOSEND_WIFI, false);
		boolean sendnetwork = sharedPreferences.getBoolean(
				PreferencesActivity.KEY_AUTOSEND_NETWORK, false);

		return (currentNetworkInfo.getType() == ConnectivityManager.TYPE_WIFI
				&& sendwifi || currentNetworkInfo.getType() == ConnectivityManager.TYPE_MOBILE
				&& sendnetwork);
	}


    private void uploadForms(Context context) {
        if (!running) {
            running = true;

            String selection = InstanceColumns.STATUS + "=? or " + InstanceColumns.STATUS + "=?";
            String selectionArgs[] =
                {
                        InstanceProviderAPI.STATUS_COMPLETE,
                        InstanceProviderAPI.STATUS_SUBMISSION_FAILED
                };

            ArrayList<Long> toUpload = new ArrayList<Long>();
            Cursor c = context.getContentResolver().query(InstanceColumns.CONTENT_URI, null,
                    selection, selectionArgs, null);
            try {
                if (c != null && c.getCount() > 0) {
                    c.move(-1);
                    while (c.moveToNext()) {
                        Long l = c.getLong(c.getColumnIndex(InstanceColumns._ID));
                        toUpload.add(Long.valueOf(l));
                    }
                }
            } finally {
                if (c != null) {
                    c.close();
                }
            }

            if (toUpload.size() < 1) {
                running = false; 
                return;
            }

            Long[] toSendArray = new Long[toUpload.size()];
            toUpload.toArray(toSendArray);

            SharedPreferences settings = PreferenceManager.getDefaultSharedPreferences(context);

            String protocol = settings.getString(PreferencesActivity.KEY_PROTOCOL,
            		context.getString(R.string.protocol_odk_default));
            // get the username, password, and server from preferences

            String storedUsername = settings.getString(PreferencesActivity.KEY_USERNAME, null);
            String storedPassword = settings.getString(PreferencesActivity.KEY_PASSWORD, null);
            String server = settings.getString(PreferencesActivity.KEY_SERVER_URL,
                    context.getString(R.string.default_server_url));
            String url = server
                    + settings.getString(PreferencesActivity.KEY_FORMLIST_URL,
                    context.getString(R.string.default_odk_formlist));

            Uri u = Uri.parse(url);
            WebUtils.addCredentials(storedUsername, storedPassword, u.getHost());

            mInstanceUploaderTask = new InstanceUploaderTask();
            mInstanceUploaderTask.setUploaderListener(this);

            mInstanceUploaderTask.execute(toSendArray);
        }
    }

    @Override
    public void uploadingComplete(HashMap<String, String> result) {
        // task is done
        if (mInstanceUploaderTask != null) {
            mInstanceUploaderTask.setUploaderListener(null);
        }
        running = false;

        StringBuilder message = new StringBuilder();
        message.append(Collect.getInstance().getApplication().getString(R.string.odk_auto_note) + " :: \n\n");

        if (result == null) {
            message.append(Collect.getInstance().getApplication().getString(R.string.odk_auth_auth_fail));
        } else {

            StringBuilder selection = new StringBuilder();
            Set<String> keys = result.keySet();
            Iterator<String> it = keys.iterator();

            String[] selectionArgs = new String[keys.size()];
            int i = 0;
            while (it.hasNext()) {
                String id = it.next();
                selection.append(InstanceColumns._ID + "=?");
                selectionArgs[i++] = id;
                if (i != keys.size()) {
                    selection.append(" or ");
                }
            }

            {
                Cursor results = null;
                try {
                    results = Collect
                            .getInstance()
                            .getApplication()
                            .getContentResolver()
                            .query(InstanceColumns.CONTENT_URI, null, selection.toString(),
                                    selectionArgs, null);
                    if (results.getCount() > 0) {
                        results.moveToPosition(-1);
                        while (results.moveToNext()) {
                            String name = results.getString(results
                                    .getColumnIndex(InstanceColumns.DISPLAY_NAME));
                            String id = results.getString(results
                                    .getColumnIndex(InstanceColumns._ID));
                            message.append(name + " - " + result.get(id) + "\n\n");
                        }
                    }
                } finally {
                    if (results != null) {
                        results.close();
                    }
                }
            }
        }

        Intent notifyIntent = new Intent(
                Collect.getInstance().getApplication(), NotificationActivity.class);
        notifyIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        notifyIntent.putExtra(NotificationActivity.NOTIFICATION_KEY, message.toString().trim());

        PendingIntent pendingNotify = PendingIntent.getActivity(
                Collect.getInstance().getApplication(), 0,
                notifyIntent, PendingIntent.FLAG_UPDATE_CURRENT);

        NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(
                Collect.getInstance().getApplication())
                .setSmallIcon(R.drawable.notes)
                .setContentTitle(Collect.getInstance().getApplication()
                        .getString(R.string.odk_auto_note))
                .setContentIntent(pendingNotify)
                .setContentText(message.toString().trim())
                .setAutoCancel(true)
                .setLargeIcon(
                        BitmapFactory.decodeResource(Collect.getInstance().getApplication()
                                        .getResources(),
                                android.R.drawable.ic_dialog_info));

        NotificationManager mNotificationManager = (NotificationManager)Collect.getInstance()
                .getApplication()
                .getSystemService(Context.NOTIFICATION_SERVICE);
        mNotificationManager.notify(1328974928, mBuilder.build());
    }


    @Override
    public void progressUpdate(int progress, int total) {
        // do nothing
    }


    @Override
    public void authRequest(Uri url, HashMap<String, String> doneSoFar) {
        // if we get an auth request, just fail
        if (mInstanceUploaderTask != null) {
            mInstanceUploaderTask.setUploaderListener(null);
        }
        running = false;
    }
}

/*
 * Copyright (C) 2012 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.utilities;

import android.content.Context;
import android.database.Cursor;
import android.view.View;
import android.widget.SimpleCursorAdapter;
import android.widget.TextView;

import org.odk.collect.android.R;

/**
 * Implementation of cursor adapter that displays the version of a form if a form has a version.
 * 
 * @author mitchellsundt@gmail.com
 *
 */
public class VersionHidingCursorAdapter extends SimpleCursorAdapter {
	
	private final Context ctxt;
	private final String versionColumnName;
	private final ViewBinder originalBinder;

	public VersionHidingCursorAdapter(String versionColumnName, Context context, int layout, Cursor c, String[] from, int[] to) {
		super(context, layout, c, from, to);
		this.versionColumnName = versionColumnName;
		ctxt =  context;
		originalBinder = getViewBinder();
		setViewBinder( new ViewBinder(){

			@Override
			public boolean setViewValue(View view, Cursor cursor,
					int columnIndex) {
				String columnName = cursor.getColumnName(columnIndex);
				if ( !columnName.equals(VersionHidingCursorAdapter.this.versionColumnName) ) {
					if ( originalBinder != null ) {
						return originalBinder.setViewValue(view, cursor, columnIndex);
					}
					return false;
				} else {
					String version = cursor.getString(columnIndex);
					TextView v = (TextView) view;
					if ( version != null ) {
						v.setText(ctxt.getString(R.string.version) + " " + version);
						v.setVisibility(View.VISIBLE);
					} else {
						v.setText(null);
						v.setVisibility(View.GONE);
					}
				}
				return true;
			}} );
	}
	
}
package org.odk.collect.android.utilities;

import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/** A localized string, made from a string of the form "cat [fr:chat] [es:gato]". */
public class Loc {
    private static final Pattern BRACKETED_PATTERN = Pattern.compile("\\[(.*?)\\]");

    protected final String base;
    protected final Map<String, String> options;

    public Loc(String packed) {
        if (packed == null) packed = "";
        base = BRACKETED_PATTERN.matcher(packed).replaceAll("").trim();
        options = new HashMap<>();
        Matcher matcher = BRACKETED_PATTERN.matcher(packed);
        for (int pos = 0; matcher.find(pos); pos = matcher.end(1)) {
            String[] parts = Utils.splitFields(matcher.group(1), ":", 2);
            options.put(parts[0], parts[1]);
        }
    }

    public Loc(String base, Map<String, String> options) {
        this.base = base;
        this.options = options;
    }

    public String get(String languageTag) {
        return get(Utils.toLocale(languageTag));
    }

    public String get(Locale locale) {
        if (options == null || options.isEmpty()) return base;

        String tag = Utils.toLanguageTag(locale);
        if (options.containsKey(tag)) return options.get(tag);

        String lang = locale.getLanguage();
        String region = locale.getCountry();
        String variant = locale.getVariant();
        tag = Utils.toLanguageTag(new Locale(lang, region, variant));
        if (options.containsKey(tag)) return options.get(tag);
        tag = Utils.toLanguageTag(new Locale(lang, region));
        if (options.containsKey(tag)) return options.get(tag);
        tag = Utils.toLanguageTag(new Locale(lang));
        if (options.containsKey(tag)) return options.get(tag);

        return base;
    }
}

package org.odk.collect.android.utilities;

import java.lang.reflect.Field;

/**
 * A Reflection-based mechanism to access the application's build config (in contrast to this
 * library's build config, which is not always accurate).
 */
public class AppBuildConfig {

    public static final String APPLICATION_ID;

    static {
        Class appBuildConfigClass = null;
        Field applicationIdField = null;
        String applicationId = null;

        try {
            appBuildConfigClass = Class.forName("org.projectbuendia.client.BuildConfig");
            applicationIdField = appBuildConfigClass.getField("APPLICATION_ID");
            applicationId = (String) applicationIdField.get(null /*object*/);
        } catch (Exception e) {
            // The application should crash.
            throw new IllegalStateException(e);
        }

        APPLICATION_ID = applicationId;
    }

    private AppBuildConfig() {}
}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.utilities;

import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.util.Log;

import org.apache.commons.io.IOUtils;
import org.javarosa.xform.parse.XFormParser;
import org.kxml2.kdom.Document;
import org.kxml2.kdom.Element;
import org.kxml2.kdom.Node;
import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.nio.channels.FileChannel;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.HashMap;

/**
 * Static methods used for common file operations.
 *
 * @author Carl Hartung (carlhartung@gmail.com)
 */
public class FileUtils {
    private final static String t = "FileUtils";

    public static final String FORMID = "formid";
    public static final String VERSION = "version"; // arbitrary string in OpenRosa 1.0
    public static final String TITLE = "title";
    public static final String SUBMISSIONURI = "submission";
    public static final String BASE64_RSA_PUBLIC_KEY = "base64RsaPublicKey";

    public static boolean createFolder(String path) {
        boolean made = true;
        File dir = new File(path);
        if (!dir.exists()) {
            made = dir.mkdirs();
        }
        return made;
    }


    public static byte[] getFileAsBytes(File file) {
        byte[] bytes = null;
        InputStream is = null;
        try {
            is = new FileInputStream(file);

            // Get the size of the file
            long length = file.length();
            if (length > Integer.MAX_VALUE) {
                Log.e(t, "File " + file.getName() + "is too large");
                return null;
            }

            // Create the byte array to hold the data
            bytes = new byte[(int) length];

            // Read in the bytes
            int offset = 0;
            int read = 0;
            try {
                while (offset < bytes.length && read >= 0) {
                    read = is.read(bytes, offset, bytes.length - offset);
                    offset += read;
                }
            } catch (IOException e) {
                Log.e(t, "Cannot read " + file.getName());
                e.printStackTrace();
                return null;
            }

            // Ensure all the bytes have been read in
            if (offset < bytes.length) {
                try {
                    throw new IOException("Could not completely read file " + file.getName());
                } catch (IOException e) {
                    e.printStackTrace();
                    return null;
                }
            }

            return bytes;

        } catch (FileNotFoundException e) {
            Log.e(t, "Cannot find " + file.getName());
            e.printStackTrace();
            return null;

        } finally {
            if (is != null) {
                // Close the input stream
                try {
                    is.close();
                } catch (IOException e) {
                    Log.e(t, "Cannot close input stream for " + file.getName());
                    e.printStackTrace();
                }
            }
        }
    }


    public static String getMd5Hash(File file) {
        try {
            // CTS (6/15/2010) : stream file through digest instead of handing it the byte[]
            MessageDigest md = MessageDigest.getInstance("MD5");
            int chunkSize = 256;

            byte[] chunk = new byte[chunkSize];

            // Get the size of the file
            long lLength = file.length();

            if (lLength > Integer.MAX_VALUE) {
                Log.e(t, "File " + file.getName() + "is too large");
                return null;
            }

            int length = (int) lLength;

            InputStream is = null;
            is = new FileInputStream(file);

            int l = 0;
            for (l = 0; l + chunkSize < length; l += chunkSize) {
                is.read(chunk, 0, chunkSize);
                md.update(chunk, 0, chunkSize);
            }

            int remaining = length - l;
            if (remaining > 0) {
                is.read(chunk, 0, remaining);
                md.update(chunk, 0, remaining);
            }
            byte[] messageDigest = md.digest();

            BigInteger number = new BigInteger(1, messageDigest);
            String md5 = number.toString(16);
            while (md5.length() < 32)
                md5 = "0" + md5;
            is.close();
            return md5;

        } catch (NoSuchAlgorithmException e) {
            Log.e("MD5", e.getMessage());
            return null;

        } catch (FileNotFoundException e) {
            Log.e("No Cache File", e.getMessage());
            return null;
        } catch (IOException e) {
            Log.e("Problem reading from file", e.getMessage());
            return null;
        }

    }


    public static Bitmap getBitmapScaledToDisplay(File f, int screenHeight, int screenWidth) {
        // Determine image size of f
        BitmapFactory.Options o = new BitmapFactory.Options();
        o.inJustDecodeBounds = true;
        BitmapFactory.decodeFile(f.getAbsolutePath(), o);

        int heightScale = o.outHeight / screenHeight;
        int widthScale = o.outWidth / screenWidth;

        // Powers of 2 work faster, sometimes, according to the doc.
        // We're just doing closest size that still fills the screen.
        int scale = Math.max(widthScale, heightScale);

        // get bitmap with scale ( < 1 is the same as 1)
        BitmapFactory.Options options = new BitmapFactory.Options();
        options.inInputShareable = true;
        options.inPurgeable = true;
        options.inSampleSize = scale;
        Bitmap b = BitmapFactory.decodeFile(f.getAbsolutePath(), options);
        if (b != null) {
        Log.i(t,
            "Screen is " + screenHeight + "x" + screenWidth + ".  Image has been scaled down by "
                    + scale + " to " + b.getHeight() + "x" + b.getWidth());
        }
        return b;
    }


    public static String copyFile(File sourceFile, File destFile) {
        if (sourceFile.exists()) {
            String errorMessage = actualCopy(sourceFile, destFile);
            if (errorMessage != null) {
                try {
                    Thread.sleep(500);
                    Log.e(t, "Retrying to copy the file after 500ms: " + sourceFile.getAbsolutePath());
                    errorMessage = actualCopy(sourceFile, destFile);
                } catch (InterruptedException e) {
                    Log.e(t, e.getMessage(), e);
                }
            }
            return errorMessage;
        } else {
            String msg = "Source file does not exist: " + sourceFile.getAbsolutePath();
            Log.e(t, msg);
            return msg;
        }
    }

    private static String actualCopy(File sourceFile, File destFile) {
        FileInputStream fileInputStream = null;
        FileOutputStream fileOutputStream = null;
        FileChannel src = null;
        FileChannel dst = null;
        try {
            fileInputStream = new FileInputStream(sourceFile);
            src = fileInputStream.getChannel();
            fileOutputStream = new FileOutputStream(destFile);
            dst = fileOutputStream.getChannel();
            dst.transferFrom(src, 0, src.size());
            dst.force(true);
            return null;
        } catch (FileNotFoundException e) {
            Log.e(t, "FileNotFoundException while copying file", e);
            return e.getMessage();
        } catch (IOException e) {
            Log.e(t, "IOException while copying file", e);
            return e.getMessage();
        } catch (Exception e) {
            Log.e(t, "Exception while copying file", e);
            return e.getMessage();
        } finally {
            IOUtils.closeQuietly(fileInputStream);
            IOUtils.closeQuietly(fileOutputStream);
            IOUtils.closeQuietly(src);
            IOUtils.closeQuietly(dst);
        }
    }

    public static HashMap<String, String> parseXML(File xmlFile) {
        HashMap<String, String> fields = new HashMap<String, String>();
        InputStream is;
        try {
            is = new FileInputStream(xmlFile);
        } catch (FileNotFoundException e1) {
            throw new IllegalStateException(e1);
        }

        InputStreamReader isr;
        try {
            isr = new InputStreamReader(is, "UTF-8");
        } catch (UnsupportedEncodingException uee) {
            Log.w(t, "UTF 8 encoding unavailable, trying default encoding");
            isr = new InputStreamReader(is);
        }

        Document doc;
        try {
            doc = XFormParser.getXMLDocument(isr);
        } catch (IOException e) {
            e.printStackTrace();
            throw new IllegalStateException("Unable to parse XML document", e);
        } finally {
            try {
                isr.close();
            } catch (IOException e) {
                Log.w(t, xmlFile.getAbsolutePath() + " Error closing form reader");
                e.printStackTrace();
            }
        }

        String xforms = "http://www.w3.org/2002/xforms";
        String html = doc.getRootElement().getNamespace();

        Element head = doc.getRootElement().getElement(html, "head");
        Element title = head.getElement(html, "title");
        if (title != null) {
            fields.put(TITLE, XFormParser.getXMLText(title, true));
        }
        Element model = getChildElement(head, "model");

        Element cur = getChildElement(model,"instance");

        int idx = cur.getChildCount();
        int i;
        for (i = 0; i < idx; ++i) {
            if (cur.isText(i))
                continue;
            if (cur.getType(i) == Node.ELEMENT) {
                break;
            }
        }

        if (i < idx) {
            cur = cur.getElement(i); // this is the first data element
            String id = cur.getAttributeValue(null, "id");
            String xmlns = cur.getNamespace();

            String version = cur.getAttributeValue(null, "version");
            String uiVersion = cur.getAttributeValue(null, "uiVersion");
            if ( uiVersion != null ) {
                // pre-OpenRosa 1.0 variant of spec
                Log.e(t, "Obsolete use of uiVersion -- IGNORED -- only using version: " + version);
            }

            fields.put(FORMID, (id == null) ? xmlns : id);
            fields.put(VERSION, (version == null) ? null : version);
        } else {
            throw new IllegalStateException(xmlFile.getAbsolutePath() + " could not be parsed");
        }
        try {
            Element submission = model.getElement(xforms, "submission");
            String submissionUri = submission.getAttributeValue(null, "action");
            fields.put(SUBMISSIONURI, (submissionUri == null) ? null : submissionUri);
            String base64RsaPublicKey = submission.getAttributeValue(null, "base64RsaPublicKey");
            fields.put(BASE64_RSA_PUBLIC_KEY,
                    (base64RsaPublicKey == null || base64RsaPublicKey.trim().length() == 0)
                            ? null : base64RsaPublicKey.trim());
        } catch (Exception e) {
            // No <submission> element was found, and that's totally fine.
        }
        return fields;
    }

    // needed because element.getelement fails when there are attributes
    private static Element getChildElement(Element parent, String childName) {
        int c = parent.getChildCount();
        for (int i = 0; i < c; i++) {
            if (parent.getType(i) == Node.ELEMENT) {
                if (parent.getElement(i).getName().equalsIgnoreCase(childName)) {
                    return parent.getElement(i);
                }
            }
        }
        return null;
    }

    public static void deleteAndReport(File file) {
        if (file != null && file.exists()) {
            // remove garbage
            if (!file.delete()) {
                Log.w(t, file.getAbsolutePath() + " will be deleted upon exit.");
                file.deleteOnExit();
            } else {
                Log.w(t, file.getAbsolutePath() + " has been deleted.");
            }
        }
    }

    public static String constructMediaPath(String formFilePath) {
        String pathNoExtension = formFilePath.substring(0, formFilePath.lastIndexOf("."));
        return pathNoExtension + "-media";
    }

    /**
     * @param mediaDir the media folder
     */
    public static void checkMediaPath(File mediaDir) {
        if (mediaDir.exists() && mediaDir.isFile()) {
            Log.e(t, "The media folder is already there and it is a FILE!! We will need to delete it and create a folder instead");
            boolean deleted = mediaDir.delete();
            if (!deleted) {
                throw new RuntimeException(Collect.getInstance().getApplication().getString(R.string.fs_delete_media_path_if_file_error, mediaDir.getAbsolutePath()));
            }
        }

        // the directory case
        boolean createdOrExisted = createFolder(mediaDir.getAbsolutePath());
        if (!createdOrExisted) {
            throw new RuntimeException(Collect.getInstance().getApplication().getString(R.string.fs_create_media_folder_error, mediaDir.getAbsolutePath()));
        }
    }

    public static void purgeMediaPath(String mediaPath) {
        File tempMediaFolder = new File(mediaPath);
        File[] tempMediaFiles = tempMediaFolder.listFiles();
        if (tempMediaFiles == null || tempMediaFiles.length == 0) {
            deleteAndReport(tempMediaFolder);
        } else {
            for (File tempMediaFile : tempMediaFiles) {
                deleteAndReport(tempMediaFile);
            }
        }
    }

    public static void moveMediaFiles(String tempMediaPath, File formMediaPath) throws IOException {
        File tempMediaFolder = new File(tempMediaPath);
        File[] mediaFiles = tempMediaFolder.listFiles();
        if (mediaFiles == null || mediaFiles.length == 0) {
            deleteAndReport(tempMediaFolder);
        } else {
            for (File mediaFile : mediaFiles) {
                org.apache.commons.io.FileUtils.moveFileToDirectory(mediaFile, formMediaPath, true);
            }
            deleteAndReport(tempMediaFolder);
        }
    }
}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.utilities;

import android.annotation.SuppressLint;
import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.Context;
import android.database.Cursor;
import android.net.Uri;
import android.os.Build;
import android.os.Environment;
import android.provider.DocumentsContract;
import android.provider.MediaStore;
import android.provider.MediaStore.Audio;
import android.provider.MediaStore.Images;
import android.provider.MediaStore.Video;
import android.util.Log;

import org.odk.collect.android.application.Collect;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

/**
 * Consolidate all interactions with media providers here.
 *
 * The functionality of getPath() was provided by paulburke as described here:
 * See
 * http://stackoverflow.com/questions/20067508/get-real-path-from-uri-android
 * -kitkat-new-storage-access-framework for details
 *
 * @author mitchellsundt@gmail.com
 * @author paulburke
 *
 *
 */
public class MediaUtils {
	private static final String t = "MediaUtils";

	private MediaUtils() {
		// static methods only
	}

	private static String escapePath(String path) {
		String ep = path;
		ep = ep.replaceAll("\\!", "!!");
		ep = ep.replaceAll("_", "!_");
		ep = ep.replaceAll("%", "!%");
		return ep;
	}

	public static final Uri getImageUriFromMediaProvider(String imageFile) {
		String selection = Images.ImageColumns.DATA + "=?";
		String[] selectArgs = { imageFile };
		String[] projection = { Images.ImageColumns._ID };
		Cursor c = null;
		try {
			c = Collect
					.getInstance()
                    .getApplication()
					.getContentResolver()
					.query(android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
							projection, selection, selectArgs, null);
			if (c.getCount() > 0) {
				c.moveToFirst();
				String id = c.getString(c
						.getColumnIndex(Images.ImageColumns._ID));

				return Uri
						.withAppendedPath(
								android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
								id);
			}
			return null;
		} finally {
			if (c != null) {
				c.close();
			}
		}
	}

	public static final int deleteImageFileFromMediaProvider(String imageFile) {
		ContentResolver cr = Collect.getInstance().getApplication().getContentResolver();
		// images
		int count = 0;
		Cursor imageCursor = null;
		try {
			String select = Images.Media.DATA + "=?";
			String[] selectArgs = { imageFile };

			String[] projection = { Images.ImageColumns._ID };
			imageCursor = cr
					.query(android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
							projection, select, selectArgs, null);
			if (imageCursor.getCount() > 0) {
				imageCursor.moveToFirst();
				List<Uri> imagesToDelete = new ArrayList<Uri>();
				do {
					String id = imageCursor.getString(imageCursor
							.getColumnIndex(Images.ImageColumns._ID));

					imagesToDelete
							.add(Uri.withAppendedPath(
									android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
									id));
				} while (imageCursor.moveToNext());

				for (Uri uri : imagesToDelete) {
					Log.i(t, "attempting to delete: " + uri);
					count += cr.delete(uri, null, null);
				}
			}
		} catch (Exception e) {
			Log.e(t, e.toString());
		} finally {
			if (imageCursor != null) {
				imageCursor.close();
			}
		}
		File f = new File(imageFile);
		if (f.exists()) {
			f.delete();
		}
		return count;
	}

	public static final int deleteImagesInFolderFromMediaProvider(File folder) {
		ContentResolver cr = Collect.getInstance().getApplication().getContentResolver();
		// images
		int count = 0;
		Cursor imageCursor = null;
		try {
			String select = Images.Media.DATA + " like ? escape '!'";
			String[] selectArgs = { escapePath(folder.getAbsolutePath()) };

			String[] projection = { Images.ImageColumns._ID };
			imageCursor = cr
					.query(android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
							projection, select, selectArgs, null);
			if (imageCursor.getCount() > 0) {
				imageCursor.moveToFirst();
				List<Uri> imagesToDelete = new ArrayList<Uri>();
				do {
					String id = imageCursor.getString(imageCursor
							.getColumnIndex(Images.ImageColumns._ID));

					imagesToDelete
							.add(Uri.withAppendedPath(
									android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
									id));
				} while (imageCursor.moveToNext());

				for (Uri uri : imagesToDelete) {
					Log.i(t, "attempting to delete: " + uri);
					count += cr.delete(uri, null, null);
				}
			}
		} catch (Exception e) {
			Log.e(t, e.toString());
		} finally {
			if (imageCursor != null) {
				imageCursor.close();
			}
		}
		return count;
	}

	public static final Uri getAudioUriFromMediaProvider(String audioFile) {
		String selection = Audio.AudioColumns.DATA + "=?";
		String[] selectArgs = { audioFile };
		String[] projection = { Audio.AudioColumns._ID };
		Cursor c = null;
		try {
			c = Collect
					.getInstance()
                    .getApplication()
					.getContentResolver()
					.query(android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
							projection, selection, selectArgs, null);
			if (c.getCount() > 0) {
				c.moveToFirst();
				String id = c.getString(c
						.getColumnIndex(Audio.AudioColumns._ID));

				return Uri
						.withAppendedPath(
								android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
								id);
			}
			return null;
		} finally {
			if (c != null) {
				c.close();
			}
		}
	}

	public static final int deleteAudioFileFromMediaProvider(String audioFile) {
		ContentResolver cr = Collect.getInstance().getApplication().getContentResolver();
		// audio
		int count = 0;
		Cursor audioCursor = null;
		try {
			String select = Audio.Media.DATA + "=?";
			String[] selectArgs = { audioFile };

			String[] projection = { Audio.AudioColumns._ID };
			audioCursor = cr
					.query(android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
							projection, select, selectArgs, null);
			if (audioCursor.getCount() > 0) {
				audioCursor.moveToFirst();
				List<Uri> audioToDelete = new ArrayList<Uri>();
				do {
					String id = audioCursor.getString(audioCursor
							.getColumnIndex(Audio.AudioColumns._ID));

					audioToDelete
							.add(Uri.withAppendedPath(
									android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
									id));
				} while (audioCursor.moveToNext());

				for (Uri uri : audioToDelete) {
					Log.i(t, "attempting to delete: " + uri);
					count += cr.delete(uri, null, null);
				}
			}
		} catch (Exception e) {
			Log.e(t, e.toString());
		} finally {
			if (audioCursor != null) {
				audioCursor.close();
			}
		}
		File f = new File(audioFile);
		if (f.exists()) {
			f.delete();
		}
		return count;
	}

	public static final int deleteAudioInFolderFromMediaProvider(File folder) {
		ContentResolver cr = Collect.getInstance().getApplication().getContentResolver();
		// audio
		int count = 0;
		Cursor audioCursor = null;
		try {
			String select = Audio.Media.DATA + " like ? escape '!'";
			String[] selectArgs = { escapePath(folder.getAbsolutePath()) };

			String[] projection = { Audio.AudioColumns._ID };
			audioCursor = cr
					.query(android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
							projection, select, selectArgs, null);
			if (audioCursor.getCount() > 0) {
				audioCursor.moveToFirst();
				List<Uri> audioToDelete = new ArrayList<Uri>();
				do {
					String id = audioCursor.getString(audioCursor
							.getColumnIndex(Audio.AudioColumns._ID));

					audioToDelete
							.add(Uri.withAppendedPath(
									android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
									id));
				} while (audioCursor.moveToNext());

				for (Uri uri : audioToDelete) {
					Log.i(t, "attempting to delete: " + uri);
					count += cr.delete(uri, null, null);
				}
			}
		} catch (Exception e) {
			Log.e(t, e.toString());
		} finally {
			if (audioCursor != null) {
				audioCursor.close();
			}
		}
		return count;
	}

	public static final Uri getVideoUriFromMediaProvider(String videoFile) {
		String selection = Video.VideoColumns.DATA + "=?";
		String[] selectArgs = { videoFile };
		String[] projection = { Video.VideoColumns._ID };
		Cursor c = null;
		try {
			c = Collect
					.getInstance()
                    .getApplication()
					.getContentResolver()
					.query(android.provider.MediaStore.Video.Media.EXTERNAL_CONTENT_URI,
							projection, selection, selectArgs, null);
			if (c.getCount() > 0) {
				c.moveToFirst();
				String id = c.getString(c
						.getColumnIndex(Video.VideoColumns._ID));

				return Uri
						.withAppendedPath(
								android.provider.MediaStore.Video.Media.EXTERNAL_CONTENT_URI,
								id);
			}
			return null;
		} finally {
			if (c != null) {
				c.close();
			}
		}
	}

	public static final int deleteVideoFileFromMediaProvider(String videoFile) {
		ContentResolver cr = Collect.getInstance().getApplication().getContentResolver();
		// video
		int count = 0;
		Cursor videoCursor = null;
		try {
			String select = Video.Media.DATA + "=?";
			String[] selectArgs = { videoFile };

			String[] projection = { Video.VideoColumns._ID };
			videoCursor = cr
					.query(android.provider.MediaStore.Video.Media.EXTERNAL_CONTENT_URI,
							projection, select, selectArgs, null);
			if (videoCursor.getCount() > 0) {
				videoCursor.moveToFirst();
				List<Uri> videoToDelete = new ArrayList<Uri>();
				do {
					String id = videoCursor.getString(videoCursor
							.getColumnIndex(Video.VideoColumns._ID));

					videoToDelete
							.add(Uri.withAppendedPath(
									android.provider.MediaStore.Video.Media.EXTERNAL_CONTENT_URI,
									id));
				} while (videoCursor.moveToNext());

				for (Uri uri : videoToDelete) {
					Log.i(t, "attempting to delete: " + uri);
					count += cr.delete(uri, null, null);
				}
			}
		} catch (Exception e) {
			Log.e(t, e.toString());
		} finally {
			if (videoCursor != null) {
				videoCursor.close();
			}
		}
		File f = new File(videoFile);
		if (f.exists()) {
			f.delete();
		}
		return count;
	}

	public static final int deleteVideoInFolderFromMediaProvider(File folder) {
		ContentResolver cr = Collect.getInstance().getApplication().getContentResolver();
		// video
		int count = 0;
		Cursor videoCursor = null;
		try {
			String select = Video.Media.DATA + " like ? escape '!'";
			String[] selectArgs = { escapePath(folder.getAbsolutePath()) };

			String[] projection = { Video.VideoColumns._ID };
			videoCursor = cr
					.query(android.provider.MediaStore.Video.Media.EXTERNAL_CONTENT_URI,
							projection, select, selectArgs, null);
			if (videoCursor.getCount() > 0) {
				videoCursor.moveToFirst();
				List<Uri> videoToDelete = new ArrayList<Uri>();
				do {
					String id = videoCursor.getString(videoCursor
							.getColumnIndex(Video.VideoColumns._ID));

					videoToDelete
							.add(Uri.withAppendedPath(
									android.provider.MediaStore.Video.Media.EXTERNAL_CONTENT_URI,
									id));
				} while (videoCursor.moveToNext());

				for (Uri uri : videoToDelete) {
					Log.i(t, "attempting to delete: " + uri);
					count += cr.delete(uri, null, null);
				}
			}
		} catch (Exception e) {
			Log.e(t, e.toString());
		} finally {
			if (videoCursor != null) {
				videoCursor.close();
			}
		}
		return count;
	}

	/**
	 * Consolidates the file path determination functionality of the various
	 * media prompts. Beginning with KitKat, the responses use a different
	 * mechanism and needs a lot of special handling.
	 *
	 * @param ctxt
	 * @param uri
	 * @param pathKey
	 * @return
	 */
	@SuppressLint("NewApi")
	public static String getPathFromUri(Context ctxt, Uri uri, String pathKey) {

		if (Build.VERSION.SDK_INT >= 19) {
			return getPath(ctxt, uri);
		} else {
			if (uri.toString().startsWith("file")) {
				return uri.toString().substring(7);
			} else {
				String[] projection = { pathKey };
				Cursor c = null;
				try {
					c = ctxt.getContentResolver().query(uri, projection, null,
							null, null);
					int column_index = c.getColumnIndexOrThrow(pathKey);
					String path = null;
					if (c.getCount() > 0) {
						c.moveToFirst();
						path = c.getString(column_index);
					}
					return path;
				} finally {
					if (c != null) {
						c.close();
					}
				}
			}
		}
	}

	@SuppressLint("NewApi")
	/**
	 * Get a file path from a Uri. This will get the the path for Storage Access
	 * Framework Documents, as well as the _data field for the MediaStore and
	 * other file-based ContentProviders.<br>
	 * <br>
	 * Callers should check whether the path is local before assuming it
	 * represents a local file.
	 *
	 * @param context The context.
	 * @param uri The Uri to query.
	 * @see #isLocal(String)
	 * @see #getFile(Context, Uri)
	 * @author paulburke
	 */
	public static String getPath(final Context context, final Uri uri) {

		final boolean isKitKat = Build.VERSION.SDK_INT >= 19;

		// DocumentProvider
		if (isKitKat && DocumentsContract.isDocumentUri(context, uri)) {

			// ExternalStorageProvider
			if (isExternalStorageDocument(uri)) {
				final String docId = DocumentsContract.getDocumentId(uri);
				final String[] split = docId.split(":");
				final String type = split[0];

				if ("primary".equalsIgnoreCase(type)) {
					return Environment.getExternalStorageDirectory() + "/"
							+ split[1];
				}

				// TODO handle non-primary volumes
			}
			// DownloadsProvider
			else if (isDownloadsDocument(uri)) {

				final String id = DocumentsContract.getDocumentId(uri);
				final Uri contentUri = ContentUris.withAppendedId(
						Uri.parse("content://downloads/public_downloads"),
						Long.valueOf(id));

				return getDataColumn(context, contentUri, null, null);
			}
			// MediaProvider
			else if (isMediaDocument(uri)) {
				final String docId = DocumentsContract.getDocumentId(uri);
				final String[] split = docId.split(":");
				final String type = split[0];

				Uri contentUri = null;
				if ("image".equals(type)) {
					contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
				} else if ("video".equals(type)) {
					contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;
				} else if ("audio".equals(type)) {
					contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
				}

				final String selection = "_id=?";
				final String[] selectionArgs = new String[] { split[1] };

				return getDataColumn(context, contentUri, selection,
						selectionArgs);
			}
		}
		// MediaStore (and general)
		else if ("content".equalsIgnoreCase(uri.getScheme())) {

			// Return the remote address
			if (isGooglePhotosUri(uri))
				return uri.getLastPathSegment();

			return getDataColumn(context, uri, null, null);
		}
		// File
		else if ("file".equalsIgnoreCase(uri.getScheme())) {
			return uri.getPath();
		}

		return null;
	}

	/**
	 * @param uri
	 *            The Uri to check.
	 * @return Whether the Uri authority is ExternalStorageProvider.
	 * @author paulburke
	 */
	public static boolean isExternalStorageDocument(Uri uri) {
		return "com.android.externalstorage.documents".equals(uri
				.getAuthority());
	}

	/**
	 * @param uri
	 *            The Uri to check.
	 * @return Whether the Uri authority is DownloadsProvider.
	 * @author paulburke
	 */
	public static boolean isDownloadsDocument(Uri uri) {
		return "com.android.providers.downloads.documents".equals(uri
				.getAuthority());
	}

	/**
	 * @param uri
	 *            The Uri to check.
	 * @return Whether the Uri authority is MediaProvider.
	 * @author paulburke
	 */
	public static boolean isMediaDocument(Uri uri) {
		return "com.android.providers.media.documents".equals(uri
				.getAuthority());
	}

	/**
	 * @param uri
	 *            The Uri to check.
	 * @return Whether the Uri authority is Google Photos.
	 */
	public static boolean isGooglePhotosUri(Uri uri) {
		return "com.google.android.apps.photos.content".equals(uri
				.getAuthority());
	}

	/**
	 * Get the value of the data column for this Uri. This is useful for
	 * MediaStore Uris, and other file-based ContentProviders.
	 *
	 * @param context
	 *            The context.
	 * @param uri
	 *            The Uri to query.
	 * @param selection
	 *            (Optional) Filter used in the query.
	 * @param selectionArgs
	 *            (Optional) Selection arguments used in the query.
	 * @return The value of the _data column, which is typically a file path.
	 * @author paulburke
	 */
	public static String getDataColumn(Context context, Uri uri,
			String selection, String[] selectionArgs) {

		Cursor cursor = null;
		final String column = "_data";
		final String[] projection = { column };

		try {
			cursor = context.getContentResolver().query(uri, projection,
					selection, selectionArgs, null);
			if (cursor != null && cursor.moveToFirst()) {

				final int column_index = cursor.getColumnIndexOrThrow(column);
				return cursor.getString(column_index);
			}
		} finally {
			if (cursor != null)
				cursor.close();
		}
		return null;
	}
}

/*
 * Copyright (C) 2009 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.utilities;

import java.net.MalformedURLException;
import java.net.URL;

public class UrlUtils {

    public static boolean isValidUrl(String url) {

        try {
            new URL(url);
            return true;
        } catch (MalformedURLException e) {
            return false;
        }

    }

}

package org.odk.collect.android.utilities;

import android.content.Context;
import android.os.Build;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;

import java.util.Locale;

public class Utils {
    // ==== Basic types ====

    /**
     * Java's default .equals() and == are both broken whereas Objects.equals is
     * usually correct, so let's make its logic available under a short, easy name.
     */
    public static boolean eq(Object a, Object b) {
        // noinspection EqualsReplaceableByObjectsCall (this is deliberately inlined)
        return (a == b) || (a != null && a.equals(b));
    }

    /** Returns a value if that value is not null, or a specified default value otherwise. */
    public static @NonNull <T> T orDefault(@Nullable T value, @NonNull T defaultValue) {
        return value != null ? value : defaultValue;
    }


    // ==== Strings ====

    /** Performs a null-safe check for a null or empty String. */
    public static boolean isEmpty(@Nullable String str) {
        return str == null || str.length() == 0;
    }

    /** Performs a null-safe check for a null, empty, or whitespace String. */
    public static boolean isBlank(@Nullable String str) {
        return str == null || str.length() == 0 || str.trim().length() == 0;
    }

    /** Performs a null-safe check for a String with at least one character. */
    public static boolean hasChars(@Nullable String str) {
        return str != null && str.length() > 0;
    }

    /** Formats a string using ASCII encoding. */
    public static String format(String template, Object... args) {
        return String.format(Locale.US, template, args);
    }

    /** Splits a string, returning an array padded out to known length with empty strings. */
    public static String[] splitFields(String text, String separator, int count) {
        String[] fields = text.split(separator, -1);
        String[] result = new String[count];
        for (int i = 0; i < count; i++) {
            result[i] = i < fields.length ? fields[i] : "";
        }
        return result;
    }


    // ==== Localization ====

    public static Locale toLocale(String languageTag) {
        if (Build.VERSION.SDK_INT >= 21) return Locale.forLanguageTag(languageTag);
        String[] parts = splitFields(languageTag, "_", 2);
        return new Locale(parts[0], parts[1]);
    }

    public static @Nullable String toLanguageTag(@Nullable Locale locale) {
        if (locale == null) return null;
        if (Build.VERSION.SDK_INT >= 21) return locale.toLanguageTag();
        return locale.getLanguage() +
            (Utils.isEmpty(locale.getCountry()) ? "" : "-" + locale.getCountry()) +
            (Utils.isEmpty(locale.getVariant()) ? "" : "-" + locale.getVariant());
    }

    public static @Nullable String localize(@Nullable String packed, Context context) {
        if (packed == null) return null;
        return new Loc(packed).get(context.getResources().getConfiguration().locale);
    }
}

/*
 * Copyright (C) 2012 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.utilities;

import android.app.Dialog;
import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.LinearGradient;
import android.graphics.Paint;
import android.graphics.Shader;
import android.os.Bundle;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup.LayoutParams;
import android.widget.HorizontalScrollView;
import android.widget.ScrollView;

import org.odk.collect.android.R;

/**
 * Based heavily upon:
 * http://www.yougli.net/android/a-photoshop-like-color-picker
 * -for-your-android-application/
 *
 * @author BehrAtherton@gmail.com
 * @author yougli@yougli.net
 *
 */
public class ColorPickerDialog extends Dialog {
	public interface OnColorChangedListener {
		void colorChanged(String key, int color);
	}

	private OnColorChangedListener mListener;
	private int mInitialColor, mDefaultColor;
	private String mKey;

	/**
	 * Modified HorizontalScrollView that communicates scroll
	 * actions to interior Vertical scroll view.
	 * From: http://stackoverflow.com/questions/3866499/two-directional-scroll-view
	 *
	 */
	public class WScrollView extends HorizontalScrollView
	{
	    public ScrollView sv;
	    public WScrollView(Context context)
	    {
	        super(context);
	    }

	    public WScrollView(Context context, AttributeSet attrs)
	    {
	        super(context, attrs);
	    }

	    public WScrollView(Context context, AttributeSet attrs, int defStyle)
	    {
	        super(context, attrs, defStyle);
	    }

	    @Override public boolean onTouchEvent(MotionEvent event)
	    {
	        boolean ret = super.onTouchEvent(event);
	        ret = ret | sv.onTouchEvent(event);
	        return ret;
	  }

	    @Override public boolean onInterceptTouchEvent(MotionEvent event)
	    {
	        boolean ret = super.onInterceptTouchEvent(event);
	        ret = ret | sv.onInterceptTouchEvent(event);
	        return ret;
	    }
	}

	private static class ColorPickerView extends View {
		private Paint mPaint;
		private float mCurrentHue = 0;
		private int mCurrentX = 0, mCurrentY = 0;
		private int mCurrentColor, mDefaultColor;
		private final int[] mHueBarColors = new int[258];
		private int[] mMainColors = new int[65536];
		private OnColorChangedListener mListener;

		ColorPickerView(Context c, OnColorChangedListener l, int color,
				int defaultColor) {
			super(c);
			mListener = l;
			mDefaultColor = defaultColor;

			// Get the current hue from the current color and update the main
			// color field
			float[] hsv = new float[3];
			Color.colorToHSV(color, hsv);
			mCurrentHue = hsv[0];
			updateMainColors();

			mCurrentColor = color;

			// Initialize the colors of the hue slider bar
			int index = 0;
			for (float i = 0; i < 256; i += 256 / 42) // Red (#f00) to pink
														// (#f0f)
			{
				mHueBarColors[index] = Color.rgb(255, 0, (int) i);
				index++;
			}
			for (float i = 0; i < 256; i += 256 / 42) // Pink (#f0f) to blue
														// (#00f)
			{
				mHueBarColors[index] = Color.rgb(255 - (int) i, 0, 255);
				index++;
			}
			for (float i = 0; i < 256; i += 256 / 42) // Blue (#00f) to light
														// blue (#0ff)
			{
				mHueBarColors[index] = Color.rgb(0, (int) i, 255);
				index++;
			}
			for (float i = 0; i < 256; i += 256 / 42) // Light blue (#0ff) to
														// green (#0f0)
			{
				mHueBarColors[index] = Color.rgb(0, 255, 255 - (int) i);
				index++;
			}
			for (float i = 0; i < 256; i += 256 / 42) // Green (#0f0) to yellow
														// (#ff0)
			{
				mHueBarColors[index] = Color.rgb((int) i, 255, 0);
				index++;
			}
			for (float i = 0; i < 256; i += 256 / 42) // Yellow (#ff0) to red
														// (#f00)
			{
				mHueBarColors[index] = Color.rgb(255, 255 - (int) i, 0);
				index++;
			}

			// Initializes the Paint that will draw the View
			mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
			mPaint.setTextAlign(Paint.Align.CENTER);
			mPaint.setTextSize(12);
		}

		// Get the current selected color from the hue bar
		private int getCurrentMainColor() {
			int translatedHue = 255 - (int) (mCurrentHue * 255 / 360);
			int index = 0;
			for (float i = 0; i < 256; i += 256 / 42) {
				if (index == translatedHue)
					return Color.rgb(255, 0, (int) i);
				index++;
			}
			for (float i = 0; i < 256; i += 256 / 42) {
				if (index == translatedHue)
					return Color.rgb(255 - (int) i, 0, 255);
				index++;
			}
			for (float i = 0; i < 256; i += 256 / 42) {
				if (index == translatedHue)
					return Color.rgb(0, (int) i, 255);
				index++;
			}
			for (float i = 0; i < 256; i += 256 / 42) {
				if (index == translatedHue)
					return Color.rgb(0, 255, 255 - (int) i);
				index++;
			}
			for (float i = 0; i < 256; i += 256 / 42) {
				if (index == translatedHue)
					return Color.rgb((int) i, 255, 0);
				index++;
			}
			for (float i = 0; i < 256; i += 256 / 42) {
				if (index == translatedHue)
					return Color.rgb(255, 255 - (int) i, 0);
				index++;
			}
			return Color.RED;
		}

		// Update the main field colors depending on the current selected hue
		private void updateMainColors() {
			int mainColor = getCurrentMainColor();
			int index = 0;
			int[] topColors = new int[256];
			for (int y = 0; y < 256; y++) {
				for (int x = 0; x < 256; x++) {
					if (y == 0) {
						mMainColors[index] = Color.rgb(
								255 - (255 - Color.red(mainColor)) * x / 255,
								255 - (255 - Color.green(mainColor)) * x / 255,
								255 - (255 - Color.blue(mainColor)) * x / 255);
						topColors[x] = mMainColors[index];
					} else
						mMainColors[index] = Color.rgb(
								(255 - y) * Color.red(topColors[x]) / 255,
								(255 - y) * Color.green(topColors[x]) / 255,
								(255 - y) * Color.blue(topColors[x]) / 255);
					index++;
				}
			}
		}

		@Override
		protected void onDraw(Canvas canvas) {
			int translatedHue = 255 - (int) (mCurrentHue * 255 / 360);
			// Display all the colors of the hue bar with lines
			for (int x = 0; x < 256; x++) {
				// If this is not the current selected hue, display the actual
				// color
				if (translatedHue != x) {
					mPaint.setColor(mHueBarColors[x]);
					mPaint.setStrokeWidth(1);
				} else // else display a slightly larger black line
				{
					mPaint.setColor(Color.BLACK);
					mPaint.setStrokeWidth(3);
				}
				canvas.drawLine(x + 10, 0, x + 10, 40, mPaint);
			}

			// Display the main field colors using LinearGradient
			for (int x = 0; x < 256; x++) {
				int[] colors = new int[2];
				colors[0] = mMainColors[x];
				colors[1] = Color.BLACK;
				Shader shader = new LinearGradient(0, 50, 0, 306, colors, null,
						Shader.TileMode.REPEAT);
				mPaint.setShader(shader);
				canvas.drawLine(x + 10, 50, x + 10, 306, mPaint);
			}
			mPaint.setShader(null);

			// Display the circle around the currently selected color in the
			// main field
			if (mCurrentX != 0 && mCurrentY != 0) {
				mPaint.setStyle(Paint.Style.STROKE);
				mPaint.setColor(Color.BLACK);
				canvas.drawCircle(mCurrentX, mCurrentY, 10, mPaint);
			}

			// Draw a 'button' with the currently selected color
			mPaint.setStyle(Paint.Style.FILL);
			mPaint.setColor(mCurrentColor);
			canvas.drawRect(10, 316, 138, 356, mPaint);

			// Set the text color according to the brightness of the color
			mPaint.setColor(getInverseColor(mCurrentColor));
			canvas.drawText(getContext().getString(R.string.ok), 74, 340,
					mPaint);

			// Draw a 'button' with the default color
			mPaint.setStyle(Paint.Style.FILL);
			mPaint.setColor(mDefaultColor);
			canvas.drawRect(138, 316, 266, 356, mPaint);

			// Set the text color according to the brightness of the color
			mPaint.setColor(getInverseColor(mDefaultColor));
			canvas.drawText(getContext().getString(R.string.cancel), 202, 340,
					mPaint);
		}

		private int getInverseColor(int color) {
			int red = Color.red(color);
			int green = Color.green(color);
			int blue = Color.blue(color);
			int alpha = Color.alpha(color);
			return Color.argb(alpha, 255 - red, 255 - green, 255 - blue);
		}

		@Override
		protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
			setMeasuredDimension(276, 366);
		}

		private boolean afterFirstDown = false;
		private float startX;
		private float startY;

		@Override
		public boolean onTouchEvent(MotionEvent event) {
			// allow scrolling...
			boolean ret = super.onTouchEvent(event);

			int action = event.getAction();
			int pointerCount = event.getPointerCount();

			if ( action == MotionEvent.ACTION_CANCEL ) {
				afterFirstDown = false;
			} else if ( pointerCount == 1 && action == MotionEvent.ACTION_DOWN ) {
				afterFirstDown = true;
				startX = event.getX();
				startY = event.getY();
			} else if ( pointerCount == 1 && action == MotionEvent.ACTION_MOVE && !afterFirstDown ) {
				afterFirstDown = true;
				startX = event.getX();
				startY = event.getY();
			}

			if ( !afterFirstDown || pointerCount != 1 || action != MotionEvent.ACTION_UP ) {
				return true;
			}

			// on an ACTION_UP, we reset the afterFirstDown flag.
			// processing uses the lifting of the finger to choose
			// the color...
			afterFirstDown = false;
			float x = event.getX();
			float y = event.getY();

			if ( Math.abs(x - startX) > 10 && Math.abs(y - startY) > 10 ) {
				// the color location drifted, so it must just be a scrolling action
				// ignore it...
				return ret;
			}

			// If the touch event is located in the hue bar
			if (x > 10 && x < 266 && y > 0 && y < 40) {
				// Update the main field colors
				mCurrentHue = (255 - x) * 360 / 255;
				updateMainColors();

				// Update the current selected color
				int transX = mCurrentX - 10;
				int transY = mCurrentY - 60;
				int index = 256 * (transY - 1) + transX;
				if (index > 0 && index < mMainColors.length)
					mCurrentColor = mMainColors[256 * (transY - 1) + transX];

				// Force the redraw of the dialog
				invalidate();
			}

			// If the touch event is located in the main field
			if (x > 10 && x < 266 && y > 50 && y < 306) {
				mCurrentX = (int) x;
				mCurrentY = (int) y;
				int transX = mCurrentX - 10;
				int transY = mCurrentY - 60;
				int index = 256 * (transY - 1) + transX;
				if (index > 0 && index < mMainColors.length) {
					// Update the current color
					mCurrentColor = mMainColors[index];
					// Force the redraw of the dialog
					invalidate();
				}
			}

			// If the touch event is located in the left button, notify the
			// listener with the current color
			if (x > 10 && x < 138 && y > 316 && y < 356)
				mListener.colorChanged("", mCurrentColor);

			// If the touch event is located in the right button, notify the
			// listener with the default color
			if (x > 138 && x < 266 && y > 316 && y < 356)
				mListener.colorChanged("", mDefaultColor);

			return true;
		}
	}

	public ColorPickerDialog(Context context, OnColorChangedListener listener,
			String key, int initialColor, int defaultColor, String title) {
		super(context);

		mListener = listener;
		mKey = key;
		mInitialColor = initialColor;
		mDefaultColor = defaultColor;
		setTitle(title);
	}

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		OnColorChangedListener l = new OnColorChangedListener() {
			public void colorChanged(String key, int color) {
				mListener.colorChanged(mKey, color);
				dismiss();
			}
		};

/*BIDIRECTIONAL SCROLLVIEW*/
        ScrollView sv = new ScrollView(this.getContext());
        WScrollView hsv = new WScrollView(this.getContext());
        hsv.sv = sv;
/*END OF BIDIRECTIONAL SCROLLVIEW*/

        sv.addView(new ColorPickerView(getContext(), l, mInitialColor,
				mDefaultColor), new LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT));
        hsv.addView(sv, new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.FILL_PARENT));
        setContentView(hsv, new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT));

        setCanceledOnTouchOutside(true);
	}
}

/*
 * Copyright (C) 2013 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.utilities;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.ActivityManager;
import android.content.Context;
import android.content.pm.ConfigurationInfo;
import android.os.Build;
import android.view.MenuItem;

/**
 * Compatibility utilities for backward-compatible support of Android APIs above SDK 8
 *
 * @author mitchellsundt@gmail.com
 *
 */
@SuppressLint("NewApi")
public class CompatibilityUtils {
	public static void setShowAsAction(MenuItem item, int action) {
		if ( Build.VERSION.SDK_INT >= 11 ) {
			item.setShowAsAction(action);
		}
	}

	public static void invalidateOptionsMenu(final Activity a) {
		if ( Build.VERSION.SDK_INT >= 11 ) {
			a.runOnUiThread(
					new Runnable() {

				@Override
				public void run() {
					a.invalidateOptionsMenu();
				}
			});

		}
	}

	public static boolean useMapsV2(final Context context) {
		if ( Build.VERSION.SDK_INT >= 8 ) {
			final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
			final ConfigurationInfo configurationInfo = activityManager.getDeviceConfigurationInfo();
			boolean supportsEs2 = configurationInfo.reqGlEsVersion >= 0x20000;
			return supportsEs2;
		}
		return false;
	}
}

/*
 * Copyright (C) 2011 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.utilities;

import android.content.ContentResolver;
import android.database.Cursor;
import android.net.Uri;
import android.util.Log;

import org.apache.commons.io.IOUtils;
import org.kxml2.io.KXmlSerializer;
import org.kxml2.kdom.Document;
import org.kxml2.kdom.Element;
import org.kxml2.kdom.Node;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.exception.EncryptionException;
import org.odk.collect.android.logic.FormController.InstanceMetadata;
import org.odk.collect.android.provider.FormsProviderAPI.FormsColumns;
import org.odk.collect.android.provider.InstanceProviderAPI.InstanceColumns;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.RandomAccessFile;
import java.io.UnsupportedEncodingException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.X509EncodedKeySpec;
import java.util.ArrayList;
import java.util.List;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.CipherOutputStream;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * Utility class for encrypting submissions during the SaveToDiskTask.
 *
 * @author mitchellsundt@gmail.com
 *
 */
public class EncryptionUtils {
	private static final String t = "EncryptionUtils";
	public static final String RSA_ALGORITHM = "RSA";
	// the symmetric key we are encrypting with RSA is only 256 bits... use SHA-256
	public static final String ASYMMETRIC_ALGORITHM = "RSA/NONE/OAEPWithSHA256AndMGF1Padding";
	public static final String SYMMETRIC_ALGORITHM = "AES/CFB/PKCS5Padding";
	public static final String UTF_8 = "UTF-8";
	public static final int SYMMETRIC_KEY_LENGTH = 256;
	public static final int IV_BYTE_LENGTH = 16;

	// tags in the submission manifest

	private static final String XML_ENCRYPTED_TAG_NAMESPACE = "http://www.opendatakit.org/xforms/encrypted";
	private static final String XML_OPENROSA_NAMESPACE = "http://openrosa.org/xforms";
	private static final String DATA = "data";
	private static final String ID = "id";
	private static final String VERSION = "version";
	private static final String ENCRYPTED = "encrypted";
	private static final String BASE64_ENCRYPTED_KEY = "base64EncryptedKey";
	private static final String ENCRYPTED_XML_FILE = "encryptedXmlFile";
	private static final String META = "meta";
	private static final String INSTANCE_ID = "instanceID";
	private static final String MEDIA = "media";
	private static final String FILE = "file";
	private static final String BASE64_ENCRYPTED_ELEMENT_SIGNATURE = "base64EncryptedElementSignature";
	private static final String NEW_LINE = "\n";
    private static final String ENCRYPTION_PROVIDER = "BC";

    private EncryptionUtils() {
	}

	public static final class EncryptedFormInformation {
		public final String formId;
		public final String formVersion;
		public final InstanceMetadata instanceMetadata;
		public final PublicKey rsaPublicKey;
		public final String base64RsaEncryptedSymmetricKey;
		public final SecretKeySpec symmetricKey;
		public final byte[] ivSeedArray;
		private int ivCounter = 0;
		public final StringBuilder elementSignatureSource = new StringBuilder();
		public final Base64Wrapper wrapper;
		private boolean isNotBouncyCastle = false;

		EncryptedFormInformation(String formId, String formVersion,
				InstanceMetadata instanceMetadata, PublicKey rsaPublicKey, Base64Wrapper wrapper) {
			this.formId = formId;
			this.formVersion = formVersion;
			this.instanceMetadata = instanceMetadata;
			this.rsaPublicKey = rsaPublicKey;
			this.wrapper = wrapper;

			// generate the symmetric key from random bits...

			SecureRandom r = new SecureRandom();
			byte[] key = new byte[SYMMETRIC_KEY_LENGTH/8];
			r.nextBytes(key);
			SecretKeySpec sk = new SecretKeySpec(key, SYMMETRIC_ALGORITHM);
			symmetricKey = sk;

			// construct the fixed portion of the iv -- the ivSeedArray
			// this is the md5 hash of the instanceID and the symmetric key
	        try {
	            MessageDigest md = MessageDigest.getInstance("MD5");
	            md.update(instanceMetadata.instanceId.getBytes(UTF_8));
	            md.update(key);
	            byte[] messageDigest = md.digest();
	            ivSeedArray = new byte[IV_BYTE_LENGTH];
	            for ( int i = 0 ; i < IV_BYTE_LENGTH ; ++i ) {
	            	ivSeedArray[i] = messageDigest[(i % messageDigest.length)];
	            }
	        } catch (NoSuchAlgorithmException e) {
	            Log.e(t, e.toString());
	            e.printStackTrace();
				throw new IllegalArgumentException(e.getMessage());
	        } catch (UnsupportedEncodingException e) {
	            Log.e(t, e.toString());
	            e.printStackTrace();
				throw new IllegalArgumentException(e.getMessage());
			}

			// construct the base64-encoded RSA-encrypted symmetric key
			try {
				Cipher pkCipher;
				pkCipher = Cipher.getInstance(ASYMMETRIC_ALGORITHM);
				// write AES key
				pkCipher.init(Cipher.ENCRYPT_MODE, rsaPublicKey);
				byte[] pkEncryptedKey = pkCipher.doFinal(key);
				String alg = pkCipher.getAlgorithm();
				Log.i(t, "AlgorithmUsed: " + alg);
				base64RsaEncryptedSymmetricKey = wrapper
						.encodeToString(pkEncryptedKey);

			} catch (NoSuchAlgorithmException e) {
				Log.e(t, "Unable to encrypt the symmetric key");
				e.printStackTrace();
				throw new IllegalArgumentException(e.getMessage());
			} catch (NoSuchPaddingException e) {
				Log.e(t, "Unable to encrypt the symmetric key");
				e.printStackTrace();
				throw new IllegalArgumentException(e.getMessage());
			} catch (InvalidKeyException e) {
				Log.e(t, "Unable to encrypt the symmetric key");
				e.printStackTrace();
				throw new IllegalArgumentException(e.getMessage());
			} catch (IllegalBlockSizeException e) {
				Log.e(t, "Unable to encrypt the symmetric key");
				e.printStackTrace();
				throw new IllegalArgumentException(e.getMessage());
			} catch (BadPaddingException e) {
				Log.e(t, "Unable to encrypt the symmetric key");
				e.printStackTrace();
				throw new IllegalArgumentException(e.getMessage());
			}

			// start building elementSignatureSource...
			appendElementSignatureSource(formId);
			if ( formVersion != null ) {
				appendElementSignatureSource(formVersion.toString());
			}
			appendElementSignatureSource(base64RsaEncryptedSymmetricKey);

			appendElementSignatureSource( instanceMetadata.instanceId );
		}

		public void appendElementSignatureSource(String value) {
			elementSignatureSource.append(value).append("\n");
		}

		public void appendFileSignatureSource(File file) {
			String md5Hash = FileUtils.getMd5Hash(file);
			appendElementSignatureSource(file.getName()+"::"+md5Hash);
		}

		public String getBase64EncryptedElementSignature() {
			// Step 0: construct the text of the elements in elementSignatureSource (done)
			// 		Where...
			//      * Elements are separated by newline characters.
			//      * Filename is the unencrypted filename (no .enc suffix).
			//      * Md5 hashes of the unencrypted files' contents are converted
			//        to zero-padded 32-character strings before concatenation.
			//      Assumes this is in the order:
			//			formId
			//			version   (omitted if null)
			//			base64RsaEncryptedSymmetricKey
			//			instanceId
			//          for each media file { filename "::" md5Hash }
			//          submission.xml "::" md5Hash

			// Step 1: construct the (raw) md5 hash of Step 0.
			byte[] messageDigest;
	        try {
	            MessageDigest md = MessageDigest.getInstance("MD5");
	            md.update(elementSignatureSource.toString().getBytes(UTF_8));
	            messageDigest = md.digest();
	        } catch (NoSuchAlgorithmException e) {
	            Log.e(t, e.toString());
	            e.printStackTrace();
				throw new IllegalArgumentException(e.getMessage());
	        } catch (UnsupportedEncodingException e) {
	            Log.e(t, e.toString());
	            e.printStackTrace();
				throw new IllegalArgumentException(e.getMessage());
			}

			// Step 2: construct the base64-encoded RSA-encrypted md5
	        try {
				Cipher pkCipher;
				pkCipher = Cipher.getInstance(ASYMMETRIC_ALGORITHM);
				// write AES key
				pkCipher.init(Cipher.ENCRYPT_MODE, rsaPublicKey);
				byte[] pkEncryptedKey = pkCipher.doFinal(messageDigest);
				return wrapper.encodeToString(pkEncryptedKey);

			} catch (NoSuchAlgorithmException e) {
				Log.e(t, "Unable to encrypt the symmetric key");
				e.printStackTrace();
				throw new IllegalArgumentException(e.getMessage());
			} catch (NoSuchPaddingException e) {
				Log.e(t, "Unable to encrypt the symmetric key");
				e.printStackTrace();
				throw new IllegalArgumentException(e.getMessage());
			} catch (InvalidKeyException e) {
				Log.e(t, "Unable to encrypt the symmetric key");
				e.printStackTrace();
				throw new IllegalArgumentException(e.getMessage());
			} catch (IllegalBlockSizeException e) {
				Log.e(t, "Unable to encrypt the symmetric key");
				e.printStackTrace();
				throw new IllegalArgumentException(e.getMessage());
			} catch (BadPaddingException e) {
				Log.e(t, "Unable to encrypt the symmetric key");
				e.printStackTrace();
				throw new IllegalArgumentException(e.getMessage());
			}
		}

		public Cipher getCipher() throws InvalidKeyException,
				InvalidAlgorithmParameterException, NoSuchAlgorithmException, NoSuchPaddingException {
			++ivSeedArray[ivCounter % ivSeedArray.length];
			++ivCounter;
			IvParameterSpec baseIv = new IvParameterSpec(ivSeedArray);
			Cipher c = null;
			try {
				c = Cipher.getInstance(EncryptionUtils.SYMMETRIC_ALGORITHM, "BC");
				isNotBouncyCastle = false;
			} catch (NoSuchProviderException e) {
				Log.w(t, "Unable to obtain BouncyCastle provider! Decryption may fail!");
				e.printStackTrace();
				isNotBouncyCastle = true;
				c = Cipher.getInstance(EncryptionUtils.SYMMETRIC_ALGORITHM);
			}
			c.init(Cipher.ENCRYPT_MODE, symmetricKey, baseIv);
			return c;
		}

		public boolean isNotBouncyCastle() {
			return isNotBouncyCastle;
		}
	}

	/**
	 * Retrieve the encryption information for this uri.
	 *
	 * @param mUri either an instance URI (if previously saved) or a form URI
	 * @param instanceMetadata
	 * @return
	 */
	public static EncryptedFormInformation getEncryptedFormInformation(Uri mUri, InstanceMetadata instanceMetadata) {

		ContentResolver cr = Collect.getInstance().getApplication().getContentResolver();

		// fetch the form information
		String formId;
		String formVersion;
		PublicKey pk;
		Base64Wrapper wrapper;

		Cursor formCursor = null;
		try {
			if (InstanceColumns.CONTENT_ITEM_TYPE.equals(cr.getType(mUri))) {
				// chain back to the Form record...
				String[] selectionArgs = null;
				String selection = null;
				Cursor instanceCursor = null;
				try {
					instanceCursor = cr.query(mUri, null, null, null, null);
					if ( instanceCursor.getCount() != 1 ) {
						Log.e(t, "Not exactly one record for this instance!");
						return null; // save unencrypted.
					}
					instanceCursor.moveToFirst();
					String jrFormId = instanceCursor.getString(instanceCursor.getColumnIndex(InstanceColumns.JR_FORM_ID));
					int idxJrVersion = instanceCursor.getColumnIndex(InstanceColumns.JR_VERSION);
					if ( !instanceCursor.isNull(idxJrVersion) ) {
						selectionArgs = new String[] {jrFormId, instanceCursor.getString(idxJrVersion)};
						selection = FormsColumns.JR_FORM_ID + " =? AND " + FormsColumns.JR_VERSION + "=?";
					} else {
						selectionArgs = new String[] {jrFormId};
						selection = FormsColumns.JR_FORM_ID + " =? AND " + FormsColumns.JR_VERSION + " IS NULL";
					}
				} finally {
					if ( instanceCursor != null ) {
						instanceCursor.close();
					}
				}

		        formCursor = cr.query(FormsColumns.CONTENT_URI, null, selection, selectionArgs,
		                null);

		        if (formCursor.getCount() != 1) {
		        	Log.e(t, "Not exactly one blank form matches this jr_form_id");
		        	return null; // save unencrypted
		        }
	            formCursor.moveToFirst();
			} else if (cr.getType(mUri) == FormsColumns.CONTENT_ITEM_TYPE) {
				formCursor = cr.query(mUri, null, null, null, null);
				if ( formCursor.getCount() != 1 ) {
					Log.e(t, "Not exactly one blank form!");
					return null; // save unencrypted.
				}
				formCursor.moveToFirst();
			}

            assert formCursor != null;
            formId = formCursor.getString(formCursor.getColumnIndex(FormsColumns.JR_FORM_ID));
			if (formId == null || formId.length() == 0) {
				Log.e(t, "No FormId specified???");
				return null;
			}
			int idxVersion = formCursor.getColumnIndex(FormsColumns.JR_VERSION);
			int idxBase64RsaPublicKey = formCursor.getColumnIndex(FormsColumns.BASE64_RSA_PUBLIC_KEY);
			formVersion = formCursor.isNull(idxVersion) ? null : formCursor.getString(idxVersion);
			String base64RsaPublicKey = formCursor.isNull(idxBase64RsaPublicKey)
					? null : formCursor.getString(idxBase64RsaPublicKey);

			if (base64RsaPublicKey == null || base64RsaPublicKey.length() == 0) {
				return null; // this is legitimately not an encrypted form
			}

			int version = android.os.Build.VERSION.SDK_INT;
			if (version < 8) {
				Log.e(t, "Phone does not support encryption.");
				return null; // save unencrypted
			}

			// this constructor will throw an exception if we are not
			// running on version 8 or above (if Base64 is not found).
			try {
				wrapper = new Base64Wrapper();
			} catch (ClassNotFoundException e) {
				Log.e(t, "Phone does not have Base64 class but API level is "
						+ version);
				e.printStackTrace();
				return null; // save unencrypted
			}

			// OK -- Base64 decode (requires API Version 8 or higher)
			byte[] publicKey = wrapper.decode(base64RsaPublicKey);
			X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(publicKey);
			KeyFactory kf;
			try {
				kf = KeyFactory.getInstance(RSA_ALGORITHM);
			} catch (NoSuchAlgorithmException e) {
				Log.e(t, "Phone does not support RSA encryption.");
				e.printStackTrace();
				return null;
			}
			try {
				pk = kf.generatePublic(publicKeySpec);
			} catch (InvalidKeySpecException e) {
				e.printStackTrace();
				Log.e(t, "Invalid RSA public key.");
				return null;
			}
		} finally {
			if (formCursor != null) {
				formCursor.close();
			}
		}

		// submission must have an OpenRosa metadata block with a non-null
		// instanceID value.
		if (instanceMetadata.instanceId == null) {
			Log.e(t, "No OpenRosa metadata block or no instanceId defined in that block");
			return null;
		}

		// For now, prevent encryption if the BouncyCastle implementation is not present.
		// https://code.google.com/p/opendatakit/issues/detail?id=918
		try {
			Cipher.getInstance(EncryptionUtils.SYMMETRIC_ALGORITHM, ENCRYPTION_PROVIDER);
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
			Log.e(t, "No BouncyCastle implementation of symmetric algorithm!");
			return null;
		} catch (NoSuchProviderException e) {
			e.printStackTrace();
			Log.e(t, "No BouncyCastle provider for implementation of symmetric algorithm!");
			return null;
		} catch (NoSuchPaddingException e) {
			e.printStackTrace();
			Log.e(t, "No BouncyCastle provider for padding implementation of symmetric algorithm!");
			return null;
		}

		return new EncryptedFormInformation(formId, formVersion, instanceMetadata,
				pk, wrapper);
	}

	private static void encryptFile(File file, EncryptedFormInformation formInfo)
            throws IOException, EncryptionException {
		File encryptedFile = new File(file.getParentFile(), file.getName()
				+ ".enc");

        if (encryptedFile.exists() && !encryptedFile.delete()) {
            throw new IOException("Cannot overwrite " + encryptedFile.getAbsolutePath() + ". Perhaps the file is locked?");
        }

		// add elementSignatureSource for this file...
		formInfo.appendFileSignatureSource(file);

        RandomAccessFile randomAccessFile = null;
        CipherOutputStream cipherOutputStream = null;
        try {
            Cipher c = formInfo.getCipher();

            randomAccessFile = new RandomAccessFile(encryptedFile, "rws");
            ByteArrayOutputStream encryptedData = new ByteArrayOutputStream();
            cipherOutputStream = new CipherOutputStream(encryptedData, c);
			InputStream fin = new FileInputStream(file);
			byte[] buffer = new byte[2048];
			int len = fin.read(buffer);
			while (len != -1) {
				cipherOutputStream.write(buffer, 0, len);
				len = fin.read(buffer);
			}
			fin.close();
			cipherOutputStream.flush();
			cipherOutputStream.close();

            randomAccessFile.write(encryptedData.toByteArray());

			Log.i(t,
					"Encrpyted:" + file.getName() + " -> "
							+ encryptedFile.getName());
		} catch (Exception e) {
            String msg = "Error encrypting: " + file.getName() + " -> "
                    + encryptedFile.getName();
            Log.e(t, msg, e);
			e.printStackTrace();
			throw new EncryptionException(msg, e);
		} finally {
            IOUtils.closeQuietly(cipherOutputStream);

            if (randomAccessFile != null) {
                randomAccessFile.close();
            }
        }
    }

	public static boolean deletePlaintextFiles(File instanceXml) {
		// NOTE: assume the directory containing the instanceXml contains ONLY
		// files related to this one instance.
		File instanceDir = instanceXml.getParentFile();

		boolean allSuccessful = true;
		// encrypt files that do not end with ".enc", and do not start with ".";
		// ignore directories
		File[] allFiles = instanceDir.listFiles();
		for (File f : allFiles) {
			if (f.equals(instanceXml))
				continue; // don't touch instance file
			if (f.isDirectory())
				continue; // don't handle directories
			if (!f.getName().endsWith(".enc")) {
				// not an encrypted file -- delete it!
				allSuccessful = allSuccessful & f.delete(); // DO NOT
															// short-circuit
			}
		}
		return allSuccessful;
	}

	private static List<File> encryptSubmissionFiles(File instanceXml,
			File submissionXml, EncryptedFormInformation formInfo) throws IOException, EncryptionException {
		// NOTE: assume the directory containing the instanceXml contains ONLY
		// files related to this one instance.
		File instanceDir = instanceXml.getParentFile();

		// encrypt files that do not end with ".enc", and do not start with ".";
		// ignore directories
		File[] allFiles = instanceDir.listFiles();
		List<File> filesToProcess = new ArrayList<File>();
		for (File f : allFiles) {
			if (f.equals(instanceXml))
				continue; // don't touch restore file
			if (f.equals(submissionXml))
				continue; // handled last
			if (f.isDirectory())
				continue; // don't handle directories
			if (f.getName().startsWith("."))
				continue; // MacOSX garbage
			if (f.getName().endsWith(".enc")) {
				f.delete(); // try to delete this (leftover junk)
			} else {
				filesToProcess.add(f);
			}
		}
		// encrypt here...
		for (File f : filesToProcess) {
		    encryptFile(f, formInfo);
        }

		// encrypt the submission.xml as the last file...
	    encryptFile(submissionXml, formInfo);

        return filesToProcess;
	}

	/**
	 * Constructs the encrypted attachments, encrypted form xml, and the
	 * plaintext submission manifest (with signature) for the form submission.
	 *
	 * Does not delete any of the original files.
	 *
	 * @param instanceXml
	 * @param submissionXml
	 * @param formInfo
	 * @return
	 */
	public static void generateEncryptedSubmission(File instanceXml,
			File submissionXml, EncryptedFormInformation formInfo) throws IOException, EncryptionException {
		// submissionXml is the submission data to be published to Aggregate
		if (!submissionXml.exists() || !submissionXml.isFile()) {
			throw new IOException("No submission.xml found");
		}

		// TODO: confirm that this xml is not already encrypted...

		// Step 1: encrypt the submission and all the media files...
		List<File> mediaFiles = encryptSubmissionFiles(instanceXml,
				submissionXml, formInfo);

		// Step 2: build the encrypted-submission manifest (overwrites
		// submission.xml)...
		writeSubmissionManifest(formInfo, submissionXml, mediaFiles);
	}
	
	private static void writeSubmissionManifest(
			EncryptedFormInformation formInfo,
			File submissionXml, List<File> mediaFiles) throws EncryptionException {

		Document d = new Document();
		d.setStandalone(true);
		d.setEncoding(UTF_8);
		Element e = d.createElement(XML_ENCRYPTED_TAG_NAMESPACE, DATA);
		e.setPrefix(null, XML_ENCRYPTED_TAG_NAMESPACE);
		e.setAttribute(null, ID, formInfo.formId);
		if ( formInfo.formVersion != null ) {
			e.setAttribute(null, VERSION, formInfo.formVersion);
		}
		e.setAttribute(null,  ENCRYPTED, "yes");
		d.addChild(0, Node.ELEMENT, e);

		int idx = 0;
		Element c;
		c = d.createElement(XML_ENCRYPTED_TAG_NAMESPACE, BASE64_ENCRYPTED_KEY);
		c.addChild(0, Node.TEXT, formInfo.base64RsaEncryptedSymmetricKey);
		e.addChild(idx++, Node.ELEMENT, c);

		c = d.createElement(XML_OPENROSA_NAMESPACE, META);
		c.setPrefix("orx", XML_OPENROSA_NAMESPACE);
		{
			Element instanceTag = d.createElement(XML_OPENROSA_NAMESPACE, INSTANCE_ID);
			instanceTag.addChild(0, Node.TEXT, formInfo.instanceMetadata.instanceId);
			c.addChild(0, Node.ELEMENT, instanceTag);
		}
		e.addChild(idx++, Node.ELEMENT, c);
		e.addChild(idx++, Node.IGNORABLE_WHITESPACE, NEW_LINE);

        if (mediaFiles != null) {
            for (File file : mediaFiles) {
                c = d.createElement(XML_ENCRYPTED_TAG_NAMESPACE, MEDIA);
                Element fileTag = d.createElement(XML_ENCRYPTED_TAG_NAMESPACE, FILE);
                fileTag.addChild(0, Node.TEXT, file.getName() + ".enc");
                c.addChild(0, Node.ELEMENT, fileTag);
                e.addChild(idx++, Node.ELEMENT, c);
                e.addChild(idx++, Node.IGNORABLE_WHITESPACE, NEW_LINE);
            }
        }
		
		c = d.createElement(XML_ENCRYPTED_TAG_NAMESPACE, ENCRYPTED_XML_FILE);
		c.addChild(0, Node.TEXT, submissionXml.getName() + ".enc");
		e.addChild(idx++, Node.ELEMENT, c);

		c = d.createElement(XML_ENCRYPTED_TAG_NAMESPACE, BASE64_ENCRYPTED_ELEMENT_SIGNATURE);
		c.addChild(0, Node.TEXT, formInfo.getBase64EncryptedElementSignature());
		e.addChild(idx++, Node.ELEMENT, c);

		FileOutputStream fout = null;
        OutputStreamWriter writer = null;
        try {
            fout = new FileOutputStream(submissionXml);
            writer = new OutputStreamWriter(fout, UTF_8);

            KXmlSerializer serializer = new KXmlSerializer();
			serializer.setOutput(writer);
			// setting the response content type emits the xml header.
			// just write the body here...
			d.writeChildren(serializer);
			serializer.flush();
			writer.flush();
            fout.getChannel().force(true);
			writer.close();
		} catch (Exception ex) {
			ex.printStackTrace();
            String msg = "Error writing submission.xml for encrypted submission: "
                    + submissionXml.getParentFile().getName();
            Log.e(t, msg);
			throw new EncryptionException(msg, ex);
		} finally {
            IOUtils.closeQuietly(writer);
            IOUtils.closeQuietly(fout);
        }
    }
}

package org.odk.collect.android.utilities;

import android.os.Parcel;

import org.joda.time.DateTime;

/**
 * Utilities for {@link Parcel}s.
 */
public class Parcels {

    /**
     * Reads a possibly-{@code null} string from a {@link Parcel}
     */
    public static String readNullableString(Parcel source) {
        return (source.readByte() == 0) ? null : source.readString();
    }

    /**
     * Writes a possibly-{@code null} string to a {@link Parcel}.
     */
    public static void writeNullableString(Parcel dest, String string) {
        if (string == null) {
            dest.writeByte((byte) 0);
        } else {
            dest.writeByte((byte) 1);
            dest.writeString(string);
        }
    }

    /**
     * Reads a possibly-{@code null} {@link DateTime} from a {@link Parcel}
     */
    public static DateTime readNullableDateTime(Parcel source) {
        return (source.readByte() == 0) ? null : new DateTime(source.readLong());
    }

    /**
     * Writes a possibly-{@code null} {@link DateTime} to a {@link Parcel}.
     */
    public static void writeNullableDateTime(Parcel dest, DateTime dateTime) {
        if (dateTime == null) {
            dest.writeByte((byte) 0);
        } else {
            dest.writeByte((byte) 1);
            dest.writeLong(dateTime.getMillis());
        }
    }

    private Parcels() {}
}

/*
 * Copyright (C) 2011 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.utilities;

import org.kxml2.kdom.Document;
 
public class DocumentFetchResult {
        public final String errorMessage;
        public final int responseCode;
        public final Document doc;
        public final boolean isOpenRosaResponse;


        public DocumentFetchResult(String msg, int response) {
            responseCode = response;
            errorMessage = msg;
            doc = null;
            isOpenRosaResponse = false;
        }


        public DocumentFetchResult(Document doc, boolean isOpenRosaResponse) {
            responseCode = 0;
            errorMessage = null;
            this.doc = doc;
            this.isOpenRosaResponse = isOpenRosaResponse;
        }
    }
/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.utilities;

import android.util.Log;

import org.apache.commons.io.IOUtils;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

/**
 * Author: Meletis Margaritis
 * Date: 2/12/14
 * Time: 1:48 PM
 */
public final class ZipUtils {

    final static String t = "ZipUtils";

    public static void unzip(File[] zipFiles) {
        for (File zipFile : zipFiles) {
            ZipInputStream zipInputStream = null;
            try {
                zipInputStream = new ZipInputStream(new FileInputStream(zipFile));
                ZipEntry zipEntry;
                while ((zipEntry = zipInputStream.getNextEntry()) != null) {
                    doExtractInTheSameFolder(zipFile, zipInputStream, zipEntry);
                }
            } catch (Exception e) {
                Log.e(t, e.getMessage(), e);
            } finally {
                IOUtils.closeQuietly(zipInputStream);
            }
        }
    }

    public static File extractFirstZipEntry(File zipFile, boolean deleteAfterUnzip) throws IOException {
        ZipInputStream zipInputStream = null;
        File targetFile = null;
        try {
            zipInputStream = new ZipInputStream(new FileInputStream(zipFile));
            ZipEntry zipEntry = zipInputStream.getNextEntry();
            if (zipEntry != null) {
                targetFile = doExtractInTheSameFolder(zipFile, zipInputStream, zipEntry);
            }
        } finally {
            IOUtils.closeQuietly(zipInputStream);
        }

        if (deleteAfterUnzip && targetFile != null && targetFile.exists()) {
            FileUtils.deleteAndReport(zipFile);
        }

        return targetFile;
    }

    private static File doExtractInTheSameFolder(File zipFile, ZipInputStream zipInputStream, ZipEntry zipEntry) throws IOException {
        File targetFile;
        String fileName = zipEntry.getName();

        Log.w(t, "Found zipEntry with name: " + fileName);

        if (fileName.contains("/") || fileName.contains("\\")) {
            // that means that this is a directory of a file inside a directory, so ignore it
            Log.w(t, "Ignored: " + fileName);
            return null;
        }

        // extract the new file
        targetFile = new File(zipFile.getParentFile(), fileName);
        FileOutputStream fileOutputStream = null;
        try {
            fileOutputStream = new FileOutputStream(targetFile);
            IOUtils.copy(zipInputStream, fileOutputStream);
        } finally {
            IOUtils.closeQuietly(fileOutputStream);
        }

        Log.w(t, "Extracted file \"" + fileName + "\" out of " + zipFile.getName());
        return targetFile;
    }
}

/*
 * Copyright (C) 2011 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 * 
 * Original License from BasicCredentialsProvider:
 * ====================================================================
 *
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 */

package org.odk.collect.android.utilities;

import org.opendatakit.httpclientandroidlib.annotation.ThreadSafe;
import org.opendatakit.httpclientandroidlib.auth.AuthScope;
import org.opendatakit.httpclientandroidlib.auth.Credentials;
import org.opendatakit.httpclientandroidlib.client.CredentialsProvider;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Modified BasicCredentialsProvider that will clear the provider
 * after 'expiryInterval' milliseconds of inactivity.  Use the WebUtils
 * methods to manipulate the credentials in the local context.  You should
 * first check that the credentials exist (which will reset the expiration
 * date), then set them if they are missing.
 * 
 * Largely a cut-and-paste of BasicCredentialsProvider.
 * 
 * @author mitchellsundt@gmail.com
 *
 */
@ThreadSafe
public class AgingCredentialsProvider implements CredentialsProvider {

    private final ConcurrentHashMap<AuthScope, Credentials> credMap;
    private final long expiryInterval;

    private long nextClearTimestamp;

    /**
     * Default constructor.
     */
    public AgingCredentialsProvider(int expiryInterval) {
        super();
        this.credMap = new ConcurrentHashMap<AuthScope, Credentials>();
        this.expiryInterval = expiryInterval;
        nextClearTimestamp = System.currentTimeMillis() + expiryInterval;
    }

    public void setCredentials(
            final AuthScope authscope,
            final Credentials credentials) {
        if (authscope == null) {
            throw new IllegalArgumentException("Authentication scope may not be null");
        }
        if (nextClearTimestamp < System.currentTimeMillis()) {
            clear();
        }
        nextClearTimestamp = System.currentTimeMillis() + expiryInterval;
        if ( credentials == null ) {
        	credMap.remove(authscope);
        } else {
        	credMap.put(authscope, credentials);
        }
    }

    /**
     * Find matching {@link Credentials credentials} for the given authentication scope.
     *
     * @param map the credentials hash map
     * @param authscope the {@link AuthScope authentication scope}
     * @return the credentials
     *
     */
    private static Credentials matchCredentials(
            final Map<AuthScope, Credentials> map,
            final AuthScope authscope) {
        // see if we get a direct hit
        Credentials creds = map.get(authscope);
        if (creds == null) {
            // Nope.
            // Do a full scan
            int bestMatchFactor  = -1;
            AuthScope bestMatch  = null;
            for (AuthScope current: map.keySet()) {
                int factor = authscope.match(current);
                if (factor > bestMatchFactor) {
                    bestMatchFactor = factor;
                    bestMatch = current;
                }
            }
            if (bestMatch != null) {
                creds = map.get(bestMatch);
            }
        }
        return creds;
    }

    public Credentials getCredentials(final AuthScope authscope) {
        if (authscope == null) {
            throw new IllegalArgumentException("Authentication scope may not be null");
        }
        if (nextClearTimestamp < System.currentTimeMillis()) {
            clear();
        }
        nextClearTimestamp = System.currentTimeMillis() + expiryInterval;
        Credentials c = matchCredentials(this.credMap, authscope);
        return c;
    }

    public void clear() {
        this.credMap.clear();
    }

    @Override
    public String toString() {
        return credMap.toString();
    }

}

/*
 * Copyright (C) 2011 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.utilities;

import java.io.UnsupportedEncodingException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * Wrapper class for accessing Base64 functionality.
 * This allows API Level 7 deployment of ODK Collect while
 * enabling API Level 8 and higher phone to support encryption.
 * 
 * @author mitchellsundt@gmail.com
 *
 */
public class Base64Wrapper {

	private static final int FLAGS = 2;// NO_WRAP
	private Class<?> base64 = null;

	public Base64Wrapper() throws ClassNotFoundException {
		base64 = this.getClass().getClassLoader()
				.loadClass("android.util.Base64");
	}

	public String encodeToString(byte[] ba) {
		Class<?>[] argClassList = new Class[]{byte[].class, int.class};
		try {
			Method m = base64.getDeclaredMethod("encode", argClassList);
			Object[] argList = new Object[]{ ba, FLAGS };
			Object o = m.invoke(null, argList);
			byte[] outArray = (byte[]) o;
			String s = new String(outArray, "UTF-8");
			return s;
		} catch (SecurityException e) {
			e.printStackTrace();
			throw new IllegalArgumentException(e.toString());
		} catch (NoSuchMethodException e) {
			e.printStackTrace();
			throw new IllegalArgumentException(e.toString());
		} catch (IllegalAccessException e) {
			e.printStackTrace();
			throw new IllegalArgumentException(e.toString());
		} catch (InvocationTargetException e) {
			e.printStackTrace();
			throw new IllegalArgumentException(e.toString());
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
			throw new IllegalArgumentException(e.toString());
		}
	}

	public byte[] decode(String base64String) {
		Class<?>[] argClassList = new Class[]{String.class, int.class};
		Object o;
		try { 	
			Method m = base64.getDeclaredMethod("decode", argClassList);
			Object[] argList = new Object[]{ base64String, FLAGS };
			o = m.invoke(null, argList);
		} catch (SecurityException e) {
			e.printStackTrace();
			throw new IllegalArgumentException(e.toString());
		} catch (NoSuchMethodException e) {
			e.printStackTrace();
			throw new IllegalArgumentException(e.toString());
		} catch (IllegalAccessException e) {
			e.printStackTrace();
			throw new IllegalArgumentException(e.toString());
		} catch (InvocationTargetException e) {
			e.printStackTrace();
			throw new IllegalArgumentException(e.toString());
		}
		return (byte[]) o;
	}
}

/*
 * Copyright (C) 2013 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.utilities;

import android.util.Log;

import org.odk.collect.android.application.Collect;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;

/**
 * Used for logging data to log files that could be retrieved after a field deployment.
 * The initial use for this is to assist in diagnosing a report of a cached geopoints
 * being reported, causing stale GPS coordinates to be recorded (issue 780).
 *
 * @author mitchellsundt@gmail.com
 *
 */
public class InfoLogger {
	private static final String t = "InfoLogger";

	private static final String LOG_DIRECTORY = "logging";
	private static final String LOG_FILE = "geotrace.log";

	public static final void geolog(String msg) {
		geologToLogcat(msg);
	}

	private static final void geologToLogcat(String msg) {
		Log.i(t, msg);
	}

	@SuppressWarnings("unused")
	private static final void geologToFile(String msg) {
		File dir = new File( Collect.getInstance().getOdkRoot() + File.separator + LOG_DIRECTORY );
		if ( !dir.exists() ) {
			dir.mkdirs();
		}
		File log = new File(dir, LOG_FILE);

		FileOutputStream fo = null;
		try {
			fo = new FileOutputStream(log, true);
			msg = msg + "\n";
			fo.write( msg.getBytes("UTF-8") );
			fo.flush();
			fo.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
			Log.e(t, "exception: " + e.toString());
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
			Log.e(t, "exception: " + e.toString());
		} catch (IOException e) {
			e.printStackTrace();
			Log.e(t, "exception: " + e.toString());
		}
	}
}

/*
 * Copyright (C) 2011 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.utilities;

import android.content.SharedPreferences;
import android.net.Uri;
import android.preference.PreferenceManager;
import android.text.format.DateFormat;
import android.util.Log;

import org.apache.http.HttpStatus;
import org.kxml2.io.KXmlParser;
import org.kxml2.kdom.Document;
import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.preferences.PreferencesActivity;
import org.opendatakit.httpclientandroidlib.Header;
import org.opendatakit.httpclientandroidlib.HttpEntity;
import org.opendatakit.httpclientandroidlib.HttpHost;
import org.opendatakit.httpclientandroidlib.HttpRequest;
import org.opendatakit.httpclientandroidlib.HttpResponse;
import org.opendatakit.httpclientandroidlib.auth.AuthScope;
import org.opendatakit.httpclientandroidlib.auth.Credentials;
import org.opendatakit.httpclientandroidlib.auth.UsernamePasswordCredentials;
import org.opendatakit.httpclientandroidlib.auth.params.AuthPNames;
import org.opendatakit.httpclientandroidlib.client.AuthCache;
import org.opendatakit.httpclientandroidlib.client.CredentialsProvider;
import org.opendatakit.httpclientandroidlib.client.HttpClient;
import org.opendatakit.httpclientandroidlib.client.methods.HttpGet;
import org.opendatakit.httpclientandroidlib.client.methods.HttpHead;
import org.opendatakit.httpclientandroidlib.client.methods.HttpPost;
import org.opendatakit.httpclientandroidlib.client.params.AuthPolicy;
import org.opendatakit.httpclientandroidlib.client.params.ClientPNames;
import org.opendatakit.httpclientandroidlib.client.params.CookiePolicy;
import org.opendatakit.httpclientandroidlib.client.params.HttpClientParams;
import org.opendatakit.httpclientandroidlib.client.protocol.ClientContext;
import org.opendatakit.httpclientandroidlib.conn.ClientConnectionManager;
import org.opendatakit.httpclientandroidlib.impl.auth.BasicScheme;
import org.opendatakit.httpclientandroidlib.impl.client.BasicAuthCache;
import org.opendatakit.httpclientandroidlib.impl.client.DefaultHttpClient;
import org.opendatakit.httpclientandroidlib.params.BasicHttpParams;
import org.opendatakit.httpclientandroidlib.params.HttpConnectionParams;
import org.opendatakit.httpclientandroidlib.params.HttpParams;
import org.opendatakit.httpclientandroidlib.protocol.HttpContext;
import org.xmlpull.v1.XmlPullParser;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URI;
import java.net.URL;
import java.util.ArrayList;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.List;
import java.util.Locale;
import java.util.TimeZone;
import java.util.zip.GZIPInputStream;

/**
 * Common utility methods for managing the credentials associated with the
 * request context and constructing http context, client and request with the
 * proper parameters and OpenRosa headers.
 *
 * @author mitchellsundt@gmail.com
 */
public final class WebUtils {
	public static final String t = "WebUtils";

	public static final String OPEN_ROSA_VERSION_HEADER = "X-OpenRosa-Version";
	public static final String OPEN_ROSA_VERSION = "1.0";
	private static final String DATE_HEADER = "Date";

	public static final String HTTP_CONTENT_TYPE_TEXT_XML = "text/xml";
	public static final int CONNECTION_TIMEOUT = 30000;

	public static final String ACCEPT_ENCODING_HEADER = "Accept-Encoding";
	public static final String GZIP_CONTENT_ENCODING = "gzip";

	private static ClientConnectionManager httpConnectionManager = null;

	public static final List<AuthScope> buildAuthScopes(String host) {
		List<AuthScope> asList = new ArrayList<AuthScope>();

		AuthScope a;
		// allow digest auth on any port...
		a = new AuthScope(host, -1, null, AuthPolicy.DIGEST);
		asList.add(a);
		// and allow basic auth on the standard TLS/SSL ports...
		a = new AuthScope(host, 443, null, AuthPolicy.BASIC);
		asList.add(a);
		a = new AuthScope(host, 8443, null, AuthPolicy.BASIC);
		asList.add(a);

		return asList;
	}

	public static final void clearAllCredentials() {
		CredentialsProvider credsProvider = Collect.getInstance()
				.getCredentialsProvider();
		Log.i(t, "clearAllCredentials");
		credsProvider.clear();
	}

	public static final boolean hasCredentials(String userEmail, String host) {
		CredentialsProvider credsProvider = Collect.getInstance()
				.getCredentialsProvider();
		List<AuthScope> asList = buildAuthScopes(host);
		boolean hasCreds = true;
		for (AuthScope a : asList) {
			Credentials c = credsProvider.getCredentials(a);
			if (c == null) {
				hasCreds = false;
				continue;
			}
		}
		return hasCreds;
	}

	/**
	 * Remove all credentials for accessing the specified host.
	 *
	 * @param host
	 */
	public static final void clearHostCredentials(String host) {
		CredentialsProvider credsProvider = Collect.getInstance()
				.getCredentialsProvider();
		Log.i(t, "clearHostCredentials: " + host);
		List<AuthScope> asList = buildAuthScopes(host);
		for (AuthScope a : asList) {
			credsProvider.setCredentials(a, null);
		}
	}

	/**
	 * Remove all credentials for accessing the specified host and, if the
	 * username is not null or blank then add a (username, password) credential
	 * for accessing this host.
	 *
	 * @param username
	 * @param password
	 * @param host
	 */
	public static final void addCredentials(String username, String password,
			String host) {
		// to ensure that this is the only authentication available for this
		// host...
		clearHostCredentials(host);
		if (username != null && username.trim().length() != 0) {
			Log.i(t, "adding credential for host: " + host + " username:"
					+ username);
			Credentials c = new UsernamePasswordCredentials(username, password);
			addCredentials(c, host);
		}
	}

	private static final void addCredentials(Credentials c, String host) {
		CredentialsProvider credsProvider = Collect.getInstance()
				.getCredentialsProvider();
		List<AuthScope> asList = buildAuthScopes(host);
		for (AuthScope a : asList) {
			credsProvider.setCredentials(a, c);
		}
	}

	public static final void enablePreemptiveBasicAuth(
			HttpContext localContext, String host) {
		AuthCache ac = (AuthCache) localContext
				.getAttribute(ClientContext.AUTH_CACHE);
		HttpHost h = new HttpHost(host);
		if (ac == null) {
			ac = new BasicAuthCache();
			localContext.setAttribute(ClientContext.AUTH_CACHE, ac);
		}
		List<AuthScope> asList = buildAuthScopes(host);
		for (AuthScope a : asList) {
			if (AuthPolicy.BASIC.equals(a.getScheme())) {
				ac.put(h, new BasicScheme());
			}
		}
	}

	private static final void setOpenRosaHeaders(HttpRequest req) {
		req.setHeader(OPEN_ROSA_VERSION_HEADER, OPEN_ROSA_VERSION);
		GregorianCalendar g = new GregorianCalendar(TimeZone.getTimeZone("GMT"));
		g.setTime(new Date());
		req.setHeader(DATE_HEADER,
				DateFormat.format("E, dd MMM yyyy HH:mm:ss zz", g).toString());
	}

	public static final HttpHead createOpenRosaHttpHead(Uri u) {
		HttpHead req = new HttpHead(URI.create(u.toString()));
		setOpenRosaHeaders(req);
		return req;
	}

	public static final HttpGet createOpenRosaHttpGet(URI uri) {
		HttpGet req = new HttpGet();
		setOpenRosaHeaders(req);
		setGoogleHeaders(req);
		req.setURI(uri);
		return req;
	}

	public static final void setGoogleHeaders(HttpRequest req) {
		SharedPreferences settings =
                PreferenceManager.getDefaultSharedPreferences(Collect.getInstance()
                        .getApplication()
                        .getApplicationContext());
		String protocol = settings.getString(PreferencesActivity.KEY_PROTOCOL,
				Collect.getInstance().getApplication().getString(R.string.protocol_odk_default));

		// TODO:  this doesn't exist....
//		if ( protocol.equals(PreferencesActivity.PROTOCOL_GOOGLE) ) {
//	        String auth = settings.getString(PreferencesActivity.KEY_AUTH, "");
//			if ((auth != null) && (auth.length() > 0)) {
//				req.setHeader("Authorization", "GoogleLogin auth=" + auth);
//			}
//		}
	}

	public static final HttpPost createOpenRosaHttpPost(Uri u) {
		HttpPost req = new HttpPost(URI.create(u.toString()));
		setOpenRosaHeaders(req);
		setGoogleHeaders(req);
		return req;
	}

	/**
	 * Create an httpClient with connection timeouts and other parameters set.
	 * Save and reuse the connection manager across invocations (this is what
	 * requires synchronized access).
	 *
	 * @param timeout
	 * @return HttpClient properly configured.
	 */
	public static final synchronized HttpClient createHttpClient(int timeout) {
		// configure connection
		HttpParams params = new BasicHttpParams();
		HttpConnectionParams.setConnectionTimeout(params, timeout);
		HttpConnectionParams.setSoTimeout(params, 2 * timeout);
		// support redirecting to handle http: => https: transition
		HttpClientParams.setRedirecting(params, true);
		// support authenticating
		HttpClientParams.setAuthenticating(params, true);
		HttpClientParams.setCookiePolicy(params,
				CookiePolicy.BROWSER_COMPATIBILITY);
		// if possible, bias toward digest auth (may not be in 4.0 beta 2)
		List<String> authPref = new ArrayList<String>();
		authPref.add(AuthPolicy.DIGEST);
		authPref.add(AuthPolicy.BASIC);
		// does this work in Google's 4.0 beta 2 snapshot?
		params.setParameter(AuthPNames.TARGET_AUTH_PREF, authPref);
		params.setParameter(ClientPNames.MAX_REDIRECTS, 1);
		params.setParameter(ClientPNames.ALLOW_CIRCULAR_REDIRECTS, true);

		// setup client
		DefaultHttpClient httpclient;

		// reuse the connection manager across all clients this ODK Collect
		// creates.
		if (httpConnectionManager == null) {
			// let Apache stack create a connection manager.
			httpclient = new DefaultHttpClient(params);
			httpConnectionManager = httpclient.getConnectionManager();
		} else {
			// reuse the connection manager we already got.
			httpclient = new DefaultHttpClient(httpConnectionManager, params);
		}

		return httpclient;
	}

	/**
	 * Utility to ensure that the entity stream of a response is drained of
	 * bytes.
	 *
	 * @param response
	 */
	public static final void discardEntityBytes(HttpResponse response) {
		// may be a server that does not handle
		HttpEntity entity = response.getEntity();
		if (entity != null) {
			try {
				// have to read the stream in order to reuse the connection
				InputStream is = response.getEntity().getContent();
				// read to end of stream...
				final long count = 1024L;
				while (is.skip(count) == count)
					;
				is.close();
			} catch (IOException e) {
				e.printStackTrace();
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}

	/**
	 * Common method for returning a parsed xml document given a url and the
	 * http context and client objects involved in the web connection.
	 *
	 * @param urlString
	 * @param localContext
	 * @param httpclient
	 * @return
	 */
	public static DocumentFetchResult getXmlDocument(String urlString,
			HttpContext localContext, HttpClient httpclient) {
		URI u = null;
		try {
			URL url = new URL(urlString);
			u = url.toURI();
		} catch (Exception e) {
			e.printStackTrace();
			return new DocumentFetchResult(e.getLocalizedMessage()
			// + app.getString(R.string.while_accessing) + urlString);
					+ ("while accessing") + urlString, 0);
		}

		if (u.getHost() == null ) {
			return new DocumentFetchResult("Invalid server URL (no hostname): " + urlString, 0);
		}

		// if https then enable preemptive basic auth...
		if (u.getScheme().equals("https")) {
			enablePreemptiveBasicAuth(localContext, u.getHost());
		}

		// set up request...
		HttpGet req = WebUtils.createOpenRosaHttpGet(u);
		req.addHeader(WebUtils.ACCEPT_ENCODING_HEADER, WebUtils.GZIP_CONTENT_ENCODING);

		HttpResponse response = null;
		try {
			response = httpclient.execute(req, localContext);
			int statusCode = response.getStatusLine().getStatusCode();

			HttpEntity entity = response.getEntity();

			if (statusCode != HttpStatus.SC_OK) {
				WebUtils.discardEntityBytes(response);
            	if (statusCode == HttpStatus.SC_UNAUTHORIZED) {
            		// clear the cookies -- should not be necessary?
            		Collect.getInstance().getCookieStore().clear();
            	}
				String webError = response.getStatusLine().getReasonPhrase()
						+ " (" + statusCode + ")";

				return new DocumentFetchResult(u.toString()
						+ " responded with: " + webError, statusCode);
			}

			if (entity == null) {
				String error = "No entity body returned from: " + u.toString();
				Log.e(t, error);
				return new DocumentFetchResult(error, 0);
			}

			if (!entity.getContentType().getValue().toLowerCase(Locale.ENGLISH)
					.contains(WebUtils.HTTP_CONTENT_TYPE_TEXT_XML)) {
				WebUtils.discardEntityBytes(response);
				String error = "ContentType: "
						+ entity.getContentType().getValue()
						+ " returned from: "
						+ u.toString()
						+ " is not text/xml.  This is often caused a network proxy.  Do you need to login to your network?";
				Log.e(t, error);
				return new DocumentFetchResult(error, 0);
			}
			// parse response
			Document doc = null;
			try {
				InputStream is = null;
				InputStreamReader isr = null;
				try {
					is = entity.getContent();
	                Header contentEncoding = entity.getContentEncoding();
	                if ( contentEncoding != null && contentEncoding.getValue().equalsIgnoreCase(WebUtils.GZIP_CONTENT_ENCODING) ) {
	                	is = new GZIPInputStream(is);
	                }
					isr = new InputStreamReader(is, "UTF-8");
					doc = new Document();
					KXmlParser parser = new KXmlParser();
					parser.setInput(isr);
					parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES,
							true);
					doc.parse(parser);
					isr.close();
					isr = null;
				} finally {
					if (isr != null) {
						try {
							// ensure stream is consumed...
							final long count = 1024L;
							while (isr.skip(count) == count)
								;
						} catch (Exception e) {
							// no-op
						}
						try {
							isr.close();
						} catch (Exception e) {
							// no-op
						}
					}
					if (is != null) {
						try {
							is.close();
						} catch (Exception e) {
							// no-op
						}
					}
				}
			} catch (Exception e) {
				e.printStackTrace();
				String error = "Parsing failed with " + e.getMessage()
						+ "while accessing " + u.toString();
				Log.e(t, error);
				return new DocumentFetchResult(error, 0);
			}

			boolean isOR = false;
			Header[] fields = response
					.getHeaders(WebUtils.OPEN_ROSA_VERSION_HEADER);
			if (fields != null && fields.length >= 1) {
				isOR = true;
				boolean versionMatch = false;
				boolean first = true;
				StringBuilder b = new StringBuilder();
				for (Header h : fields) {
					if (WebUtils.OPEN_ROSA_VERSION.equals(h.getValue())) {
						versionMatch = true;
						break;
					}
					if (!first) {
						b.append("; ");
					}
					first = false;
					b.append(h.getValue());
				}
				if (!versionMatch) {
					Log.w(t, WebUtils.OPEN_ROSA_VERSION_HEADER
							+ " unrecognized version(s): " + b.toString());
				}
			}
			return new DocumentFetchResult(doc, isOR);
		} catch (Exception e) {
			clearHttpConnectionManager();
			e.printStackTrace();
			String cause;
			Throwable c = e;
			while (c.getCause() != null) {
				c = c.getCause();
			}
			cause = c.toString();
			String error = "Error: " + cause + " while accessing "
					+ u.toString();

			Log.w(t, error);
			return new DocumentFetchResult(error, 0);
		}
	}

	public static void clearHttpConnectionManager() {
		// If we get an unexpected exception, the safest thing is to close
		// all connections
		// so that if there is garbage on the connection we ensure it is
		// removed. This
		// is especially important if the connection times out.
		if ( httpConnectionManager != null ) {
			httpConnectionManager.shutdown();
			httpConnectionManager = null;
		}
	}
}

/*
 * Copyright (C) 2009 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.adapters;

import android.content.Context;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;

import org.odk.collect.android.logic.HierarchyElement;
import org.odk.collect.android.views.HierarchyElementView;

import java.util.ArrayList;
import java.util.List;

public class HierarchyListAdapter extends BaseAdapter {

    private Context mContext;
    private List<HierarchyElement> mItems = new ArrayList<HierarchyElement>();


    public HierarchyListAdapter(Context context) {
        mContext = context;
    }


    @Override
    public int getCount() {
        return mItems.size();
    }


    @Override
    public Object getItem(int position) {
        return mItems.get(position);
    }


    @Override
    public long getItemId(int position) {
        return position;
    }


    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        HierarchyElementView hev;
        if (convertView == null) {
            hev = new HierarchyElementView(mContext, mItems.get(position));
        } else {
            hev = (HierarchyElementView) convertView;
            hev.setPrimaryText(mItems.get(position).getPrimaryText());
            hev.setSecondaryText(mItems.get(position).getSecondaryText());
            hev.setIcon(mItems.get(position).getIcon());
            hev.setColor(mItems.get(position).getColor());
        }

        if (mItems.get(position).getSecondaryText() == null
                || mItems.get(position).getSecondaryText().equals("")) {
            hev.showSecondary(false);
        } else {
            hev.showSecondary(true);
        }
        return hev;

    }


    /**
     * Sets the list of items for this adapter to use.
     */
    public void setListItems(List<HierarchyElement> it) {
        mItems = it;
    }

}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.odk.collect.android.serializers;

import org.javarosa.core.model.data.DateTimeData;
import org.javarosa.xform.util.XFormAnswerDataSerializer;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.TimeZone;

/**
 * An {@link XFormAnswerDataSerializer} that correctly formats dates in the RFC3339 format. The
 * default XFormAnswerDataSerializer has logic to perform this task, but seems to improperly
 * determine the client's time zone offset. This class overrides this default behavior to ensure
 * that the local time is correctly represented by always representing timestamps in UTC, accounting
 * for the local time zone offset.
 */
public class XFormUtcDateAnswerDataSerializer extends XFormAnswerDataSerializer {
    private static final DateFormat RFC3339_UTC_FORMAT = new SimpleDateFormat(
            "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", Locale.US);

    static {
        RFC3339_UTC_FORMAT.setTimeZone(TimeZone.getTimeZone("UTC"));
    }

    @Override
    public Object serializeAnswerData(DateTimeData data) {
        return RFC3339_UTC_FORMAT.format((Date)data.getValue());
    }

    // TODO/generalize: Similar overrides for DateData and TimeData?
}

package org.odk.collect.android.model;

import android.os.Parcel;
import android.os.Parcelable;

import org.joda.time.DateTime;
import org.odk.collect.android.utilities.Parcels;

/** A Parcelable data object that specifies preset values for certain form fields. */
public class Preset implements Parcelable {

    public static final int UNSPECIFIED = -1;
    public static final int UNKNOWN = 1;
    public static final int YES = 2;
    public static final int NO = 3;

    public DateTime encounterDatetime;  // the preset value for encounter.encounter_datetime
    public String locationUuid;  // UUID of the preset value for encounter.location_id
    public String providerUuid;  // UUID of the preset value for encounter.provider_id
    public int pregnancy = UNSPECIFIED;
    public int ivAccess = UNSPECIFIED;
    public String targetGroup;  // text of a section heading in the form to scroll to

    public Preset() {}

    public Preset(Parcel in) {
        encounterDatetime = Parcels.readNullableDateTime(in);
        locationUuid = Parcels.readNullableString(in);
        providerUuid = Parcels.readNullableString(in);
        pregnancy = in.readInt();
        ivAccess = in.readInt();
        targetGroup = Parcels.readNullableString(in);
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        Parcels.writeNullableDateTime(dest, encounterDatetime);
        Parcels.writeNullableString(dest, locationUuid);
        Parcels.writeNullableString(dest, providerUuid);
        dest.writeInt(pregnancy);
        dest.writeInt(ivAccess);
        Parcels.writeNullableString(dest, targetGroup);
    }

    @SuppressWarnings("unused")
    public static final Parcelable.Creator<Preset> CREATOR =
            new Parcelable.Creator<Preset>() {

        @Override
        public Preset createFromParcel(Parcel in) {
            return new Preset(in);
        }

        @Override
        public Preset[] newArray(int size) {
            return new Preset[size];
        }
    };
}

package org.odk.collect.android.model;

import android.os.Parcel;
import android.os.Parcelable;

/**
 * Patient details.
 */
public final class Patient implements Parcelable {

    // TODO: Document this field.
    public final String uuid;
    // TODO: Document this field.
    public final String id;
    public final String givenName;
    public final String familyName;

    public Patient(String uuid, String id, String givenName, String familyName) {
        this.uuid = uuid;
        this.id = id;
        this.givenName = givenName;
        this.familyName = familyName;
    }

    protected Patient(Parcel in) {
        uuid = in.readString();
        id = in.readString();
        givenName = in.readString();
        familyName = in.readString();
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(uuid);
        dest.writeString(id);
        dest.writeString(givenName);
        dest.writeString(familyName);
    }

    public static final Parcelable.Creator<Patient> CREATOR = new Parcelable.Creator<Patient>() {
        @Override
        public Patient createFromParcel(Parcel in) {
            return new Patient(in);
        }

        @Override
        public Patient[] newArray(int size) {
            return new Patient[size];
        }
    };
}

/*
 * Copyright (C) 2013 Nafundi
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.activities;

import android.app.Activity;
import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.os.Bundle;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;

public class BearingActivity extends Activity implements SensorEventListener {
    private ProgressDialog mBearingDialog;

    private SensorManager mSensorManager;
    private Sensor accelerometer;
    private Sensor magnetometer;

    private static float[] mAccelerometer = null;
    private static float[] mGeomagnetic = null;

    private String mBearing = null;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setTitle(getString(R.string.app_name) + " > " + getString(R.string.get_bearing));

        mSensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
        accelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
        magnetometer = mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);

        setupBearingDialog();
    }

    @Override
    protected void onPause() {
        super.onPause();

        mSensorManager.unregisterListener(this, accelerometer);
        mSensorManager.unregisterListener(this, magnetometer);

        if (mBearingDialog != null && mBearingDialog.isShowing())
            mBearingDialog.dismiss();
    }

    @Override
    protected void onResume() {
        super.onResume();
        mSensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_GAME);
        mSensorManager.registerListener(this, magnetometer, SensorManager.SENSOR_DELAY_GAME);
        mBearingDialog.show();
    }

    @Override
    protected void onStart() {
        super.onStart();
        Collect.getInstance().getActivityLogger().logOnStart(this);
    }

    @Override
    protected void onStop() {
        Collect.getInstance().getActivityLogger().logOnStop(this);
        super.onStop();
    }

    /**
     * Sets up the look and actions for the progress dialog while the compass is
     * searching.
     */
    private void setupBearingDialog() {
        Collect.getInstance().getActivityLogger()
                .logInstanceAction(this, "setupBearingDialog", "show");
        // dialog displayed while fetching bearing
        mBearingDialog = new ProgressDialog(this);
        DialogInterface.OnClickListener geopointButtonListener =
                new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        switch (which) {
                            case DialogInterface.BUTTON_POSITIVE:
                                Collect.getInstance().getActivityLogger()
                                        .logInstanceAction(this, "acceptBearing", "OK");
                                returnBearing();
                                break;
                            case DialogInterface.BUTTON_NEGATIVE:
                                Collect.getInstance().getActivityLogger()
                                        .logInstanceAction(this, "cancelBearing", "cancel");
                                mBearing = null;
                                finish();
                                break;
                        }
                    }
                };

        // back button doesn't cancel
        mBearingDialog.setCancelable(false);
        mBearingDialog.setIndeterminate(true);
        mBearingDialog.setIcon(android.R.drawable.ic_dialog_info);
        mBearingDialog.setTitle(getString(R.string.getting_bearing));
        mBearingDialog.setMessage(getString(R.string.please_wait_long));
        mBearingDialog.setButton(DialogInterface.BUTTON_POSITIVE, getString(R.string.accept_bearing),
                geopointButtonListener);
        mBearingDialog.setButton(DialogInterface.BUTTON_NEGATIVE, getString(R.string.cancel_location),
                geopointButtonListener);
    }

    private void returnBearing() {
        if (mBearing != null) {
            Intent i = new Intent();
            i.putExtra(
                    FormEntryActivity.BEARING_RESULT, mBearing);
            setResult(RESULT_OK, i);
        }
        finish();
    }

    @Override
    public void onAccuracyChanged(Sensor arg0, int arg1) {
        // TODO Auto-generated method stub

    }

    @Override
    public void onSensorChanged(SensorEvent event) {
        // onSensorChanged gets called for each sensor so we have to remember
        // the values
        if (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) {
            mAccelerometer = event.values;
        }

        if (event.sensor.getType() == Sensor.TYPE_MAGNETIC_FIELD) {
            mGeomagnetic = event.values;
        }

        if (mAccelerometer != null && mGeomagnetic != null) {
            float R[] = new float[9];
            float I[] = new float[9];
            boolean success = SensorManager.getRotationMatrix(R, I, mAccelerometer, mGeomagnetic);

            if (success) {
                float orientation[] = new float[3];
                SensorManager.getOrientation(R, orientation);
                // at this point, orientation contains the azimuth(direction),
                // pitch and roll values.
                double azimuth = 180 * orientation[0] / Math.PI;
                // double pitch = 180 * orientation[1] / Math.PI;
                // double roll = 180 * orientation[2] / Math.PI;
                double degrees = normalizeDegree(azimuth);
                mBearing = String.format("%.3f", degrees);
                String dir = "N";
                if ((degrees > 0 && degrees <= 22.5) || degrees > 337.5) {
                    dir = "N";
                } else if (degrees > 22.5 && degrees <= 67.5) {
                    dir = "NE";
                } else if (degrees > 67.5 && degrees <= 112.5) {
                    dir = "E";
                } else if (degrees > 112.5 && degrees <= 157.5) {
                    dir = "SE";
                } else if (degrees > 157.5 && degrees <= 222.5) {
                    dir = "S";
                } else if (degrees > 222.5 && degrees <= 247.5) {
                    dir = "SW";
                } else if (degrees > 247.5 && degrees <= 292.5) {
                    dir = "W";
                } else if (degrees > 292.5 && degrees <= 337.5) {
                    dir = "NW";
                }
                mBearingDialog.setMessage("Dir: " + dir + " Bearing: " + mBearing);

            }
        }
    }

    private double normalizeDegree(double value) {
        if (value >= 0.0f && value <= 180.0f) {
            return value;
        } else {
            return 180 + (180 + value);
        }
    }

}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.activities;

import android.app.AlertDialog;
import android.app.ListActivity;
import android.content.DialogInterface;
import android.database.Cursor;
import android.os.AsyncTask;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.ListView;
import android.widget.SimpleCursorAdapter;
import android.widget.Toast;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.listeners.DeleteInstancesListener;
import org.odk.collect.android.provider.InstanceProviderAPI.InstanceColumns;
import org.odk.collect.android.tasks.DeleteInstancesTask;

import java.util.ArrayList;

/**
 * Responsible for displaying and deleting all the valid forms in the forms
 * directory.
 *
 * @author Carl Hartung (carlhartung@gmail.com)
 * @author Yaw Anokwa (yanokwa@gmail.com)
 */
public class DataManagerList extends ListActivity implements
		DeleteInstancesListener {
	private static final String t = "DataManagerList";
	private AlertDialog mAlertDialog;
	private Button mDeleteButton;
	private Button mToggleButton;

	private SimpleCursorAdapter mInstances;
	private ArrayList<Long> mSelected = new ArrayList<Long>();

	DeleteInstancesTask mDeleteInstancesTask = null;

	private static final String SELECTED = "selected";

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.data_manage_list);

		mDeleteButton = (Button) findViewById(R.id.delete_button);
		mDeleteButton.setText(getString(R.string.delete_file));
		mDeleteButton.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
		    	Collect.getInstance().getActivityLogger().logAction(this, "deleteButton", Integer.toString(mSelected.size()));
				if (mSelected.size() > 0) {
					createDeleteInstancesDialog();
				} else {
					Toast.makeText(getApplicationContext(),
							R.string.noselect_error, Toast.LENGTH_SHORT).show();
				}
			}
		});

		mToggleButton = (Button) findViewById(R.id.toggle_button);
        mToggleButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                boolean checkAll = false;
                // if everything is checked, uncheck
                if (mSelected.size() == mInstances.getCount()) {
                    checkAll = false;
                    mSelected.clear();
                    mDeleteButton.setEnabled(false);
                } else {
                    // otherwise check everything
                    checkAll = true;
                    for (int pos = 0; pos < DataManagerList.this.getListView().getCount(); pos++) {
                        Long id = getListAdapter().getItemId(pos);
                        if (!mSelected.contains(id)) {
                            mSelected.add(id);
                        }
                    }
                    mDeleteButton.setEnabled(true);
                }
                for (int pos = 0; pos < DataManagerList.this.getListView().getCount(); pos++) {
                    DataManagerList.this.getListView().setItemChecked(pos, checkAll);
                }
            }
        });

		Cursor c = managedQuery(InstanceColumns.CONTENT_URI, null, null, null,
				InstanceColumns.DISPLAY_NAME + " ASC");

		String[] data = new String[] { InstanceColumns.DISPLAY_NAME,
				InstanceColumns.DISPLAY_SUBTEXT };
		int[] view = new int[] { R.id.text1, R.id.text2 };

		mInstances = new SimpleCursorAdapter(this,
				R.layout.two_item_multiple_choice, c, data, view);
		setListAdapter(mInstances);
		getListView().setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
		getListView().setItemsCanFocus(false);
		mDeleteButton.setEnabled(false);

		mDeleteInstancesTask = (DeleteInstancesTask) getLastNonConfigurationInstance();
	}

    @Override
    protected void onStart() {
    	super.onStart();
		Collect.getInstance().getActivityLogger().logOnStart(this);
    }

    @Override
    protected void onStop() {
		Collect.getInstance().getActivityLogger().logOnStop(this);
    	super.onStop();
    }

	@Override
	public Object onRetainNonConfigurationInstance() {
		// pass the tasks on orientation-change restart
		return mDeleteInstancesTask;
	}

	@Override
	protected void onRestoreInstanceState(Bundle savedInstanceState) {
		super.onRestoreInstanceState(savedInstanceState);
		long[] selectedArray = savedInstanceState.getLongArray(SELECTED);
		for (int i = 0; i < selectedArray.length; i++) {
			mSelected.add(selectedArray[i]);
		}
		mDeleteButton.setEnabled(selectedArray.length > 0);
	}

	@Override
	protected void onSaveInstanceState(Bundle outState) {
		super.onSaveInstanceState(outState);
		long[] selectedArray = new long[mSelected.size()];
		for (int i = 0; i < mSelected.size(); i++) {
			selectedArray[i] = mSelected.get(i);
		}
		outState.putLongArray(SELECTED, selectedArray);
	}

	@Override
	protected void onResume() {
		// hook up to receive completion events
		if (mDeleteInstancesTask != null) {
			mDeleteInstancesTask.setDeleteListener(this);
		}
		super.onResume();
		// async task may have completed while we were reorienting...
		if (mDeleteInstancesTask != null
				&& mDeleteInstancesTask.getStatus() == AsyncTask.Status.FINISHED) {
			deleteComplete(mDeleteInstancesTask.getDeleteCount());
		}
	}

	@Override
	protected void onPause() {
		if (mDeleteInstancesTask != null ) {
			mDeleteInstancesTask.setDeleteListener(null);
		}
		if (mAlertDialog != null && mAlertDialog.isShowing()) {
			mAlertDialog.dismiss();
		}
		super.onPause();
	}

	/**
	 * Create the instance delete dialog
	 */
	private void createDeleteInstancesDialog() {
        Collect.getInstance().getActivityLogger().logAction(this, "createDeleteInstancesDialog", "show");

		mAlertDialog = new AlertDialog.Builder(this).create();
		mAlertDialog.setTitle(getString(R.string.delete_file));
		mAlertDialog.setMessage(getString(R.string.delete_confirm,
				mSelected.size()));
		DialogInterface.OnClickListener dialogYesNoListener = new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int i) {
				switch (i) {
				case DialogInterface.BUTTON_POSITIVE: // delete
			    	Collect.getInstance().getActivityLogger().logAction(this, "createDeleteInstancesDialog", "delete");
					deleteSelectedInstances();
					break;
				case DialogInterface. BUTTON_NEGATIVE: // do nothing
			    	Collect.getInstance().getActivityLogger().logAction(this, "createDeleteInstancesDialog", "cancel");
					break;
				}
			}
		};
		mAlertDialog.setCancelable(false);
		mAlertDialog.setButton(getString(R.string.delete_yes),
				dialogYesNoListener);
		mAlertDialog.setButton2(getString(R.string.delete_no),
				dialogYesNoListener);
		mAlertDialog.show();
	}

	/**
	 * Deletes the selected files. Content provider handles removing the files
	 * from the filesystem.
	 */
	private void deleteSelectedInstances() {
		if (mDeleteInstancesTask == null) {
			mDeleteInstancesTask = new DeleteInstancesTask();
			mDeleteInstancesTask.setContentResolver(getContentResolver());
			mDeleteInstancesTask.setDeleteListener(this);
			mDeleteInstancesTask.execute(mSelected.toArray(new Long[mSelected
					.size()]));
		} else {
			Toast.makeText(this, getString(R.string.file_delete_in_progress),
					Toast.LENGTH_LONG).show();
		}
	}

	@Override
	protected void onListItemClick(ListView l, View v, int position, long id) {
		super.onListItemClick(l, v, position, id);

		// get row id from db
		Cursor c = (Cursor) getListAdapter().getItem(position);
		long k = c.getLong(c.getColumnIndex(InstanceColumns._ID));

		// add/remove from selected list
		if (mSelected.contains(k))
			mSelected.remove(k);
		else
			mSelected.add(k);

		Collect.getInstance().getActivityLogger().logAction(this, "onListItemClick", Long.toString(k));

		mDeleteButton.setEnabled(!(mSelected.size() == 0));
	}

	@Override
	public void deleteComplete(int deletedInstances) {
		Log.i(t, "Delete instances complete");
        Collect.getInstance().getActivityLogger().logAction(this, "deleteComplete", Integer.toString(deletedInstances));
		if (deletedInstances == mSelected.size()) {
			// all deletes were successful
			Toast.makeText(this,
					getString(R.string.file_deleted_ok, deletedInstances),
					Toast.LENGTH_SHORT).show();
		} else {
			// had some failures
			Log.e(t, "Failed to delete "
					+ (mSelected.size() - deletedInstances) + " instances");
			Toast.makeText(
					this,
					getString(R.string.file_deleted_error, mSelected.size()
							- deletedInstances, mSelected.size()),
					Toast.LENGTH_LONG).show();
		}
		mDeleteInstancesTask = null;
		mSelected.clear();
		getListView().clearChoices(); // doesn't unset the checkboxes
		for ( int i = 0 ; i < getListView().getCount() ; ++i ) {
			getListView().setItemChecked(i, false);
		}
		mDeleteButton.setEnabled(false);
	}
}

/*
 * Copyright (C) 2011 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.activities;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Bundle;
import android.preference.PreferenceManager;
import android.view.View;
import android.view.Window;
import android.widget.ImageView;
import android.widget.LinearLayout;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.preferences.PreferencesActivity;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class SplashScreenActivity extends Activity {

    private static final int mSplashTimeout = 2000; // milliseconds
    private static final boolean EXIT = true;

    private int mImageMaxWidth;
    private AlertDialog mAlertDialog;


    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // must be at the beginning of any activity that can be called from an external intent
        try {
            Collect.getInstance().createODKDirs();
        } catch (RuntimeException e) {
            createErrorDialog(e.getMessage(), EXIT);
            return;
        }

        mImageMaxWidth = getWindowManager().getDefaultDisplay().getWidth();

        // this splash screen should be a blank slate
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        setContentView(R.layout.splash_screen);

        // get the shared preferences object
        SharedPreferences mSharedPreferences = PreferenceManager.getDefaultSharedPreferences(this);
        Editor editor = mSharedPreferences.edit();

        // get the package info object with version number
        PackageInfo packageInfo = null;
        try {
            packageInfo =
                getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_META_DATA);
        } catch (NameNotFoundException e) {
            e.printStackTrace();
        }

        boolean firstRun = mSharedPreferences.getBoolean(PreferencesActivity.KEY_FIRST_RUN, true);
        boolean showSplash =
            mSharedPreferences.getBoolean(PreferencesActivity.KEY_SHOW_SPLASH, false);
        String splashPath =
            mSharedPreferences.getString(PreferencesActivity.KEY_SPLASH_PATH,
                getString(R.string.default_splash_path));

        // if you've increased version code, then update the version number and set firstRun to true
        if (mSharedPreferences.getLong(PreferencesActivity.KEY_LAST_VERSION, 0) < packageInfo.versionCode) {
            editor.putLong(PreferencesActivity.KEY_LAST_VERSION, packageInfo.versionCode);
            editor.commit();

            firstRun = true;
        }

        // do all the first run things
        if (firstRun || showSplash) {
            editor.putBoolean(PreferencesActivity.KEY_FIRST_RUN, false);
            editor.commit();
            startSplashScreen(splashPath);
        } else {
            endSplashScreen();
        }

    }


    private void endSplashScreen() {

        // launch new activity and close splash screen
        startActivity(new Intent(SplashScreenActivity.this, MainMenuActivity.class));
        finish();
    }


    // decodes image and scales it to reduce memory consumption
    private Bitmap decodeFile(File f) {
        Bitmap b = null;
        try {
            // Decode image size
            BitmapFactory.Options o = new BitmapFactory.Options();
            o.inJustDecodeBounds = true;

            FileInputStream fis = new FileInputStream(f);
            BitmapFactory.decodeStream(fis, null, o);
            try {
                fis.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

            int scale = 1;
            if (o.outHeight > mImageMaxWidth || o.outWidth > mImageMaxWidth) {
                scale =
                    (int) Math.pow(
                        2,
                        (int) Math.round(Math.log(mImageMaxWidth
                                / (double) Math.max(o.outHeight, o.outWidth))
                                / Math.log(0.5)));
            }

            // Decode with inSampleSize
            BitmapFactory.Options o2 = new BitmapFactory.Options();
            o2.inSampleSize = scale;
            fis = new FileInputStream(f);
            b = BitmapFactory.decodeStream(fis, null, o2);
            try {
                fis.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        } catch (FileNotFoundException e) {
        }
        return b;
    }


    private void startSplashScreen(String path) {

        // add items to the splash screen here. makes things less distracting.
        ImageView iv = (ImageView) findViewById(R.id.splash);
        LinearLayout ll = (LinearLayout) findViewById(R.id.splash_default);

        File f = new File(path);
        if (f.exists()) {
            iv.setImageBitmap(decodeFile(f));
            ll.setVisibility(View.GONE);
            iv.setVisibility(View.VISIBLE);
        }

        // create a thread that counts up to the timeout
        Thread t = new Thread() {
            int count = 0;


            @Override
            public void run() {
                try {
                    super.run();
                    while (count < mSplashTimeout) {
                        sleep(100);
                        count += 100;
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    endSplashScreen();
                }
            }
        };
        t.start();
    }


    private void createErrorDialog(String errorMsg, final boolean shouldExit) {
	    Collect.getInstance().getActivityLogger().logAction(this, "createErrorDialog", "show");
        mAlertDialog = new AlertDialog.Builder(this).create();
        mAlertDialog.setIcon(android.R.drawable.ic_dialog_info);
        mAlertDialog.setMessage(errorMsg);
        DialogInterface.OnClickListener errorListener = new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int i) {
                switch (i) {
                    case DialogInterface.BUTTON_POSITIVE:
                	    Collect.getInstance().getActivityLogger().logAction(this, "createErrorDialog", "OK");
                        if (shouldExit) {
                            finish();
                        }
                        break;
                }
            }
        };
        mAlertDialog.setCancelable(false);
        mAlertDialog.setButton(getString(R.string.ok), errorListener);
        mAlertDialog.show();
    }

    @Override
    protected void onStart() {
    	super.onStart();
		Collect.getInstance().getActivityLogger().logOnStart(this);
    }

    @Override
    protected void onStop() {
		Collect.getInstance().getActivityLogger().logOnStop(this);
    	super.onStop();
    }

}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.activities;

import android.app.AlertDialog;
import android.app.ListActivity;
import android.content.DialogInterface;
import android.database.Cursor;
import android.os.AsyncTask;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.ListView;
import android.widget.SimpleCursorAdapter;
import android.widget.TextView;
import android.widget.Toast;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.listeners.DeleteFormsListener;
import org.odk.collect.android.listeners.DiskSyncListener;
import org.odk.collect.android.provider.FormsProviderAPI.FormsColumns;
import org.odk.collect.android.tasks.DeleteFormsTask;
import org.odk.collect.android.tasks.DiskSyncTask;
import org.odk.collect.android.utilities.VersionHidingCursorAdapter;

import java.util.ArrayList;

/**
 * Responsible for displaying and deleting all the valid forms in the forms
 * directory.
 *
 * @author Carl Hartung (carlhartung@gmail.com)
 * @author Yaw Anokwa (yanokwa@gmail.com)
 */
public class FormManagerList extends ListActivity implements DiskSyncListener,
		DeleteFormsListener {
	private static String t = "FormManagerList";
	private static final String SELECTED = "selected";
	private static final String syncMsgKey = "syncmsgkey";

	private AlertDialog mAlertDialog;
	private Button mDeleteButton;
	private Button mToggleButton;

	private SimpleCursorAdapter mInstances;
	private ArrayList<Long> mSelected = new ArrayList<Long>();

	static class BackgroundTasks {
		DiskSyncTask mDiskSyncTask = null;
		DeleteFormsTask mDeleteFormsTask = null;

		BackgroundTasks() {
		};
	}

	BackgroundTasks mBackgroundTasks; // handed across orientation changes

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.form_manage_list);

		mDeleteButton = (Button) findViewById(R.id.delete_button);
		mDeleteButton.setText(getString(R.string.delete_file));
		mDeleteButton.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
		    	Collect.getInstance().getActivityLogger().logAction(this, "deleteButton", Integer.toString(mSelected.size()));

				if (mSelected.size() > 0) {
					createDeleteFormsDialog();
				} else {
					Toast.makeText(getApplicationContext(),
							R.string.noselect_error, Toast.LENGTH_SHORT).show();
				}
			}
		});

		mToggleButton = (Button) findViewById(R.id.toggle_button);
        mToggleButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                boolean checkAll = false;
                // if everything is checked, uncheck
                if (mSelected.size() == mInstances.getCount()) {
                    checkAll = false;
                    mSelected.clear();
                    mDeleteButton.setEnabled(false);
                } else {
                    // otherwise check everything
                    checkAll = true;
                    for (int pos = 0; pos < FormManagerList.this.getListView().getCount(); pos++) {
                        Long id = getListAdapter().getItemId(pos);
                        if (!mSelected.contains(id)) {
                            mSelected.add(id);
                        }
                    }
                    mDeleteButton.setEnabled(true);
                }
                for (int pos = 0; pos < FormManagerList.this.getListView().getCount(); pos++) {
                    FormManagerList.this.getListView().setItemChecked(pos, checkAll);
                }
            }
        });

		String sortOrder = FormsColumns.DISPLAY_NAME + " ASC, " + FormsColumns.JR_VERSION + " DESC";
        Cursor c = managedQuery(FormsColumns.CONTENT_URI, null, null, null, sortOrder);

		String[] data = new String[] { FormsColumns.DISPLAY_NAME,
				FormsColumns.DISPLAY_SUBTEXT, FormsColumns.JR_VERSION };
		int[] view = new int[] { R.id.text1, R.id.text2, R.id.text3 };

		// render total instance view
		mInstances = new VersionHidingCursorAdapter(FormsColumns.JR_VERSION, this,
				R.layout.two_item_multiple_choice, c, data, view);
		setListAdapter(mInstances);
		getListView().setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
		getListView().setItemsCanFocus(false);
		mDeleteButton.setEnabled(!(mSelected.size() == 0));

		if (savedInstanceState != null
				&& savedInstanceState.containsKey(syncMsgKey)) {
			TextView tv = (TextView) findViewById(R.id.status_text);
			tv.setText(savedInstanceState.getString(syncMsgKey));
		}

		mBackgroundTasks = (BackgroundTasks) getLastNonConfigurationInstance();
		if (mBackgroundTasks == null) {
			mBackgroundTasks = new BackgroundTasks();
			mBackgroundTasks.mDiskSyncTask = new DiskSyncTask();
			mBackgroundTasks.mDiskSyncTask.setDiskSyncListener(this);
			mBackgroundTasks.mDiskSyncTask.execute((Void[]) null);
		}
	}

    @Override
    protected void onStart() {
    	super.onStart();
		Collect.getInstance().getActivityLogger().logOnStart(this);
    }

    @Override
    protected void onStop() {
		Collect.getInstance().getActivityLogger().logOnStop(this);
    	super.onStop();
    }

	@Override
	public Object onRetainNonConfigurationInstance() {
		// pass the tasks on restart
		return mBackgroundTasks;
	}

	@Override
	protected void onRestoreInstanceState(Bundle savedInstanceState) {
		super.onRestoreInstanceState(savedInstanceState);
		long[] selectedArray = savedInstanceState.getLongArray(SELECTED);
		for (int i = 0; i < selectedArray.length; i++) {
			mSelected.add(selectedArray[i]);
		}
		mDeleteButton.setEnabled(selectedArray.length > 0);
	}

	@Override
	protected void onSaveInstanceState(Bundle outState) {
		super.onSaveInstanceState(outState);
		long[] selectedArray = new long[mSelected.size()];
		for (int i = 0; i < mSelected.size(); i++) {
			selectedArray[i] = mSelected.get(i);
		}
		outState.putLongArray(SELECTED, selectedArray);
		TextView tv = (TextView) findViewById(R.id.status_text);
		outState.putString(syncMsgKey, tv.getText().toString());
	}

	@Override
	protected void onResume() {
		// hook up to receive completion events
		mBackgroundTasks.mDiskSyncTask.setDiskSyncListener(this);
		if (mBackgroundTasks.mDeleteFormsTask != null) {
			mBackgroundTasks.mDeleteFormsTask.setDeleteListener(this);
		}
		super.onResume();
		// async task may have completed while we were reorienting...
		if (mBackgroundTasks.mDiskSyncTask.getStatus() == AsyncTask.Status.FINISHED) {
			SyncComplete(mBackgroundTasks.mDiskSyncTask.getStatusMessage());
		}
		if (mBackgroundTasks.mDeleteFormsTask != null
				&& mBackgroundTasks.mDeleteFormsTask.getStatus() == AsyncTask.Status.FINISHED) {
			deleteComplete(mBackgroundTasks.mDeleteFormsTask.getDeleteCount());
		}
	}

	@Override
	protected void onPause() {
		mBackgroundTasks.mDiskSyncTask.setDiskSyncListener(null);
		if (mBackgroundTasks.mDeleteFormsTask != null ) {
			mBackgroundTasks.mDeleteFormsTask.setDeleteListener(null);
		}
		if (mAlertDialog != null && mAlertDialog.isShowing()) {
			mAlertDialog.dismiss();
		}

		super.onPause();
	}

	/**
	 * Create the form delete dialog
	 */
	private void createDeleteFormsDialog() {
    	Collect.getInstance().getActivityLogger().logAction(this, "createDeleteFormsDialog", "show");
		mAlertDialog = new AlertDialog.Builder(this).create();
		mAlertDialog.setTitle(getString(R.string.delete_file));
		mAlertDialog.setMessage(getString(R.string.delete_confirm,
				mSelected.size()));
		DialogInterface.OnClickListener dialogYesNoListener = new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int i) {
				switch (i) {
				case DialogInterface.BUTTON_POSITIVE: // delete
			    	Collect.getInstance().getActivityLogger().logAction(this, "createDeleteFormsDialog", "delete");
					deleteSelectedForms();
					break;
				case DialogInterface. BUTTON_NEGATIVE: // do nothing
			    	Collect.getInstance().getActivityLogger().logAction(this, "createDeleteFormsDialog", "cancel");
					break;
				}
			}
		};
		mAlertDialog.setCancelable(false);
		mAlertDialog.setButton(getString(R.string.delete_yes),
				dialogYesNoListener);
		mAlertDialog.setButton2(getString(R.string.delete_no),
				dialogYesNoListener);
		mAlertDialog.show();
	}

	/**
	 * Deletes the selected files.First from the database then from the file
	 * system
	 */
	private void deleteSelectedForms() {
		// only start if no other task is running
		if (mBackgroundTasks.mDeleteFormsTask == null) {
			mBackgroundTasks.mDeleteFormsTask = new DeleteFormsTask();
			mBackgroundTasks.mDeleteFormsTask
					.setContentResolver(getContentResolver());
			mBackgroundTasks.mDeleteFormsTask.setDeleteListener(this);
			mBackgroundTasks.mDeleteFormsTask.execute(mSelected
					.toArray(new Long[mSelected.size()]));
		} else {
			Toast.makeText(this, getString(R.string.file_delete_in_progress),
					Toast.LENGTH_LONG).show();
		}
	}

	@Override
	protected void onListItemClick(ListView l, View v, int position, long id) {
		super.onListItemClick(l, v, position, id);

		// get row id from db
		Cursor c = (Cursor) getListAdapter().getItem(position);
		long k = c.getLong(c.getColumnIndex(FormsColumns._ID));

		// add/remove from selected list
		if (mSelected.contains(k))
			mSelected.remove(k);
		else
			mSelected.add(k);

		Collect.getInstance().getActivityLogger().logAction(this, "onListItemClick", Long.toString(k));

		mDeleteButton.setEnabled(!(mSelected.size() == 0));

	}

	@Override
	public void SyncComplete(String result) {
		Log.i(t, "Disk scan complete");
		TextView tv = (TextView) findViewById(R.id.status_text);
		tv.setText(result);
	}

	@Override
	public void deleteComplete(int deletedForms) {
		Log.i(t, "Delete forms complete");
        Collect.getInstance().getActivityLogger().logAction(this, "deleteComplete", Integer.toString(deletedForms));
		if (deletedForms == mSelected.size()) {
			// all deletes were successful
			Toast.makeText(getApplicationContext(),
					getString(R.string.file_deleted_ok, deletedForms),
					Toast.LENGTH_SHORT).show();
		} else {
			// had some failures
			Log.e(t, "Failed to delete " + (mSelected.size() - deletedForms)
					+ " forms");
			Toast.makeText(
					getApplicationContext(),
					getString(R.string.file_deleted_error, mSelected.size()
							- deletedForms, mSelected.size()),
					Toast.LENGTH_LONG).show();
		}
		mBackgroundTasks.mDeleteFormsTask = null;
		mSelected.clear();
		getListView().clearChoices(); // doesn't unset the checkboxes
		for ( int i = 0 ; i < getListView().getCount() ; ++i ) {
			getListView().setItemChecked(i, false);
		}
		mDeleteButton.setEnabled(false);
	}
}


package org.odk.collect.android.activities;

import android.app.Activity;
import android.graphics.Typeface;
import android.os.Bundle;
import android.util.TypedValue;
import android.widget.TextView;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;

public class NotificationActivity extends Activity {

    public final static String NOTIFICATION_KEY = "message";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.notification_layout);

        String note = this.getIntent().getStringExtra(NOTIFICATION_KEY);
        if (note == null) {
            note = getString(R.string.notification_error);
        }

        TextView notificationText = (TextView)findViewById(R.id.notification);
        notificationText.setTextSize(TypedValue.COMPLEX_UNIT_DIP, Collect.getQuestionFontsize());
        notificationText.setTypeface(null, Typeface.BOLD);
        notificationText.setPadding(0, 0, 0, 7);
        notificationText.setText(note);
    }

}

/*
 * Copyright (C) 2012 University of Washington
 * Copyright (C) 2007 The Android Open Source Project
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.activities;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.pm.ActivityInfo;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.PorterDuff;
import android.net.Uri;
import android.os.Bundle;
import android.util.Log;
import android.view.Display;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.Window;
import android.view.WindowManager;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.RelativeLayout;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.utilities.ColorPickerDialog;
import org.odk.collect.android.utilities.FileUtils;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;

/**
 * Modified from the FingerPaint example found in The Android Open Source
 * Project.
 * 
 * @author BehrAtherton@gmail.com
 * 
 */
public class DrawActivity extends Activity {
	public static final String t = "DrawActivity";
	
	public static final String OPTION = "option";
	public static final String OPTION_SIGNATURE = "signature";
	public static final String OPTION_ANNOTATE = "annotate";
	public static final String OPTION_DRAW = "draw";
	public static final String REF_IMAGE = "refImage";
	public static final String EXTRA_OUTPUT = android.provider.MediaStore.EXTRA_OUTPUT;
	public static final String SAVEPOINT_IMAGE = "savepointImage"; // during
																	// restore

	// incoming options...
	private String loadOption = null;
	private File refImage = null;
	private File output = null;
	private File savepointImage = null;

	private Button btnDrawColor;
	private Button btnFinished;
	private Button btnReset;
	private Button btnCancel;
	private Paint paint;
	private Paint pointPaint;
	private int currentColor = 0xFF000000;
	private DrawView drawView;
	private String alertTitleString;
	private AlertDialog alertDialog;

	@Override
	protected void onSaveInstanceState(Bundle outState) {
		super.onSaveInstanceState(outState);
		try {
			saveFile(savepointImage);
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		if ( savepointImage.exists() ) {
			outState.putString(SAVEPOINT_IMAGE, savepointImage.getAbsolutePath());
		}
	}

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);

		requestWindowFeature(Window.FEATURE_NO_TITLE);
		getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
				WindowManager.LayoutParams.FLAG_FULLSCREEN);

		Bundle extras = getIntent().getExtras();

		if (extras == null) {
			loadOption = OPTION_DRAW;
			refImage = null;
			savepointImage = new File(Collect.getInstance().getTmpDrawFilePath());
			savepointImage.delete();
			output = new File(Collect.getInstance().getTmpFilePath());
		} else {
			loadOption = extras.getString(OPTION);
			if (loadOption == null) {
				loadOption = OPTION_DRAW;
			}
			// refImage can also be present if resuming a drawing
			Uri uri = (Uri) extras.get(REF_IMAGE);
			if (uri != null) {
				refImage = new File(uri.getPath());
			}
			String savepoint = extras.getString(SAVEPOINT_IMAGE);
			if (savepoint != null) {
				savepointImage = new File(savepoint);
				if (!savepointImage.exists() && refImage != null
						&& refImage.exists()) {
					FileUtils.copyFile(refImage, savepointImage);
				}
			} else {
				savepointImage = new File(Collect.getInstance().getTmpDrawFilePath());
				savepointImage.delete();
				if (refImage != null && refImage.exists()) {
					FileUtils.copyFile(refImage, savepointImage);
				}
			}
			uri = (Uri) extras.get(EXTRA_OUTPUT);
			if (uri != null) {
				output = new File(uri.getPath());
			} else {
				output = new File(Collect.getInstance().getTmpFilePath());
			}
		}

		// At this point, we have:
		// loadOption -- type of activity (draw, signature, annotate)
		// refImage -- original image to work with
		// savepointImage -- drawing to use as a starting point (may be copy of
		// original)
		// output -- where the output should be written

		if (OPTION_SIGNATURE.equals(loadOption)) {
			// set landscape
			setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
			alertTitleString = getString(R.string.quit_application,
					getString(R.string.sign_button));
		} else if (OPTION_ANNOTATE.equals(loadOption)) {
            setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
			alertTitleString = getString(R.string.quit_application,
					getString(R.string.markup_image));
		} else {
			alertTitleString = getString(R.string.quit_application,
					getString(R.string.draw_image));
		}

		setTitle(getString(R.string.app_name) + " > "
				+ getString(R.string.draw_image));

		LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		RelativeLayout v = (RelativeLayout) inflater.inflate(
				R.layout.draw_layout, null);
		LinearLayout ll = (LinearLayout) v.findViewById(R.id.drawViewLayout);

		drawView = new DrawView(this, OPTION_SIGNATURE.equals(loadOption),
				savepointImage);

		ll.addView(drawView);

		setContentView(v);

		paint = new Paint();
		paint.setAntiAlias(true);
		paint.setDither(true);
		paint.setColor(currentColor);
		paint.setStyle(Paint.Style.STROKE);
		paint.setStrokeJoin(Paint.Join.ROUND);
		paint.setStrokeWidth(10);

		pointPaint = new Paint();
		pointPaint.setAntiAlias(true);
		pointPaint.setDither(true);
		pointPaint.setColor(currentColor);
		pointPaint.setStyle(Paint.Style.FILL_AND_STROKE);
		pointPaint.setStrokeWidth(10);

		btnDrawColor = (Button) findViewById(R.id.btnSelectColor);
		btnDrawColor.setTextColor(getInverseColor(currentColor));
		btnDrawColor.getBackground().setColorFilter(currentColor,
				PorterDuff.Mode.SRC_ATOP);
		btnDrawColor.setText(getString(R.string.set_color));
		btnDrawColor.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {
				Collect.getInstance()
						.getActivityLogger()
						.logInstanceAction(
								DrawActivity.this,
								"setColorButton",
								"click",
								Collect.getInstance().getFormController()
										.getFormIndex());
				ColorPickerDialog cpd = new ColorPickerDialog(
						DrawActivity.this,
						new ColorPickerDialog.OnColorChangedListener() {
							public void colorChanged(String key, int color) {
								btnDrawColor
										.setTextColor(getInverseColor(color));
								btnDrawColor.getBackground().setColorFilter(
										color, PorterDuff.Mode.SRC_ATOP);
								currentColor = color;
								paint.setColor(color);
								pointPaint.setColor(color);
							}
						}, "key", currentColor, currentColor,
						getString(R.string.select_drawing_color));
				cpd.show();
			}
		});
		btnFinished = (Button) findViewById(R.id.btnFinishDraw);
		btnFinished.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				Collect.getInstance()
						.getActivityLogger()
						.logInstanceAction(
								DrawActivity.this,
								"saveAndCloseButton",
								"click",
								Collect.getInstance().getFormController()
										.getFormIndex());
				SaveAndClose();
			}
		});
		btnReset = (Button) findViewById(R.id.btnResetDraw);
		btnReset.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				Collect.getInstance()
						.getActivityLogger()
						.logInstanceAction(
								DrawActivity.this,
								"resetButton",
								"click",
								Collect.getInstance().getFormController()
										.getFormIndex());
				Reset();
			}
		});
		btnCancel = (Button) findViewById(R.id.btnCancelDraw);
		btnCancel.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				Collect.getInstance()
						.getActivityLogger()
						.logInstanceAction(
								DrawActivity.this,
								"cancelAndCloseButton",
								"click",
								Collect.getInstance().getFormController()
										.getFormIndex());
				CancelAndClose();
			}
		});

	}

	private int getInverseColor(int color) {
		int red = Color.red(color);
		int green = Color.green(color);
		int blue = Color.blue(color);
		int alpha = Color.alpha(color);
		return Color.argb(alpha, 255 - red, 255 - green, 255 - blue);
	}

	private void SaveAndClose() {
		try {
			saveFile(output);
			setResult(Activity.RESULT_OK);
		} catch (FileNotFoundException e) {
			e.printStackTrace();
			setResult(Activity.RESULT_CANCELED);
		}
		this.finish();
	}

	private void saveFile(File f) throws FileNotFoundException {
		if ( drawView.getWidth() == 0 || drawView.getHeight() == 0 ) {
			// apparently on 4.x, the orientation change notification can occur
			// sometime before the view is rendered. In that case, the view
			// dimensions will not be known.
			Log.e(t,"view has zero width or zero height");
		} else {
			FileOutputStream fos = new FileOutputStream(f);
			Bitmap bitmap = Bitmap.createBitmap(drawView.getWidth(),
					drawView.getHeight(), Bitmap.Config.ARGB_8888);
			Canvas canvas = new Canvas(bitmap);
			drawView.draw(canvas);
			bitmap.compress(Bitmap.CompressFormat.JPEG, 70, fos);
			try {
                fos.flush();
                fos.close();
			} catch ( Exception e) {
			}
		}
	}

	private void Reset() {
		savepointImage.delete();
		if (!OPTION_SIGNATURE.equals(loadOption) && refImage != null
				&& refImage.exists()) {
			FileUtils.copyFile(refImage, savepointImage);
		}
		drawView.reset();
		drawView.invalidate();
	}

	private void CancelAndClose() {
		setResult(Activity.RESULT_CANCELED);
		this.finish();
	}

	@Override
	public void onConfigurationChanged(Configuration newConfig) {
		super.onConfigurationChanged(newConfig);
	}

	@Override
	public boolean onKeyDown(int keyCode, KeyEvent event) {
		switch (keyCode) {
		case KeyEvent.KEYCODE_BACK:
			Collect.getInstance().getActivityLogger()
					.logInstanceAction(this, "onKeyDown.KEYCODE_BACK", "quit");
			createQuitDrawDialog();
			return true;
		case KeyEvent.KEYCODE_DPAD_RIGHT:
			if (event.isAltPressed()) {
				Collect.getInstance()
						.getActivityLogger()
						.logInstanceAction(this,
								"onKeyDown.KEYCODE_DPAD_RIGHT", "showNext");
				createQuitDrawDialog();
				return true;
			}
			break;
		case KeyEvent.KEYCODE_DPAD_LEFT:
			if (event.isAltPressed()) {
				Collect.getInstance()
						.getActivityLogger()
						.logInstanceAction(this, "onKeyDown.KEYCODE_DPAD_LEFT",
								"showPrevious");
				createQuitDrawDialog();
				return true;
			}
			break;
		}
		return super.onKeyDown(keyCode, event);
	}

	/**
	 * Create a dialog with options to save and exit, save, or quit without
	 * saving
	 */
	private void createQuitDrawDialog() {
		String[] items = { getString(R.string.keep_changes),
				getString(R.string.do_not_save) };

		Collect.getInstance().getActivityLogger()
				.logInstanceAction(this, "createQuitDrawDialog", "show");
		alertDialog = new AlertDialog.Builder(this)
				.setIcon(android.R.drawable.ic_dialog_info)
				.setTitle(alertTitleString)
				.setNeutralButton(getString(R.string.do_not_exit),
						new DialogInterface.OnClickListener() {
							@Override
							public void onClick(DialogInterface dialog, int id) {

								Collect.getInstance()
										.getActivityLogger()
										.logInstanceAction(this,
												"createQuitDrawDialog",
												"cancel");
								dialog.cancel();

							}
						})
				.setItems(items, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						switch (which) {

						case 0: // save and exit
							Collect.getInstance()
									.getActivityLogger()
									.logInstanceAction(this,
											"createQuitDrawDialog",
											"saveAndExit");
							SaveAndClose();
							break;

						case 1: // discard changes and exit

							Collect.getInstance()
									.getActivityLogger()
									.logInstanceAction(this,
											"createQuitDrawDialog",
											"discardAndExit");
							CancelAndClose();
							break;

						case 2:// do nothing
							Collect.getInstance()
									.getActivityLogger()
									.logInstanceAction(this,
											"createQuitDrawDialog", "cancel");
							break;
						}
					}
				}).create();
		alertDialog.show();
	}

	public class DrawView extends View {
		private boolean isSignature;
		private Bitmap mBitmap;
		private Canvas mCanvas;
		private Path mCurrentPath;
		private Paint mBitmapPaint;
		private File mBackgroundBitmapFile;

		public DrawView(final Context c) {
			super(c);
			isSignature = false;
			mBitmapPaint = new Paint(Paint.DITHER_FLAG);
			mCurrentPath = new Path();
			setBackgroundColor(0xFFFFFFFF);
			mBackgroundBitmapFile = new File(Collect.getInstance().getTmpDrawFilePath());
		}

		public DrawView(Context c, boolean isSignature, File f) {
			this(c);
			this.isSignature = isSignature;
			mBackgroundBitmapFile = f;
		}

		public void reset() {
			Display display = ((WindowManager) getContext().getSystemService(
					Context.WINDOW_SERVICE)).getDefaultDisplay();
			int screenWidth = display.getWidth();
			int screenHeight = display.getHeight();
			resetImage(screenWidth, screenHeight);
		}

		public void resetImage(int w, int h) {
			if (mBackgroundBitmapFile.exists()) {
				mBitmap = FileUtils.getBitmapScaledToDisplay(
						mBackgroundBitmapFile, w, h).copy(
						Bitmap.Config.ARGB_8888, true);
				// mBitmap =
				// Bitmap.createScaledBitmap(BitmapFactory.decodeFile(mBackgroundBitmapFile.getPath()),
				// w, h, true);
				mCanvas = new Canvas(mBitmap);
			} else {
				mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
				mCanvas = new Canvas(mBitmap);
				mCanvas.drawColor(0xFFFFFFFF);
				if (isSignature)
					drawSignLine();
			}
		}

		@Override
		protected void onSizeChanged(int w, int h, int oldw, int oldh) {
			super.onSizeChanged(w, h, oldw, oldh);
			resetImage(w, h);
		}

		@Override
		protected void onDraw(Canvas canvas) {
			canvas.drawColor(0xFFAAAAAA);
			canvas.drawBitmap(mBitmap, 0, 0, mBitmapPaint);
			canvas.drawPath(mCurrentPath, paint);
		}

		private float mX, mY;

		private void touch_start(float x, float y) {
			mCurrentPath.reset();
			mCurrentPath.moveTo(x, y);
			mX = x;
			mY = y;
		}

		public void drawSignLine() {
			mCanvas.drawLine(0, (int) (mCanvas.getHeight() * .7),
					mCanvas.getWidth(), (int) (mCanvas.getHeight() * .7), paint);
		}

		private void touch_move(float x, float y) {
			mCurrentPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);
			mX = x;
			mY = y;
		}

		private void touch_up() {
			if (mCurrentPath.isEmpty()) {
				mCanvas.drawPoint(mX, mY, pointPaint);
			} else {
				mCurrentPath.lineTo(mX, mY);
				// commit the path to our offscreen
				mCanvas.drawPath(mCurrentPath, paint);
			}
			// kill this so we don't double draw
			mCurrentPath.reset();
		}

		@Override
		public boolean onTouchEvent(MotionEvent event) {
			float x = event.getX();
			float y = event.getY();

			switch (event.getAction()) {
			case MotionEvent.ACTION_DOWN:
				touch_start(x, y);
				invalidate();
				break;
			case MotionEvent.ACTION_MOVE:
				touch_move(x, y);
				invalidate();
				break;
			case MotionEvent.ACTION_UP:
				touch_up();
				invalidate();
				break;
			}
			return true;
		}

	}

}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.activities;

import android.app.TabActivity;
import android.content.Intent;
import android.graphics.Color;
import android.os.Bundle;
import android.view.View;
import android.view.ViewGroup;
import android.widget.LinearLayout;
import android.widget.TabHost;
import android.widget.TabWidget;
import android.widget.TextView;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;

/**
 * An example of tab content that launches an activity via
 * {@link android.widget.TabHost.TabSpec#setContent(android.content.Intent)}
 */
public class FileManagerTabs extends TabActivity {

	private TextView mTVFF;
	private TextView mTVDF;

	private static final String FORMS_TAB = "forms_tab";
	private static final String DATA_TAB = "data_tab";

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);

		setTitle(getString(R.string.app_name) + " > "
				+ getString(R.string.manage_files));

		final TabHost tabHost = getTabHost();
		tabHost.setBackgroundColor(Color.WHITE);
		tabHost.getTabWidget().setBackgroundColor(Color.DKGRAY);

		Intent remote = new Intent(this, DataManagerList.class);
		tabHost.addTab(tabHost.newTabSpec(DATA_TAB)
				.setIndicator(getString(R.string.data)).setContent(remote));

		Intent local = new Intent(this, FormManagerList.class);
		tabHost.addTab(tabHost.newTabSpec(FORMS_TAB)
				.setIndicator(getString(R.string.forms)).setContent(local));

		// hack to set font size
		LinearLayout ll = (LinearLayout) tabHost.getChildAt(0);
		TabWidget tw = (TabWidget) ll.getChildAt(0);

		int fontsize = Collect.getQuestionFontsize();

		ViewGroup rllf = (ViewGroup) tw.getChildAt(0);
		mTVFF = getTextViewChild(rllf);
		if (mTVFF != null) {
			mTVFF.setTextSize(fontsize);
			mTVFF.setTextColor(Color.WHITE);
			mTVFF.setPadding(0, 0, 0, 6);
		}

		ViewGroup rlrf = (ViewGroup) tw.getChildAt(1);
		mTVDF = getTextViewChild(rlrf);
		if (mTVDF != null) {
			mTVDF.setTextSize(fontsize);
			mTVDF.setTextColor(Color.WHITE);
			mTVDF.setPadding(0, 0, 0, 6);
		}
	}

	private TextView getTextViewChild(ViewGroup viewGroup) {
		for (int i = 0; i < viewGroup.getChildCount(); i++) {
			View view = viewGroup.getChildAt(i);
			if (view instanceof TextView) {
				return (TextView) view;
			}
		}
		return null;
	}

	@Override
	protected void onStart() {
		super.onStart();
		Collect.getInstance().getActivityLogger().logOnStart(this);
	}

	@Override
	protected void onStop() {
		Collect.getInstance().getActivityLogger().logOnStop(this);
		super.onStop();
	}

}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.activities;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.database.ContentObserver;
import android.database.Cursor;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.preference.PreferenceManager;
import android.text.InputType;
import android.text.method.PasswordTransformationMethod;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.WindowManager;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.preferences.AdminPreferencesActivity;
import org.odk.collect.android.preferences.PreferencesActivity;
import org.odk.collect.android.provider.InstanceProviderAPI;
import org.odk.collect.android.provider.InstanceProviderAPI.InstanceColumns;
import org.odk.collect.android.utilities.CompatibilityUtils;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.lang.ref.WeakReference;
import java.util.Map;
import java.util.Map.Entry;

/**
 * Responsible for displaying buttons to launch the major activities. Launches
 * some activities based on returns of others.
 *
 * @author Carl Hartung (carlhartung@gmail.com)
 * @author Yaw Anokwa (yanokwa@gmail.com)
 */
public class MainMenuActivity extends Activity {
	private static final String t = "MainMenuActivity";

	private static final int PASSWORD_DIALOG = 1;

	// menu options
	private static final int MENU_PREFERENCES = Menu.FIRST;
	private static final int MENU_ADMIN = Menu.FIRST + 1;

	// buttons
	private Button mEnterDataButton;
	private Button mManageFilesButton;
	private Button mSendDataButton;
	private Button mReviewDataButton;
	private Button mGetFormsButton;

	private View mReviewSpacer;
	private View mGetFormsSpacer;

	private AlertDialog mAlertDialog;
	private SharedPreferences mAdminPreferences;

	private int mCompletedCount;
	private int mSavedCount;

	private Cursor mFinalizedCursor;
	private Cursor mSavedCursor;

	private IncomingHandler mHandler = new IncomingHandler(this);
	private MyContentObserver mContentObserver = new MyContentObserver();

	private static boolean EXIT = true;

	// private static boolean DO_NOT_EXIT = false;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);

		// must be at the beginning of any activity that can be called from an
		// external intent
		Log.i(t, "Starting up, creating directories");
		try {
			Collect.getInstance().createODKDirs();
		} catch (RuntimeException e) {
			createErrorDialog(e.getMessage(), EXIT);
			return;
		}

		setContentView(R.layout.main_menu);

		{
			// dynamically construct the "ODK Collect vA.B" string
			TextView mainMenuMessageLabel = (TextView) findViewById(R.id.main_menu_header);
			mainMenuMessageLabel.setText(Collect.getInstance()
					.getVersionedAppName());
		}

		setTitle(getString(R.string.app_name) + " > "
				+ getString(R.string.main_menu));

		File f = new File(Collect.getInstance().getOdkRoot() + "/collect.settings");
		if (f.exists()) {
			boolean success = loadSharedPreferencesFromFile(f);
			if (success) {
				Toast.makeText(this,
						"Settings successfully loaded from file",
						Toast.LENGTH_LONG).show();
				f.delete();
			} else {
				Toast.makeText(
						this,
						"Sorry, settings file is corrupt and should be deleted or replaced",
						Toast.LENGTH_LONG).show();
			}
		}

		mReviewSpacer = findViewById(R.id.review_spacer);
		mGetFormsSpacer = findViewById(R.id.get_forms_spacer);

		mAdminPreferences = this.getSharedPreferences(
				AdminPreferencesActivity.ADMIN_PREFERENCES, 0);

		// enter data button. expects a result.
		mEnterDataButton = (Button) findViewById(R.id.enter_data);
		mEnterDataButton.setText(getString(R.string.enter_data_button));
		mEnterDataButton.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				Collect.getInstance().getActivityLogger()
						.logAction(this, "fillBlankForm", "click");
				Intent i = new Intent(getApplicationContext(),
						FormChooserList.class);
				startActivity(i);
			}
		});

		// review data button. expects a result.
		mReviewDataButton = (Button) findViewById(R.id.review_data);
		mReviewDataButton.setText(getString(R.string.review_data_button));
		mReviewDataButton.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				Collect.getInstance().getActivityLogger()
						.logAction(this, "editSavedForm", "click");
				Intent i = new Intent(getApplicationContext(),
						InstanceChooserList.class);
				startActivity(i);
			}
		});

		// send data button. expects a result.
		mSendDataButton = (Button) findViewById(R.id.send_data);
		mSendDataButton.setText(getString(R.string.send_data_button));
		mSendDataButton.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				Collect.getInstance().getActivityLogger()
						.logAction(this, "uploadForms", "click");
				Intent i = new Intent(getApplicationContext(),
						InstanceUploaderList.class);
				startActivity(i);
			}
		});

		// manage forms button. no result expected.
		mGetFormsButton = (Button) findViewById(R.id.get_forms);
		mGetFormsButton.setText(getString(R.string.get_forms));
		mGetFormsButton.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				Collect.getInstance().getActivityLogger()
						.logAction(this, "downloadBlankForms", "click");
				SharedPreferences sharedPreferences = PreferenceManager
						.getDefaultSharedPreferences(MainMenuActivity.this);
				String protocol = sharedPreferences.getString(
						PreferencesActivity.KEY_PROTOCOL, getString(R.string.protocol_odk_default));
				Intent i = null;
                i = new Intent(getApplicationContext(),
                        FormDownloadList.class);
				startActivity(i);
			}
		});

		// manage forms button. no result expected.
		mManageFilesButton = (Button) findViewById(R.id.manage_forms);
		mManageFilesButton.setText(getString(R.string.manage_files));
		mManageFilesButton.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				Collect.getInstance().getActivityLogger()
						.logAction(this, "deleteSavedForms", "click");
				Intent i = new Intent(getApplicationContext(),
						FileManagerTabs.class);
				startActivity(i);
			}
		});

		// count for finalized instances
		String selection = InstanceColumns.STATUS + "=? or "
				+ InstanceColumns.STATUS + "=?";
		String selectionArgs[] = { InstanceProviderAPI.STATUS_COMPLETE,
				InstanceProviderAPI.STATUS_SUBMISSION_FAILED };

        try {
            mFinalizedCursor = managedQuery(InstanceColumns.CONTENT_URI, null,
                    selection, selectionArgs, null);
        } catch (Exception e) {
            createErrorDialog(e.getMessage(), EXIT);
            return;
        }

    if (mFinalizedCursor != null) {
      startManagingCursor(mFinalizedCursor);
    }
    mCompletedCount = mFinalizedCursor != null ? mFinalizedCursor.getCount() : 0;
        getContentResolver().registerContentObserver(InstanceColumns.CONTENT_URI, true, mContentObserver);
//		mFinalizedCursor.registerContentObserver(mContentObserver);

		// count for finalized instances
		String selectionSaved = InstanceColumns.STATUS + "=?";
		String selectionArgsSaved[] = { InstanceProviderAPI.STATUS_INCOMPLETE };

        try {
            mSavedCursor = managedQuery(InstanceColumns.CONTENT_URI, null,
                    selectionSaved, selectionArgsSaved, null);
        } catch (Exception e) {
            createErrorDialog(e.getMessage(), EXIT);
            return;
        }

    if (mSavedCursor != null) {
      startManagingCursor(mSavedCursor);
    }
    mSavedCount = mSavedCursor != null ? mSavedCursor.getCount() : 0;
		// don't need to set a content observer because it can't change in the
		// background

		updateButtons();
	}

	@Override
	protected void onResume() {
		super.onResume();
		SharedPreferences sharedPreferences = this.getSharedPreferences(
				AdminPreferencesActivity.ADMIN_PREFERENCES, 0);

		boolean edit = sharedPreferences.getBoolean(
				AdminPreferencesActivity.KEY_EDIT_SAVED, true);
		if (!edit) {
			mReviewDataButton.setVisibility(View.GONE);
			mReviewSpacer.setVisibility(View.GONE);
		} else {
			mReviewDataButton.setVisibility(View.VISIBLE);
			mReviewSpacer.setVisibility(View.VISIBLE);
		}

		boolean send = sharedPreferences.getBoolean(
				AdminPreferencesActivity.KEY_SEND_FINALIZED, true);
		if (!send) {
			mSendDataButton.setVisibility(View.GONE);
		} else {
			mSendDataButton.setVisibility(View.VISIBLE);
		}

		boolean get_blank = sharedPreferences.getBoolean(
				AdminPreferencesActivity.KEY_GET_BLANK, true);
		if (!get_blank) {
			mGetFormsButton.setVisibility(View.GONE);
			mGetFormsSpacer.setVisibility(View.GONE);
		} else {
			mGetFormsButton.setVisibility(View.VISIBLE);
			mGetFormsSpacer.setVisibility(View.VISIBLE);
		}

		boolean delete_saved = sharedPreferences.getBoolean(
				AdminPreferencesActivity.KEY_DELETE_SAVED, true);
		if (!delete_saved) {
			mManageFilesButton.setVisibility(View.GONE);
		} else {
			mManageFilesButton.setVisibility(View.VISIBLE);
		}
	}

	@Override
	protected void onPause() {
		super.onPause();
		if (mAlertDialog != null && mAlertDialog.isShowing()) {
			mAlertDialog.dismiss();
		}
	}

	@Override
	protected void onStart() {
		super.onStart();
		Collect.getInstance().getActivityLogger().logOnStart(this);
	}

	@Override
	protected void onStop() {
		Collect.getInstance().getActivityLogger().logOnStop(this);
		super.onStop();
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		Collect.getInstance().getActivityLogger()
				.logAction(this, "onCreateOptionsMenu", "show");
		super.onCreateOptionsMenu(menu);

		CompatibilityUtils.setShowAsAction(
    		menu.add(0, MENU_PREFERENCES, 0, R.string.general_preferences)
				.setIcon(R.drawable.ic_menu_preferences),
			MenuItem.SHOW_AS_ACTION_NEVER);
		CompatibilityUtils.setShowAsAction(
    		menu.add(0, MENU_ADMIN, 0, R.string.admin_preferences)
				.setIcon(R.drawable.ic_menu_login),
			MenuItem.SHOW_AS_ACTION_NEVER);
		return true;
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch (item.getItemId()) {
		case MENU_PREFERENCES:
			Collect.getInstance()
					.getActivityLogger()
					.logAction(this, "onOptionsItemSelected",
							"MENU_PREFERENCES");
			Intent ig = new Intent(this, PreferencesActivity.class);
			startActivity(ig);
			return true;
		case MENU_ADMIN:
			Collect.getInstance().getActivityLogger()
					.logAction(this, "onOptionsItemSelected", "MENU_ADMIN");
			String pw = mAdminPreferences.getString(
					AdminPreferencesActivity.KEY_ADMIN_PW, "");
			if ("".equalsIgnoreCase(pw)) {
				Intent i = new Intent(getApplicationContext(),
						AdminPreferencesActivity.class);
				startActivity(i);
			} else {
				showDialog(PASSWORD_DIALOG);
				Collect.getInstance().getActivityLogger()
						.logAction(this, "createAdminPasswordDialog", "show");
			}
			return true;
		}
		return super.onOptionsItemSelected(item);
	}

	private void createErrorDialog(String errorMsg, final boolean shouldExit) {
		Collect.getInstance().getActivityLogger()
				.logAction(this, "createErrorDialog", "show");
		mAlertDialog = new AlertDialog.Builder(this).create();
		mAlertDialog.setIcon(android.R.drawable.ic_dialog_info);
		mAlertDialog.setMessage(errorMsg);
		DialogInterface.OnClickListener errorListener = new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int i) {
				switch (i) {
				case DialogInterface.BUTTON_POSITIVE:
					Collect.getInstance()
							.getActivityLogger()
							.logAction(this, "createErrorDialog",
									shouldExit ? "exitApplication" : "OK");
					if (shouldExit) {
						finish();
					}
					break;
				}
			}
		};
		mAlertDialog.setCancelable(false);
		mAlertDialog.setButton(getString(R.string.ok), errorListener);
		mAlertDialog.show();
	}

	@Override
	protected Dialog onCreateDialog(int id) {
		switch (id) {
		case PASSWORD_DIALOG:

			AlertDialog.Builder builder = new AlertDialog.Builder(this);
			final AlertDialog passwordDialog = builder.create();

			passwordDialog.setTitle(getString(R.string.enter_admin_password));
			final EditText input = new EditText(this);
			input.setInputType(InputType.TYPE_TEXT_VARIATION_PASSWORD);
			input.setTransformationMethod(PasswordTransformationMethod
					.getInstance());
			passwordDialog.setView(input, 20, 10, 20, 10);

			passwordDialog.setButton(AlertDialog.BUTTON_POSITIVE,
					getString(R.string.ok),
					new DialogInterface.OnClickListener() {
						public void onClick(DialogInterface dialog,
								int whichButton) {
							String value = input.getText().toString();
							String pw = mAdminPreferences.getString(
									AdminPreferencesActivity.KEY_ADMIN_PW, "");
							if (pw.compareTo(value) == 0) {
								Intent i = new Intent(getApplicationContext(),
										AdminPreferencesActivity.class);
								startActivity(i);
								input.setText("");
								passwordDialog.dismiss();
							} else {
								Toast.makeText(
										MainMenuActivity.this,
										getString(R.string.admin_password_incorrect),
										Toast.LENGTH_SHORT).show();
								Collect.getInstance()
										.getActivityLogger()
										.logAction(this, "adminPasswordDialog",
												"PASSWORD_INCORRECT");
							}
						}
					});

			passwordDialog.setButton(AlertDialog.BUTTON_NEGATIVE,
					getString(R.string.cancel),
					new DialogInterface.OnClickListener() {

						public void onClick(DialogInterface dialog, int which) {
							Collect.getInstance()
									.getActivityLogger()
									.logAction(this, "adminPasswordDialog",
											"cancel");
							input.setText("");
							return;
						}
					});

			passwordDialog.getWindow().setSoftInputMode(
					WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);
			return passwordDialog;

		}
		return null;
	}

	private void updateButtons() {
    if (mFinalizedCursor != null && !mFinalizedCursor.isClosed()) {
      mFinalizedCursor.requery();
      mCompletedCount = mFinalizedCursor.getCount();
      if (mCompletedCount > 0) {
        mSendDataButton.setText(getString(R.string.send_data_button, mCompletedCount));
      } else {
        mSendDataButton.setText(getString(R.string.send_data));
      }
    } else {
      mSendDataButton.setText(getString(R.string.send_data));
      Log.w(t, "Cannot update \"Send Finalized\" button label since the database is closed. Perhaps the app is running in the background?");
    }

    if (mSavedCursor != null && !mSavedCursor.isClosed()) {
      mSavedCursor.requery();
      mSavedCount = mSavedCursor.getCount();
      if (mSavedCount > 0) {
        mReviewDataButton.setText(getString(R.string.review_data_button,
                mSavedCount));
      } else {
        mReviewDataButton.setText(getString(R.string.review_data));
      }
    } else {
      mReviewDataButton.setText(getString(R.string.review_data));
      Log.w(t, "Cannot update \"Edit Form\" button label since the database is closed. Perhaps the app is running in the background?");
    }
  }

	/**
	 * notifies us that something changed
	 *
	 */
	private class MyContentObserver extends ContentObserver {

		public MyContentObserver() {
			super(null);
		}

		@Override
		public void onChange(boolean selfChange) {
			super.onChange(selfChange);
			mHandler.sendEmptyMessage(0);
		}
	}

	/*
	 * Used to prevent memory leaks
	 */
	static class IncomingHandler extends Handler {
		private final WeakReference<MainMenuActivity> mTarget;

		IncomingHandler(MainMenuActivity target) {
			mTarget = new WeakReference<MainMenuActivity>(target);
		}

		@Override
		public void handleMessage(Message msg) {
			MainMenuActivity target = mTarget.get();
			if (target != null) {
				target.updateButtons();
			}
		}
	}

	private boolean loadSharedPreferencesFromFile(File src) {
		// this should probably be in a thread if it ever gets big
		boolean res = false;
		ObjectInputStream input = null;
		try {
			input = new ObjectInputStream(new FileInputStream(src));
			Editor prefEdit = PreferenceManager.getDefaultSharedPreferences(
					this).edit();
			prefEdit.clear();
			// first object is preferences
			Map<String, ?> entries = (Map<String, ?>) input.readObject();
			for (Entry<String, ?> entry : entries.entrySet()) {
				Object v = entry.getValue();
				String key = entry.getKey();

				if (v instanceof Boolean)
					prefEdit.putBoolean(key, ((Boolean) v).booleanValue());
				else if (v instanceof Float)
					prefEdit.putFloat(key, ((Float) v).floatValue());
				else if (v instanceof Integer)
					prefEdit.putInt(key, ((Integer) v).intValue());
				else if (v instanceof Long)
					prefEdit.putLong(key, ((Long) v).longValue());
				else if (v instanceof String)
					prefEdit.putString(key, ((String) v));
			}
			prefEdit.commit();

			// second object is admin options
			Editor adminEdit = getSharedPreferences(AdminPreferencesActivity.ADMIN_PREFERENCES, 0).edit();
			adminEdit.clear();
			// first object is preferences
			Map<String, ?> adminEntries = (Map<String, ?>) input.readObject();
			for (Entry<String, ?> entry : adminEntries.entrySet()) {
				Object v = entry.getValue();
				String key = entry.getKey();

				if (v instanceof Boolean)
					adminEdit.putBoolean(key, ((Boolean) v).booleanValue());
				else if (v instanceof Float)
					adminEdit.putFloat(key, ((Float) v).floatValue());
				else if (v instanceof Integer)
					adminEdit.putInt(key, ((Integer) v).intValue());
				else if (v instanceof Long)
					adminEdit.putLong(key, ((Long) v).longValue());
				else if (v instanceof String)
					adminEdit.putString(key, ((String) v));
			}
			adminEdit.commit();

			res = true;
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		} finally {
			try {
				if (input != null) {
					input.close();
				}
			} catch (IOException ex) {
				ex.printStackTrace();
			}
		}
		return res;
	}

}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.activities;

import android.app.AlertDialog;
import android.app.ListActivity;
import android.content.ContentUris;
import android.content.DialogInterface;
import android.content.Intent;
import android.database.Cursor;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.ListView;
import android.widget.SimpleCursorAdapter;
import android.widget.TextView;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.listeners.DiskSyncListener;
import org.odk.collect.android.provider.FormsProviderAPI.FormsColumns;
import org.odk.collect.android.tasks.DiskSyncTask;
import org.odk.collect.android.utilities.VersionHidingCursorAdapter;

/**
 * Responsible for displaying all the valid forms in the forms directory. Stores the path to
 * selected form for use by {@link MainMenuActivity}.
 *
 * @author Yaw Anokwa (yanokwa@gmail.com)
 * @author Carl Hartung (carlhartung@gmail.com)
 */
public class FormChooserList extends ListActivity implements DiskSyncListener {

    private static final String t = "FormChooserList";
    private static final boolean EXIT = true;
    private static final String syncMsgKey = "syncmsgkey";

    private DiskSyncTask mDiskSyncTask;

    private AlertDialog mAlertDialog;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // must be at the beginning of any activity that can be called from an external intent
        try {
            Collect.getInstance().createODKDirs();
        } catch (RuntimeException e) {
            createErrorDialog(e.getMessage(), EXIT);
            return;
        }

        setContentView(R.layout.chooser_list_layout);
        setTitle(getString(R.string.app_name) + " > " + getString(R.string.enter_data));

        String sortOrder = FormsColumns.DISPLAY_NAME + " ASC, " + FormsColumns.JR_VERSION + " DESC";
        Cursor c = managedQuery(FormsColumns.CONTENT_URI, null, null, null, sortOrder);

        String[] data = new String[] {
                FormsColumns.DISPLAY_NAME, FormsColumns.DISPLAY_SUBTEXT, FormsColumns.JR_VERSION
        };
        int[] view = new int[] {
                R.id.text1, R.id.text2, R.id.text3
        };

        // render total instance view
        SimpleCursorAdapter instances =
            new VersionHidingCursorAdapter(FormsColumns.JR_VERSION, this, R.layout.two_item, c, data, view);
        setListAdapter(instances);

        if (savedInstanceState != null && savedInstanceState.containsKey(syncMsgKey)) {
            TextView tv = (TextView) findViewById(R.id.status_text);
            tv.setText(savedInstanceState.getString(syncMsgKey));
        }

        // DiskSyncTask checks the disk for any forms not already in the content provider
        // that is, put here by dragging and dropping onto the SDCard
        mDiskSyncTask = (DiskSyncTask) getLastNonConfigurationInstance();
        if (mDiskSyncTask == null) {
            Log.i(t, "Starting new disk sync task");
            mDiskSyncTask = new DiskSyncTask();
            mDiskSyncTask.setDiskSyncListener(this);
            mDiskSyncTask.execute((Void[]) null);
        }
    }


    @Override
    public Object onRetainNonConfigurationInstance() {
        // pass the thread on restart
        return mDiskSyncTask;
    }


    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        TextView tv = (TextView) findViewById(R.id.status_text);
        outState.putString(syncMsgKey, tv.getText().toString());
    }


    /**
     * Stores the path of selected form and finishes.
     */
    @Override
    protected void onListItemClick(ListView listView, View view, int position, long id) {
        // get uri to form
    	long idFormsTable = ((SimpleCursorAdapter) getListAdapter()).getItemId(position);
        Uri formUri = ContentUris.withAppendedId(FormsColumns.CONTENT_URI, idFormsTable);

		Collect.getInstance().getActivityLogger().logAction(this, "onListItemClick", formUri.toString());

        String action = getIntent().getAction();
        if (Intent.ACTION_PICK.equals(action)) {
            // caller is waiting on a picked form
            setResult(RESULT_OK, new Intent().setData(formUri));
        } else {
            // caller wants to view/edit a form, so launch formentryactivity
            startActivity(new Intent(Intent.ACTION_EDIT, formUri));
        }

        finish();
    }


    @Override
    protected void onResume() {
        mDiskSyncTask.setDiskSyncListener(this);
        super.onResume();

        if (mDiskSyncTask.getStatus() == AsyncTask.Status.FINISHED) {
        	SyncComplete(mDiskSyncTask.getStatusMessage());
        }
    }


    @Override
    protected void onPause() {
        mDiskSyncTask.setDiskSyncListener(null);
        super.onPause();
    }


    @Override
    protected void onStart() {
    	super.onStart();
		Collect.getInstance().getActivityLogger().logOnStart(this);
    }

    @Override
    protected void onStop() {
		Collect.getInstance().getActivityLogger().logOnStop(this);
    	super.onStop();
    }


    /**
     * Called by DiskSyncTask when the task is finished
     */
    @Override
    public void SyncComplete(String result) {
        Log.i(t, "disk sync task complete");
        TextView tv = (TextView) findViewById(R.id.status_text);
        tv.setText(result);
    }


    /**
     * Creates a dialog with the given message. Will exit the activity when the user preses "ok" if
     * shouldExit is set to true.
     *
     * @param errorMsg
     * @param shouldExit
     */
    private void createErrorDialog(String errorMsg, final boolean shouldExit) {

    	Collect.getInstance().getActivityLogger().logAction(this, "createErrorDialog", "show");

        mAlertDialog = new AlertDialog.Builder(this).create();
        mAlertDialog.setIcon(android.R.drawable.ic_dialog_info);
        mAlertDialog.setMessage(errorMsg);
        DialogInterface.OnClickListener errorListener = new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int i) {
                switch (i) {
                    case DialogInterface.BUTTON_POSITIVE:
                    	Collect.getInstance().getActivityLogger().logAction(this, "createErrorDialog",
                    			shouldExit ? "exitApplication" : "OK");
                        if (shouldExit) {
                            finish();
                        }
                        break;
                }
            }
        };
        mAlertDialog.setCancelable(false);
        mAlertDialog.setButton(getString(R.string.ok), errorListener);
        mAlertDialog.show();
    }

}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.activities;

import android.app.AlertDialog;
import android.app.ListActivity;
import android.content.DialogInterface;
import android.graphics.Color;
import android.os.Bundle;
import android.util.Log;
import android.view.KeyEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.ListView;
import android.widget.TextView;

import org.javarosa.core.model.FormIndex;
import org.javarosa.form.api.FormEntryCaption;
import org.javarosa.form.api.FormEntryController;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.R;
import org.odk.collect.android.adapters.HierarchyListAdapter;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.exception.JavaRosaException;
import org.odk.collect.android.logic.FormController;
import org.odk.collect.android.logic.HierarchyElement;

import java.util.ArrayList;
import java.util.List;

public class FormHierarchyActivity extends ListActivity {

    private static final String t = "FormHierarchyActivity";

    private static final int CHILD = 1;
    private static final int EXPANDED = 2;
    private static final int COLLAPSED = 3;
    private static final int QUESTION = 4;

    private static final String mIndent = "     ";

    private Button jumpPreviousButton;

    List<HierarchyElement> formList;
    TextView mPath;

    FormIndex mStartIndex;
    private FormIndex currentIndex;


    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.hierarchy_layout);

        FormController formController = Collect.getInstance().getFormController();

        // We use a static FormEntryController to make jumping faster.
        mStartIndex = formController.getFormIndex();

        setTitle(getString(R.string.app_name) + " > "
                + formController.getFormTitle());

        mPath = (TextView) findViewById(R.id.pathtext);

        jumpPreviousButton = (Button) findViewById(R.id.jumpPreviousButton);
        jumpPreviousButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                Collect.getInstance().getActivityLogger().logInstanceAction(this, "goUpLevelButton", "click");
                goUpLevel();
            }
        });

        Button jumpBeginningButton = (Button) findViewById(R.id.jumpBeginningButton);
        jumpBeginningButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                Collect.getInstance().getActivityLogger().logInstanceAction(this, "jumpToBeginning", "click");
                Collect.getInstance().getFormController().jumpToIndex(FormIndex
                        .createBeginningOfFormIndex());
                setResult(RESULT_OK);
                finish();
            }
        });

        Button jumpEndButton = (Button) findViewById(R.id.jumpEndButton);
        jumpEndButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                Collect.getInstance().getActivityLogger().logInstanceAction(this, "jumpToEnd", "click");
                Collect.getInstance().getFormController().jumpToIndex(FormIndex.createEndOfFormIndex());
                setResult(RESULT_OK);
                finish();
            }
        });

        refreshView();

        // kinda slow, but works.
        // this scrolls to the last question the user was looking at
        if (getListAdapter() != null && getListView() != null) {
            getListView().post(new Runnable() {
                @Override
                public void run() {
                    int position = 0;
                    int count = getListAdapter().getCount();
                    for (int i = 0; i < count; i++) {
                        HierarchyElement he = (HierarchyElement) getListAdapter().getItem(i);
                        if (mStartIndex.equals(he.getFormIndex())) {
                            position = i;
                            break;
                        }
                    }
                    getListView().setSelection(position);
                }
            });
        }
    }

    @Override
    protected void onStart() {
    	super.onStart();
		Collect.getInstance().getActivityLogger().logOnStart(this);
    }

    @Override
    protected void onStop() {
		Collect.getInstance().getActivityLogger().logOnStop(this);
    	super.onStop();
    }

    private void goUpLevel() {
    	Collect.getInstance().getFormController().stepToOuterScreenEvent();

        refreshView();
    }


    private String getCurrentPath() {
    	FormController formController = Collect.getInstance().getFormController();
        FormIndex index = formController.getFormIndex();
        // move to enclosing group...
        index = formController.stepIndexOut(index);

        String path = "";
        while (index != null) {

            path =
            		formController.getCaptionPrompt(index).getLongText()
                        + " ("
                        + (formController.getCaptionPrompt(index)
                                .getMultiplicity() + 1) + ") > " + path;

            index = formController.stepIndexOut(index);
        }
        // return path?
        return path.substring(0, path.length() - 2);
    }


    public void refreshView() {
        try {
            FormController formController = Collect.getInstance().getFormController();
            // Record the current index so we can return to the same place if the user hits 'back'.
            currentIndex = formController.getFormIndex();

            // If we're not at the first level, we're inside a repeated group so we want to only display
            // everything enclosed within that group.
            String contextGroupRef = "";
            formList = new ArrayList<HierarchyElement>();

            // If we're currently at a repeat node, record the name of the node and step to the next
            // node to display.
            if (formController.getEvent() == FormEntryController.EVENT_REPEAT) {
            	contextGroupRef =
                        formController.getFormIndex().getReference().toString(true);
                formController.stepToNextEvent(FormController.STEP_INTO_GROUP);
            } else {
                FormIndex startTest = formController.stepIndexOut(currentIndex);
                // If we have a 'group' tag, we want to step back until we hit a repeat or the
                // beginning.
                while (startTest != null
                        && formController.getEvent(startTest) == FormEntryController.EVENT_GROUP) {
                    startTest = formController.stepIndexOut(startTest);
                }
                if (startTest == null) {
                    // check to see if the question is at the first level of the hierarchy. If it is,
                    // display the root level from the beginning.
                    formController.jumpToIndex(FormIndex
                            .createBeginningOfFormIndex());
                } else {
                    // otherwise we're at a repeated group
                    formController.jumpToIndex(startTest);
                }

                // now test again for repeat. This should be true at this point or we're at the
                // beginning
                if (formController.getEvent() == FormEntryController.EVENT_REPEAT) {
                	contextGroupRef =
                            formController.getFormIndex().getReference().toString(true);
                    formController.stepToNextEvent(FormController.STEP_INTO_GROUP);
                }
            }

            int event = formController.getEvent();
            if (event == FormEntryController.EVENT_BEGINNING_OF_FORM) {
                // The beginning of form has no valid prompt to display.
                formController.stepToNextEvent(FormController.STEP_INTO_GROUP);
                contextGroupRef = formController.getFormIndex().getReference().getParentRef().toString(true);
                mPath.setVisibility(View.GONE);
                jumpPreviousButton.setEnabled(false);
            } else {
                mPath.setVisibility(View.VISIBLE);
                mPath.setText(getCurrentPath());
                jumpPreviousButton.setEnabled(true);
            }

            // Refresh the current event in case we did step forward.
            event = formController.getEvent();

            // Big change from prior implementation:
            //
            // The ref strings now include the instance number designations
            // i.e., [0], [1], etc. of the repeat groups (and also [1] for
            // non-repeat elements).
            //
            // The contextGroupRef is now also valid for the top-level form.
            //
            // The repeatGroupRef is null if we are not skipping a repeat
            // section.
            //
            String repeatGroupRef = null;

            event_search: while (event != FormEntryController.EVENT_END_OF_FORM) {

        		// get the ref to this element
        		String currentRef = formController.getFormIndex().getReference().toString(true);

        		// retrieve the current group
        		String curGroup = (repeatGroupRef == null) ? contextGroupRef : repeatGroupRef;

        		if (!currentRef.startsWith(curGroup)) {
                    // We have left the current group
        			if ( repeatGroupRef == null ) {
        				// We are done.
        				break event_search;
        			} else {
        				// exit the inner repeat group
        				repeatGroupRef = null;
        			}
                }

        		if (repeatGroupRef != null) {
                    // We're in a repeat group within the one we want to list
                	// skip this question/group/repeat and move to the next index.
                    event = formController.stepToNextEvent(FormController.STEP_INTO_GROUP);
                    continue;
                }

        		switch (event) {
                    case FormEntryController.EVENT_QUESTION:
                        FormEntryPrompt fp = formController.getQuestionPrompt();
                        String label = fp.getLongText();
                        if ( !fp.isReadOnly() || (label != null && label.length() > 0) ) {
                            // show the question if it is an editable field.
                            // or if it is read-only and the label is not blank.
                            formList.add(new HierarchyElement(fp.getLongText(), fp.getAnswerText(), null,
                                    Color.WHITE, QUESTION, fp.getIndex()));
                        }
                        break;
                    case FormEntryController.EVENT_GROUP:
                        // ignore group events
                        break;
                    case FormEntryController.EVENT_PROMPT_NEW_REPEAT:
                    	// this would display the 'add new repeat' dialog
                    	// ignore it.
                        break;
                    case FormEntryController.EVENT_REPEAT:
                        FormEntryCaption fc = formController.getCaptionPrompt();
                        // push this repeat onto the stack.
                        repeatGroupRef = currentRef;
                        // Because of the guard conditions above, we will skip
                        // everything until we exit this repeat.
                        //
                        // Note that currentRef includes the multiplicity of the
                        // repeat (e.g., [0], [1], ...), so every repeat will be
                        // detected as different and reach this case statement.
                        // Only the [0] emits the repeat header.
                        // Every one displays the descend-into action element.

                        if (fc.getMultiplicity() == 0) {
                            // Display the repeat header for the group.
                            HierarchyElement group =
                                new HierarchyElement(fc.getLongText(), null, getResources()
                                        .getDrawable(R.drawable.expander_ic_minimized), Color.WHITE,
                                        COLLAPSED, fc.getIndex());
                            formList.add(group);
                        }
                        // Add this group name to the drop down list for this repeating group.
                        HierarchyElement h = formList.get(formList.size() - 1);
                        h.addChild(new HierarchyElement(mIndent + fc.getLongText() + " "
                                + (fc.getMultiplicity() + 1), null, null, Color.WHITE, CHILD, fc
                                .getIndex()));
                        break;
            	}
                event =
                        formController.stepToNextEvent(FormController.STEP_INTO_GROUP);
            }

            HierarchyListAdapter itla = new HierarchyListAdapter(this);
            itla.setListItems(formList);
            setListAdapter(itla);

            // set the controller back to the current index in case the user hits 'back'
            formController.jumpToIndex(currentIndex);
        } catch (Exception e) {
            Log.e(t, e.getMessage(), e);
            createErrorDialog(e.getMessage());
        }
    }

    /**
     * Creates and displays dialog with the given errorMsg.
     */
    private void createErrorDialog(String errorMsg) {
        Collect.getInstance()
                .getActivityLogger()
                .logInstanceAction(this, "createErrorDialog", "show.");

        AlertDialog alertDialog = new AlertDialog.Builder(this).create();

        alertDialog.setIcon(android.R.drawable.ic_dialog_info);
        alertDialog.setTitle(getString(R.string.error_occured));
        alertDialog.setMessage(errorMsg);
        DialogInterface.OnClickListener errorListener = new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int i) {
                switch (i) {
                    case DialogInterface.BUTTON_POSITIVE:
                        Collect.getInstance().getActivityLogger()
                                .logInstanceAction(this, "createErrorDialog", "OK");
                        FormController formController = Collect.getInstance().getFormController();
                        formController.jumpToIndex(currentIndex);
                        break;
                }
            }
        };
        alertDialog.setCancelable(false);
        alertDialog.setButton(getString(R.string.ok), errorListener);
        alertDialog.show();
    }

    @Override
    protected void onListItemClick(ListView l, View v, int position, long id) {
        HierarchyElement h = (HierarchyElement) l.getItemAtPosition(position);
        FormIndex index = h.getFormIndex();
        if (index == null) {
            goUpLevel();
            return;
        }

        switch (h.getType()) {
            case EXPANDED:
                Collect.getInstance().getActivityLogger().logInstanceAction(this, "onListItemClick", "COLLAPSED", h.getFormIndex());
                h.setType(COLLAPSED);
                ArrayList<HierarchyElement> children = h.getChildren();
                for (int i = 0; i < children.size(); i++) {
                    formList.remove(position + 1);
                }
                h.setIcon(getResources().getDrawable(R.drawable.expander_ic_minimized));
                h.setColor(Color.WHITE);
                break;
            case COLLAPSED:
                Collect.getInstance().getActivityLogger().logInstanceAction(this, "onListItemClick", "EXPANDED", h.getFormIndex());
                h.setType(EXPANDED);
                ArrayList<HierarchyElement> children1 = h.getChildren();
                for (int i = 0; i < children1.size(); i++) {
                    Log.i(t, "adding child: " + children1.get(i).getFormIndex());
                    formList.add(position + 1 + i, children1.get(i));

                }
                h.setIcon(getResources().getDrawable(R.drawable.expander_ic_maximized));
                h.setColor(Color.WHITE);
                break;
            case QUESTION:
                Collect.getInstance().getActivityLogger().logInstanceAction(this, "onListItemClick", "QUESTION-JUMP", index);
                Collect.getInstance().getFormController().jumpToIndex(index);
            	if ( Collect.getInstance().getFormController().indexIsInFieldList() ) {
                    try {
                        Collect.getInstance().getFormController().stepToPreviousScreenEvent();
                    } catch (JavaRosaException e) {
                        Log.e(t, e.getMessage(), e);
                        createErrorDialog(e.getCause().getMessage());
                        return;
                    }
                }
                setResult(RESULT_OK);
                finish();
                return;
            case CHILD:
                Collect.getInstance().getActivityLogger().logInstanceAction(this, "onListItemClick", "REPEAT-JUMP", h.getFormIndex());
                Collect.getInstance().getFormController().jumpToIndex(h.getFormIndex());
                setResult(RESULT_OK);
                refreshView();
                return;
        }

        // Should only get here if we've expanded or collapsed a group
        HierarchyListAdapter itla = new HierarchyListAdapter(this);
        itla.setListItems(formList);
        setListAdapter(itla);
        getListView().setSelection(position);
    }


    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        switch (keyCode) {
            case KeyEvent.KEYCODE_BACK:
                Collect.getInstance().getActivityLogger().logInstanceAction(this, "onKeyDown", "KEYCODE_BACK.JUMP", mStartIndex);
                Collect.getInstance().getFormController().jumpToIndex(mStartIndex);
        }
        return super.onKeyDown(keyCode, event);
    }

}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.activities;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.database.Cursor;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.preference.PreferenceManager;
import android.provider.MediaStore.Images;
import android.support.annotation.Nullable;
import android.util.Log;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewTreeObserver;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.ScrollView;
import android.widget.TextView;
import android.widget.Toast;

import org.javarosa.core.model.FormIndex;
import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.instance.FormInstance;
import org.javarosa.core.model.instance.TreeElement;
import org.javarosa.core.model.instance.TreeReference;
import org.javarosa.form.api.FormEntryCaption;
import org.javarosa.form.api.FormEntryController;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.exception.JavaRosaException;
import org.odk.collect.android.listeners.FormLoaderListener;
import org.odk.collect.android.listeners.FormSavedListener;
import org.odk.collect.android.listeners.SavePointListener;
import org.odk.collect.android.logic.FormController;
import org.odk.collect.android.logic.FormController.FailedConstraint;
import org.odk.collect.android.logic.FormTraverser;
import org.odk.collect.android.logic.FormVisitor;
import org.odk.collect.android.model.Patient;
import org.odk.collect.android.model.Preset;
import org.odk.collect.android.preferences.PreferencesActivity;
import org.odk.collect.android.provider.FormsProviderAPI.FormsColumns;
import org.odk.collect.android.provider.InstanceProviderAPI.InstanceColumns;
import org.odk.collect.android.tasks.FormLoaderTask;
import org.odk.collect.android.tasks.SavePointTask;
import org.odk.collect.android.tasks.SaveResult;
import org.odk.collect.android.tasks.SaveToDiskTask;
import org.odk.collect.android.utilities.CompatibilityUtils;
import org.odk.collect.android.utilities.FileUtils;
import org.odk.collect.android.utilities.MediaUtils;
import org.odk.collect.android.utilities.Utils;
import org.odk.collect.android.views.ODKView;
import org.odk.collect.android.widgets.QuestionWidget;

import java.io.File;
import java.io.FileFilter;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Vector;

import static org.odk.collect.android.utilities.Utils.eq;

//import android.view.GestureDetector;
//import android.view.GestureDetector.OnGestureListener;

/**
 * FormEntryActivity is responsible for displaying questions, animating
 * transitions between questions, and allowing the user to enter data.
 *
 * @author Carl Hartung (carlhartung@gmail.com)
 * @author Thomas Smyth, Sassafras Tech Collective (tom@sassafrastech.com; constraint behavior option)
 */
public class FormEntryActivity
        extends Activity implements FormLoaderListener, FormSavedListener, SavePointListener {

	private static final String TAG = FormEntryActivity.class.getName();

	// save with every swipe forward or back. Timings indicate this takes .25
	// seconds.
	// if it ever becomes an issue, this value can be changed to save every n'th
	// screen.
//	private static final int SAVEPOINT_INTERVAL = 1;

	// Defines for FormEntryActivity
	private static final boolean EXIT = true;
	private static final boolean DO_NOT_EXIT = false;
	private static final boolean EVALUATE_CONSTRAINTS = true;
	private static final boolean DO_NOT_EVALUATE_CONSTRAINTS = false;

	// Request codes for returning data from specified intent.
	public static final int IMAGE_CAPTURE = 1;
	public static final int BARCODE_CAPTURE = 2;
	public static final int AUDIO_CAPTURE = 3;
	public static final int VIDEO_CAPTURE = 4;
	public static final int LOCATION_CAPTURE = 5;
//	public static final int HIERARCHY_ACTIVITY = 6;
	public static final int IMAGE_CHOOSER = 7;
	public static final int AUDIO_CHOOSER = 8;
	public static final int VIDEO_CHOOSER = 9;
	public static final int EX_STRING_CAPTURE = 10;
	public static final int EX_INT_CAPTURE = 11;
	public static final int EX_DECIMAL_CAPTURE = 12;
	public static final int DRAW_IMAGE = 13;
	public static final int SIGNATURE_CAPTURE = 14;
	public static final int ANNOTATE_IMAGE = 15;
	public static final int ALIGNED_IMAGE = 16;
	public static final int BEARING_CAPTURE = 17;
    public static final int EX_GROUP_CAPTURE = 18;

	// Extra returned from gp activity
	public static final String LOCATION_RESULT = "LOCATION_RESULT";
	public static final String BEARING_RESULT = "BEARING_RESULT";

	public static final String KEY_INSTANCES = "instances";
	public static final String KEY_SUCCESS = "success";
	public static final String KEY_ERROR = "error";

	// Identifies the gp of the form used to launch form entry
	public static final String KEY_FORMPATH = "formpath";

	// Identifies whether this is a new form, or reloading a form after a screen
	// rotation (or similar)
	private static final String NEWFORM = "newform";
	// these are only processed if we shut down and are restoring after an
	// external intent fires

	public static final String KEY_INSTANCEPATH = "instancepath";
	public static final String KEY_XPATH = "xpath";
	public static final String KEY_XPATH_WAITING_FOR_DATA = "xpathwaiting";

	// Tracks whether we are autosaving
	public static final String KEY_AUTO_SAVED = "autosaved";

//	private static final int MENU_LANGUAGES = Menu.FIRST;
//	private static final int MENU_HIERARCHY_VIEW = Menu.FIRST + 1;
//    private static final int MENU_CANCEL = Menu.FIRST;
//	private static final int MENU_SAVE = MENU_CANCEL + 1;
//	private static final int MENU_PREFERENCES = Menu.FIRST + 3;

	private static final int PROGRESS_DIALOG = 1;
	private static final int SAVING_DIALOG = 2;

    // Alert dialog styling.
    private static final float ALERT_DIALOG_TEXT_SIZE = 32.0f;
    private static final float ALERT_DIALOG_TITLE_TEXT_SIZE = 34.0f;
    private static final int ALERT_DIALOG_PADDING = 32;

    private boolean mAutoSaved;

	// Random ID
	private static final int DELETE_REPEAT = 654321;

	private String mFormPath;
//	private GestureDetector mGestureDetector;
//
//	private Animation mInAnimation;
//	private Animation mOutAnimation;
//	private View mStaleView = null;

    private ScrollView mScrollView;
	private LinearLayout mQuestionHolder;
	private View mCurrentView;
    private ImageButton mUpButton;
    private ImageButton mDownButton;

    private Button mCancelButton;
    private Button mDoneButton;

	private AlertDialog mAlertDialog;
	private ProgressDialog mProgressDialog;
	private String mErrorMessage;

	// used to limit forward/backward swipes to one per question
//	private boolean mBeenSwiped = false;

    private final Object saveDialogLock = new Object();
	private int viewCount = 0;

	private FormLoaderTask mFormLoaderTask;
	private SaveToDiskTask mSaveToDiskTask;

    private String stepMessage = "";
    private ODKView mTargetView;
    private Map<FormIndex, IAnswerData> mOriginalAnswerData;

    private static final double MAX_SCROLL_FRACTION = 0.9; // fraction of mScrollView height
    private View mBottomPaddingView;

    // ScrollY values that we try to scroll to when paging up and down.
    private List<Integer> mPageBreaks = new ArrayList<>();

    private enum ScrollDirection {UP, DOWN}

    public static Locale locale;

//	enum AnimationType {
//		LEFT, RIGHT, FADE
//	}

//	private SharedPreferences mAdminPreferences;


	@Override protected void attachBaseContext(Context base) {
		super.attachBaseContext(applyLocaleSetting(base));
	}

	public Context applyLocaleSetting(Context base) {
		Locale.setDefault(locale);
		Resources resources = base.getResources();
		Configuration config = resources.getConfiguration();
		config.setLocale(locale);
		config.setLayoutDirection(locale);
		return base.createConfigurationContext(config);
	}

	/** Called when the activity is first created. */
	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);

		// must be at the beginning of any activity that can be called from an
		// external intent
		try {
			Collect.getInstance().createODKDirs();
		} catch (RuntimeException e) {
			createErrorDialog(e.getMessage(), EXIT);
			return;
		}

		setContentView(R.layout.form_entry);

        setTitle(getString(R.string.title_loading_form));

		// Turn the action bar icon into a "back" arrow that goes back in the activity stack.
		getActionBar().setIcon(R.drawable.ic_back_36dp);
		getActionBar().setDisplayHomeAsUpEnabled(true);

		//
//		setTitle(getString(R.string.app_name) + " > "
//				+ getString(R.string.loading_form));

        mErrorMessage = null;

//        mBeenSwiped = false;
		mAlertDialog = new AlertDialog.Builder(this)
                .setIcon(android.R.drawable.ic_dialog_info)
                .setTitle(getString(R.string.title_discard_observations))
                //.setMessage(R.string.observations_are_you_sure)
                .setPositiveButton(
                        R.string.yes,
                        new DialogInterface.OnClickListener() {

                            @Override
                            public void onClick(DialogInterface dialog, int i) {
                                finish();
                            }
                        }
                )
                .setNegativeButton(R.string.no, null)
                .create();

		mCurrentView = null;
//		mInAnimation = null;
//		mOutAnimation = null;
//		mGestureDetector = new GestureDetector(this, this);
        mScrollView = (ScrollView) findViewById(R.id.question_holder_scroller);
		mQuestionHolder = (LinearLayout) findViewById(R.id.questionholder);

        findViewById(R.id.button_up).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                scrollPage(ScrollDirection.UP);
            }
        });
        findViewById(R.id.button_down).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                scrollPage(ScrollDirection.DOWN);
            }
        });

        mCancelButton = (Button) findViewById(R.id.form_entry_button_cancel);
        mCancelButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                if (allContentsUnchanged()) {
                    finish();
                } else {
                    showAlertDialog();
                }
            }
        });

        mDoneButton = (Button) findViewById(R.id.form_entry_button_done);
        mDoneButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Collect.getInstance()
                        .getActivityLogger()
                        .logInstanceAction(this, "onOptionsItemSelected",
                                "MENU_SAVE");

                InputMethodManager imm = (InputMethodManager) getSystemService(
                        Context.INPUT_METHOD_SERVICE);
                imm.hideSoftInputFromWindow(findViewById(android.R.id.content).getWindowToken(), 0);

                saveDataToDisk(EXIT, true /*complete*/, null);
            }
        });

        // get admin preference settings
//		mAdminPreferences = getSharedPreferences(
//				AdminPreferencesActivity.ADMIN_PREFERENCES, 0);

		String startingXPath = null;
		String waitingXPath = null;
		String instancePath = null;
		Boolean newForm = true;
		mAutoSaved = false;
		if (savedInstanceState != null) {
			if (savedInstanceState.containsKey(KEY_FORMPATH)) {
				mFormPath = savedInstanceState.getString(KEY_FORMPATH);
			}
			if (savedInstanceState.containsKey(KEY_INSTANCEPATH)) {
				instancePath = savedInstanceState.getString(KEY_INSTANCEPATH);
			}
			if (savedInstanceState.containsKey(KEY_XPATH)) {
				startingXPath = savedInstanceState.getString(KEY_XPATH);
				Log.i(TAG, "startingXPath is: " + startingXPath);
			}
			if (savedInstanceState.containsKey(KEY_XPATH_WAITING_FOR_DATA)) {
				waitingXPath = savedInstanceState
						.getString(KEY_XPATH_WAITING_FOR_DATA);
				Log.i(TAG, "waitingXPath is: " + waitingXPath);
			}
			if (savedInstanceState.containsKey(NEWFORM)) {
				newForm = savedInstanceState.getBoolean(NEWFORM, true);
			}
			if (savedInstanceState.containsKey(KEY_ERROR)) {
				mErrorMessage = savedInstanceState.getString(KEY_ERROR);
			}
			if (savedInstanceState.containsKey(KEY_AUTO_SAVED)) {
			    mAutoSaved = savedInstanceState.getBoolean(KEY_AUTO_SAVED);
			}
		}

		// If a parse error message is showing then nothing else is loaded
		// Dialogs mid form just disappear on rotation.
		if (mErrorMessage != null) {
			createErrorDialog(mErrorMessage, EXIT);
			return;
		}

		// Check to see if this is a screen flip or a new form load.
		Object data = getLastNonConfigurationInstance();
		if (data instanceof FormLoaderTask) {
			mFormLoaderTask = (FormLoaderTask) data;
		} else if (data instanceof SaveToDiskTask) {
			mSaveToDiskTask = (SaveToDiskTask) data;
		} else if (data == null) {
			if (!newForm) {
				if (Collect.getInstance().getFormController() != null) {
					populateViews((Preset) getIntent().getParcelableExtra("fields"));
				} else {
					Log.w(TAG, "Reloading form and restoring state.");
					// we need to launch the form loader to load the form
					// controller...
					mFormLoaderTask = new FormLoaderTask(instancePath,
							startingXPath, waitingXPath);
					Collect.getInstance().getActivityLogger()
							.logAction(this, "formReloaded", mFormPath);
                    // TODO: this doesn't work (dialog does not get removed):
					// showDialog(PROGRESS_DIALOG);
					// show dialog before we execute...
					mFormLoaderTask.execute(mFormPath);
				}
				return;
			}

			// Not a restart from a screen orientation change (or other).
			Collect.getInstance().setFormController(null);
			CompatibilityUtils.invalidateOptionsMenu(this);

			Intent intent = getIntent();
			if (intent != null) {
				Uri uri = intent.getData();

				if (getContentResolver().getType(uri).equals(InstanceColumns.CONTENT_ITEM_TYPE)) {
					// get the formId and version for this instance...
					String jrFormId = null;
					String jrVersion = null;
					{
						Cursor instanceCursor = null;
						try {
							instanceCursor = getContentResolver().query(uri,
									null, null, null, null);
							if (instanceCursor.getCount() != 1) {
								Log.w(TAG, "No form instance found for URI " + uri);
								this.createErrorDialog("Bad URI: " + uri, EXIT);
								return;
							} else {
								instanceCursor.moveToFirst();
								instancePath = instanceCursor
										.getString(instanceCursor
												.getColumnIndex(InstanceColumns.INSTANCE_FILE_PATH));
								Collect.getInstance()
										.getActivityLogger()
										.logAction(this, "instanceLoaded",
												instancePath);

								jrFormId = instanceCursor
										.getString(instanceCursor
												.getColumnIndex(InstanceColumns.JR_FORM_ID));
								int idxJrVersion = instanceCursor
										.getColumnIndex(InstanceColumns.JR_VERSION);

								jrVersion = instanceCursor.isNull(idxJrVersion) ? null
										: instanceCursor
												.getString(idxJrVersion);
							}
						} finally {
							if (instanceCursor != null) {
								instanceCursor.close();
							}
						}
					}

					String[] selectionArgs;
					String selection;

					if (jrVersion == null) {
						selectionArgs = new String[] { jrFormId };
						selection = FormsColumns.JR_FORM_ID + "=? AND "
								+ FormsColumns.JR_VERSION + " IS NULL";
					} else {
						selectionArgs = new String[] { jrFormId, jrVersion };
						selection = FormsColumns.JR_FORM_ID + "=? AND "
								+ FormsColumns.JR_VERSION + "=?";
					}

					{
						Cursor formCursor = null;
						try {
							formCursor = getContentResolver().query(
									FormsColumns.CONTENT_URI, null, selection,
									selectionArgs, null);
							if (formCursor.getCount() == 1) {
								formCursor.moveToFirst();
								mFormPath = formCursor
										.getString(formCursor
												.getColumnIndex(FormsColumns.FORM_FILE_PATH));
							} else if (formCursor.getCount() < 1) {
								this.createErrorDialog(
										getString(
												R.string.parent_form_not_present,
												jrFormId)
												+ ((jrVersion == null) ? ""
														: "\n"
																+ getString(R.string.version)
																+ " "
																+ jrVersion),
										EXIT);
								return;
							} else if (formCursor.getCount() > 1) {
								// still take the first entry, but warn that
								// there are multiple rows.
								// user will need to hand-edit the SQLite
								// database to fix it.
								formCursor.moveToFirst();
								mFormPath = formCursor.getString(formCursor.getColumnIndex(FormsColumns.FORM_FILE_PATH));
								this.createErrorDialog(getString(R.string.survey_multiple_forms_error),	EXIT);
                                return;
							}
						} finally {
							if (formCursor != null) {
								formCursor.close();
							}
						}
					}
				} else if (getContentResolver().getType(uri).equals(FormsColumns.CONTENT_ITEM_TYPE)) {
					Cursor c = null;
					try {
						c = getContentResolver().query(uri, null, null, null,
								null);
						if (c.getCount() != 1) {
							Log.w(TAG, "No form found for URI " + uri);
							this.createErrorDialog("Bad URI: " + uri, EXIT);
							return;
						} else {
							c.moveToFirst();
							mFormPath = c.getString(c.getColumnIndex(FormsColumns.FORM_FILE_PATH));
							// This is the fill-blank-form code path.
							// See if there is a savepoint for this form that
							// has never been
							// explicitly saved
							// by the user. If there is, open this savepoint
							// (resume this filled-in
							// form).
							// Savepoints for forms that were explicitly saved
							// will be recovered
							// when that
							// explicitly saved instance is edited via
							// edit-saved-form.
							final String filePrefix = mFormPath.substring(
									mFormPath.lastIndexOf('/') + 1,
									mFormPath.lastIndexOf('.'))
									+ "_";
							final String fileSuffix = ".xml.save";
							File cacheDir = new File(Collect.getInstance().getCachePath());
							File[] files = cacheDir.listFiles(new FileFilter() {
								@Override
								public boolean accept(File pathname) {
									String name = pathname.getName();
									return name.startsWith(filePrefix)
											&& name.endsWith(fileSuffix);
								}
							});
							// see if any of these savepoints are for a
							// filled-in form that has never been
							// explicitly saved by the user...
							for (int i = 0; i < files.length; ++i) {
								File candidate = files[i];
								String instanceDirName = candidate.getName()
										.substring(
												0,
												candidate.getName().length()
														- fileSuffix.length());
								File instanceDir = new File(
										Collect.getInstance().getInstancesPath() + File.separator
												+ instanceDirName);
								File instanceFile = new File(instanceDir,
										instanceDirName + ".xml");
								if (instanceDir.exists()
										&& instanceDir.isDirectory()
										&& !instanceFile.exists()) {
									// yes! -- use this savepoint file
									instancePath = instanceFile
											.getAbsolutePath();
									break;
								}
							}
						}
					} finally {
						if (c != null) {
							c.close();
						}
					}
				} else {
					Log.e(TAG, "unrecognized URI");
					this.createErrorDialog("Unrecognized URI: " + uri, EXIT);
					return;
				}

				mFormLoaderTask = new FormLoaderTask(instancePath, null, null);
				Collect.getInstance().getActivityLogger()
						.logAction(this, "formLoaded", mFormPath);
				showDialog(PROGRESS_DIALOG);
				// show dialog before we execute...
				mFormLoaderTask.execute(mFormPath);
			}
		}
	}

    private void populateViews(Preset preset) {
        FormTraverser traverser = new FormTraverser.Builder()
                .addVisitor(new QuestionHolderFormVisitor(preset))
                .build();
        traverser.traverse(Collect.getInstance().getFormController());

        mBottomPaddingView = new View(this);
        mBottomPaddingView.setLayoutParams(
                new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 0));
        mQuestionHolder.addView(mBottomPaddingView);

        // After the form elements have all been sized and laid out, figure out
        // where (vertically) the up/down buttons should jump to.
        mScrollView.getViewTreeObserver().addOnGlobalLayoutListener(
                new ViewTreeObserver.OnGlobalLayoutListener() {
                    @Override
                    public void onGlobalLayout() {
                        paginate();
                    }
                }
        );

        if (mTargetView != null) {
            (new Handler(Looper.getMainLooper())).post(new Runnable() {
                @Override
                public void run() {
                    mScrollView.scrollTo(0, mTargetView.getTop());
                }
            });
        }

        // Store any pre-populated answers to enable performing a diff later on.
        mOriginalAnswerData = getAnswers();
    }

    /**
     * Determines the vertical positions that the up/down buttons will jump to.
     * These positions are selected so that the height of each page is up to
     * MAX_SCROLL_FRACTION of the ScrollView's height, and (if possible) each
     * page break is at the top edge of a group or question.
     */
    private void paginate() {
        // Gather a list of the top edges of the question groups and widgets.
        List<Integer> edges = new ArrayList<>();
        for (int i = 0; i < mQuestionHolder.getChildCount(); i++) {
            View child = mQuestionHolder.getChildAt(i);
            edges.add(child.getTop());
            if (child instanceof ODKView) {
                List<QuestionWidget> widgets = ((ODKView) child).getWidgets();
                // Skip the first widget: it's better to land above the group title
                // than between the group title and the first question widget.
                for (int j = 1; j < widgets.size(); j++) {
                    edges.add(child.getTop() + widgets.get(j).getTop());
                }
            }
        }

        // Select a subset of these edges to be the page breaks.  Dividing the
        // form into fixed pages ensures that each question appears at a fixed
        // vertical position on the screen within its page, which helps keep
        // the user oriented.
        int maxPageHeight = (int) (mScrollView.getMeasuredHeight() * MAX_SCROLL_FRACTION);
        mPageBreaks.clear();
        mPageBreaks.add(0);
        int prevBreak = 0;
        int nextBreak = prevBreak + maxPageHeight;
        for (int y : edges) {
            while (y > prevBreak + maxPageHeight) { // next edge won't land on this page
                mPageBreaks.add(nextBreak);
                prevBreak = nextBreak;
                // Usually this initial value of nextBreak will be overwritten
                // by a value from edges (nextBreak = y below); this value is
                // just a fallback in case the nearest edge is too far away.
                nextBreak = prevBreak + maxPageHeight;
            }
            if (y > prevBreak) {
                nextBreak = y;
            }
        }

        // Add enough padding so that when the form is scrolled all the way to
        // the end, the last page break lands at the top of the ScrollView.
        // This can sometimes be a lot of padding (e.g. most of a page), but
        // we think the benefit of having a consistent n:1 relationship between
        // questions and pages is worth the occasionally large wasted space.
        int bottom = prevBreak + mScrollView.getMeasuredHeight();
        int paddingHeight = bottom - mBottomPaddingView.getTop();
        ViewGroup.LayoutParams params = mBottomPaddingView.getLayoutParams();
        if (params.height != paddingHeight) {
            // To avoid triggering an infinite loop, only invoke
            // requestLayout() when the height actually changes.
            params.height = paddingHeight;
            mBottomPaddingView.requestLayout();
        }
    }

    /**
     * Scrolls the form up or down to the next page break.  To keep the user
     * oriented, we always go to the nearest page break (even if it is nearby),
     * giving a consistent set of pages with a consistent layout on each page.
     */
    private void scrollPage(ScrollDirection direction) {
        int inc = direction == ScrollDirection.DOWN ? 1 : -1;
        int y = mScrollView.getScrollY();
        int n = mPageBreaks.size();
        for (int i = (inc > 0) ? 0 : n - 1; i >= 0 && i < n; i += inc) {
            int deltaY = mPageBreaks.get(i) - y;
            if (inc * deltaY > 0) {
                mScrollView.smoothScrollTo(0, y + deltaY);
                break;
            }
        }
    }

    private class QuestionHolderFormVisitor implements FormVisitor {
        private final Preset mPreset;

        public QuestionHolderFormVisitor(Preset preset) {
            mPreset = preset;
        }

        @Override
        public void visit(int event, FormController formController) {
            View view = createView(event, false /*advancingPage*/, mPreset);
            if (view != null) {
                mQuestionHolder.addView(view);
            }
        }
    }

    /**
     * Create save-points asynchronously in order to not affect swiping performance
     * on larger forms.
     */
    private void nonblockingCreateSavePointData() {
        try {
            SavePointTask savePointTask = new SavePointTask(this);
            savePointTask.execute();
        } catch (Exception e) {
            Log.e(TAG, "Could not schedule SavePointTask. Perhaps a lot of swiping is taking place?");
        }
    }

	@Override
	protected void onSaveInstanceState(Bundle outState) {
		super.onSaveInstanceState(outState);
		outState.putString(KEY_FORMPATH, mFormPath);
		FormController formController = Collect.getInstance()
				.getFormController();
		if (formController != null) {
			outState.putString(KEY_INSTANCEPATH, formController
					.getInstancePath().getAbsolutePath());
			outState.putString(KEY_XPATH,
					formController.getXPath(formController.getFormIndex()));
			FormIndex waiting = formController.getIndexWaitingForData();
			if (waiting != null) {
				outState.putString(KEY_XPATH_WAITING_FOR_DATA,
						formController.getXPath(waiting));
			}
			// save the instance to a temp path...
			nonblockingCreateSavePointData();
		}
		outState.putBoolean(NEWFORM, false);
		outState.putString(KEY_ERROR, mErrorMessage);
		outState.putBoolean(KEY_AUTO_SAVED, mAutoSaved);
	}

	@Override
	protected void onActivityResult(int requestCode, int resultCode,
			Intent intent) {
		super.onActivityResult(requestCode, resultCode, intent);
		FormController formController = Collect.getInstance()
				.getFormController();
		if (formController == null) {
			// we must be in the midst of a reload of the FormController.
			// try to save this callback data to the FormLoaderTask
			if (mFormLoaderTask != null
					&& mFormLoaderTask.getStatus() != AsyncTask.Status.FINISHED) {
				mFormLoaderTask.setActivityResult(requestCode, resultCode,
						intent);
			} else {
				Log.e(TAG,
						"Got an activityResult without any pending form loader");
			}
			return;
		}

		if (resultCode == RESULT_CANCELED) {
			// request was canceled...
//			if (requestCode != HIERARCHY_ACTIVITY) {
				((ODKView) mCurrentView).cancelWaitingForBinaryData();
//			}
			return;
		}

		switch (requestCode) {
            case BARCODE_CAPTURE:
                String sb = intent.getStringExtra("SCAN_RESULT");
                ((ODKView) mCurrentView).setBinaryData(sb);
                saveAnswersForCurrentScreen(DO_NOT_EVALUATE_CONSTRAINTS);
                break;
            case EX_STRING_CAPTURE:
            case EX_INT_CAPTURE:
            case EX_DECIMAL_CAPTURE:
                String key = "value";
                boolean exists = intent.getExtras().containsKey(key);
                if (exists) {
                    Object externalValue = intent.getExtras().get(key);
                    ((ODKView) mCurrentView).setBinaryData(externalValue);
                    saveAnswersForCurrentScreen(DO_NOT_EVALUATE_CONSTRAINTS);
                }
                break;
            case EX_GROUP_CAPTURE:
                try {
                    Bundle extras = intent.getExtras();
                    ((ODKView) mCurrentView).setDataForFields(extras);
                } catch (JavaRosaException e) {
                    Log.e(TAG, e.getMessage(), e);
                    createErrorDialog(e.getCause().getMessage(), DO_NOT_EXIT);
                }
                break;
            case DRAW_IMAGE:
            case ANNOTATE_IMAGE:
            case SIGNATURE_CAPTURE:
            case IMAGE_CAPTURE:
                /*
                 * We saved the image to the tempfile_path, but we really want it to
                 * be in: /sdcard/odk/instances/[current instnace]/something.jpg so
                 * we move it there before inserting it into the content provider.
                 * Once the android image capture bug gets fixed, (read, we move on
                 * from Android 1.6) we want to handle images the audio and video
                 */
                // The intent is empty, but we know we saved the image to the temp
                // file
                File fi = new File(Collect.getInstance().getTmpFilePath());
                String mInstanceFolder = formController.getInstancePath()
                        .getParent();
                String s = mInstanceFolder + File.separator
                        + System.currentTimeMillis() + ".jpg";

                File nf = new File(s);
                if (!fi.renameTo(nf)) {
                    Log.e(TAG, "Failed to rename " + fi.getAbsolutePath());
                } else {
                    Log.i(TAG,
                            "renamed " + fi.getAbsolutePath() + " to "
                                    + nf.getAbsolutePath());
                }

                ((ODKView) mCurrentView).setBinaryData(nf);
                saveAnswersForCurrentScreen(DO_NOT_EVALUATE_CONSTRAINTS);
                break;
            case ALIGNED_IMAGE:
                /*
                 * We saved the image to the tempfile_path; the app returns the full
                 * path to the saved file in the EXTRA_OUTPUT extra. Take that file
                 * and move it into the instance folder.
                 */
                String path = intent
                        .getStringExtra(android.provider.MediaStore.EXTRA_OUTPUT);
                fi = new File(path);
                mInstanceFolder = formController.getInstancePath().getParent();
                s = mInstanceFolder + File.separator + System.currentTimeMillis()
                        + ".jpg";

                nf = new File(s);
                if (!fi.renameTo(nf)) {
                    Log.e(TAG, "Failed to rename " + fi.getAbsolutePath());
                } else {
                    Log.i(TAG,
                            "renamed " + fi.getAbsolutePath() + " to "
                                    + nf.getAbsolutePath());
                }

                ((ODKView) mCurrentView).setBinaryData(nf);
                saveAnswersForCurrentScreen(DO_NOT_EVALUATE_CONSTRAINTS);
                break;
            case IMAGE_CHOOSER:
                /*
                 * We have a saved image somewhere, but we really want it to be in:
                 * /sdcard/odk/instances/[current instnace]/something.jpg so we move
                 * it there before inserting it into the content provider. Once the
                 * android image capture bug gets fixed, (read, we move on from
                 * Android 1.6) we want to handle images the audio and video
                 */

                // get gp of chosen file
                Uri selectedImage = intent.getData();
                String sourceImagePath =
                        MediaUtils.getPathFromUri(this, selectedImage, Images.Media.DATA);

                // Copy file to sdcard
                String mInstanceFolder1 = formController.getInstancePath()
                        .getParent();
                String destImagePath = mInstanceFolder1 + File.separator
                        + System.currentTimeMillis() + ".jpg";

                File source = new File(sourceImagePath);
                File newImage = new File(destImagePath);
                FileUtils.copyFile(source, newImage);

                ((ODKView) mCurrentView).setBinaryData(newImage);
                saveAnswersForCurrentScreen(DO_NOT_EVALUATE_CONSTRAINTS);
                break;
            case AUDIO_CAPTURE:
            case VIDEO_CAPTURE:
            case AUDIO_CHOOSER:
            case VIDEO_CHOOSER:
                // For audio/video capture/chooser, we get the URI from the content
                // provider
                // then the widget copies the file and makes a new entry in the
                // content provider.
                Uri media = intent.getData();
                ((ODKView) mCurrentView).setBinaryData(media);
                saveAnswersForCurrentScreen(DO_NOT_EVALUATE_CONSTRAINTS);
                break;
            case LOCATION_CAPTURE:
                String sl = intent.getStringExtra(LOCATION_RESULT);
                ((ODKView) mCurrentView).setBinaryData(sl);
                saveAnswersForCurrentScreen(DO_NOT_EVALUATE_CONSTRAINTS);
                break;
            case BEARING_CAPTURE:
                String bearing = intent.getStringExtra(BEARING_RESULT);
                ((ODKView) mCurrentView).setBinaryData(bearing);
                saveAnswersForCurrentScreen(DO_NOT_EVALUATE_CONSTRAINTS);
//		case HIERARCHY_ACTIVITY:
//			// We may have jumped to a new index in hierarchy activity, so
//			// refresh
//			break;

		}
//		refreshCurrentView();
	}
//
//	/**
//	 * Refreshes the current view. the controller and the displayed view can get
//	 * out of sync due to dialogs and restarts caused by screen orientation
//	 * changes, so they're resynchronized here.
//	 */
//	public void refreshCurrentView() {
//		FormController formController = Collect.getInstance()
//				.getFormController();
//		int event = formController.getEvent();
//
//		// When we refresh, repeat dialog state isn't maintained, so step back
//		// to the previous
//		// question.
//		// Also, if we're within a group labeled 'field list', step back to the
//		// beginning of that
//		// group.
//		// That is, skip backwards over repeat prompts, groups that are not
//		// field-lists,
//		// repeat events, and indexes in field-lists that is not the containing
//		// group.
//		if (event == FormEntryController.EVENT_PROMPT_NEW_REPEAT) {
//			createRepeatDialog();
//		} else {
//			View current = createView(event, false);
//			showView(current, AnimationType.FADE);
//		}
//	}

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if(keyCode == KeyEvent.KEYCODE_BACK) {
            showAlertDialog();
            return true;
        }
        else {
            return super.onKeyDown(keyCode, event);
        }
    }

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		Collect.getInstance().getActivityLogger()
				.logInstanceAction(this, "onCreateOptionsMenu", "show");
		super.onCreateOptionsMenu(menu);

//        CompatibilityUtils.setShowAsAction(
//                menu.add(0, MENU_CANCEL, 0, R.string.cancel),
//                MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);

//		CompatibilityUtils.setShowAsAction(
//				menu.add(0, MENU_SAVE, 0, R.string.save_all_answers),
//				MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);

//		CompatibilityUtils.setShowAsAction(
//				menu.add(0, MENU_HIERARCHY_VIEW, 0, R.string.view_hierarchy)
//						.setIcon(R.drawable.ic_menu_goto),
//				MenuItem.SHOW_AS_ACTION_IF_ROOM);

//		CompatibilityUtils.setShowAsAction(
//				menu.add(0, MENU_LANGUAGES, 0, R.string.change_language)
//						.setIcon(R.drawable.ic_menu_start_conversation),
//				MenuItem.SHOW_AS_ACTION_NEVER);

//		CompatibilityUtils.setShowAsAction(
//				menu.add(0, MENU_PREFERENCES, 0, R.string.general_preferences)
//						.setIcon(R.drawable.ic_menu_preferences),
//				MenuItem.SHOW_AS_ACTION_NEVER);
		return true;
	}

	@Override
	public boolean onPrepareOptionsMenu(Menu menu) {
		super.onPrepareOptionsMenu(menu);

//        menu.findItem(MENU_CANCEL).setVisible(true).setEnabled(true);
//        menu.findItem(MENU_SAVE).setVisible(true).setEnabled(true);
//
//		FormController formController = Collect.getInstance()
//				.getFormController();
//
//		boolean useability;
//		useability = mAdminPreferences.getBoolean(
//				AdminPreferencesActivity.KEY_SAVE_MID, true);
//
//		menu.findItem(MENU_SAVE).setVisible(useability).setEnabled(useability);
//
//		useability = mAdminPreferences.getBoolean(
//				AdminPreferencesActivity.KEY_JUMP_TO, true);
//
//		menu.findItem(MENU_HIERARCHY_VIEW).setVisible(useability)
//				.setEnabled(useability);
//
//		useability = mAdminPreferences.getBoolean(
//				AdminPreferencesActivity.KEY_CHANGE_LANGUAGE, true)
//				&& (formController != null)
//				&& formController.getLanguages() != null
//				&& formController.getLanguages().length > 1;
//
//		menu.findItem(MENU_LANGUAGES).setVisible(useability)
//				.setEnabled(useability);
//
//		useability = mAdminPreferences.getBoolean(
//				AdminPreferencesActivity.KEY_ACCESS_SETTINGS, true);
//
//		menu.findItem(MENU_PREFERENCES).setVisible(useability)
//				.setEnabled(useability);
		return true;
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
//		FormController formController = Collect.getInstance()
//				.getFormController();
		switch (item.getItemId()) {
			case android.R.id.home :
				// Go back rather than reloading the activity, so that the patient list retains its
				// filter state.
				onBackPressed();
				return true;
////		case MENU_LANGUAGES:
////			Collect.getInstance()
////					.getActivityLogger()
////					.logInstanceAction(this, "onOptionsItemSelected",
////							"MENU_LANGUAGES");
////			createLanguageDialog();
////			return true;
//        case MENU_CANCEL:
//            showAlertDialog();
//            return true;
//		case MENU_SAVE:
//			Collect.getInstance()
//					.getActivityLogger()
//					.logInstanceAction(this, "onOptionsItemSelected",
//							"MENU_SAVE");

//            InputMethodManager imm = (InputMethodManager)getSystemService(
//                    Context.INPUT_METHOD_SERVICE);
//            imm.hideSoftInputFromWindow( findViewById(android.R.id.content).getWindowToken(), 0);

//			saveDataToDisk(EXIT, true /*complete*/, null);
//			return true;
//		case MENU_HIERARCHY_VIEW:
//			Collect.getInstance()
//					.getActivityLogger()
//					.logInstanceAction(this, "onOptionsItemSelected",
//							"MENU_HIERARCHY_VIEW");
//			if (formController.currentPromptIsQuestion()) {
//				saveAnswersForCurrentScreen(DO_NOT_EVALUATE_CONSTRAINTS);
//			}
//			Intent i = new Intent(this, FormHierarchyActivity.class);
//			startActivityForResult(i, HIERARCHY_ACTIVITY);
//			return true;
//		case MENU_PREFERENCES:
//			Collect.getInstance()
//					.getActivityLogger()
//					.logInstanceAction(this, "onOptionsItemSelected",
//							"MENU_PREFERENCES");
//			Intent pref = new Intent(this, PreferencesActivity.class);
//			startActivity(pref);
//			return true;
		}
		return super.onOptionsItemSelected(item);
	}

	/**
	 * Attempt to save the answer(s) in the current screen to into the data
	 * model.
	 *
	 * @param evaluateConstraints
	 * @return false if any error occurs while saving (constraint violated,
	 *         etc...), true otherwise.
	 */
	private boolean saveAnswersForCurrentScreen(boolean evaluateConstraints) {
		FormController formController = Collect.getInstance()
				.getFormController();
		// only try to save if the current event is a question or a field-list
		// group
		if (formController.currentPromptIsQuestion()) {
			LinkedHashMap<FormIndex, IAnswerData> answers = ((ODKView) mCurrentView)
					.getAnswers();
            try {
                FailedConstraint constraint = formController.saveAnswers(answers, evaluateConstraints);
                if (constraint != null) {
                    createConstraintToast(constraint.index, constraint.status);
                    return false;
                }
            } catch (JavaRosaException e) {
                Log.e(TAG, e.getMessage(), e);
                createErrorDialog(e.getCause().getMessage(), DO_NOT_EXIT);
                return false;
            }
		}
		return true;
	}

    /**
     * Collects all answers in the form into a single map.
     * @return a {@link java.util.LinkedHashMap} of all answers in the form.
     */
    private LinkedHashMap<FormIndex, IAnswerData> getAnswers() {
        int childCount = mQuestionHolder.getChildCount();
        LinkedHashMap<FormIndex, IAnswerData> answers = new LinkedHashMap<FormIndex, IAnswerData>();
        for (int i = 0; i < childCount; i++) {
            View view = mQuestionHolder.getChildAt(i);
            if (!(view instanceof ODKView)) {
                continue;
            }
            answers.putAll(((ODKView) view).getAnswers());
        }

        return answers;
    }

    /**
     * Saves all answers in the form.
     *
     * @return false if any error occurs while saving (constraint violated,
     *         etc...), true otherwise
     */
    private boolean saveAnswers(boolean evaluateConstraints) {
        FormController formController = Collect.getInstance().getFormController();
        int childCount = mQuestionHolder.getChildCount();
        LinkedHashMap<FormIndex, IAnswerData> answers = getAnswers();

        try {
            FailedConstraint constraint = formController.saveAnswers(answers, evaluateConstraints);
            if (constraint != null) {
                createConstraintToast(constraint.index, constraint.status);
                return false;
            }
        } catch (JavaRosaException e) {
            Log.e(TAG, e.getMessage(), e);
            createErrorDialog(e.getCause().getMessage(), DO_NOT_EXIT);
            return false;
        }

        return true;
    }

	/**
	 * Clears the answer on the screen.
	 */
	private void clearAnswer(QuestionWidget qw) {
		if (qw.getAnswer() != null) {
			qw.clearAnswer();
		}
	}

//	@Override
//	public void onCreateContextMenu(ContextMenu menu, View v,
//			ContextMenuInfo menuInfo) {
//		super.onCreateContextMenu(menu, v, menuInfo);
//		Collect.getInstance().getActivityLogger()
//				.logInstanceAction(this, "onCreateContextMenu", "show");
//		FormController formController = Collect.getInstance()
//				.getFormController();
//
//		menu.add(0, v.getId(), 0, getString(R.string.clear_answer));
////		if (formController.indexContainsRepeatableGroup()) {
////			menu.add(0, DELETE_REPEAT, 0, getString(R.string.delete_repeat));
////		}
//		menu.setHeaderTitle(getString(R.string.edit_prompt));
//	}

//	@Override
//	public boolean onContextItemSelected(MenuItem item) {
//		/*
//		 * We don't have the right view here, so we store the View's ID as the
//		 * item ID and loop through the possible views to find the one the user
//		 * clicked on.
//		 */
//		for (QuestionWidget qw : ((ODKView) mCurrentView).getWidgets()) {
//			if (item.getItemId() == qw.getId()) {
//				Collect.getInstance()
//						.getActivityLogger()
//						.logInstanceAction(this, "onContextItemSelected",
//								"createClearDialog", qw.getPrompt().getIndex());
//				createClearDialog(qw);
//			}
//		}
////		if (item.getItemId() == DELETE_REPEAT) {
////			Collect.getInstance()
////					.getActivityLogger()
////					.logInstanceAction(this, "onContextItemSelected",
////							"createDeleteRepeatConfirmDialog");
////			createDeleteRepeatConfirmDialog();
////		}
//
//		return super.onContextItemSelected(item);
//	}

	/**
	 * If we're loading, then we pass the loading thread to our next instance.
	 */
	@Override
	public Object onRetainNonConfigurationInstance() {
		FormController formController = Collect.getInstance()
				.getFormController();
		// if a form is loading, pass the loader task
		if (mFormLoaderTask != null
				&& mFormLoaderTask.getStatus() != AsyncTask.Status.FINISHED)
			return mFormLoaderTask;

		// if a form is writing to disk, pass the save to disk task
		if (mSaveToDiskTask != null
				&& mSaveToDiskTask.getStatus() != AsyncTask.Status.FINISHED)
			return mSaveToDiskTask;

		// mFormEntryController is static so we don't need to pass it.
		if (formController != null && formController.currentPromptIsQuestion()) {
			saveAnswersForCurrentScreen(DO_NOT_EVALUATE_CONSTRAINTS);
		}
		return null;
	}

	/**
	 * Creates a view given the View type and an event
	 *
	 * @param event
	 * @param advancingPage
	 *            -- true if this results from advancing through the form
	 * @param preset
     * @return newly created View
	 */
	private View createView(int event, boolean advancingPage, Preset preset) {
		FormController formController = Collect.getInstance()
				.getFormController();
		FormInstance formInstance = formController.getFormDef().getMainInstance();
//		setTitle(getString(R.string.app_name) + " > "
//				+ formController.getFormTitle());

		switch (event) {
//		case FormEntryController.EVENT_BEGINNING_OF_FORM:
//			View startView = View
//					.inflate(this, R.layout.form_entry_start, null);
//			setTitle(getString(R.string.app_name) + " > "
//					+ formController.getFormTitle());
//
//			Drawable image = null;
//			File mediaFolder = formController.getMediaFolder();
//			String mediaDir = mediaFolder.getAbsolutePath();
//			BitmapDrawable bitImage = null;
//			// attempt to load the form-specific logo...
//			// this is arbitrarily silly
//			bitImage = new BitmapDrawable(getResources(), mediaDir + File.separator
//					+ "form_logo.png");
//
//			if (bitImage != null && bitImage.getBitmap() != null
//					&& bitImage.getIntrinsicHeight() > 0
//					&& bitImage.getIntrinsicWidth() > 0) {
//				image = bitImage;
//			}
//
//			if (image == null) {
//				// show the opendatakit zig...
//				// image =
//				// getResources().getDrawable(R.drawable.opendatakit_zig);
//				((ImageView) startView.findViewById(R.id.form_start_bling))
//						.setVisibility(View.GONE);
//			} else {
//				ImageView v = ((ImageView) startView
//						.findViewById(R.id.form_start_bling));
//				v.setImageDrawable(image);
//				v.setContentDescription(formController.getFormTitle());
//			}
//
//			// change start screen based on navigation prefs
//			String navigationChoice = PreferenceManager
//					.getDefaultSharedPreferences(this).getString(
//							PreferencesActivity.KEY_NAVIGATION,
//							PreferencesActivity.KEY_NAVIGATION);
//			Boolean useSwipe = false;
//			Boolean useButtons = false;
//			ImageView ia = ((ImageView) startView
//					.findViewById(R.id.image_advance));
//			ImageView ib = ((ImageView) startView
//					.findViewById(R.id.image_backup));
//			TextView ta = ((TextView) startView.findViewById(R.id.text_advance));
//			TextView tb = ((TextView) startView.findViewById(R.id.text_backup));
//			TextView d = ((TextView) startView.findViewById(R.id.description));
//
//			if (navigationChoice != null) {
//				if (navigationChoice
//						.contains(PreferencesActivity.NAVIGATION_SWIPE)) {
//					useSwipe = true;
//				}
//				if (navigationChoice
//						.contains(PreferencesActivity.NAVIGATION_BUTTONS)) {
//					useButtons = true;
//				}
//			}
//			if (useSwipe && !useButtons) {
//				d.setText(getString(R.string.swipe_instructions,
//						formController.getFormTitle()));
//			} else if (useButtons && !useSwipe) {
//				ia.setVisibility(View.GONE);
//				ib.setVisibility(View.GONE);
//				ta.setVisibility(View.GONE);
//				tb.setVisibility(View.GONE);
//				d.setText(getString(R.string.buttons_instructions,
//						formController.getFormTitle()));
//			} else {
//				d.setText(getString(R.string.swipe_buttons_instructions,
//						formController.getFormTitle()));
//			}
//
//			return startView;
//		case FormEntryController.EVENT_END_OF_FORM:
//			View endView = View.inflate(this, R.layout.form_entry_end, null);
//			((TextView) endView.findViewById(R.id.description))
//					.setText(getString(R.string.save_enter_data_description,
//							formController.getFormTitle()));
//
//			// checkbox for if finished or ready to send
//			final CheckBox instanceComplete = ((CheckBox) endView
//					.findViewById(R.id.mark_finished));
//			instanceComplete.setChecked(isInstanceComplete(true));
//
//			if (!mAdminPreferences.getBoolean(
//					AdminPreferencesActivity.KEY_MARK_AS_FINALIZED, true)) {
//				instanceComplete.setVisibility(View.GONE);
//			}
//
//			// edittext to change the displayed name of the instance
//			final EditText saveAs = (EditText) endView
//					.findViewById(R.id.save_name);
//
//			// disallow carriage returns in the name
//			InputFilter returnFilter = new InputFilter() {
//				public CharSequence filter(CharSequence source, int start,
//						int end, Spanned dest, int dstart, int dend) {
//					for (int i = start; i < end; i++) {
//						if (Character.getType((source.charAt(i))) == Character.CONTROL) {
//							return "";
//						}
//					}
//					return null;
//				}
//			};
//			saveAs.setFilters(new InputFilter[] { returnFilter });
//
//			String saveName = formController.getSubmissionMetadata().instanceName;
//			if (saveName == null) {
//				// no meta/instanceName field in the form -- see if we have a
//				// name for this instance from a previous save attempt...
//				if (getContentResolver().getType(getIntent().getData()) == InstanceColumns.CONTENT_ITEM_TYPE) {
//					Uri instanceUri = getIntent().getData();
//					Cursor instance = null;
//					try {
//						instance = getContentResolver().query(instanceUri,
//								null, null, null, null);
//						if (instance.getCount() == 1) {
//							instance.moveToFirst();
//							saveName = instance
//									.getString(instance
//											.getColumnIndex(InstanceColumns.DISPLAY_NAME));
//						}
//					} finally {
//						if (instance != null) {
//							instance.close();
//						}
//					}
//				}
//				if (saveName == null) {
//					// last resort, default to the form title
//					saveName = formController.getFormTitle();
//				}
//				// present the prompt to allow user to name the form
//				TextView sa = (TextView) endView
//						.findViewById(R.id.save_form_as);
//				sa.setVisibility(View.VISIBLE);
//				saveAs.setText(saveName);
//				saveAs.setEnabled(true);
//				saveAs.setVisibility(View.VISIBLE);
//			} else {
//				// if instanceName is defined in form, this is the name -- no
//				// revisions
//				// display only the name, not the prompt, and disable edits
//				TextView sa = (TextView) endView
//						.findViewById(R.id.save_form_as);
//				sa.setVisibility(View.GONE);
//				saveAs.setText(saveName);
//				saveAs.setEnabled(false);
//				saveAs.setBackgroundColor(Color.WHITE);
//				saveAs.setVisibility(View.VISIBLE);
//			}
//
//			// override the visibility settings based upon admin preferences
//			if (!mAdminPreferences.getBoolean(
//					AdminPreferencesActivity.KEY_SAVE_AS, true)) {
//				saveAs.setVisibility(View.GONE);
//				TextView sa = (TextView) endView
//						.findViewById(R.id.save_form_as);
//				sa.setVisibility(View.GONE);
//			}
//
//			// Create 'save' button
//			((Button) endView.findViewById(R.id.save_exit_button))
//					.setOnClickListener(new OnClickListener() {
//						@Override
//						public void onClick(View v) {
//							Collect.getInstance()
//									.getActivityLogger()
//									.logInstanceAction(
//											this,
//											"createView.saveAndExit",
//											instanceComplete.isChecked() ? "saveAsComplete"
//													: "saveIncomplete");
//							// Form is marked as 'saved' here.
//							if (saveAs.getText().length() < 1) {
//								Toast.makeText(FormEntryActivity.this,
//										R.string.save_as_error,
//										Toast.LENGTH_SHORT).show();
//							} else {
//								saveDataToDisk(EXIT, instanceComplete
//										.isChecked(), saveAs.getText()
//										.toString());
//							}
//						}
//					});
//
//			return endView;
//        case FormEntryController.EVENT_GROUP:
//            FormEntryCaption[] groups = formController.getGroupsForCurrentIndex();
//            if (groups.length == 0) {
//                Log.e(
//                        TAG,
//                        "Attempted to handle a FormEntryController.EVENT_GROUP when the form was "
//                                + "not on a group.");
//                break;
//            }
//            WidgetGroupBuilder builder =
//                    Widget2Factory.INSTANCE.createGroupBuilder(this, groups[groups.length - 1]);
//            if (builder != null) {
//                // TODO: Use the builder.
//                break;
//            }
//
//            // Fall through to the next case if we didn't manage to create a builder.
		case FormEntryController.EVENT_QUESTION:
		case FormEntryController.EVENT_GROUP:
		case FormEntryController.EVENT_REPEAT:
			ODKView odkv = null;
			// should only be a group here if the event_group is a field-list
			try {
				FormEntryPrompt[] prompts = formController.getQuestionPrompts();
				FormEntryCaption[] groups = formController
						.getGroupsForCurrentIndex();
				TreeReference ref = formController.getFormIndex().getReference();
				TreeElement element = formInstance.resolveReference(ref);

				odkv = new ODKView(this, prompts, groups, advancingPage, preset);
                if (preset != null
                        && preset.targetGroup != null
                        && preset.targetGroup.equals(groups[groups.length - 1].getLongText())) {
                    mTargetView = odkv;
                }
				Log.i(TAG,
						"created view for group "
								+ (groups.length > 0 ? groups[groups.length - 1]
										.getLongText() : "[top]")
								+ " "
								+ (prompts.length > 0 ? prompts[0]
										.getQuestionText() : "[no question]"));
			} catch (RuntimeException e) {
				Log.e(TAG, e.getMessage(), e);
				// this is badness to avoid a crash.
                try {
                    event = formController.stepToNextScreenEvent();
                    createErrorDialog(e.getMessage(), DO_NOT_EXIT);
                } catch (JavaRosaException e1) {
                    Log.e(TAG, e1.getMessage(), e1);
                    createErrorDialog(e.getMessage() + "\n\n" + e1.getCause().getMessage(), DO_NOT_EXIT);
                }
                return createView(event, advancingPage, preset);
            }

			// Makes a "clear answer" menu pop up on long-click
			for (QuestionWidget qw : odkv.getWidgets()) {
				if (!qw.getPrompt().isReadOnly()) {
					registerForContextMenu(qw);
				}
			}
			return odkv;
		default:
            return null;
//			Log.e(TAG, "Attempted to create a view that does not exist.");
//			// this is badness to avoid a crash.
//            try {
//                event = formController.stepToNextScreenEvent();
//                createErrorDialog(getString(R.string.survey_internal_error), EXIT);
//            } catch (JavaRosaException e) {
//                Log.e(TAG, e.getMessage(), e);
//                createErrorDialog(e.getCause().getMessage(), EXIT);
//            }
//            return createView(event, advancingPage);
		}
	}

//	@Override
//	public boolean dispatchTouchEvent(MotionEvent mv) {
//		boolean handled = mGestureDetector.onTouchEvent(mv);
//		if (!handled) {
//			return super.dispatchTouchEvent(mv);
//		}
//
//		return handled; // this is always true
//	}
//
//	/**
//	 * Determines what should be displayed on the screen. Possible options are:
//	 * a question, an ask repeat dialog, or the submit screen. Also saves
//	 * answers to the data model after checking constraints.
//	 */
//	private void showNextView() {
//		try {
//            FormController formController = Collect.getInstance()
//                    .getFormController();
//
//            // get constraint behavior preference value with appropriate default
//            String constraint_behavior = PreferenceManager.getDefaultSharedPreferences(this)
//                    .getString(PreferencesActivity.KEY_CONSTRAINT_BEHAVIOR,
//                            PreferencesActivity.CONSTRAINT_BEHAVIOR_DEFAULT);
//
//            if (formController.currentPromptIsQuestion()) {
//
//                // if constraint behavior says we should validate on swipe, do so
//                if (constraint_behavior.equals(PreferencesActivity.CONSTRAINT_BEHAVIOR_ON_SWIPE)) {
//                    if (!saveAnswersForCurrentScreen(EVALUATE_CONSTRAINTS)) {
//                        // A constraint was violated so a dialog should be showing.
//                        mBeenSwiped = false;
//                        return;
//                    }
//
//                    // otherwise, just save without validating (constraints will be validated on finalize)
//                } else
//                    saveAnswersForCurrentScreen(DO_NOT_EVALUATE_CONSTRAINTS);
//            }
//
//            View next;
//            int event = formController.stepToNextScreenEvent();
//
//
//            switch (event) {
//                case FormEntryController.EVENT_QUESTION:
//                case FormEntryController.EVENT_GROUP:
//                    // create a savepoint
//                    if ((++viewCount) % SAVEPOINT_INTERVAL == 0) {
//                        nonblockingCreateSavePointData();
//                    }
//                    next = createView(event, true);
//                    showView(next, AnimationType.RIGHT);
//                    break;
//                case FormEntryController.EVENT_END_OF_FORM:
//                case FormEntryController.EVENT_REPEAT:
//                    next = createView(event, true);
//                    showView(next, AnimationType.RIGHT);
//                    break;
//                case FormEntryController.EVENT_PROMPT_NEW_REPEAT:
//                    createRepeatDialog();
//                    break;
//                case FormEntryController.EVENT_REPEAT_JUNCTURE:
//                    Log.i(TAG, "repeat juncture: "
//                            + formController.getFormIndex().getReference());
//                    // skip repeat junctures until we implement them
//                    break;
//                default:
//                    Log.w(TAG,
//                            "JavaRosa added a new EVENT type and didn't tell us... shame on them.");
//                    break;
//            }
//        } catch (JavaRosaException e) {
//            Log.e(TAG, e.getMessage(), e);
//            createErrorDialog(e.getCause().getMessage(), DO_NOT_EXIT);
//        }
//    }
//
//	/**
//	 * Determines what should be displayed between a question, or the start
//	 * screen and displays the appropriate view. Also saves answers to the data
//	 * model without checking constraints.
//	 */
//	private void showPreviousView() {
//        try {
//            FormController formController = Collect.getInstance()
//                    .getFormController();
//            // The answer is saved on a back swipe, but question constraints are
//            // ignored.
//            if (formController.currentPromptIsQuestion()) {
//                saveAnswersForCurrentScreen(DO_NOT_EVALUATE_CONSTRAINTS);
//            }
//
//            if (formController.getEvent() != FormEntryController.EVENT_BEGINNING_OF_FORM) {
//                int event = formController.stepToPreviousScreenEvent();
//
//                if (event == FormEntryController.EVENT_BEGINNING_OF_FORM
//                        || event == FormEntryController.EVENT_GROUP
//                        || event == FormEntryController.EVENT_QUESTION) {
//                    // create savepoint
//                    if ((++viewCount) % SAVEPOINT_INTERVAL == 0) {
//                        nonblockingCreateSavePointData();
//                    }
//                }
//                View next = createView(event, false);
//                showView(next, AnimationType.LEFT);
//            } else {
//                mBeenSwiped = false;
//            }
//        } catch (JavaRosaException e) {
//            Log.e(TAG, e.getMessage(), e);
//            createErrorDialog(e.getCause().getMessage(), DO_NOT_EXIT);
//        }
//    }
//
//	/**
//	 * Displays the View specified by the parameter 'next', animating both the
//	 * current view and next appropriately given the AnimationType. Also updates
//	 * the progress bar.
//	 */
//	public void showView(View next, AnimationType from) {
//
//		// disable notifications...
//		if (mInAnimation != null) {
//			mInAnimation.setAnimationListener(null);
//		}
//		if (mOutAnimation != null) {
//			mOutAnimation.setAnimationListener(null);
//		}
//
//		// logging of the view being shown is already done, as this was handled
//		// by createView()
//		switch (from) {
//		case RIGHT:
//			mInAnimation = AnimationUtils.loadAnimation(this,
//					R.anim.push_left_in);
//			mOutAnimation = AnimationUtils.loadAnimation(this,
//					R.anim.push_left_out);
//			// if animation is left or right then it was a swipe, and we want to re-save on entry
//			mAutoSaved = false;
//			break;
//		case LEFT:
//			mInAnimation = AnimationUtils.loadAnimation(this,
//					R.anim.push_right_in);
//			mOutAnimation = AnimationUtils.loadAnimation(this,
//					R.anim.push_right_out);
//			mAutoSaved = false;
//			break;
//		case FADE:
//			mInAnimation = AnimationUtils.loadAnimation(this, R.anim.fade_in);
//			mOutAnimation = AnimationUtils.loadAnimation(this, R.anim.fade_out);
//			break;
//		}
//
//		// complete setup for animations...
//		mInAnimation.setAnimationListener(this);
//		mOutAnimation.setAnimationListener(this);
//
//		// drop keyboard before transition...
//		if (mCurrentView != null) {
//			InputMethodManager inputManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
//			inputManager.hideSoftInputFromWindow(mCurrentView.getWindowToken(),
//					0);
//		}
//
//		RelativeLayout.LayoutParams lp = new RelativeLayout.LayoutParams(
//				LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT);
//
//		// adjust which view is in the layout container...
//		mStaleView = mCurrentView;
//		mCurrentView = next;
//		mQuestionHolder.addView(mCurrentView, lp);
//		mAnimationCompletionSet = 0;
//
//		if (mStaleView != null) {
//			// start OutAnimation for transition...
//			mStaleView.startAnimation(mOutAnimation);
//			// and remove the old view (MUST occur after start of animation!!!)
//			mQuestionHolder.removeView(mStaleView);
//		} else {
//			mAnimationCompletionSet = 2;
//		}
//		// start InAnimation for transition...
//		mCurrentView.startAnimation(mInAnimation);
//
//		String logString = "";
//		switch (from) {
//		case RIGHT:
//			logString = "next";
//			break;
//		case LEFT:
//			logString = "previous";
//			break;
//		case FADE:
//			logString = "refresh";
//			break;
//		}
//
//        Collect.getInstance().getActivityLogger().logInstanceAction(this, "showView", logString);
//
//        FormController formController = Collect.getInstance().getFormController();
//        if (formController.getEvent() == FormEntryController.EVENT_QUESTION
//                || formController.getEvent() == FormEntryController.EVENT_GROUP
//                || formController.getEvent() == FormEntryController.EVENT_REPEAT) {
//            FormEntryPrompt[] prompts = Collect.getInstance().getFormController()
//                    .getQuestionPrompts();
//            for (FormEntryPrompt p : prompts) {
//                Vector<TreeElement> attrs = p.getBindAttributes();
//                for (int i = 0; i < attrs.size(); i++) {
//                    if (!mAutoSaved && "saveIncomplete".equals(attrs.get(i).getName())) {
//                        saveDataToDisk(false, false, null, false);
//                        mAutoSaved = true;
//                    }
//                }
//            }
//        }
//	}

	// Hopefully someday we can use managed dialogs when the bugs are fixed
	/*
	 * Ideally, we'd like to use Android to manage dialogs with onCreateDialog()
	 * and onPrepareDialog(), but dialogs with dynamic content are broken in 1.5
	 * (cupcake). We do use managed dialogs for our static loading
	 * ProgressDialog. The main issue we noticed and are waiting to see fixed
	 * is: onPrepareDialog() is not called after a screen orientation change.
	 * http://code.google.com/p/android/issues/detail?id=1639
	 */

	private String getAttribute(Vector<TreeElement> attrs, String name) {
		for (TreeElement attr : attrs) {
		    if (eq(attr.getName(), name)) {
		        return attr.getAttributeValue();
			}
        }
		return null;
	}

	/** Displays a toast message showing a violated constraint. */
	private void createConstraintToast(FormIndex index, int saveStatus) {
		FormController formController = Collect.getInstance().getFormController();
		FormEntryPrompt prompt = formController.getQuestionPrompt(index);
		String questionText = Utils.localize(prompt.getQuestionText(), this).trim();
		String message;

		switch (saveStatus) {
			case FormEntryController.ANSWER_CONSTRAINT_VIOLATED:
				Collect.getInstance()
					.getActivityLogger()
					.logInstanceAction(this,
						"createConstraintToast.ANSWER_CONSTRAINT_VIOLATED",
						"show", index);

				Vector<TreeElement> attrs = prompt.getBindAttributes();
				String min = getAttribute(attrs, "constraint-min");
				String max = getAttribute(attrs, "constraint-max");
				if (min != null && max != null) {
					message = getString(R.string.invalid_min_max, questionText, min, max);
				} else if (min != null) {
					message = getString(R.string.invalid_min, questionText, min);
				} else if (max != null) {
					message = getString(R.string.invalid_max, questionText, max);
				} else {
					message = Utils.localize(prompt.getConstraintText(), this);
					if (message == null) {
						message = Utils.localize(prompt.getSpecialFormQuestionText("constraintMsg"), this);
					}
					if (message == null) {
						message = questionText + ": " + Utils.localize(getAttribute(prompt.getBindAttributes(), "message"), this);
					}
					if (message == null) {
						message = getString(R.string.question_is_invalid, questionText);
					}
				}
				break;
			case FormEntryController.ANSWER_REQUIRED_BUT_EMPTY:
				Collect.getInstance()
						.getActivityLogger()
						.logInstanceAction(this,
								"createConstraintToast.ANSWER_REQUIRED_BUT_EMPTY",
								"show", index);
				message = Utils.localize(formController.getQuestionPromptRequiredText(index), this);
				if (message == null) {
					message = Utils.localize(prompt.getSpecialFormQuestionText("requiredMsg"), this);
				}
				if (message == null) {
					message = getString(R.string.question_is_required, questionText);
				}
				break;
			default:
				return;
		}

		showCustomToast(message, Toast.LENGTH_SHORT);
	}

	/**
	 * Creates a toast with the specified message.
	 *
	 * @param message
	 */
	private void showCustomToast(String message, int duration) {
		LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);

		View view = inflater.inflate(R.layout.toast_view, null);

		// set the text in the view
		TextView tv = (TextView) view.findViewById(R.id.message);
		tv.setText(message);

		Toast t = new Toast(this);
		t.setView(view);
		t.setDuration(duration);
		t.setGravity(Gravity.CENTER, 0, 0);
		t.show();
	}

//	/**
//	 * Creates and displays a dialog asking the user if they'd like to create a
//	 * repeat of the current group.
//	 */
//	private void createRepeatDialog() {
//		FormController formController = Collect.getInstance()
//				.getFormController();
//		Collect.getInstance().getActivityLogger()
//				.logInstanceAction(this, "createRepeatDialog", "show");
//		mAlertDialog = new AlertDialog.Builder(this).create();
//		mAlertDialog.setIcon(android.R.drawable.ic_dialog_info);
//		DialogInterface.OnClickListener repeatListener = new DialogInterface.OnClickListener() {
//			@Override
//			public void onClick(DialogInterface dialog, int i) {
//				FormController formController = Collect.getInstance()
//						.getFormController();
//				switch (i) {
//				case DialogInterface.BUTTON_POSITIVE: // yes, repeat
//					Collect.getInstance()
//							.getActivityLogger()
//							.logInstanceAction(this, "createRepeatDialog",
//									"addRepeat");
//					try {
//						formController.newRepeat();
//					} catch (Exception e) {
//						FormEntryActivity.this.createErrorDialog(
//								e.getMessage(), DO_NOT_EXIT);
//						return;
//					}
//					if (!formController.indexIsInFieldList()) {
//						// we are at a REPEAT event that does not have a
//						// field-list appearance
//						// step to the next visible field...
//						// which could be the start of a new repeat group...
//						showNextView();
//					} else {
//						// we are at a REPEAT event that has a field-list
//						// appearance
//						// just display this REPEAT event's group.
//						refreshCurrentView();
//					}
//					break;
//				case DialogInterface. BUTTON_NEGATIVE: // no, no repeat
//					Collect.getInstance()
//							.getActivityLogger()
//							.logInstanceAction(this, "createRepeatDialog",
//									"showNext");
//
//                    //
//                    // Make sure the error dialog will not disappear.
//                    //
//                    // When showNextView() popups an error dialog (because of a JavaRosaException)
//                    // the issue is that the "add new repeat dialog" is referenced by mAlertDialog
//                    // like the error dialog. When the "no repeat" is clicked, the error dialog
//                    // is shown. Android by default dismisses the dialogs when a button is clicked,
//                    // so instead of closing the first dialog, it closes the second.
//                    new Thread() {
//
//                        @Override
//                        public void run() {
//                            FormEntryActivity.this.runOnUiThread(new Runnable() {
//                                @Override
//                                public void run() {
//                                    try {
//                                        Thread.sleep(500);
//                                    } catch (InterruptedException e) {
//                                        e.printStackTrace();
//                                    }
//                                    showNextView();
//                                }
//                            });
//                        }
//                    }.start();
//
//					break;
//				}
//			}
//		};
//		if (formController.getLastRepeatCount() > 0) {
//			mAlertDialog.setTitle(getString(R.string.leaving_repeat_ask));
//			mAlertDialog.setMessage(getString(R.string.add_another_repeat,
//					formController.getLastGroupText()));
//			mAlertDialog.setButton(getString(R.string.add_another),
//					repeatListener);
//			mAlertDialog.setButton2(getString(R.string.leave_repeat_yes),
//					repeatListener);
//
//		} else {
//			mAlertDialog.setTitle(getString(R.string.entering_repeat_ask));
//			mAlertDialog.setMessage(getString(R.string.add_repeat,
//					formController.getLastGroupText()));
//			mAlertDialog.setButton(getString(R.string.entering_repeat),
//					repeatListener);
//			mAlertDialog.setButton2(getString(R.string.add_repeat_no),
//					repeatListener);
//		}
//		mAlertDialog.setCancelable(false);
//		mBeenSwiped = false;
//		showAlertDialog();
//	}

	/**
	 * Creates and displays dialog with the given errorMsg.
	 */
	private void createErrorDialog(String errorMsg, final boolean shouldExit) {
		Collect.getInstance()
				.getActivityLogger()
				.logInstanceAction(this, "createErrorDialog",
						"show." + Boolean.toString(shouldExit));

        if (mAlertDialog != null && mAlertDialog.isShowing()) {
            errorMsg = mErrorMessage + "\n\n" + errorMsg;
            mErrorMessage = errorMsg;
        } else {
            mAlertDialog = new AlertDialog.Builder(this).create();
            mErrorMessage = errorMsg;
        }

		mAlertDialog.setIcon(android.R.drawable.ic_dialog_info);
		mAlertDialog.setTitle(getString(R.string.error_occured));
		mAlertDialog.setMessage(errorMsg);
		DialogInterface.OnClickListener errorListener = new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int i) {
				switch (i) {
				case DialogInterface.BUTTON_POSITIVE:
					Collect.getInstance().getActivityLogger()
							.logInstanceAction(this, "createErrorDialog", "OK");
					if (shouldExit) {
                        mErrorMessage = null;
						finish();
					}
					break;
				}
			}
		};
		mAlertDialog.setCancelable(false);
		mAlertDialog.setButton(getString(R.string.ok), errorListener);
		showAlertDialog();
	}

//	/**
//	 * Creates a confirm/cancel dialog for deleting repeats.
//	 */
//	private void createDeleteRepeatConfirmDialog() {
//		Collect.getInstance()
//				.getActivityLogger()
//				.logInstanceAction(this, "createDeleteRepeatConfirmDialog",
//						"show");
//		FormController formController = Collect.getInstance()
//				.getFormController();
//		mAlertDialog = new AlertDialog.Builder(this).create();
//		mAlertDialog.setIcon(android.R.drawable.ic_dialog_info);
//		String name = formController.getLastRepeatedGroupName();
//		int repeatcount = formController.getLastRepeatedGroupRepeatCount();
//		if (repeatcount != -1) {
//			name += " (" + (repeatcount + 1) + ")";
//		}
//		mAlertDialog.setTitle(getString(R.string.delete_repeat_ask));
//		mAlertDialog
//				.setMessage(getString(R.string.delete_repeat_confirm, name));
//		DialogInterface.OnClickListener quitListener = new DialogInterface.OnClickListener() {
//			@Override
//			public void onClick(DialogInterface dialog, int i) {
//				FormController formController = Collect.getInstance()
//						.getFormController();
//				switch (i) {
//				case DialogInterface.BUTTON_POSITIVE: // yes
//					Collect.getInstance()
//							.getActivityLogger()
//							.logInstanceAction(this,
//									"createDeleteRepeatConfirmDialog", "OK");
//					formController.deleteRepeat();
//					showPreviousView();
//					break;
//				case DialogInterface. BUTTON_NEGATIVE: // no
//					Collect.getInstance()
//							.getActivityLogger()
//							.logInstanceAction(this,
//									"createDeleteRepeatConfirmDialog", "cancel");
//					break;
//				}
//			}
//		};
//		mAlertDialog.setCancelable(false);
//		mAlertDialog.setButton(getString(R.string.discard_group), quitListener);
//		mAlertDialog.setButton2(getString(R.string.delete_repeat_no),
//				quitListener);
//		showAlertDialog();
//	}

	/**
	 * Saves data and writes it to disk. If exit is set, program will exit after
	 * save completes. Complete indicates whether the user has marked the
	 * isntancs as complete. If updatedSaveName is non-null, the instances
	 * content provider is updated with the new name
	 */
    // by default, save the current screen
    private boolean saveDataToDisk(boolean exit, boolean complete, String updatedSaveName) {
        return saveDataToDisk(exit, complete, updatedSaveName, true);
    }

    // but if you want save in the background, can't be current screen
    private boolean saveDataToDisk(boolean exit, boolean complete, String updatedSaveName,
            boolean current) {
        // save current answer
        if (!saveAnswers(EVALUATE_CONSTRAINTS)) {
            return false;
        }

        synchronized (saveDialogLock) {
            mSaveToDiskTask = new SaveToDiskTask(getIntent().getData(), exit, complete,
                    updatedSaveName);
            mSaveToDiskTask.setFormSavedListener(this);
            mAutoSaved = true;
            showDialog(SAVING_DIALOG);
            // show dialog before we execute...
            mSaveToDiskTask.execute();
        }

        return true;
    }

	/**
	 * Create a dialog with options to save and exit, save, or quit without
	 * saving
	 */
	private void createQuitDialog() {
		FormController formController = Collect.getInstance()
				.getFormController();
		String[] items;
        String[] two = { getString(R.string.keep_changes),
                getString(R.string.do_not_save) };
        items = two;

		Collect.getInstance().getActivityLogger()
				.logInstanceAction(this, "createQuitDialog", "show");
		showAlertDialog();
	}

	/**
	 * this method cleans up unneeded files when the user selects 'discard and
	 * exit'
	 */
	private void removeTempInstance() {
		FormController formController = Collect.getInstance()
				.getFormController();

		// attempt to remove any scratch file
		File temp = SaveToDiskTask.savepointFile(formController
				.getInstancePath());
		if (temp.exists()) {
			temp.delete();
		}

		String selection = InstanceColumns.INSTANCE_FILE_PATH + "=?";
		String[] selectionArgs = { formController.getInstancePath()
				.getAbsolutePath() };

		boolean erase = false;
		{
			Cursor c = null;
			try {
				c = getContentResolver().query(InstanceColumns.CONTENT_URI,
						null, selection, selectionArgs, null);
				erase = (c.getCount() < 1);
			} finally {
				if (c != null) {
					c.close();
				}
			}
		}

		// if it's not already saved, erase everything
		if (erase) {
			// delete media first
			String instanceFolder = formController.getInstancePath()
					.getParent();
			Log.i(TAG, "attempting to delete: " + instanceFolder);
			int images = MediaUtils
					.deleteImagesInFolderFromMediaProvider(formController
							.getInstancePath().getParentFile());
			int audio = MediaUtils
					.deleteAudioInFolderFromMediaProvider(formController
							.getInstancePath().getParentFile());
			int video = MediaUtils
					.deleteVideoInFolderFromMediaProvider(formController
							.getInstancePath().getParentFile());

			Log.i(TAG, "removed from content providers: " + images
					+ " image files, " + audio + " audio files," + " and "
					+ video + " video files.");
			File f = new File(instanceFolder);
			if (f.exists() && f.isDirectory()) {
				for (File del : f.listFiles()) {
					Log.i(TAG, "deleting file: " + del.getAbsolutePath());
					del.delete();
				}
				f.delete();
			}
		}
	}

	/**
	 * Confirm clear answer dialog
	 */
	private void createClearDialog(final QuestionWidget qw) {
		Collect.getInstance()
				.getActivityLogger()
				.logInstanceAction(this, "createClearDialog", "show",
						qw.getPrompt().getIndex());
		mAlertDialog = new AlertDialog.Builder(this).create();
		mAlertDialog.setIcon(android.R.drawable.ic_dialog_info);

		mAlertDialog.setTitle(getString(R.string.clear_answer_ask));

		String question = qw.getPrompt().getLongText();
		if (question == null) {
			question = "";
		}
		if (question.length() > 50) {
			question = question.substring(0, 50) + "...";
		}

		mAlertDialog.setMessage(getString(R.string.clearanswer_confirm,
				question));

		DialogInterface.OnClickListener quitListener = new DialogInterface.OnClickListener() {

			@Override
			public void onClick(DialogInterface dialog, int i) {
				switch (i) {
				case DialogInterface.BUTTON_POSITIVE: // yes
					Collect.getInstance()
							.getActivityLogger()
							.logInstanceAction(this, "createClearDialog",
									"clearAnswer", qw.getPrompt().getIndex());
					clearAnswer(qw);
					saveAnswersForCurrentScreen(DO_NOT_EVALUATE_CONSTRAINTS);
					break;
				case DialogInterface. BUTTON_NEGATIVE: // no
					Collect.getInstance()
							.getActivityLogger()
							.logInstanceAction(this, "createClearDialog",
                                    "cancel", qw.getPrompt().getIndex());
					break;
				}
			}
		};
		mAlertDialog.setCancelable(false);
		mAlertDialog
				.setButton(getString(R.string.discard_answer), quitListener);
		mAlertDialog.setButton2(getString(R.string.clear_answer_no),
				quitListener);
		showAlertDialog();
	}
//
//	/**
//	 * Creates and displays a dialog allowing the user to set the language for
//	 * the form.
//	 */
//	private void createLanguageDialog() {
//		Collect.getInstance().getActivityLogger()
//				.logInstanceAction(this, "createLanguageDialog", "show");
//		FormController formController = Collect.getInstance()
//				.getFormController();
//		final String[] languages = formController.getLanguages();
//		int selected = -1;
//		if (languages != null) {
//			String language = formController.getLanguage();
//			for (int i = 0; i < languages.length; i++) {
//				if (language.equals(languages[i])) {
//					selected = i;
//				}
//			}
//		}
//		mAlertDialog = new AlertDialog.Builder(this)
//				.setSingleChoiceItems(languages, selected,
//						new DialogInterface.OnClickListener() {
//							@Override
//							public void onClick(DialogInterface dialog,
//									int whichButton) {
//								FormController formController = Collect
//										.getInstance().getFormController();
//								// Update the language in the content provider
//								// when selecting a new
//								// language
//								ContentValues values = new ContentValues();
//								values.put(FormsColumns.LANGUAGE,
//										languages[whichButton]);
//								String selection = FormsColumns.FORM_FILE_PATH
//										+ "=?";
//								String selectArgs[] = { mFormPath };
//								int updated = getContentResolver().update(
//										FormsColumns.CONTENT_URI, values,
//										selection, selectArgs);
//								Log.i(TAG, "Updated language to: "
//										+ languages[whichButton] + " in "
//										+ updated + " rows");
//
//								Collect.getInstance()
//										.getActivityLogger()
//										.logInstanceAction(
//												this,
//												"createLanguageDialog",
//												"changeLanguage."
//														+ languages[whichButton]);
//								formController
//										.setLanguage(languages[whichButton]);
//								dialog.dismiss();
//								if (formController.currentPromptIsQuestion()) {
//									saveAnswersForCurrentScreen(DO_NOT_EVALUATE_CONSTRAINTS);
//								}
//								refreshCurrentView();
//							}
//						})
//				.setTitle(getString(R.string.change_language))
//				.setNegativeButton(getString(R.string.do_not_change),
//						new DialogInterface.OnClickListener() {
//							@Override
//							public void onClick(DialogInterface dialog,
//									int whichButton) {
//								Collect.getInstance()
//										.getActivityLogger()
//										.logInstanceAction(this,
//												"createLanguageDialog",
//												"cancel");
//							}
//						}).create();
//		showAlertDialog();
//	}

	/**
	 * We use Android's dialog management for loading/saving progress dialogs
	 */
	@Override
	protected Dialog onCreateDialog(int id) {
		switch (id) {
		case PROGRESS_DIALOG:
			Log.e(TAG, "Creating PROGRESS_DIALOG");
			Collect.getInstance()
					.getActivityLogger()
					.logInstanceAction(this, "onCreateDialog.PROGRESS_DIALOG",
							"show");
			mProgressDialog = new ProgressDialog(this);
			DialogInterface.OnClickListener loadingButtonListener = new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					Collect.getInstance()
							.getActivityLogger()
							.logInstanceAction(this,
									"onCreateDialog.PROGRESS_DIALOG", "cancel");
					dialog.dismiss();
					mFormLoaderTask.setFormLoaderListener(null);
					FormLoaderTask t = mFormLoaderTask;
					mFormLoaderTask = null;
					t.cancel(true);
					t.destroy();
					finish();
				}
			};
			mProgressDialog.setIcon(android.R.drawable.ic_dialog_info);
			mProgressDialog.setTitle(getString(R.string.loading_form));
			mProgressDialog.setMessage(getString(R.string.please_wait));
			mProgressDialog.setIndeterminate(true);
			mProgressDialog.setCancelable(false);
			mProgressDialog.setButton(getString(R.string.cancel_loading_form),
					loadingButtonListener);
			return mProgressDialog;
		case SAVING_DIALOG:
            Log.e(TAG, "Creating SAVING_DIALOG");
			Collect.getInstance()
					.getActivityLogger()
					.logInstanceAction(this, "onCreateDialog.SAVING_DIALOG",
							"show");
			mProgressDialog = new ProgressDialog(this);
			DialogInterface.OnClickListener cancelSavingButtonListener = new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					Collect.getInstance()
							.getActivityLogger()
							.logInstanceAction(this,
									"onCreateDialog.SAVING_DIALOG", "cancel");
					dialog.dismiss();
                    cancelSaveToDiskTask();
				}
			};
			mProgressDialog.setIcon(android.R.drawable.ic_dialog_info);
			mProgressDialog.setTitle(getString(R.string.saving_form));
			mProgressDialog.setMessage(getString(R.string.please_wait));
			mProgressDialog.setIndeterminate(true);
            mProgressDialog.setOnDismissListener(new DialogInterface.OnDismissListener() {
                @Override
                public void onDismiss(DialogInterface dialog) {
					Collect.getInstance()
					.getActivityLogger()
					.logInstanceAction(this,
							"onCreateDialog.SAVING_DIALOG", "OnDismissListener");
                    cancelSaveToDiskTask();
                }
            });
			return mProgressDialog;
		}
		return null;
	}

    private void cancelSaveToDiskTask() {
        synchronized (saveDialogLock) {
            mSaveToDiskTask.setFormSavedListener(null);
            boolean cancelled = mSaveToDiskTask.cancel(true);
            Log.w(TAG, "Cancelled SaveToDiskTask! (" + cancelled + ")");
            mSaveToDiskTask = null;
        }
    }
	/**
	 * Dismiss any showing dialogs that we manually manage.
	 */
	private void dismissDialogs() {
		Log.e(TAG, "Dismiss dialogs");
		if (mAlertDialog != null && mAlertDialog.isShowing()) {
			mAlertDialog.dismiss();
		}
	}

	@Override
	protected void onPause() {
		FormController formController = Collect.getInstance()
				.getFormController();
		dismissDialogs();
		// make sure we're not already saving to disk. if we are, currentPrompt
		// is getting constantly updated
		if (mSaveToDiskTask == null
				|| mSaveToDiskTask.getStatus() == AsyncTask.Status.FINISHED) {
			if (mCurrentView != null && formController != null
					&& formController.currentPromptIsQuestion()) {
				saveAnswersForCurrentScreen(DO_NOT_EVALUATE_CONSTRAINTS);
			}
		}

		super.onPause();
	}

	@Override
	protected void onResume() {
		super.onResume();

        if (mErrorMessage != null) {
            if (mAlertDialog != null && !mAlertDialog.isShowing()) {
                createErrorDialog(mErrorMessage, EXIT);
            } else {
                return;
            }
        }

        FormController formController = Collect.getInstance().getFormController();
        Collect.getInstance().getActivityLogger().open();

		if (mFormLoaderTask != null) {
			mFormLoaderTask.setFormLoaderListener(this);
			if (formController == null
					&& mFormLoaderTask.getStatus() == AsyncTask.Status.FINISHED) {
				FormController fec = mFormLoaderTask.getFormController();
				if (fec != null) {
					loadingComplete(mFormLoaderTask);
				} else {
					dismissDialog(PROGRESS_DIALOG);
					FormLoaderTask t = mFormLoaderTask;
					mFormLoaderTask = null;
					t.cancel(true);
					t.destroy();
					// there is no formController -- fire MainMenu activity?
					startActivity(new Intent(this, MainMenuActivity.class));
				}
			}
		} else {
            if (formController == null) {
                // there is no formController -- fire MainMenu activity?
                startActivity(new Intent(this, MainMenuActivity.class));
                return;
            }
//            else {
//                refreshCurrentView();
//            }
		}

		if (mSaveToDiskTask != null) {
			mSaveToDiskTask.setFormSavedListener(this);
		}

		// only check the buttons if it's enabled in preferences
		SharedPreferences sharedPreferences = PreferenceManager
				.getDefaultSharedPreferences(this);
		String navigation = sharedPreferences.getString(
				PreferencesActivity.KEY_NAVIGATION,
				PreferencesActivity.KEY_NAVIGATION);
		Boolean showButtons = false;
		if (navigation.contains(PreferencesActivity.NAVIGATION_BUTTONS)) {
			showButtons = true;
		}
	}
//
//	@Override
//	public boolean onKeyDown(int keyCode, KeyEvent event) {
//		switch (keyCode) {
//		case KeyEvent.KEYCODE_BACK:
//			Collect.getInstance().getActivityLogger()
//					.logInstanceAction(this, "onKeyDown.KEYCODE_BACK", "quit");
//			createQuitDialog();
//			return true;
//		case KeyEvent.KEYCODE_DPAD_RIGHT:
//			if (event.isAltPressed() && !mBeenSwiped) {
//				mBeenSwiped = true;
//				Collect.getInstance()
//						.getActivityLogger()
//						.logInstanceAction(this,
//								"onKeyDown.KEYCODE_DPAD_RIGHT", "showNext");
//				showNextView();
//				return true;
//			}
//			break;
//		case KeyEvent.KEYCODE_DPAD_LEFT:
//			if (event.isAltPressed() && !mBeenSwiped) {
//				mBeenSwiped = true;
//				Collect.getInstance()
//						.getActivityLogger()
//						.logInstanceAction(this, "onKeyDown.KEYCODE_DPAD_LEFT",
//								"showPrevious");
//				showPreviousView();
//				return true;
//			}
//			break;
//		}
//		return super.onKeyDown(keyCode, event);
//	}

	@Override
	protected void onDestroy() {
		if (mFormLoaderTask != null) {
			mFormLoaderTask.setFormLoaderListener(null);
			// We have to call cancel to terminate the thread, otherwise it
			// lives on and retains the FEC in memory.
			// but only if it's done, otherwise the thread never returns
			if (mFormLoaderTask.getStatus() == AsyncTask.Status.FINISHED) {
				FormLoaderTask t = mFormLoaderTask;
				mFormLoaderTask = null;
				t.cancel(true);
				t.destroy();
			}
		}
		if (mSaveToDiskTask != null) {
			mSaveToDiskTask.setFormSavedListener(null);
			// We have to call cancel to terminate the thread, otherwise it
			// lives on and retains the FEC in memory.
			if (mSaveToDiskTask.getStatus() == AsyncTask.Status.FINISHED) {
				mSaveToDiskTask.cancel(true);
				mSaveToDiskTask = null;
			}
		}

		super.onDestroy();
	}
//
//	private int mAnimationCompletionSet = 0;
//
//	private void afterAllAnimations() {
//		Log.i(TAG, "afterAllAnimations");
//		if (mStaleView != null) {
//			if (mStaleView instanceof ODKView) {
//				// http://code.google.com/p/android/issues/detail?id=8488
//				((ODKView) mStaleView).recycleDrawables();
//			}
//			mStaleView = null;
//		}
//
//		if (mCurrentView instanceof ODKView) {
//			((ODKView) mCurrentView).setFocus(this);
//		}
//		mBeenSwiped = false;
//	}
//
//	@Override
//	public void onAnimationEnd(Animation animation) {
//		Log.i(TAG, "onAnimationEnd "
//				+ ((animation == mInAnimation) ? "in"
//						: ((animation == mOutAnimation) ? "out" : "other")));
//		if (mInAnimation == animation) {
//			mAnimationCompletionSet |= 1;
//		} else if (mOutAnimation == animation) {
//			mAnimationCompletionSet |= 2;
//		} else {
//			Log.e(TAG, "Unexpected animation");
//		}
//
//		if (mAnimationCompletionSet == 3) {
//			this.afterAllAnimations();
//		}
//	}
//
//	@Override
//	public void onAnimationRepeat(Animation animation) {
//		// Added by AnimationListener interface.
//		Log.i(TAG, "onAnimationRepeat "
//				+ ((animation == mInAnimation) ? "in"
//						: ((animation == mOutAnimation) ? "out" : "other")));
//	}
//
//	@Override
//	public void onAnimationStart(Animation animation) {
//		// Added by AnimationListener interface.
//		Log.i(TAG, "onAnimationStart "
//				+ ((animation == mInAnimation) ? "in"
//						: ((animation == mOutAnimation) ? "out" : "other")));
//	}

	/**
	 * loadingComplete() is called by FormLoaderTask once it has finished
	 * loading a form.
	 */
	@Override
	public void loadingComplete(FormLoaderTask task) {
		dismissDialog(PROGRESS_DIALOG);

		FormController formController = task.getFormController();
		boolean pendingActivityResult = task.hasPendingActivityResult();
		boolean hasUsedSavepoint = task.hasUsedSavepoint();
		int requestCode = task.getRequestCode(); // these are bogus if
													// pendingActivityResult is
													// false
		int resultCode = task.getResultCode();
		Intent intent = task.getIntent();

		mFormLoaderTask.setFormLoaderListener(null);
		FormLoaderTask t = mFormLoaderTask;
		mFormLoaderTask = null;
		t.cancel(true);
		t.destroy();
		Collect.getInstance().setFormController(formController);
		CompatibilityUtils.invalidateOptionsMenu(this);

        Collect.getInstance().setExternalDataManager(task.getExternalDataManager());

		// Set the language if one has already been set in the past
		String[] languageTest = formController.getLanguages();
		if (languageTest != null) {
			String defaultLanguage = formController.getLanguage();
			String newLanguage = "";
			String selection = FormsColumns.FORM_FILE_PATH + "=?";
			String selectArgs[] = { mFormPath };
			Cursor c = null;
			try {
				c = getContentResolver().query(FormsColumns.CONTENT_URI, null,
						selection, selectArgs, null);
				if (c.getCount() == 1) {
					c.moveToFirst();
					newLanguage = c.getString(c
							.getColumnIndex(FormsColumns.LANGUAGE));
				}
			} finally {
				if (c != null) {
					c.close();
				}
			}

			// if somehow we end up with a bad language, set it to the default
			try {
				formController.setLanguage(newLanguage);
			} catch (Exception e) {
				formController.setLanguage(defaultLanguage);
			}
		}

		if (pendingActivityResult) {
			// set the current view to whatever group we were at...
			populateViews((Preset) getIntent().getParcelableExtra("fields"));
			// process the pending activity request...
			onActivityResult(requestCode, resultCode, intent);
			return;
		}
//
//		// it can be a normal flow for a pending activity result to restore from
//		// a savepoint
//		// (the call flow handled by the above if statement). For all other use
//		// cases, the
//		// user should be notified, as it means they wandered off doing other
//		// things then
//		// returned to ODK Collect and chose Edit Saved Form, but that the
//		// savepoint for that
//		// form is newer than the last saved version of their form data.
//		if (hasUsedSavepoint) {
//			runOnUiThread(new Runnable() {
//				@Override
//				public void run() {
//					Toast.makeText(FormEntryActivity.this,
//							getString(R.string.savepoint_used),
//							Toast.LENGTH_LONG).show();
//				}
//			});
//		}

		// Set saved answer path
		if (formController.getInstancePath() == null) {

			// Create new answer folder.
			String time = new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss",
					Locale.ENGLISH).format(Calendar.getInstance().getTime());
			String file = mFormPath.substring(mFormPath.lastIndexOf('/') + 1,
					mFormPath.lastIndexOf('.'));
			String path = Collect.getInstance().getInstancesPath() + File.separator + file + "_"
					+ time;
			if (FileUtils.createFolder(path)) {
				formController.setInstancePath(new File(path + File.separator
						+ file + "_" + time + ".xml"));
			}
		}
//        else {
//			Intent reqIntent = getIntent();
//			boolean showFirst = reqIntent.getBooleanExtra("start", false);
//
//			if (!showFirst) {
//				// we've just loaded a saved form, so start in the hierarchy
//				// view
//				Intent i = new Intent(this, FormHierarchyActivity.class);
//				startActivity(i);
//				return; // so we don't show the intro screen before jumping to
//						// the hierarchy
//			}
//		}

        Patient patient = getIntent().getParcelableExtra("patient");
        if (patient != null) {
            setTitle(patient.id + ": " + patient.givenName + " " + patient.familyName);
        } else {
            setTitle(formController.getFormTitle());
        }

		populateViews((Preset) getIntent().getParcelableExtra("fields"));
	}

	/**
	 * called by the FormLoaderTask if something goes wrong.
	 */
	@Override
	public void loadingError(String errorMsg) {
		dismissDialog(PROGRESS_DIALOG);
		if (errorMsg != null) {
			createErrorDialog(errorMsg, EXIT);
		} else {
			createErrorDialog(getString(R.string.parse_error), EXIT);
		}
	}

	/**
	 * Called by SavetoDiskTask if everything saves correctly.
	 */
	@Override
	public void savingComplete(SaveResult saveResult) {
		dismissDialog(SAVING_DIALOG);

        int saveStatus = saveResult.getSaveResult();
        switch (saveStatus) {
		case SaveToDiskTask.SAVED:
//			Toast.makeText(this, getString(R.string.data_saved_ok),
//					Toast.LENGTH_SHORT).show();
			sendSavedBroadcast();
			break;
		case SaveToDiskTask.SAVED_AND_EXIT:
//			Toast.makeText(this, getString(R.string.data_saved_ok),
//					Toast.LENGTH_SHORT).show();
			sendSavedBroadcast();
			finishReturnInstance();
			break;
		case SaveToDiskTask.SAVE_ERROR:
            String message;
            if (saveResult.getSaveErrorMessage() != null) {
                message = getString(R.string.data_saved_error) + ": " + saveResult.getSaveErrorMessage();
            } else {
                message = getString(R.string.data_saved_error);
            }
            Toast.makeText(this, message,
                    Toast.LENGTH_LONG).show();
			break;
		case FormEntryController.ANSWER_CONSTRAINT_VIOLATED:
		case FormEntryController.ANSWER_REQUIRED_BUT_EMPTY:
//			refreshCurrentView();

			// get constraint behavior preference value with appropriate default
			String constraint_behavior = PreferenceManager.getDefaultSharedPreferences(this)
				.getString(PreferencesActivity.KEY_CONSTRAINT_BEHAVIOR,
					PreferencesActivity.CONSTRAINT_BEHAVIOR_DEFAULT);
//
//			// an answer constraint was violated, so we need to display the proper toast(s)
//			// if constraint behavior is on_swipe, this will happen if we do a 'swipe' to the next question
//			if (constraint_behavior.equals(PreferencesActivity.CONSTRAINT_BEHAVIOR_ON_SWIPE))
//				next();
//			// otherwise, we can get the proper toast(s) by saving with constraint check
//			else
//				saveAnswersForCurrentScreen(EVALUATE_CONSTRAINTS);

			break;
		}
	}

    @Override
    public void onProgressStep(String stepMessage) {
        this.stepMessage = stepMessage;
        if (mProgressDialog != null) {
            mProgressDialog.setMessage(getString(R.string.please_wait) + "\n\n" + stepMessage);
        }
    }

	/**
	 * Attempts to save an answer to the specified index.
	 *
	 * @param answer
	 * @param index
	 * @param evaluateConstraints
	 * @return status as determined in FormEntryController
	 */
	public int saveAnswer(IAnswerData answer, FormIndex index,
			boolean evaluateConstraints) throws JavaRosaException {
		FormController formController = Collect.getInstance()
				.getFormController();
		if (evaluateConstraints) {
			return formController.answerQuestion(index, answer);
		} else {
			formController.saveAnswer(index, answer);
			return FormEntryController.ANSWER_OK;
		}
	}

//	/**
//	 * Checks the database to determine if the current instance being edited has
//	 * already been 'marked completed'. A form can be 'unmarked' complete and
//	 * then resaved.
//	 *
//	 * @return true if form has been marked completed, false otherwise.
//	 */
//	private boolean isInstanceComplete(boolean end) {
//		FormController formController = Collect.getInstance()
//				.getFormController();
//		// default to false if we're mid form
//		boolean complete = false;
//
//		// if we're at the end of the form, then check the preferences
//		if (end) {
//			// First get the value from the preferences
//			SharedPreferences sharedPreferences = PreferenceManager
//					.getDefaultSharedPreferences(this);
//			complete = sharedPreferences.getBoolean(
//					PreferencesActivity.KEY_COMPLETED_DEFAULT, true);
//		}
//
//		// Then see if we've already marked this form as complete before
//		String selection = InstanceColumns.INSTANCE_FILE_PATH + "=?";
//		String[] selectionArgs = { formController.getInstancePath()
//				.getAbsolutePath() };
//		Cursor c = null;
//		try {
//			c = getContentResolver().query(InstanceColumns.CONTENT_URI, null,
//					selection, selectionArgs, null);
//			if (c != null && c.getCount() > 0) {
//				c.moveToFirst();
//				String status = c.getString(c
//						.getColumnIndex(InstanceColumns.STATUS));
//				if (InstanceProviderAPI.STATUS_COMPLETE.compareTo(status) == 0) {
//					complete = true;
//				}
//			}
//		} finally {
//			if (c != null) {
//				c.close();
//			}
//		}
//		return complete;
//	}
//
//	public void next() {
//		if (!mBeenSwiped) {
//			mBeenSwiped = true;
//			showNextView();
//		}
//	}

	/**
	 * Returns the instance that was just filled out to the calling activity, if
	 * requested.
	 */
	private void finishReturnInstance() {
		FormController formController = Collect.getInstance()
				.getFormController();
		String action = getIntent().getAction();
		if (Intent.ACTION_PICK.equals(action)
				|| Intent.ACTION_EDIT.equals(action)) {
			// caller is waiting on a picked form
			String selection = InstanceColumns.INSTANCE_FILE_PATH + "=?";
			String[] selectionArgs = { formController.getInstancePath()
					.getAbsolutePath() };
			Cursor c = null;
			try {
				c = getContentResolver().query(InstanceColumns.CONTENT_URI,
						null, selection, selectionArgs, null);
				if (c.getCount() > 0) {
					// should only be one...
					c.moveToFirst();
					String id = c.getString(c
							.getColumnIndex(InstanceColumns._ID));
					Uri instance = Uri.withAppendedPath(
							InstanceColumns.CONTENT_URI, id);
					setResult(RESULT_OK, new Intent().setData(instance));
				}
			} finally {
				if (c != null) {
					c.close();
				}
			}
		}
		finish();
	}
//
//	@Override
//	public boolean onDown(MotionEvent e) {
//		return false;
//	}
//
//	@Override
//	public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,
//			float velocityY) {
//		// only check the swipe if it's enabled in preferences
//		SharedPreferences sharedPreferences = PreferenceManager
//				.getDefaultSharedPreferences(this);
//		String navigation = sharedPreferences.getString(
//				PreferencesActivity.KEY_NAVIGATION,
//				PreferencesActivity.NAVIGATION_SWIPE);
//		Boolean doSwipe = false;
//		if (navigation.contains(PreferencesActivity.NAVIGATION_SWIPE)) {
//			doSwipe = true;
//		}
//		if (doSwipe) {
//			// Looks for user swipes. If the user has swiped, move to the
//			// appropriate screen.
//
//			// for all screens a swipe is left/right of at least
//			// .25" and up/down of less than .25"
//			// OR left/right of > .5"
//			DisplayMetrics dm = new DisplayMetrics();
//			getWindowManager().getDefaultDisplay().getMetrics(dm);
//			int xPixelLimit = (int) (dm.xdpi * .25);
//			int yPixelLimit = (int) (dm.ydpi * .25);
//
//			if (mCurrentView instanceof ODKView) {
//				if (((ODKView) mCurrentView).suppressFlingGesture(e1, e2,
//						velocityX, velocityY)) {
//					return false;
//				}
//			}
//
//			if (mBeenSwiped) {
//				return false;
//			}
//
//			if ((Math.abs(e1.getX() - e2.getX()) > xPixelLimit && Math.abs(e1
//					.getY() - e2.getY()) < yPixelLimit)
//					|| Math.abs(e1.getX() - e2.getX()) > xPixelLimit * 2) {
//				mBeenSwiped = true;
//				if (velocityX > 0) {
//					if (e1.getX() > e2.getX()) {
//						Log.e(TAG,
//								"showNextView VelocityX is bogus! " + e1.getX()
//										+ " > " + e2.getX());
//						Collect.getInstance().getActivityLogger()
//								.logInstanceAction(this, "onFling", "showNext");
//						showNextView();
//					} else {
//						Collect.getInstance()
//								.getActivityLogger()
//								.logInstanceAction(this, "onFling",
//										"showPrevious");
//						showPreviousView();
//					}
//				} else {
//					if (e1.getX() < e2.getX()) {
//						Log.e(TAG,
//								"showPreviousView VelocityX is bogus! "
//										+ e1.getX() + " < " + e2.getX());
//						Collect.getInstance()
//								.getActivityLogger()
//								.logInstanceAction(this, "onFling",
//										"showPrevious");
//						showPreviousView();
//					} else {
//						Collect.getInstance().getActivityLogger()
//								.logInstanceAction(this, "onFling", "showNext");
//						showNextView();
//					}
//				}
//				return true;
//			}
//		}
//
//		return false;
//	}
//
//	@Override
//	public void onLongPress(MotionEvent e) {
//	}
//
//	@Override
//	public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX,
//			float distanceY) {
//		// The onFling() captures the 'up' event so our view thinks it gets long
//		// pressed.
//		// We don't wnat that, so cancel it.
//        if (mCurrentView != null) {
//            mCurrentView.cancelLongPress();
//        }
//		return false;
//	}
//
//	@Override
//	public void onShowPress(MotionEvent e) {
//	}
//
//	@Override
//	public boolean onSingleTapUp(MotionEvent e) {
//		return false;
//	}
//
//	@Override
//	public void advance() {
//		next();
//	}

    public static void hideKeyboard(Context context, View view) {
        InputMethodManager inputMethodManager =
                (InputMethodManager) context.getSystemService(Activity.INPUT_METHOD_SERVICE);
        inputMethodManager.hideSoftInputFromWindow(view.getWindowToken(), 0);
    }

	@Override
	protected void onStart() {
		super.onStart();
		Collect.getInstance().getActivityLogger().logOnStart(this);
	}

	@Override
	protected void onStop() {
		Collect.getInstance().getActivityLogger().logOnStop(this);
		super.onStop();
	}

	private void sendSavedBroadcast() {
		Intent i = new Intent();
		i.setAction("org.odk.collect.android.FormSaved");
		this.sendBroadcast(i);
	}

    @Override
    public void onSavePointError(String errorMessage) {
        if (errorMessage != null && errorMessage.trim().length() > 0) {
            Toast.makeText(this, getString(R.string.save_point_error, errorMessage), Toast.LENGTH_LONG).show();
        }
    }

    private void showAlertDialog() {
        if (mAlertDialog == null) {
            return;
        }

        mAlertDialog.show();

        // Increase text sizes in dialog, which must be done after the alert is shown when not
        // specifying a custom alert dialog theme or layout.
        TextView[] views = {
                (TextView) mAlertDialog.findViewById(android.R.id.message),
                mAlertDialog.getButton(DialogInterface.BUTTON_NEGATIVE),
                mAlertDialog.getButton(DialogInterface.BUTTON_NEUTRAL),
                mAlertDialog.getButton(DialogInterface.BUTTON_POSITIVE)

        };
        for (TextView view : views) {
            if (view != null) {
                view.setTextSize(ALERT_DIALOG_TEXT_SIZE);
                view.setPadding(
                        ALERT_DIALOG_PADDING, ALERT_DIALOG_PADDING,
                        ALERT_DIALOG_PADDING, ALERT_DIALOG_PADDING);
            }
        }

        // Title should be bigger than message and button text.
        int alertTitleResource = getResources().getIdentifier("alertTitle", "id", "android");
        TextView title = (TextView)mAlertDialog.findViewById(alertTitleResource);
        if (title != null) {
            title.setTextSize(ALERT_DIALOG_TITLE_TEXT_SIZE);
            title.setPadding(
                    ALERT_DIALOG_PADDING, ALERT_DIALOG_PADDING,
                    ALERT_DIALOG_PADDING, ALERT_DIALOG_PADDING);
        }
    }

    /**
     * Returns true iff no values in the form have changed from the
     * pre-populated defaults. This will return true even if a value
     * has been given and subsequently cleared.
     *
     * @return true iff no form values have changed, false otherwise
     */
    private boolean allContentsUnchanged() {
        Map<FormIndex, IAnswerData> answers = getAnswers();

        // Compare each individual answer to the original answers (after
        // pre-population), returning false for any unmatched answer.
        for (Map.Entry<FormIndex, IAnswerData> entry : answers.entrySet()) {
            // Double-check the key even exists before continuing to avoid
            // a NullPointerException, but this should never happen in
            // practice.
            if (!mOriginalAnswerData.containsKey(entry.getKey())) {
                return false;
            }

            // Check for differences based on the display text of answers. This
            // has the (rare) downside that different values may be considered
            // equal if they have the same display text, but equals() is not
            // reliable for IAnswerData objects.
            String newText = getDisplayText(entry.getValue());
            String oldText = getDisplayText(mOriginalAnswerData.get(entry.getKey()));
            if (!equalOrBothNull(newText, oldText)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Retrieves the displayed text for an {@link IAnswerData} object.
     *
     * @param data the field
     * @return the displayed text, or null if the data is null
     */
    @Nullable
    private String getDisplayText(@Nullable IAnswerData data) {
        if (data == null) {
            return null;
        }

        return data.getDisplayText();
    }

    /**
     * Checks if the given objects are both equal or both null (equivalent to Objects.equals,
     * but without the requirement for API level 19).
     * @param obj1 the first object to compare
     * @param obj2 the second object to compare
     * @return true if obj1 == obj2 or obj1 and obj2 are both null, false otherwise
     */
    private boolean equalOrBothNull(Object obj1, Object obj2) {
        // Check if the Objects refer to the same Object or are both null.
        if (obj1 == obj2) {
            return true;
        }

        // If either Object is null, then the two cannot be equal.
        if (obj1 == null || obj2 == null) {
            return false;
        }

        return obj1.equals(obj2);
    }
}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.activities;

import android.app.AlertDialog;
import android.app.Dialog;
import android.app.ListActivity;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Color;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.preference.PreferenceManager;
import android.util.Log;
import android.util.SparseBooleanArray;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ListView;
import android.widget.SimpleAdapter;
import android.widget.Toast;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.listeners.FormDownloaderListener;
import org.odk.collect.android.listeners.FormListDownloaderListener;
import org.odk.collect.android.logic.FormDetails;
import org.odk.collect.android.preferences.PreferencesActivity;
import org.odk.collect.android.tasks.DownloadFormListTask;
import org.odk.collect.android.tasks.DownloadFormsTask;
import org.odk.collect.android.utilities.CompatibilityUtils;
import org.odk.collect.android.utilities.WebUtils;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Set;

/**
 * Responsible for displaying, adding and deleting all the valid forms in the forms directory. One
 * caveat. If the server requires authentication, a dialog will pop up asking when you request the
 * form list. If somehow you manage to wait long enough and then try to download selected forms and
 * your authorization has timed out, it won't again ask for authentication, it will just throw a 401
 * and you'll have to hit 'refresh' where it will ask for credentials again. Technically a server
 * could point at other servers requiring authentication to download the forms, but the current
 * implementation in Collect doesn't allow for that. Mostly this is just because it's a pain in the
 * butt to keep track of which forms we've downloaded and where we're needing to authenticate. I
 * think we do something similar in the instanceuploader task/activity, so should change the
 * implementation eventually.
 *
 * @author Carl Hartung (carlhartung@gmail.com)
 */
public class FormDownloadList extends ListActivity implements FormListDownloaderListener,
        FormDownloaderListener {
    private static final String t = "RemoveFileManageList";

    private static final int PROGRESS_DIALOG = 1;
    private static final int AUTH_DIALOG = 2;
    private static final int MENU_PREFERENCES = Menu.FIRST;

    private static final String BUNDLE_TOGGLED_KEY = "toggled";
    private static final String BUNDLE_SELECTED_COUNT = "selectedcount";
    private static final String BUNDLE_FORM_MAP = "formmap";
    private static final String DIALOG_TITLE = "dialogtitle";
    private static final String DIALOG_MSG = "dialogmsg";
    private static final String DIALOG_SHOWING = "dialogshowing";
    private static final String FORMLIST = "formlist";

    public static final String LIST_URL = "listurl";

    private static final String FORMNAME = "formname";
    private static final String FORMDETAIL_KEY = "formdetailkey";
    private static final String FORMID_DISPLAY = "formiddisplay";

    private String mAlertMsg;
    private boolean mAlertShowing = false;
    private String mAlertTitle;

    private AlertDialog mAlertDialog;
    private ProgressDialog mProgressDialog;
    private Button mDownloadButton;

    private DownloadFormListTask mDownloadFormListTask;
    private DownloadFormsTask mDownloadFormsTask;
    private Button mToggleButton;
    private Button mRefreshButton;

    private HashMap<String, FormDetails> mFormNamesAndURLs = new HashMap<String,FormDetails>();
    private SimpleAdapter mFormListAdapter;
    private ArrayList<HashMap<String, String>> mFormList;

    private boolean mToggled = false;
    private int mSelectedCount = 0;

    private static final boolean EXIT = true;
    private static final boolean DO_NOT_EXIT = false;
    private boolean mShouldExit;
    private static final String SHOULD_EXIT = "shouldexit";


    @SuppressWarnings("unchecked")
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.remote_file_manage_list);
        setTitle(getString(R.string.app_name) + " > " + getString(R.string.get_forms));
        mAlertMsg = getString(R.string.please_wait);

        // need white background before load
        getListView().setBackgroundColor(Color.WHITE);

        mDownloadButton = (Button) findViewById(R.id.add_button);
        mDownloadButton.setEnabled(selectedItemCount() > 0);
        mDownloadButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
            	// this is callled in downloadSelectedFiles():
            	//    Collect.getInstance().getActivityLogger().logAction(this, "downloadSelectedFiles", ...);
                downloadSelectedFiles();
                mToggled = false;
                clearChoices();
            }
        });

        mToggleButton = (Button) findViewById(R.id.toggle_button);
        mToggleButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                // toggle selections of items to all or none
                ListView ls = getListView();
                mToggled = !mToggled;

                Collect.getInstance().getActivityLogger().logAction(this, "toggleFormCheckbox", Boolean.toString(mToggled));

                for (int pos = 0; pos < ls.getCount(); pos++) {
                    ls.setItemChecked(pos, mToggled);
                }

                mDownloadButton.setEnabled(!(selectedItemCount() == 0));
            }
        });

        mRefreshButton = (Button) findViewById(R.id.refresh_button);
        mRefreshButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                Collect.getInstance().getActivityLogger().logAction(this, "refreshForms", "");

                mToggled = false;
                downloadFormList();
                FormDownloadList.this.getListView().clearChoices();
                clearChoices();
            }
        });

        if (savedInstanceState != null) {
            // If the screen has rotated, the hashmap with the form ids and urls is passed here.
            if (savedInstanceState.containsKey(BUNDLE_FORM_MAP)) {
                mFormNamesAndURLs =
                    (HashMap<String, FormDetails>) savedInstanceState
                            .getSerializable(BUNDLE_FORM_MAP);
            }

            // indicating whether or not select-all is on or off.
            if (savedInstanceState.containsKey(BUNDLE_TOGGLED_KEY)) {
                mToggled = savedInstanceState.getBoolean(BUNDLE_TOGGLED_KEY);
            }

            // how many items we've selected
            // Android should keep track of this, but broken on rotate...
            if (savedInstanceState.containsKey(BUNDLE_SELECTED_COUNT)) {
                mSelectedCount = savedInstanceState.getInt(BUNDLE_SELECTED_COUNT);
                mDownloadButton.setEnabled(!(mSelectedCount == 0));
            }

            // to restore alert dialog.
            if (savedInstanceState.containsKey(DIALOG_TITLE)) {
                mAlertTitle = savedInstanceState.getString(DIALOG_TITLE);
            }
            if (savedInstanceState.containsKey(DIALOG_MSG)) {
                mAlertMsg = savedInstanceState.getString(DIALOG_MSG);
            }
            if (savedInstanceState.containsKey(DIALOG_SHOWING)) {
                mAlertShowing = savedInstanceState.getBoolean(DIALOG_SHOWING);
            }
            if (savedInstanceState.containsKey(SHOULD_EXIT)) {
                mShouldExit = savedInstanceState.getBoolean(SHOULD_EXIT);
            }
        }

        if (savedInstanceState != null && savedInstanceState.containsKey(FORMLIST)) {
            mFormList =
                (ArrayList<HashMap<String, String>>) savedInstanceState.getSerializable(FORMLIST);
        } else {
            mFormList = new ArrayList<HashMap<String, String>>();
        }

        if (getLastNonConfigurationInstance() instanceof DownloadFormListTask) {
            mDownloadFormListTask = (DownloadFormListTask) getLastNonConfigurationInstance();
            if (mDownloadFormListTask.getStatus() == AsyncTask.Status.FINISHED) {
                try {
                    dismissDialog(PROGRESS_DIALOG);
                } catch (IllegalArgumentException e) {
                    Log.i(t, "Attempting to close a dialog that was not previously opened");
                }
                mDownloadFormsTask = null;
            }
        } else if (getLastNonConfigurationInstance() instanceof DownloadFormsTask) {
            mDownloadFormsTask = (DownloadFormsTask) getLastNonConfigurationInstance();
            if (mDownloadFormsTask.getStatus() == AsyncTask.Status.FINISHED) {
                try {
                    dismissDialog(PROGRESS_DIALOG);
                } catch (IllegalArgumentException e) {
                    Log.i(t, "Attempting to close a dialog that was not previously opened");
                }
                mDownloadFormsTask = null;
            }
        } else if (getLastNonConfigurationInstance() == null) {
            // first time, so get the formlist
            downloadFormList();
        }

        String[] data = new String[] {
                FORMNAME, FORMID_DISPLAY, FORMDETAIL_KEY
        };
        int[] view = new int[] {
                R.id.text1, R.id.text2
        };

        mFormListAdapter =
            new SimpleAdapter(this, mFormList, R.layout.two_item_multiple_choice, data, view);
        getListView().setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
        getListView().setItemsCanFocus(false);
        setListAdapter(mFormListAdapter);
    }


    @Override
    protected void onStart() {
    	super.onStart();
		Collect.getInstance().getActivityLogger().logOnStart(this);
    }

    @Override
    protected void onStop() {
		Collect.getInstance().getActivityLogger().logOnStop(this);
    	super.onStop();
    }

    private void clearChoices() {
        FormDownloadList.this.getListView().clearChoices();
        mDownloadButton.setEnabled(false);
    }


    @Override
    protected void onListItemClick(ListView l, View v, int position, long id) {
		super.onListItemClick(l, v, position, id);
		mDownloadButton.setEnabled(!(selectedItemCount() == 0));

		Object o = getListAdapter().getItem(position);
		@SuppressWarnings("unchecked")
		HashMap<String, String> item = (HashMap<String, String>) o;
        FormDetails detail = mFormNamesAndURLs.get(item.get(FORMDETAIL_KEY));

        Collect.getInstance().getActivityLogger().logAction(this, "onListItemClick", detail.downloadUrl);
    }


    /**
     * Starts the download task and shows the progress dialog.
     */
    private void downloadFormList() {
        ConnectivityManager connectivityManager =
            (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo ni = connectivityManager.getActiveNetworkInfo();

        if (ni == null || !ni.isConnected()) {
            Toast.makeText(this, R.string.no_connection, Toast.LENGTH_SHORT).show();
        } else {

            mFormNamesAndURLs = new HashMap<String, FormDetails>();
            if (mProgressDialog != null) {
                // This is needed because onPrepareDialog() is broken in 1.6.
                mProgressDialog.setMessage(getString(R.string.please_wait));
            }
            showDialog(PROGRESS_DIALOG);

            if (mDownloadFormListTask != null &&
            	mDownloadFormListTask.getStatus() != AsyncTask.Status.FINISHED) {
            	return; // we are already doing the download!!!
            } else if (mDownloadFormListTask != null) {
            	mDownloadFormListTask.setDownloaderListener(null);
            	mDownloadFormListTask.cancel(true);
            	mDownloadFormListTask = null;
            }

            mDownloadFormListTask = new DownloadFormListTask();
            mDownloadFormListTask.setDownloaderListener(this);
            mDownloadFormListTask.execute();
        }
    }


    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putBoolean(BUNDLE_TOGGLED_KEY, mToggled);
        outState.putInt(BUNDLE_SELECTED_COUNT, selectedItemCount());
        outState.putSerializable(BUNDLE_FORM_MAP, mFormNamesAndURLs);
        outState.putString(DIALOG_TITLE, mAlertTitle);
        outState.putString(DIALOG_MSG, mAlertMsg);
        outState.putBoolean(DIALOG_SHOWING, mAlertShowing);
        outState.putBoolean(SHOULD_EXIT, mShouldExit);
        outState.putSerializable(FORMLIST, mFormList);
    }


    /**
     * returns the number of items currently selected in the list.
     *
     * @return
     */
    private int selectedItemCount() {
        int count = 0;
        SparseBooleanArray sba = getListView().getCheckedItemPositions();
        for (int i = 0; i < getListView().getCount(); i++) {
            if (sba.get(i, false)) {
                count++;
            }
        }
        return count;
    }


    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        Collect.getInstance().getActivityLogger().logAction(this, "onCreateOptionsMenu", "show");
    	super.onCreateOptionsMenu(menu);

        CompatibilityUtils.setShowAsAction(
    		menu.add(0, MENU_PREFERENCES, 0, R.string.general_preferences)
        		.setIcon(R.drawable.ic_menu_preferences),
        	MenuItem.SHOW_AS_ACTION_NEVER);
        return true;
    }


    @Override
    public boolean onMenuItemSelected(int featureId, MenuItem item) {
        switch (item.getItemId()) {
            case MENU_PREFERENCES:
                Collect.getInstance().getActivityLogger().logAction(this, "onMenuItemSelected", "MENU_PREFERENCES");
                Intent i = new Intent(this, PreferencesActivity.class);
                startActivity(i);
                return true;
        }
        return super.onMenuItemSelected(featureId, item);
    }


    @Override
    protected Dialog onCreateDialog(int id) {
        switch (id) {
            case PROGRESS_DIALOG:
                Collect.getInstance().getActivityLogger().logAction(this, "onCreateDialog.PROGRESS_DIALOG", "show");
                mProgressDialog = new ProgressDialog(this);
                DialogInterface.OnClickListener loadingButtonListener =
                    new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                            Collect.getInstance().getActivityLogger().logAction(this, "onCreateDialog.PROGRESS_DIALOG", "OK");
                            dialog.dismiss();
                            // we use the same progress dialog for both
                            // so whatever isn't null is running
                            if (mDownloadFormListTask != null) {
                                mDownloadFormListTask.setDownloaderListener(null);
                                mDownloadFormListTask.cancel(true);
                                mDownloadFormListTask = null;
                            }
                            if (mDownloadFormsTask != null) {
                                mDownloadFormsTask.setDownloaderListener(null);
                                mDownloadFormsTask.cancel(true);
                                mDownloadFormsTask = null;
                            }
                        }
                    };
                mProgressDialog.setTitle(getString(R.string.downloading_data));
                mProgressDialog.setMessage(mAlertMsg);
                mProgressDialog.setIcon(android.R.drawable.ic_dialog_info);
                mProgressDialog.setIndeterminate(true);
                mProgressDialog.setCancelable(false);
                mProgressDialog.setButton(getString(R.string.cancel), loadingButtonListener);
                return mProgressDialog;
            case AUTH_DIALOG:
                Collect.getInstance().getActivityLogger().logAction(this, "onCreateDialog.AUTH_DIALOG", "show");
                AlertDialog.Builder b = new AlertDialog.Builder(this);

                LayoutInflater factory = LayoutInflater.from(this);
                final View dialogView = factory.inflate(R.layout.server_auth_dialog, null);

                // Get the server, username, and password from the settings
                SharedPreferences settings =
                    PreferenceManager.getDefaultSharedPreferences(getBaseContext());
                String server =
                    settings.getString(PreferencesActivity.KEY_SERVER_URL,
                        getString(R.string.default_server_url));

                String formListUrl = getString(R.string.default_odk_formlist);
                final String url =
                    server + settings.getString(PreferencesActivity.KEY_FORMLIST_URL, formListUrl);
                Log.i(t, "Trying to get formList from: " + url);

                EditText username = (EditText) dialogView.findViewById(R.id.username_edit);
                String storedUsername = settings.getString(PreferencesActivity.KEY_USERNAME, null);
                username.setText(storedUsername);

                EditText password = (EditText) dialogView.findViewById(R.id.password_edit);
                String storedPassword = settings.getString(PreferencesActivity.KEY_PASSWORD, null);
                password.setText(storedPassword);

                b.setTitle(getString(R.string.server_requires_auth));
                b.setMessage(getString(R.string.server_auth_credentials, url));
                b.setView(dialogView);
                b.setPositiveButton(getString(R.string.ok), new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        Collect.getInstance().getActivityLogger().logAction(this, "onCreateDialog.AUTH_DIALOG", "OK");

                        EditText username = (EditText) dialogView.findViewById(R.id.username_edit);
                        EditText password = (EditText) dialogView.findViewById(R.id.password_edit);

                        Uri u = Uri.parse(url);

                        WebUtils.addCredentials(username.getText().toString(), password.getText()
                                .toString(), u.getHost());
                        downloadFormList();
                    }
                });
                b.setNegativeButton(getString(R.string.cancel),
                    new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                            Collect.getInstance().getActivityLogger().logAction(this, "onCreateDialog.AUTH_DIALOG", "Cancel");
                            finish();
                        }
                    });

                b.setCancelable(false);
                mAlertShowing = false;
                return b.create();
        }
        return null;
    }


    /**
     * starts the task to download the selected forms, also shows progress dialog
     */
    @SuppressWarnings("unchecked")
    private void downloadSelectedFiles() {
        int totalCount = 0;
        ArrayList<FormDetails> filesToDownload = new ArrayList<FormDetails>();

        SparseBooleanArray sba = getListView().getCheckedItemPositions();
        for (int i = 0; i < getListView().getCount(); i++) {
            if (sba.get(i, false)) {
                HashMap<String, String> item =
                    (HashMap<String, String>) getListAdapter().getItem(i);
                filesToDownload.add(mFormNamesAndURLs.get(item.get(FORMDETAIL_KEY)));
            }
        }
        totalCount = filesToDownload.size();

        Collect.getInstance().getActivityLogger().logAction(this, "downloadSelectedFiles", Integer.toString(totalCount));

        if (totalCount > 0) {
            // show dialog box
            showDialog(PROGRESS_DIALOG);

            mDownloadFormsTask = new DownloadFormsTask();
            mDownloadFormsTask.setDownloaderListener(this);
            mDownloadFormsTask.execute(filesToDownload);
        } else {
            Toast.makeText(getApplicationContext(), R.string.noselect_error, Toast.LENGTH_SHORT)
                    .show();
        }
    }


    @Override
    public Object onRetainNonConfigurationInstance() {
        if (mDownloadFormsTask != null) {
            return mDownloadFormsTask;
        } else {
            return mDownloadFormListTask;
        }
    }


    @Override
    protected void onDestroy() {
        if (mDownloadFormListTask != null) {
            mDownloadFormListTask.setDownloaderListener(null);
        }
        if (mDownloadFormsTask != null) {
            mDownloadFormsTask.setDownloaderListener(null);
        }
        super.onDestroy();
    }


    @Override
    protected void onResume() {
        if (mDownloadFormListTask != null) {
            mDownloadFormListTask.setDownloaderListener(this);
        }
        if (mDownloadFormsTask != null) {
            mDownloadFormsTask.setDownloaderListener(this);
        }
        if (mAlertShowing) {
            createAlertDialog(mAlertTitle, mAlertMsg, mShouldExit);
        }
        super.onResume();
    }


    @Override
    protected void onPause() {
        if (mAlertDialog != null && mAlertDialog.isShowing()) {
            mAlertDialog.dismiss();
        }
        super.onPause();
    }


    /**
     * Called when the form list has finished downloading. results will either contain a set of
     * <formname, formdetails> tuples, or one tuple of DL.ERROR.MSG and the associated message.
     *
     * @param result
     */
    public void formListDownloadingComplete(HashMap<String, FormDetails> result) {
        dismissDialog(PROGRESS_DIALOG);
        mDownloadFormListTask.setDownloaderListener(null);
        mDownloadFormListTask = null;

        if (result == null) {
            Log.e(t, "Formlist Downloading returned null.  That shouldn't happen");
            // Just displayes "error occured" to the user, but this should never happen.
            createAlertDialog(getString(R.string.load_remote_form_error),
                getString(R.string.error_occured), EXIT);
            return;
        }

        if (result.containsKey(DownloadFormListTask.DL_AUTH_REQUIRED)) {
            // need authorization
            showDialog(AUTH_DIALOG);
        } else if (result.containsKey(DownloadFormListTask.DL_ERROR_MSG)) {
            // Download failed
            String dialogMessage =
                getString(R.string.list_failed_with_error,
                    result.get(DownloadFormListTask.DL_ERROR_MSG).errorStr);
            String dialogTitle = getString(R.string.load_remote_form_error);
            createAlertDialog(dialogTitle, dialogMessage, DO_NOT_EXIT);
        } else {
            // Everything worked. Clear the list and add the results.
            mFormNamesAndURLs = result;

            mFormList.clear();

            ArrayList<String> ids = new ArrayList<String>(mFormNamesAndURLs.keySet());
            for (int i = 0; i < result.size(); i++) {
            	String formDetailsKey = ids.get(i);
            	FormDetails details = mFormNamesAndURLs.get(formDetailsKey);
                HashMap<String, String> item = new HashMap<String, String>();
                item.put(FORMNAME, details.formName);
                item.put(FORMID_DISPLAY,
                		((details.formVersion == null) ? "" : (getString(R.string.version) + " " + details.formVersion + " ")) +
                		"ID: " + details.formID );
                item.put(FORMDETAIL_KEY, formDetailsKey);

                // Insert the new form in alphabetical order.
                if (mFormList.size() == 0) {
                    mFormList.add(item);
                } else {
                    int j;
                    for (j = 0; j < mFormList.size(); j++) {
                        HashMap<String, String> compareMe = mFormList.get(j);
                        String name = compareMe.get(FORMNAME);
                        if (name.compareTo(mFormNamesAndURLs.get(ids.get(i)).formName) > 0) {
                            break;
                        }
                    }
                    mFormList.add(j, item);
                }
            }
            mFormListAdapter.notifyDataSetChanged();
        }
    }


    /**
     * Creates an alert dialog with the given tite and message. If shouldExit is set to true, the
     * activity will exit when the user clicks "ok".
     *
     * @param title
     * @param message
     * @param shouldExit
     */
    private void createAlertDialog(String title, String message, final boolean shouldExit) {
        Collect.getInstance().getActivityLogger().logAction(this, "createAlertDialog", "show");
        mAlertDialog = new AlertDialog.Builder(this).create();
        mAlertDialog.setTitle(title);
        mAlertDialog.setMessage(message);
        DialogInterface.OnClickListener quitListener = new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int i) {
                switch (i) {
                    case DialogInterface.BUTTON_POSITIVE: // ok
                        Collect.getInstance().getActivityLogger().logAction(this, "createAlertDialog", "OK");
                        // just close the dialog
                        mAlertShowing = false;
                        // successful download, so quit
                        if (shouldExit) {
                            finish();
                        }
                        break;
                }
            }
        };
        mAlertDialog.setCancelable(false);
        mAlertDialog.setButton(getString(R.string.ok), quitListener);
        mAlertDialog.setIcon(android.R.drawable.ic_dialog_info);
        mAlertMsg = message;
        mAlertTitle = title;
        mAlertShowing = true;
        mShouldExit = shouldExit;
        mAlertDialog.show();
    }


    @Override
    public void progressUpdate(String currentFile, int progress, int total) {
        mAlertMsg = getString(R.string.fetching_file, currentFile, progress, total);
        mProgressDialog.setMessage(mAlertMsg);
    }


    @Override
    public void formsDownloadingComplete(HashMap<FormDetails, String> result) {
        if (mDownloadFormsTask != null) {
            mDownloadFormsTask.setDownloaderListener(null);
        }

        if (mProgressDialog.isShowing()) {
            // should always be true here
            mProgressDialog.dismiss();
        }

        Set<FormDetails> keys = result.keySet();
        StringBuilder b = new StringBuilder();
        for (FormDetails k : keys) {
            b.append(k.formName +
            	" (" +
            	((k.formVersion != null) ?
            			(this.getString(R.string.version) + ": " + k.formVersion + " ")
            			: "") +
            	"ID: " + k.formID + ") - " +
            	result.get(k));
            b.append("\n\n");
        }

        createAlertDialog(getString(R.string.download_forms_result), b.toString().trim(), EXIT);
    }

}

/*
 * Copyright (C) 2009 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.activities;

import android.app.TabActivity;
import android.content.Intent;
import android.graphics.Color;
import android.os.Bundle;
import android.widget.LinearLayout;
import android.widget.RelativeLayout;
import android.widget.TabHost;
import android.widget.TabWidget;
import android.widget.TextView;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;

/**
 * A host activity for {@link InstanceChooserList}.
 * 
 * @author Yaw Anokwa (yanokwa@gmail.com)
 */
public class InstanceChooserTabs extends TabActivity {

    private static final String SAVED_TAB = "saved_tab";
    private static final String COMPLETED_TAB = "completed_tab";

    // count for tab menu bar
    private int mSavedCount;
    private int mCompletedCount;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setTitle(getString(R.string.app_name) + " > " + getString(R.string.review_data));

        // create tab host and tweak color
        final TabHost tabHost = getTabHost();
        tabHost.setBackgroundColor(Color.WHITE);
        tabHost.getTabWidget().setBackgroundColor(Color.BLACK);

        // create intent for saved tab
        Intent saved = new Intent(this, InstanceChooserList.class);
        tabHost.addTab(tabHost.newTabSpec(SAVED_TAB)
                .setIndicator(getString(R.string.saved_data, mSavedCount)).setContent(saved));

        // create intent for completed tab
        Intent completed = new Intent(this, InstanceChooserList.class);
        tabHost.addTab(tabHost.newTabSpec(COMPLETED_TAB)
                .setIndicator(getString(R.string.completed_data, mCompletedCount))
                .setContent(completed));

        // hack to set font size and padding in tab headers
        // arrived at these paths by using hierarchy viewer
        LinearLayout ll = (LinearLayout) tabHost.getChildAt(0);
        TabWidget tw = (TabWidget) ll.getChildAt(0);

        int fontsize = Collect.getQuestionFontsize();

        RelativeLayout rls = (RelativeLayout) tw.getChildAt(0);
        TextView tvs = (TextView) rls.getChildAt(1);
        tvs.setTextSize(fontsize);
        tvs.setPadding(0, 0, 0, 6);

        RelativeLayout rlc = (RelativeLayout) tw.getChildAt(1);
        TextView tvc = (TextView) rlc.getChildAt(1);
        tvc.setTextSize(fontsize);
        tvc.setPadding(0, 0, 0, 6);

        if (mSavedCount >= mCompletedCount) {
            getTabHost().setCurrentTabByTag(SAVED_TAB);
        } else {
            getTabHost().setCurrentTabByTag(COMPLETED_TAB);
        }
    }

}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.activities;

import android.app.AlertDialog;
import android.app.ListActivity;
import android.content.ContentUris;
import android.content.DialogInterface;
import android.content.Intent;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.view.View;
import android.widget.ListView;
import android.widget.SimpleCursorAdapter;
import android.widget.TextView;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.provider.InstanceProviderAPI;
import org.odk.collect.android.provider.InstanceProviderAPI.InstanceColumns;

/**
 * Responsible for displaying all the valid instances in the instance directory.
 *
 * @author Yaw Anokwa (yanokwa@gmail.com)
 * @author Carl Hartung (carlhartung@gmail.com)
 */
public class InstanceChooserList extends ListActivity {

    private static final boolean EXIT = true;
    private static final boolean DO_NOT_EXIT = false;
    private AlertDialog mAlertDialog;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // must be at the beginning of any activity that can be called from an external intent
        try {
            Collect.getInstance().createODKDirs();
        } catch (RuntimeException e) {
            createErrorDialog(e.getMessage(), EXIT);
            return;
        }

        setContentView(R.layout.chooser_list_layout);
        setTitle(getString(R.string.app_name) + " > " + getString(R.string.review_data));
        TextView tv = (TextView) findViewById(R.id.status_text);
        tv.setVisibility(View.GONE);

        String selection = InstanceColumns.STATUS + " != ?";
        String[] selectionArgs = {InstanceProviderAPI.STATUS_SUBMITTED};
        String sortOrder = InstanceColumns.STATUS + " DESC, " + InstanceColumns.DISPLAY_NAME + " ASC";
        Cursor c = managedQuery(InstanceColumns.CONTENT_URI, null, selection, selectionArgs, sortOrder);

        String[] data = new String[] {
                InstanceColumns.DISPLAY_NAME, InstanceColumns.DISPLAY_SUBTEXT
        };
        int[] view = new int[] {
                R.id.text1, R.id.text2
        };

        // render total instance view
        SimpleCursorAdapter instances =
            new SimpleCursorAdapter(this, R.layout.two_item, c, data, view);
        setListAdapter(instances);
    }


    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {
        super.onActivityResult(requestCode, resultCode, intent);
    }


    /**
     * Stores the path of selected instance in the parent class and finishes.
     */
    @Override
    protected void onListItemClick(ListView listView, View view, int position, long id) {
        Cursor c = (Cursor) getListAdapter().getItem(position);
        startManagingCursor(c);
        Uri instanceUri =
            ContentUris.withAppendedId(InstanceColumns.CONTENT_URI,
                c.getLong(c.getColumnIndex(InstanceColumns._ID)));

        Collect.getInstance().getActivityLogger().logAction(this, "onListItemClick", instanceUri.toString());

        String action = getIntent().getAction();
        if (Intent.ACTION_PICK.equals(action)) {
            // caller is waiting on a picked form
            setResult(RESULT_OK, new Intent().setData(instanceUri));
        } else {
            // the form can be edited if it is incomplete or if, when it was
            // marked as complete, it was determined that it could be edited
            // later.
            String status = c.getString(c.getColumnIndex(InstanceColumns.STATUS));
            String strCanEditWhenComplete =
                c.getString(c.getColumnIndex(InstanceColumns.CAN_EDIT_WHEN_COMPLETE));

            boolean canEdit = status.equals(InstanceProviderAPI.STATUS_INCOMPLETE)
                	           || Boolean.parseBoolean(strCanEditWhenComplete);
            if (!canEdit) {
            	createErrorDialog(getString(R.string.cannot_edit_completed_form),
                    	          DO_NOT_EXIT);
            	return;
            }
            // caller wants to view/edit a form, so launch formentryactivity
            startActivity(new Intent(Intent.ACTION_EDIT, instanceUri));
        }
        finish();
    }

    @Override
    protected void onStart() {
    	super.onStart();
		Collect.getInstance().getActivityLogger().logOnStart(this);
    }

    @Override
    protected void onStop() {
		Collect.getInstance().getActivityLogger().logOnStop(this);
    	super.onStop();
    }

    private void createErrorDialog(String errorMsg, final boolean shouldExit) {
        Collect.getInstance().getActivityLogger().logAction(this, "createErrorDialog", "show");

        mAlertDialog = new AlertDialog.Builder(this).create();
        mAlertDialog.setIcon(android.R.drawable.ic_dialog_info);
        mAlertDialog.setMessage(errorMsg);
        DialogInterface.OnClickListener errorListener = new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int i) {
                switch (i) {
                    case DialogInterface.BUTTON_POSITIVE:
                        Collect.getInstance().getActivityLogger().logAction(this, "createErrorDialog",
                        		shouldExit ? "exitApplication" : "OK");
                        if (shouldExit) {
                            finish();
                        }
                        break;
                }
            }
        };
        mAlertDialog.setCancelable(false);
        mAlertDialog.setButton(getString(R.string.ok), errorListener);
        mAlertDialog.show();
    }


}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.activities;

import android.app.AlertDialog;
import android.app.Dialog;
import android.app.ListActivity;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.os.Bundle;
import android.preference.PreferenceManager;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.View.OnLongClickListener;
import android.widget.Button;
import android.widget.ListView;
import android.widget.SimpleCursorAdapter;
import android.widget.Toast;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.preferences.PreferencesActivity;
import org.odk.collect.android.provider.InstanceProviderAPI;
import org.odk.collect.android.provider.InstanceProviderAPI.InstanceColumns;
import org.odk.collect.android.receivers.NetworkReceiver;
import org.odk.collect.android.utilities.CompatibilityUtils;

import java.util.ArrayList;

/**
 * Responsible for displaying all the valid forms in the forms directory. Stores
 * the path to selected form for use by {@link MainMenuActivity}.
 *
 * @author Carl Hartung (carlhartung@gmail.com)
 * @author Yaw Anokwa (yanokwa@gmail.com)
 */

public class InstanceUploaderList extends ListActivity implements
		OnLongClickListener {

	private static final String BUNDLE_SELECTED_ITEMS_KEY = "selected_items";
	private static final String BUNDLE_TOGGLED_KEY = "toggled";

	private static final int MENU_PREFERENCES = Menu.FIRST;
	private static final int MENU_SHOW_UNSENT = Menu.FIRST + 1;
	private static final int INSTANCE_UPLOADER = 0;
	
	private static final int GOOGLE_USER_DIALOG = 1;

	private Button mUploadButton;
	private Button mToggleButton;

	private boolean mShowUnsent = true;
	private SimpleCursorAdapter mInstances;
	private ArrayList<Long> mSelected = new ArrayList<Long>();
	private boolean mRestored = false;
	private boolean mToggled = false;

	public Cursor getUnsentCursor() {
		// get all complete or failed submission instances
		String selection = InstanceColumns.STATUS + "=? or "
				+ InstanceColumns.STATUS + "=?";
		String selectionArgs[] = { InstanceProviderAPI.STATUS_COMPLETE,
				InstanceProviderAPI.STATUS_SUBMISSION_FAILED };
		String sortOrder = InstanceColumns.DISPLAY_NAME + " ASC";
		Cursor c = managedQuery(InstanceColumns.CONTENT_URI, null, selection,
				selectionArgs, sortOrder);
		return c;
	}

	public Cursor getAllCursor() {
		// get all complete or failed submission instances
		String selection = InstanceColumns.STATUS + "=? or "
				+ InstanceColumns.STATUS + "=? or " + InstanceColumns.STATUS
				+ "=?";
		String selectionArgs[] = { InstanceProviderAPI.STATUS_COMPLETE,
				InstanceProviderAPI.STATUS_SUBMISSION_FAILED,
				InstanceProviderAPI.STATUS_SUBMITTED };
		String sortOrder = InstanceColumns.DISPLAY_NAME + " ASC";
		Cursor c = managedQuery(InstanceColumns.CONTENT_URI, null, selection,
				selectionArgs, sortOrder);
		return c;
	}

	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.instance_uploader_list);

		// set up long click listener

		mUploadButton = (Button) findViewById(R.id.upload_button);
		mUploadButton.setOnClickListener(new OnClickListener() {

			@Override
			public void onClick(View arg0) {
				ConnectivityManager connectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
				NetworkInfo ni = connectivityManager.getActiveNetworkInfo();

				if (NetworkReceiver.running == true) {
					Toast.makeText(
							InstanceUploaderList.this,
							"Background send running, please try again shortly",
							Toast.LENGTH_SHORT).show();
				} else if (ni == null || !ni.isConnected()) {
					Collect.getInstance().getActivityLogger()
							.logAction(this, "uploadButton", "noConnection");

					Toast.makeText(InstanceUploaderList.this,
							R.string.no_connection, Toast.LENGTH_SHORT).show();
				} else {
					Collect.getInstance()
							.getActivityLogger()
							.logAction(this, "uploadButton",
									Integer.toString(mSelected.size()));

					if (mSelected.size() > 0) {
						// items selected
						uploadSelectedFiles();
						mToggled = false;
						mSelected.clear();
						InstanceUploaderList.this.getListView().clearChoices();
						mUploadButton.setEnabled(false);
					} else {
						// no items selected
						Toast.makeText(getApplicationContext(),
								getString(R.string.noselect_error),
								Toast.LENGTH_SHORT).show();
					}
				}
			}
		});

		mToggleButton = (Button) findViewById(R.id.toggle_button);
		mToggleButton.setLongClickable(true);
		mToggleButton.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				// toggle selections of items to all or none
				ListView ls = getListView();
				mToggled = !mToggled;

				Collect.getInstance()
						.getActivityLogger()
						.logAction(this, "toggleButton",
								Boolean.toString(mToggled));
				// remove all items from selected list
				mSelected.clear();
				for (int pos = 0; pos < ls.getCount(); pos++) {
					ls.setItemChecked(pos, mToggled);
					// add all items if mToggled sets to select all
					if (mToggled)
						mSelected.add(ls.getItemIdAtPosition(pos));
				}
				mUploadButton.setEnabled(!(mSelected.size() == 0));

			}
		});
		mToggleButton.setOnLongClickListener(this);

		Cursor c = mShowUnsent ? getUnsentCursor() : getAllCursor();

		String[] data = new String[] { InstanceColumns.DISPLAY_NAME,
				InstanceColumns.DISPLAY_SUBTEXT };
		int[] view = new int[] { R.id.text1, R.id.text2 };

		// render total instance view
		mInstances = new SimpleCursorAdapter(this,
				R.layout.two_item_multiple_choice, c, data, view);

		setListAdapter(mInstances);
		getListView().setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
		getListView().setItemsCanFocus(false);
		mUploadButton.setEnabled(!(mSelected.size() == 0));

		// set title
		setTitle(getString(R.string.app_name) + " > "
				+ getString(R.string.send_data));

		// if current activity is being reinitialized due to changing
		// orientation restore all check
		// marks for ones selected
		if (mRestored) {
			ListView ls = getListView();
			for (long id : mSelected) {
				for (int pos = 0; pos < ls.getCount(); pos++) {
					if (id == ls.getItemIdAtPosition(pos)) {
						ls.setItemChecked(pos, true);
						break;
					}
				}

			}
			mRestored = false;
		}
	}

	@Override
	protected void onStart() {
		super.onStart();
		Collect.getInstance().getActivityLogger().logOnStart(this);
	}

	@Override
	protected void onStop() {
		Collect.getInstance().getActivityLogger().logOnStop(this);
		super.onStop();
	}

	private void uploadSelectedFiles() {
        // send list of _IDs.
        long[] instanceIDs = new long[mSelected.size()];
        for (int i = 0; i < mSelected.size(); i++) {
            instanceIDs[i] = mSelected.get(i);
        }

        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
        String server = prefs.getString(PreferencesActivity.KEY_PROTOCOL, null);
        // otherwise, do the normal agregate/other thing.
        Intent i = new Intent(this, InstanceUploaderActivity.class);
        i.putExtra(FormEntryActivity.KEY_INSTANCES, instanceIDs);
        startActivityForResult(i, INSTANCE_UPLOADER);
    }

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		Collect.getInstance().getActivityLogger()
				.logAction(this, "onCreateOptionsMenu", "show");
		super.onCreateOptionsMenu(menu);

		CompatibilityUtils.setShowAsAction(
				menu.add(0, MENU_PREFERENCES, 0, R.string.general_preferences)
						.setIcon(R.drawable.ic_menu_preferences),
				MenuItem.SHOW_AS_ACTION_NEVER);
		CompatibilityUtils.setShowAsAction(
				menu.add(0, MENU_SHOW_UNSENT, 1, R.string.change_view)
						.setIcon(R.drawable.ic_menu_manage),
				MenuItem.SHOW_AS_ACTION_NEVER);
		return true;
	}

	@Override
	public boolean onMenuItemSelected(int featureId, MenuItem item) {
		switch (item.getItemId()) {
		case MENU_PREFERENCES:
			Collect.getInstance().getActivityLogger()
					.logAction(this, "onMenuItemSelected", "MENU_PREFERENCES");
			createPreferencesMenu();
			return true;
		case MENU_SHOW_UNSENT:
			Collect.getInstance().getActivityLogger()
					.logAction(this, "onMenuItemSelected", "MENU_SHOW_UNSENT");
			showSentAndUnsentChoices();
			return true;
		}
		return super.onMenuItemSelected(featureId, item);
	}

	private void createPreferencesMenu() {
		Intent i = new Intent(this, PreferencesActivity.class);
		startActivity(i);
	}

	@Override
	protected void onListItemClick(ListView l, View v, int position, long id) {
		super.onListItemClick(l, v, position, id);

		// get row id from db
		Cursor c = (Cursor) getListAdapter().getItem(position);
		long k = c.getLong(c.getColumnIndex(InstanceColumns._ID));

		Collect.getInstance().getActivityLogger()
				.logAction(this, "onListItemClick", Long.toString(k));

		// add/remove from selected list
		if (mSelected.contains(k))
			mSelected.remove(k);
		else
			mSelected.add(k);

		mUploadButton.setEnabled(!(mSelected.size() == 0));

	}

	@Override
	protected void onRestoreInstanceState(Bundle savedInstanceState) {
		super.onRestoreInstanceState(savedInstanceState);
		long[] selectedArray = savedInstanceState
				.getLongArray(BUNDLE_SELECTED_ITEMS_KEY);
		for (int i = 0; i < selectedArray.length; i++)
			mSelected.add(selectedArray[i]);
		mToggled = savedInstanceState.getBoolean(BUNDLE_TOGGLED_KEY);
		mRestored = true;
		mUploadButton.setEnabled(selectedArray.length > 0);
	}

	@Override
	protected void onSaveInstanceState(Bundle outState) {
		super.onSaveInstanceState(outState);
		long[] selectedArray = new long[mSelected.size()];
		for (int i = 0; i < mSelected.size(); i++)
			selectedArray[i] = mSelected.get(i);
		outState.putLongArray(BUNDLE_SELECTED_ITEMS_KEY, selectedArray);
		outState.putBoolean(BUNDLE_TOGGLED_KEY, mToggled);
	}

	@Override
	protected void onActivityResult(int requestCode, int resultCode,
			Intent intent) {
		if (resultCode == RESULT_CANCELED) {
			return;
		}
		switch (requestCode) {
		// returns with a form path, start entry
		case INSTANCE_UPLOADER:
			if (intent.getBooleanExtra(FormEntryActivity.KEY_SUCCESS, false)) {
				mSelected.clear();
				getListView().clearChoices();
				if (mInstances.isEmpty()) {
					finish();
				}
			}
			break;
		default:
			break;
		}
		super.onActivityResult(requestCode, resultCode, intent);
	}

	private void showUnsent() {
		mShowUnsent = true;
		Cursor c = mShowUnsent ? getUnsentCursor() : getAllCursor();
		Cursor old = mInstances.getCursor();
		try {
			mInstances.changeCursor(c);
		} finally {
			if (old != null) {
				old.close();
				this.stopManagingCursor(old);
			}
		}
		getListView().invalidate();
	}

	private void showAll() {
		mShowUnsent = false;
		Cursor c = mShowUnsent ? getUnsentCursor() : getAllCursor();
		Cursor old = mInstances.getCursor();
		try {
			mInstances.changeCursor(c);
		} finally {
			if (old != null) {
				old.close();
				this.stopManagingCursor(old);
			}
		}
		getListView().invalidate();
	}

	@Override
	public boolean onLongClick(View v) {
		Collect.getInstance()
				.getActivityLogger()
				.logAction(this, "toggleButton.longClick",
						Boolean.toString(mToggled));
		return showSentAndUnsentChoices();
	}

	private boolean showSentAndUnsentChoices() {
		/**
		 * Create a dialog with options to save and exit, save, or quit without
		 * saving
		 */
		String[] items = { getString(R.string.show_unsent_forms),
				getString(R.string.show_sent_and_unsent_forms) };

		Collect.getInstance().getActivityLogger()
				.logAction(this, "changeView", "show");

		AlertDialog alertDialog = new AlertDialog.Builder(this)
				.setIcon(android.R.drawable.ic_dialog_info)
				.setTitle(getString(R.string.change_view))
				.setNeutralButton(getString(R.string.cancel),
						new DialogInterface.OnClickListener() {
							@Override
							public void onClick(DialogInterface dialog, int id) {
								Collect.getInstance()
										.getActivityLogger()
										.logAction(this, "changeView", "cancel");
								dialog.cancel();
							}
						})
				.setItems(items, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						switch (which) {

						case 0: // show unsent
							Collect.getInstance()
									.getActivityLogger()
									.logAction(this, "changeView", "showUnsent");
							InstanceUploaderList.this.showUnsent();
							break;

						case 1: // show all
							Collect.getInstance().getActivityLogger()
									.logAction(this, "changeView", "showAll");
							InstanceUploaderList.this.showAll();
							break;

						case 2:// do nothing
							break;
						}
					}
				}).create();
		alertDialog.show();
		return true;
	}
	
	@Override
    protected Dialog onCreateDialog(int id) {
        switch (id) {
            case GOOGLE_USER_DIALOG:
                AlertDialog.Builder gudBuilder = new AlertDialog.Builder(this);

                gudBuilder.setTitle(R.string.no_google_account);
                gudBuilder
                        .setMessage("You have selected Google Maps Engine as your server, please select a corresponding Google Account in the General Settings before continuing");
                gudBuilder.setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                    }
                });
                gudBuilder.setCancelable(false);
                return gudBuilder.create();
        }
        return null;
    }

}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.activities;

import android.app.Activity;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.location.LocationProvider;
import android.os.Bundle;
import android.widget.Toast;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.utilities.InfoLogger;
import org.odk.collect.android.widgets.GeoPointWidget;

import java.text.DecimalFormat;
import java.util.List;

public class GeoPointActivity extends Activity implements LocationListener {

	private static final String LOCATION_COUNT = "locationCount";

    private ProgressDialog mLocationDialog;
    private LocationManager mLocationManager;
    private Location mLocation;
    private boolean mGPSOn = false;
    private boolean mNetworkOn = false;
    private double mLocationAccuracy;
    private int mLocationCount = 0;


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        if ( savedInstanceState != null ) {
        	mLocationCount = savedInstanceState.getInt(LOCATION_COUNT);
        }

        Intent intent = getIntent();

        mLocationAccuracy = GeoPointWidget.DEFAULT_LOCATION_ACCURACY;
        if (intent != null && intent.getExtras() != null) {
        	if ( intent.hasExtra(GeoPointWidget.ACCURACY_THRESHOLD) ) {
        		mLocationAccuracy = intent.getDoubleExtra(GeoPointWidget.ACCURACY_THRESHOLD, GeoPointWidget.DEFAULT_LOCATION_ACCURACY);
        	}
        }

        setTitle(getString(R.string.app_name) + " > " + getString(R.string.get_location));

        mLocationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);

        // make sure we have a good location provider before continuing
        List<String> providers = mLocationManager.getProviders(true);
        for (String provider : providers) {
            if (provider.equalsIgnoreCase(LocationManager.GPS_PROVIDER)) {
                mGPSOn = true;
            }
            if (provider.equalsIgnoreCase(LocationManager.NETWORK_PROVIDER)) {
                mNetworkOn = true;
            }
        }
        if (!mGPSOn && !mNetworkOn) {
            Toast.makeText(getBaseContext(), getString(R.string.provider_disabled_error),
                Toast.LENGTH_SHORT).show();
            finish();
        }

        if ( mGPSOn ) {
        	Location loc = mLocationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);
        	if ( loc != null ) {
            	InfoLogger.geolog("GeoPointActivity: " + System.currentTimeMillis() +
          			   " lastKnownLocation(GPS) lat: " +
          			loc.getLatitude() + " long: " +
          			loc.getLongitude() + " acc: " +
          			loc.getAccuracy() );
        	} else {
            	InfoLogger.geolog("GeoPointActivity: " + System.currentTimeMillis() +
           			   " lastKnownLocation(GPS) null location");
        	}
        }

        if ( mNetworkOn ) {
        	Location loc = mLocationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER);
        	if ( loc != null ) {
            	InfoLogger.geolog("GeoPointActivity: " + System.currentTimeMillis() +
          			   " lastKnownLocation(Network) lat: " +
          			loc.getLatitude() + " long: " +
          			loc.getLongitude() + " acc: " +
          			loc.getAccuracy() );
        	} else {
            	InfoLogger.geolog("GeoPointActivity: " + System.currentTimeMillis() +
           			   " lastKnownLocation(Network) null location");
        	}
        }

        setupLocationDialog();

    }

	@Override
	protected void onSaveInstanceState(Bundle outState) {
		super.onSaveInstanceState(outState);
		outState.putInt(LOCATION_COUNT, mLocationCount);
	}

    @Override
    protected void onPause() {
        super.onPause();

        // stops the GPS. Note that this will turn off the GPS if the screen goes to sleep.
        mLocationManager.removeUpdates(this);

        // We're not using managed dialogs, so we have to dismiss the dialog to prevent it from
        // leaking memory.
        if (mLocationDialog != null && mLocationDialog.isShowing())
            mLocationDialog.dismiss();
    }


    @Override
    protected void onResume() {
        super.onResume();
        if (mGPSOn) {
            mLocationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, this);
        }
        if (mNetworkOn) {
            mLocationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 0, 0, this);
        }
        mLocationDialog.show();
    }

    @Override
    protected void onStart() {
    	super.onStart();
		Collect.getInstance().getActivityLogger().logOnStart(this);
    }

    @Override
    protected void onStop() {
		Collect.getInstance().getActivityLogger().logOnStop(this);
    	super.onStop();
    }

    /**
     * Sets up the look and actions for the progress dialog while the GPS is searching.
     */
    private void setupLocationDialog() {
    	Collect.getInstance().getActivityLogger().logInstanceAction(this, "setupLocationDialog", "show");
        // dialog displayed while fetching gps location
        mLocationDialog = new ProgressDialog(this);
        DialogInterface.OnClickListener geopointButtonListener =
            new DialogInterface.OnClickListener() {
                @Override
                public void onClick(DialogInterface dialog, int which) {
                    switch (which) {
                        case DialogInterface.BUTTON_POSITIVE:
                            Collect.getInstance().getActivityLogger().logInstanceAction(this, "acceptLocation", "OK");
                            returnLocation();
                            break;
                        case DialogInterface. BUTTON_NEGATIVE:
                            Collect.getInstance().getActivityLogger().logInstanceAction(this, "cancelLocation", "cancel");
                            mLocation = null;
                            finish();
                            break;
                    }
                }
            };

        // back button doesn't cancel
        mLocationDialog.setCancelable(false);
        mLocationDialog.setIndeterminate(true);
        mLocationDialog.setIcon(android.R.drawable.ic_dialog_info);
        mLocationDialog.setTitle(getString(R.string.getting_location));
        mLocationDialog.setMessage(getString(R.string.please_wait_long));
        mLocationDialog.setButton(DialogInterface.BUTTON_POSITIVE, getString(R.string.accept_location),
            geopointButtonListener);
        mLocationDialog.setButton(DialogInterface. BUTTON_NEGATIVE, getString(R.string.cancel_location),
            geopointButtonListener);
    }


    private void returnLocation() {
        if (mLocation != null) {
            Intent i = new Intent();
            i.putExtra(
                FormEntryActivity.LOCATION_RESULT,
                mLocation.getLatitude() + " " + mLocation.getLongitude() + " "
                        + mLocation.getAltitude() + " " + mLocation.getAccuracy());
            setResult(RESULT_OK, i);
        }
        finish();
    }


    @Override
    public void onLocationChanged(Location location) {
    	mLocation = location;
        if (mLocation != null) {
        	// Bug report: cached GeoPoint is being returned as the first value.
        	// Wait for the 2nd value to be returned, which is hopefully not cached?
        	++mLocationCount;
        	InfoLogger.geolog("GeoPointActivity: " + System.currentTimeMillis() +
     			   " onLocationChanged(" + mLocationCount + ") lat: " +
         			mLocation.getLatitude() + " long: " +
         			mLocation.getLongitude() + " acc: " +
         			mLocation.getAccuracy() );

        	if (mLocationCount > 1) {
	            mLocationDialog.setMessage(getString(R.string.location_provider_accuracy,
	                mLocation.getProvider(), truncateDouble(mLocation.getAccuracy())));

	            if (mLocation.getAccuracy() <= mLocationAccuracy) {
	                returnLocation();
	            }
        	}
        } else {
        	InfoLogger.geolog("GeoPointActivity: " + System.currentTimeMillis() +
      			   " onLocationChanged(" + mLocationCount + ") null location");
        }
    }


    private String truncateDouble(float number) {
        DecimalFormat df = new DecimalFormat("#.##");
        return df.format(number);
    }


    @Override
    public void onProviderDisabled(String provider) {

    }


    @Override
    public void onProviderEnabled(String provider) {

    }


    @Override
    public void onStatusChanged(String provider, int status, Bundle extras) {
        switch (status) {
            case LocationProvider.AVAILABLE:
                if (mLocation != null) {
                    mLocationDialog.setMessage(getString(R.string.location_accuracy,
                        mLocation.getAccuracy()));
                }
                break;
            case LocationProvider.OUT_OF_SERVICE:
                break;
            case LocationProvider.TEMPORARILY_UNAVAILABLE:
                break;
        }
    }

}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.activities;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.preference.PreferenceManager;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.EditText;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.listeners.InstanceUploaderListener;
import org.odk.collect.android.preferences.PreferencesActivity;
import org.odk.collect.android.provider.InstanceProviderAPI.InstanceColumns;
import org.odk.collect.android.tasks.InstanceUploaderTask;
import org.odk.collect.android.utilities.WebUtils;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;

/**
 * Activity to upload completed forms.
 *
 * @author Carl Hartung (carlhartung@gmail.com)
 */
public class InstanceUploaderActivity extends Activity implements InstanceUploaderListener {
    private final static String t = "InstanceUploaderActivity";
    private final static int PROGRESS_DIALOG = 1;
    private final static int AUTH_DIALOG = 2;

    private final static String AUTH_URI = "auth";
    private static final String ALERT_MSG = "alertmsg";
    private static final String ALERT_SHOWING = "alertshowing";
    private static final String TO_SEND = "tosend";

    private ProgressDialog mProgressDialog;
    private AlertDialog mAlertDialog;

    private String mAlertMsg;
    private boolean mAlertShowing;

    private InstanceUploaderTask mInstanceUploaderTask;

    // maintain a list of what we've yet to send, in case we're interrupted by auth requests
    private Long[] mInstancesToSend;

    // maintain a list of what we've sent, in case we're interrupted by auth requests
    private HashMap<String, String> mUploadedInstances;
    private String mUrl;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Log.i(t, "onCreate: " + ((savedInstanceState == null) ? "creating" : "re-initializing"));

        mAlertMsg = getString(R.string.please_wait);
        mAlertShowing = false;

        mUploadedInstances = new HashMap<String, String>();

        setTitle(getString(R.string.app_name) + " > " + getString(R.string.send_data));

        // get any simple saved state...
        if (savedInstanceState != null) {
            if (savedInstanceState.containsKey(ALERT_MSG)) {
                mAlertMsg = savedInstanceState.getString(ALERT_MSG);
            }
            if (savedInstanceState.containsKey(ALERT_SHOWING)) {
                mAlertShowing = savedInstanceState.getBoolean(ALERT_SHOWING, false);
            }

            mUrl = savedInstanceState.getString(AUTH_URI);
        }

        // and if we are resuming, use the TO_SEND list of not-yet-sent submissions
        // Otherwise, construct the list from the incoming intent value
        long[] selectedInstanceIDs = null;
        if (savedInstanceState != null && savedInstanceState.containsKey(TO_SEND)) {
            selectedInstanceIDs = savedInstanceState.getLongArray(TO_SEND);
        } else {
            // get instances to upload...
            Intent intent = getIntent();
            selectedInstanceIDs = intent.getLongArrayExtra(FormEntryActivity.KEY_INSTANCES);
        }

        mInstancesToSend = new Long[(selectedInstanceIDs == null) ? 0 : selectedInstanceIDs.length];
        if ( selectedInstanceIDs != null ) {
        	for ( int i = 0 ; i < selectedInstanceIDs.length ; ++i ) {
        		mInstancesToSend[i] = selectedInstanceIDs[i];
        	}
        }

        // at this point, we don't expect this to be empty...
        if (mInstancesToSend.length == 0) {
            Log.e(t, "onCreate: No instances to upload!");
            // drop through -- everything will process through OK
        } else {
            Log.i(t, "onCreate: Beginning upload of " + mInstancesToSend.length + " instances!");
        }

        // get the task if we've changed orientations. If it's null it's a new upload.
        mInstanceUploaderTask = (InstanceUploaderTask) getLastNonConfigurationInstance();
        if (mInstanceUploaderTask == null) {
            // setup dialog and upload task
            showDialog(PROGRESS_DIALOG);
            mInstanceUploaderTask = new InstanceUploaderTask();

            // register this activity with the new uploader task
            mInstanceUploaderTask.setUploaderListener(InstanceUploaderActivity.this);

            mInstanceUploaderTask.execute(mInstancesToSend);
        }
    }

    @Override
    protected void onStart() {
    	super.onStart();
		Collect.getInstance().getActivityLogger().logOnStart(this);
    }

    @Override
    protected void onResume() {
        Log.i(t, "onResume: Resuming upload of " + mInstancesToSend.length + " instances!");
        if (mInstanceUploaderTask != null) {
            mInstanceUploaderTask.setUploaderListener(this);
        }
        if (mAlertShowing) {
            createAlertDialog(mAlertMsg);
        }
        super.onResume();
    }


    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putString(ALERT_MSG, mAlertMsg);
        outState.putBoolean(ALERT_SHOWING, mAlertShowing);
        outState.putString(AUTH_URI, mUrl);

        long[] toSend = new long[mInstancesToSend.length];
        for ( int i = 0 ; i < mInstancesToSend.length ; ++i ) {
        	toSend[i] = mInstancesToSend[i];
        }
        outState.putLongArray(TO_SEND, toSend);
    }


    @Override
    public Object onRetainNonConfigurationInstance() {
        return mInstanceUploaderTask;
    }

    @Override
    protected void onPause() {
        Log.i(t, "onPause: Pausing upload of " + mInstancesToSend.length + " instances!");
        super.onPause();
        if (mAlertDialog != null && mAlertDialog.isShowing()) {
            mAlertDialog.dismiss();
        }
    }


    @Override
    protected void onStop() {
		Collect.getInstance().getActivityLogger().logOnStop(this);
    	super.onStop();
    }

    @Override
    protected void onDestroy() {
        if (mInstanceUploaderTask != null) {
            mInstanceUploaderTask.setUploaderListener(null);
        }
        super.onDestroy();
    }

    @Override
    public void uploadingComplete(HashMap<String, String> result) {
        Log.i(t, "uploadingComplete: Processing results (" + result.size() + ") from upload of " + mInstancesToSend.length + " instances!");

        try {
            dismissDialog(PROGRESS_DIALOG);
        } catch (Exception e) {
            // tried to close a dialog not open. don't care.
        }

        StringBuilder selection = new StringBuilder();
        Set<String> keys = result.keySet();
        Iterator<String> it = keys.iterator();

        String[] selectionArgs = new String[keys.size()];
        int i = 0;
        while (it.hasNext()) {
            String id = it.next();
            selection.append(InstanceColumns._ID + "=?");
            selectionArgs[i++] = id;
            if (i != keys.size()) {
                selection.append(" or ");
            }
        }

        StringBuilder message = new StringBuilder();
        {
        	Cursor results = null;
        	try {
                results = getContentResolver().query(InstanceColumns.CONTENT_URI,
                		null, selection.toString(), selectionArgs, null);
                if (results.getCount() > 0) {
                    results.moveToPosition(-1);
                    while (results.moveToNext()) {
                        String name =
                            results.getString(results.getColumnIndex(InstanceColumns.DISPLAY_NAME));
                        String id = results.getString(results.getColumnIndex(InstanceColumns._ID));
                        message.append(name + " - " + result.get(id) + "\n\n");
                    }
                } else {
                    message.append(getString(R.string.no_forms_uploaded));
                }
        	} finally {
        		if ( results != null ) {
        			results.close();
        		}
        	}
        }

        createAlertDialog(message.toString().trim());
    }


    @Override
    public void progressUpdate(int progress, int total) {
        mAlertMsg = getString(R.string.sending_items, progress, total);
        mProgressDialog.setMessage(mAlertMsg);
    }


    @Override
    protected Dialog onCreateDialog(int id) {
        switch (id) {
            case PROGRESS_DIALOG:
            	Collect.getInstance().getActivityLogger().logAction(this, "onCreateDialog.PROGRESS_DIALOG", "show");

                mProgressDialog = new ProgressDialog(this);
                DialogInterface.OnClickListener loadingButtonListener =
                    new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                        	Collect.getInstance().getActivityLogger().logAction(this, "onCreateDialog.PROGRESS_DIALOG", "cancel");
                            dialog.dismiss();
                            mInstanceUploaderTask.cancel(true);
                            mInstanceUploaderTask.setUploaderListener(null);
                            finish();
                        }
                    };
                mProgressDialog.setTitle(getString(R.string.uploading_data));
                mProgressDialog.setMessage(mAlertMsg);
                mProgressDialog.setIndeterminate(true);
                mProgressDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
                mProgressDialog.setCancelable(false);
                mProgressDialog.setButton(getString(R.string.cancel), loadingButtonListener);
                return mProgressDialog;
            case AUTH_DIALOG:
                Log.i(t, "onCreateDialog(AUTH_DIALOG): for upload of " + mInstancesToSend.length + " instances!");
            	Collect.getInstance().getActivityLogger().logAction(this, "onCreateDialog.AUTH_DIALOG", "show");
                AlertDialog.Builder b = new AlertDialog.Builder(this);

                LayoutInflater factory = LayoutInflater.from(this);
                final View dialogView = factory.inflate(R.layout.server_auth_dialog, null);

                // Get the server, username, and password from the settings
                SharedPreferences settings =
                    PreferenceManager.getDefaultSharedPreferences(getBaseContext());

                String server = mUrl;
                if (server == null) {
                    Log.e(t, "onCreateDialog(AUTH_DIALOG): No failing mUrl specified for upload of " + mInstancesToSend.length + " instances!");
                    // if the bundle is null, we're looking for a formlist
                    String submissionUrl = getString(R.string.default_odk_submission);
                    server =
                        settings.getString(PreferencesActivity.KEY_SERVER_URL,
                            getString(R.string.default_server_url))
                                + settings.getString(PreferencesActivity.KEY_SUBMISSION_URL, submissionUrl);
                }

                final String url = server;

                Log.i(t, "Trying connecting to: " + url);

                EditText username = (EditText) dialogView.findViewById(R.id.username_edit);
                String storedUsername = settings.getString(PreferencesActivity.KEY_USERNAME, null);
                username.setText(storedUsername);

                EditText password = (EditText) dialogView.findViewById(R.id.password_edit);
                String storedPassword = settings.getString(PreferencesActivity.KEY_PASSWORD, null);
                password.setText(storedPassword);

                b.setTitle(getString(R.string.server_requires_auth));
                b.setMessage(getString(R.string.server_auth_credentials, url));
                b.setView(dialogView);
                b.setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                    	Collect.getInstance().getActivityLogger().logAction(this, "onCreateDialog.AUTH_DIALOG", "OK");
                        EditText username = (EditText) dialogView.findViewById(R.id.username_edit);
                        EditText password = (EditText) dialogView.findViewById(R.id.password_edit);

                        Uri u = Uri.parse(url);
                        WebUtils.addCredentials(username.getText().toString(), password.getText()
                                .toString(), u.getHost());

                        showDialog(PROGRESS_DIALOG);
                        mInstanceUploaderTask = new InstanceUploaderTask();

                        // register this activity with the new uploader task
                        mInstanceUploaderTask.setUploaderListener(InstanceUploaderActivity.this);

                        mInstanceUploaderTask.execute(mInstancesToSend);
                    }
                });
                b.setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                    	Collect.getInstance().getActivityLogger().logAction(this, "onCreateDialog.AUTH_DIALOG", "cancel");
                        finish();
                    }
                });

                b.setCancelable(false);
                return b.create();
        }
        return null;
    }


    @Override
    public void authRequest(Uri url, HashMap<String, String> doneSoFar) {
        if (mProgressDialog.isShowing()) {
            // should always be showing here
            mProgressDialog.dismiss();
        }

        // add our list of completed uploads to "completed"
        // and remove them from our toSend list.
        ArrayList<Long> workingSet = new ArrayList<Long>();
        Collections.addAll(workingSet, mInstancesToSend);
        if (doneSoFar != null) {
            Set<String> uploadedInstances = doneSoFar.keySet();
            Iterator<String> itr = uploadedInstances.iterator();

            while (itr.hasNext()) {
                Long removeMe = Long.valueOf(itr.next());
                boolean removed = workingSet.remove(removeMe);
                if (removed) {
                    Log.i(t, removeMe
                            + " was already sent, removing from queue before restarting task");
                }
            }
            mUploadedInstances.putAll(doneSoFar);
        }

        // and reconstruct the pending set of instances to send
        Long[] updatedToSend = new Long[workingSet.size()];
        for ( int i = 0 ; i < workingSet.size() ; ++i ) {
        	updatedToSend[i] = workingSet.get(i);
        }
        mInstancesToSend = updatedToSend;

        mUrl = url.toString();
        showDialog(AUTH_DIALOG);
    }


    private void createAlertDialog(String message) {
    	Collect.getInstance().getActivityLogger().logAction(this, "createAlertDialog", "show");

        mAlertDialog = new AlertDialog.Builder(this).create();
        mAlertDialog.setTitle(getString(R.string.upload_results));
        mAlertDialog.setMessage(message);
        DialogInterface.OnClickListener quitListener = new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int i) {
                switch (i) {
                    case DialogInterface.BUTTON_POSITIVE: // ok
                    	Collect.getInstance().getActivityLogger().logAction(this, "createAlertDialog", "OK");
                        // always exit this activity since it has no interface
                        mAlertShowing = false;
                        finish();
                        break;
                }
            }
        };
        mAlertDialog.setCancelable(false);
        mAlertDialog.setButton(getString(R.string.ok), quitListener);
        mAlertDialog.setIcon(android.R.drawable.ic_dialog_info);
        mAlertShowing = true;
        mAlertMsg = message;
        mAlertDialog.show();
    }

}

/*
 * Copyright (C) 2011 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.application;

import android.app.Application;
import android.content.SharedPreferences;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.os.Environment;
import android.preference.PreferenceManager;

import org.odk.collect.android.R;
import org.odk.collect.android.database.ActivityLogger;
import org.odk.collect.android.external.ExternalDataManager;
import org.odk.collect.android.logic.FormController;
import org.odk.collect.android.logic.PropertyManager;
import org.odk.collect.android.preferences.PreferencesActivity;
import org.odk.collect.android.utilities.AgingCredentialsProvider;
import org.opendatakit.httpclientandroidlib.client.CookieStore;
import org.opendatakit.httpclientandroidlib.client.CredentialsProvider;
import org.opendatakit.httpclientandroidlib.client.protocol.ClientContext;
import org.opendatakit.httpclientandroidlib.impl.client.BasicCookieStore;
import org.opendatakit.httpclientandroidlib.protocol.BasicHttpContext;
import org.opendatakit.httpclientandroidlib.protocol.HttpContext;

import java.io.File;

/**
 * Extends the Application class to implement
 *
 * @author carlhartung
 */
public class Collect {

    // share all session cookies across all sessions...
    private CookieStore cookieStore = new BasicCookieStore();
    // retain credentials for 7 minutes...
    private CredentialsProvider credsProvider = new AgingCredentialsProvider(7 * 60 * 1000);
    private ActivityLogger mActivityLogger;
    private FormController mFormController = null;
    private ExternalDataManager externalDataManager;
    // The root application when embedded as a library
    private Application mApplication;

    // Storage paths (which require ODK to be embedded as a library)
    private final String mOdkRoot;
    private final String mFormsPath;
    private final String mInstancesPath;
    private final String mCachePath;
    private final String mMetadataPath;
    private final String mTmpFilePath;
    private final String mTmpDrawFilePath;
    private final String mTmpXmlPath;
    private final String mLogPath;

    public String getOdkRoot() {
        return mOdkRoot;
    }

    public String getFormsPath() {
        return mFormsPath;
    }

    public String getInstancesPath() {
        return mInstancesPath;
    }

    public String getCachePath() {
        return mCachePath;
    }

    public String getMetadataPath() {
        return mMetadataPath;
    }

    public String getTmpFilePath() {
        return mTmpFilePath;
    }

    public String getTmpDrawFilePath() {
        return mTmpDrawFilePath;
    }

    public String getTmpXmlPath() {
        return mTmpXmlPath;
    }

    public String getLogPath() {
        return mLogPath;
    }

    public static final String DEFAULT_FONTSIZE = "21";

    private static Collect singleton = null;

    public static Collect getInstance() {
        assert singleton != null;
        return singleton;
    }

    public ActivityLogger getActivityLogger() {
        return mActivityLogger;
    }

    private Collect(Application mApplication) {
        this.mApplication = mApplication;
        mOdkRoot = mApplication.getApplicationContext().getFilesDir()
                + File.separator + "odk";
        mFormsPath = mOdkRoot + File.separator + "forms";
        mInstancesPath = mOdkRoot + File.separator + "instances";
        mCachePath = mOdkRoot + File.separator + ".cache";
        mMetadataPath = mOdkRoot + File.separator + "metadata";
        mTmpFilePath = mCachePath + File.separator + "tmp.jpg";
        mTmpDrawFilePath = mCachePath + File.separator + "tmpDraw.jpg";
        mTmpXmlPath = mCachePath + File.separator + "tmp.xml";
        mLogPath = mOdkRoot + File.separator + "log";
    }

    public Application getApplication() {
        return mApplication;
    }

    public FormController getFormController() {
        return mFormController;
    }

    public void setFormController(FormController controller) {
        mFormController = controller;
    }

    public ExternalDataManager getExternalDataManager() {
        return externalDataManager;
    }

    public void setExternalDataManager(ExternalDataManager externalDataManager) {
        this.externalDataManager = externalDataManager;
    }

    public static int getQuestionFontsize() {
        SharedPreferences settings = PreferenceManager.getDefaultSharedPreferences(Collect
                .getInstance().getApplication());
        String question_font = settings.getString(PreferencesActivity.KEY_FONT_SIZE,
                Collect.DEFAULT_FONTSIZE);
        int questionFontsize = Integer.valueOf(question_font);
        return questionFontsize;
    }

    public String getVersionedAppName() {
        String versionDetail = "";
        try {
            PackageInfo pinfo;
            pinfo = getApplication().getPackageManager().getPackageInfo(
                    getApplication().getPackageName(), 0);
            int versionNumber = pinfo.versionCode;
            String versionName = pinfo.versionName;
            versionDetail = " " + versionName + " (" + versionNumber + ")";
        } catch (NameNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return getApplication().getString(R.string.app_name) + versionDetail;
    }

    /**
     * Creates required directories on the SDCard (or other external storage)
     *
     * @throws RuntimeException if there is no SDCard or the directory exists as a non directory
     */
    public void createODKDirs() throws RuntimeException {
        String cardstatus = Environment.getExternalStorageState();
        if (!cardstatus.equals(Environment.MEDIA_MOUNTED)) {
            throw new RuntimeException(Collect.getInstance().getApplication().getString(
                    R.string.sdcard_unmounted, cardstatus));
        }

        String[] dirs = {
                mOdkRoot, mFormsPath, mInstancesPath, mCachePath, mMetadataPath
        };

        for (String dirName : dirs) {
            File dir = new File(dirName);
            if (!dir.exists()) {
                if (!dir.mkdirs()) {
                    RuntimeException e =
                            new RuntimeException("ODK reports :: Cannot create directory: "
                                    + dirName);
                    throw e;
                }
            } else {
                if (!dir.isDirectory()) {
                    RuntimeException e =
                            new RuntimeException("ODK reports :: " + dirName
                                    + " exists, but is not a directory");
                    throw e;
                }
            }
        }
    }

    /**
     * Predicate that tests whether a directory path might refer to an
     * ODK Tables instance data directory (e.g., for media attachments).
     *
     * @param directory
     * @return
     */
    public boolean isODKTablesInstanceDataDirectory(File directory) {
		/**
		 * Special check to prevent deletion of files that
		 * could be in use by ODK Tables.
		 */
    	String dirPath = directory.getAbsolutePath();
    	if ( dirPath.startsWith(mOdkRoot) ) {
    		dirPath = dirPath.substring(mOdkRoot.length());
    		String[] parts = dirPath.split(File.separator);
    		// [appName, instances, tableId, instanceId ]
    		if ( parts.length == 4 && parts[1].equals("instances") ) {
    			return true;
    		}
    	}
    	return false;
	}

    /**
     * Construct and return a session context with shared cookieStore and credsProvider so a user
     * does not have to re-enter login information.
     *
     * @return
     */
    public synchronized HttpContext getHttpContext() {

        // context holds authentication state machine, so it cannot be
        // shared across independent activities.
        HttpContext localContext = new BasicHttpContext();

        localContext.setAttribute(ClientContext.COOKIE_STORE, cookieStore);
        localContext.setAttribute(ClientContext.CREDS_PROVIDER, credsProvider);

        return localContext;
    }

    public CredentialsProvider getCredentialsProvider() {
        return credsProvider;
    }

    public CookieStore getCookieStore() {
        return cookieStore;
    }
    
    public static void onCreate(Application application) {
        singleton = new Collect(application);

        // // set up logging defaults for apache http component stack
        // Log log;
        // log = LogFactory.getLog("org.opendatakit.httpclientandroidlib");
        // log.enableError(true);
        // log.enableWarn(true);
        // log.enableInfo(true);
        // log.enableDebug(true);
        // log = LogFactory.getLog("org.opendatakit.httpclientandroidlib.wire");
        // log.enableError(true);
        // log.enableWarn(false);
        // log.enableInfo(false);
        // log.enableDebug(false);

        initialisePreferences(application);

        PropertyManager mgr = new PropertyManager(application);

        FormController.initializeJavaRosa(mgr);
        
        singleton.mActivityLogger = new ActivityLogger(
                mgr.getSingularProperty(PropertyManager.DEVICE_ID_PROPERTY));
    }

    private static void initialisePreferences(Application application) {
        PreferenceManager.setDefaultValues(application, R.xml.preferences, false);
        PreferenceManager.setDefaultValues(application, R.xml.admin_preferences, false);
    }

}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.external;

import android.content.ContentValues;
import android.database.sqlite.SQLiteDatabase;
import android.util.Log;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.database.ODKSQLiteOpenHelper;
import org.odk.collect.android.exception.ExternalDataException;
import org.odk.collect.android.tasks.FormLoaderTask;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import au.com.bytecode.opencsv.CSVReader;

/**
 * Author: Meletis Margaritis
 * Date: 30/04/13
 * Time: 09:36
 */
public class ExternalSQLiteOpenHelper extends ODKSQLiteOpenHelper {

    private static final int VERSION = 1;
    private static final char DELIMITING_CHAR = ",".charAt(0);
    private static final char QUOTE_CHAR = "\"".charAt(0);
    private static final char ESCAPE_CHAR = "\0".charAt(0);

    private File dataSetFile;
    private ExternalDataReader externalDataReader;
    private FormLoaderTask formLoaderTask;

    public ExternalSQLiteOpenHelper(File dbFile) {
        super(dbFile.getParentFile().getAbsolutePath(), dbFile.getName(), null, VERSION);
    }

    public void importFromCSV(File dataSetFile, ExternalDataReader externalDataReader, FormLoaderTask formLoaderTask) {
        this.dataSetFile = dataSetFile;
        this.externalDataReader = externalDataReader;
        this.formLoaderTask = formLoaderTask;

        SQLiteDatabase writableDatabase = null;
        try {
            writableDatabase = getWritableDatabase();
        } finally {
            if (writableDatabase != null) {
                writableDatabase.close();
            }
        }
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        if (externalDataReader == null) {
            // this means that the function handler needed the database through calling getReadableDatabase() --> getWritableDatabase(),
            // but this is not allowed, so just return;
            Log.e(ExternalDataUtil.LOGGER_NAME, "The function handler triggered this external data population. This is not good.");
            return;
        }

        try {
            onCreateNamed(db, ExternalDataUtil.EXTERNAL_DATA_TABLE_NAME);
        } catch (Exception e) {
            throw new ExternalDataException(Collect.getInstance().getApplication().getString(R.string.ext_import_generic_error, dataSetFile.getName(), e.getMessage()), e);
        }
    }

    private void onCreateNamed(SQLiteDatabase db, String tableName) throws Exception {
        Log.w(ExternalDataUtil.LOGGER_NAME, "Reading data from '" + dataSetFile);

        onProgress(Collect.getInstance().getApplication().getString(R.string.ext_import_progress_message, dataSetFile.getName(), ""));

        CSVReader reader = null;
        try {
            reader = new CSVReader(new InputStreamReader(new FileInputStream(dataSetFile), "UTF-8"), DELIMITING_CHAR, QUOTE_CHAR, ESCAPE_CHAR);
            String[] headerRow = reader.readNext();

            if (!ExternalDataUtil.containsAnyData(headerRow)) {
                throw new ExternalDataException(Collect.getInstance().getApplication().getString(R.string.ext_file_no_data_error));
            }

            List<String> conflictingColumns = ExternalDataUtil.findMatchingColumnsAfterSafeningNames(headerRow);

            if (conflictingColumns != null && conflictingColumns.size() > 0) {
                // this means that after removing invalid characters, some column names resulted with the same name,
                // so the create table query will fail with "duplicate column" error.
                throw new ExternalDataException(Collect.getInstance().getApplication().getString(R.string.ext_conflicting_columns_error, conflictingColumns));
            }

            Map<String, String> columnNamesCache = new HashMap<String, String>();

            StringBuilder sb = new StringBuilder();

            boolean sortColumnAlreadyPresent = false;

            sb.append("CREATE TABLE ");
            sb.append(tableName);
            sb.append(" ( ");
            for (int i = 0; i < headerRow.length; i++) {
                String columnName = headerRow[i].trim();
                if (columnName.length() == 0) {
                    continue;
                }
                if (i != 0) {
                    sb.append(", ");
                }
                String safeColumnName = ExternalDataUtil.toSafeColumnName(columnName, columnNamesCache);
                if (safeColumnName.equals(ExternalDataUtil.SORT_COLUMN_NAME)) {
                    sortColumnAlreadyPresent = true;
                    sb.append(safeColumnName).append(" real ");
                } else {
                    sb.append(safeColumnName).append(" text collate nocase ");
                }
            }
            if (!sortColumnAlreadyPresent) {
                sb.append(", ");
                sb.append(ExternalDataUtil.SORT_COLUMN_NAME).append(" real ");
            }

            sb.append(" );");
            String sql = sb.toString();

            Log.w(ExternalDataUtil.LOGGER_NAME, "Creating database for " + dataSetFile + " with query: " + sql);
            db.execSQL(sql);

            // create the indexes.
            // save the sql for later because inserts will be much faster if we don't have indexes already.
            List<String> createIndexesCommands = new ArrayList<String>();
            for (String header : headerRow) {
                if (header.endsWith("_key")) {
                    String indexSQL = "CREATE INDEX " + header + "_idx ON " + tableName + " (" + ExternalDataUtil.toSafeColumnName(header, columnNamesCache) + ");";
                    createIndexesCommands.add(indexSQL);
                    Log.w(ExternalDataUtil.LOGGER_NAME, "Will create an index on " + header + " later.");
                }
            }

            // populate the database
            String[] row = reader.readNext();
            int rowCount = 0;
            while (row != null && !formLoaderTask.isCancelled()) {
                // SCTO-894 - first we should make sure that this is not an empty line
                if (!ExternalDataUtil.containsAnyData(row)) {
                    // yes, that is an empty row, ignore it
                    row = reader.readNext();
                    continue;
                }

                // SCTO-894 - then check if the row contains less values than the header
                // we should not ignore the existing values in the row,
                // we will just fill up the rest with empty strings
                if (row.length < headerRow.length) {
                    row = ExternalDataUtil.fillUpNullValues(row, headerRow);
                }

                ContentValues values = new ContentValues();
                if (!sortColumnAlreadyPresent) {
                    values.put(ExternalDataUtil.SORT_COLUMN_NAME, rowCount + 1);
                }

                for (int i = 0; i < row.length && i < headerRow.length; i++) {
                    String columnName = headerRow[i].trim();
                    String columnValue = row[i];
                    if (columnName.length() == 0) {
                        continue;
                    }
                    String safeColumnName = ExternalDataUtil.toSafeColumnName(columnName, columnNamesCache);
                    if (safeColumnName.equals(ExternalDataUtil.SORT_COLUMN_NAME)) {
                        try {
                            values.put(safeColumnName, Double.parseDouble(columnValue));
                        } catch (NumberFormatException e) {
                            throw new ExternalDataException(Collect.getInstance().getApplication().getString(R.string.ext_sortBy_numeric_error, columnValue));
                        }
                    } else {
                        values.put(safeColumnName, columnValue);
                    }
                }
                db.insertOrThrow(tableName, null, values);
                row = reader.readNext();
                rowCount++;
                if (rowCount % 100 == 0) {
                    onProgress(Collect.getInstance().getApplication().getString(R.string.ext_import_progress_message, dataSetFile.getName(), " (" + rowCount + " records so far)"));
                }
            }

            if (formLoaderTask.isCancelled()) {
                Log.w(ExternalDataUtil.LOGGER_NAME, "User canceled reading data from " + dataSetFile);
                onProgress(Collect.getInstance().getApplication().getString(R.string.ext_import_cancelled_message));
            } else {

                onProgress(Collect.getInstance().getApplication().getString(R.string.ext_import_finalizing_message));

                // now create the indexes
                for (String createIndexCommand : createIndexesCommands) {
                    Log.w(ExternalDataUtil.LOGGER_NAME, createIndexCommand);
                    db.execSQL(createIndexCommand);
                }

                Log.w(ExternalDataUtil.LOGGER_NAME, "Read all data from " + dataSetFile);
                onProgress(Collect.getInstance().getApplication().getString(R.string.ext_import_completed_message));
            }
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    Log.e(ExternalDataUtil.LOGGER_NAME, e.getMessage(), e);
                }
            }
        }
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    }

    private void onProgress(String message) {
        if (formLoaderTask != null) {
            formLoaderTask.publishExternalDataLoadingProgress(message);
        }
    }
}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.external;

import android.content.Intent;
import android.database.Cursor;

import org.javarosa.core.model.condition.EvaluationContext;
import org.javarosa.core.model.data.DecimalData;
import org.javarosa.core.model.data.IntegerData;
import org.javarosa.core.model.data.StringData;
import org.javarosa.core.model.instance.FormInstance;
import org.javarosa.core.model.instance.TreeReference;
import org.javarosa.model.xform.XPathReference;
import org.javarosa.xpath.XPathNodeset;
import org.javarosa.xpath.XPathParseTool;
import org.javarosa.xpath.expr.XPathExpression;
import org.javarosa.xpath.expr.XPathFuncExpr;
import org.javarosa.xpath.expr.XPathPathExpr;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.exception.ExternalParamsException;
import org.odk.collect.android.provider.InstanceProviderAPI.InstanceColumns;

import java.io.Serializable;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 *
 * Author: Meletis Margaritis
 * Date: 30/07/13
 * Time: 10:44
 */
public class ExternalAppsUtils {

    private static final String LEFT_PARENTHESIS = "(";
    private static final String RIGHT_PARENTHESIS = ")";

    public static String extractIntentName(String exString) {
        if (!exString.contains(LEFT_PARENTHESIS)) {
            if (exString.contains(RIGHT_PARENTHESIS)) {
                return exString.substring(0, exString.indexOf(RIGHT_PARENTHESIS)).trim();
            } else {
                return exString;
            }
        }

        int leftParIndex = exString.indexOf(LEFT_PARENTHESIS);
        return exString.substring(0, leftParIndex).trim();
    }

    public static Map<String, String> extractParameters(String exString) {
        exString = exString.trim();

        int leftParIndex = exString.indexOf(LEFT_PARENTHESIS);
        if (leftParIndex == -1) {
            return Collections.emptyMap();
        }

        String paramsStr;
        if (exString.endsWith(")")) {
            paramsStr = exString.substring(leftParIndex + 1, exString.lastIndexOf(")"));
        } else {
            paramsStr = exString.substring(leftParIndex + 1, exString.length());
        }

        Map<String, String> parameters = new LinkedHashMap<String, String>();
        String[] paramsPairs = paramsStr.trim().split(",");
        for (String paramsPair : paramsPairs) {
            String[] keyValue = paramsPair.trim().split("=");
            if (keyValue.length == 2) {
                parameters.put(keyValue[0].trim(), keyValue[1].trim());
            }
        }
        return parameters;
    }

    public static void populateParameters(Intent intent, Map<String, String> exParams, TreeReference reference) throws ExternalParamsException {
        FormInstance formInstance = Collect.getInstance().getFormController().getFormDef().getInstance();
        EvaluationContext baseEvaluationContext = new EvaluationContext(formInstance);
        EvaluationContext evaluationContext = new EvaluationContext(baseEvaluationContext, reference);

        if (exParams != null) {
            for (Map.Entry<String, String> paramEntry : exParams.entrySet()) {
                String paramEntryValue = paramEntry.getValue();

                try {
                    Object result;
                    if (paramEntryValue.startsWith("'")) {
                        // treat this as a constant parameter
                        // but not require an ending quote
                        if (paramEntryValue.endsWith("'")) {
                            result = paramEntryValue.substring(1, paramEntryValue.length() - 1);
                        } else {
                            result = paramEntryValue.substring(1, paramEntryValue.length());
                        }
                    } else if (paramEntryValue.startsWith("/")) {
                        // treat this is an xpath
                        XPathPathExpr pathExpr = XPathReference.getPathExpr(paramEntryValue);
                        XPathNodeset xPathNodeset = pathExpr.eval(formInstance, evaluationContext);
                        result = XPathFuncExpr.unpack(xPathNodeset);
                    } else if (paramEntryValue.equals("instanceProviderID()")) {
                        // instanceProviderID returns -1 if the current instance has not been
                        // saved to disk already
                        String path = Collect.getInstance().getFormController().getInstancePath().getAbsolutePath();
                        String selection = InstanceColumns.INSTANCE_FILE_PATH + "=?";
                        String selectionArgs[] = {path};
                        
                        String instanceProviderID = "-1";
                        Cursor c = Collect.getInstance().getApplication().getContentResolver().query(InstanceColumns.CONTENT_URI, null, selection, selectionArgs, null);
                        if (c != null && c.getCount() > 0) {
                            // should only ever be one
                            c.moveToFirst();
                            instanceProviderID = c.getString(c.getColumnIndex(InstanceColumns._ID));
                        }
                        if (c != null) {
                            c.close();
                        }
                       
                        result = instanceProviderID;
                    } else {
                        // treat this is a function
                        XPathExpression xPathExpression = XPathParseTool.parseXPath(paramEntryValue);
                        result = xPathExpression.eval(formInstance, evaluationContext);
                    }
                    if (result != null && result instanceof Serializable) {
                        intent.putExtra(paramEntry.getKey(), (Serializable) result);
                    }
                } catch (Exception e) {
                    throw new ExternalParamsException("Could not evaluate '" + paramEntryValue + "'", e);
                }
            }
        }
    }

    public static StringData asStringData(Object value) {
        if (value == null) {
            return null;
        } else {
            return new StringData(value.toString());
        }
    }

    public static IntegerData asIntegerData(Object value) {
        if (value == null) {
            return null;
        } else {
            try {
                String s = value.toString();
                int i = Integer.parseInt(s);
                return new IntegerData(i);
            } catch (NumberFormatException e) {
                return null;
            }
        }
    }

    public static DecimalData asDecimalData(Object value) {
        if (value == null) {
            return null;
        } else {
            try {
                String s = value.toString();
                double d = Double.parseDouble(s);
                return new DecimalData(d);
            } catch (NumberFormatException e) {
                return null;
            }
        }
    }
}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.external;

import android.database.sqlite.SQLiteDatabase;
import android.util.Log;

import org.apache.commons.io.FileUtils;
import org.odk.collect.android.tasks.FormLoaderTask;

import java.io.File;
import java.io.IOException;
import java.util.Map;

/**
 * Author: Meletis Margaritis
 * Date: 30/04/13
 * Time: 09:32
 */
public class ExternalDataReaderImpl implements ExternalDataReader {

    private FormLoaderTask formLoaderTask;

    public ExternalDataReaderImpl(FormLoaderTask formLoaderTask) {
        this.formLoaderTask = formLoaderTask;
    }

    @Override
    public void doImport(Map<String, File> externalDataMap) {
        for (Map.Entry<String, File> stringFileEntry : externalDataMap.entrySet()) {
            String dataSetName = stringFileEntry.getKey();
            File dataSetFile = stringFileEntry.getValue();
            if (dataSetFile.exists()) {
                File dbFile = new File(dataSetFile.getParentFile().getAbsolutePath(), dataSetName + ".db");
                if (dbFile.exists()) {
                    // this means the someone updated the csv file, so we need to reload it
                    boolean deleted = dbFile.delete();
                    if (!deleted) {
                        Log.e(ExternalDataUtil.LOGGER_NAME, dataSetFile.getName() + " has changed but we could not delete the previous DB at " + dbFile.getAbsolutePath());
                        continue;
                    }
                }
                ExternalSQLiteOpenHelper externalSQLiteOpenHelper = new ExternalSQLiteOpenHelper(dbFile);
                externalSQLiteOpenHelper.importFromCSV(dataSetFile, this, formLoaderTask);

                if (formLoaderTask.isCancelled()) {
                    Log.w(ExternalDataUtil.LOGGER_NAME, "The import was cancelled, so we need to rollback.");

                    // we need to drop the database file since it might be partially populated. It will be re-created next time.

                    Log.w(ExternalDataUtil.LOGGER_NAME, "Closing database to be deleted " + dbFile);

                    // then close the database
                    SQLiteDatabase db = externalSQLiteOpenHelper.getReadableDatabase();
                    db.close();

                    // the physically delete the db.
                    try {
                        FileUtils.forceDelete(dbFile);
                        Log.w(ExternalDataUtil.LOGGER_NAME, "Deleted " + dbFile.getName());
                    } catch (IOException e) {
                        Log.e(ExternalDataUtil.LOGGER_NAME, e.getMessage(), e);
                    }

                    // then just exit and do not process any other CSVs.
                    return;

                } else {
                    // rename the dataSetFile into "dataSetFile.csv.imported" in order not to be loaded again
                    File importedFile = new File(dataSetFile.getParentFile(), dataSetFile.getName() + ".imported");
                    boolean renamed = dataSetFile.renameTo(importedFile);
                    if (!renamed) {
                        Log.e(ExternalDataUtil.LOGGER_NAME, dataSetFile.getName() + " could not be renamed to be archived. It will be re-imported again! :(");
                    } else {
                        Log.e(ExternalDataUtil.LOGGER_NAME, dataSetFile.getName() + " was renamed to " + importedFile.getName());
                    }
                }
            }
        }
    }

}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.external;

import org.javarosa.core.model.SelectChoice;

/**
 * Author: Meletis Margaritis
 * Date: 18/11/2013
 * Time: 2:08 
 */
public class ExternalSelectChoice extends SelectChoice {

    String image;

    public ExternalSelectChoice(String labelOrID, String value, boolean isLocalizable) {
        super(labelOrID, value, isLocalizable);
    }

    public String getImage() {
        return image;
    }

    public void setImage(String image) {
        this.image = image;
    }
}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.external;

import org.javarosa.core.model.SelectChoice;
import org.javarosa.core.model.condition.EvaluationContext;
import org.javarosa.core.model.instance.FormInstance;
import org.javarosa.form.api.FormEntryCaption;
import org.javarosa.form.api.FormEntryPrompt;
import org.javarosa.xpath.XPathParseTool;
import org.javarosa.xpath.expr.XPathExpression;
import org.javarosa.xpath.expr.XPathFuncExpr;
import org.javarosa.xpath.parser.XPathSyntaxException;
import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.exception.ExternalDataException;
import org.odk.collect.android.exception.InvalidSyntaxException;
import org.odk.collect.android.external.handler.ExternalDataHandlerSearch;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Author: Meletis Margaritis
 * Date: 30/04/13
 * Time: 09:29
 */
public final class ExternalDataUtil {

    public static final String LOGGER_NAME = "ExternalData";
    public static final String EXTERNAL_DATA_TABLE_NAME = "externalData";
    public static final String SORT_COLUMN_NAME = "c_sortby";

    private static final Pattern SEARCH_FUNCTION_REGEX = Pattern.compile("search\\(.+\\)");
    private static final String COLUMN_SEPARATOR = ",";
    private static final String FALLBACK_COLUMN_SEPARATOR = " ";
    public static final String JR_IMAGES_PREFIX = "jr://images/";

    public static String toSafeColumnName(String columnName, Map<String, String> cache) {
        String cachedName = cache.get(columnName);
        if (cachedName == null) {
            String safeColumnName = toSafeColumnName(columnName);
            cache.put(columnName, safeColumnName);
            return safeColumnName;
        } else {
            return cachedName;
        }
    }

    public static String toSafeColumnName(String columnName) {
        // SCTO-567 - begin all column names with "c_" to avoid possible conflicts with
        // reserved keywords; also, escape any potentially-illegal characters
        return "c_" + columnName.trim().replaceAll("[^A-Za-z0-9_]", "_").toLowerCase();
    }

    public static List<String> findMatchingColumnsAfterSafeningNames(String[] columnNames) {
        // key is the safe, value is the unsafe
        Map<String, String> map = new HashMap<String, String>();
        for (String columnName : columnNames) {
            if (columnName.trim().length() > 0) {
                String safeColumn = toSafeColumnName(columnName);
                if (!map.containsKey(safeColumn)) {
                    map.put(safeColumn, columnName);
                } else {
                    return Arrays.asList(map.get(safeColumn), columnName);
                }
            }
        }
        return null;
    }

    public static XPathFuncExpr getSearchXPathExpression(String appearance) {
        if (appearance == null) {
            appearance = "";
        }
        appearance = appearance.trim();

        Matcher matcher = SEARCH_FUNCTION_REGEX.matcher(appearance);
        if (matcher.find()) {
            String function = matcher.group(0);
            try {
                XPathExpression xPathExpression = XPathParseTool.parseXPath(function);
                if (XPathFuncExpr.class.isAssignableFrom(xPathExpression.getClass())) {
                    XPathFuncExpr xPathFuncExpr = (XPathFuncExpr) xPathExpression;
                    if (xPathFuncExpr.id.name.equalsIgnoreCase(ExternalDataHandlerSearch.HANDLER_NAME)) {
                        // also check that the args are either 1, 4 or 6.
                        if (xPathFuncExpr.args.length == 1 || xPathFuncExpr.args.length == 4 || xPathFuncExpr.args.length == 6) {
                            return xPathFuncExpr;
                        } else {
                            throw new InvalidSyntaxException(Collect.getInstance().getApplication().getString(R.string.ext_search_wrong_arguments_error));
                        }
                    } else {
                        // this might mean a problem in the regex above. Unit tests required.
                        throw new InvalidSyntaxException(Collect.getInstance().getApplication().getString(R.string.ext_search_wrong_function_error, xPathFuncExpr.id.name));
                    }
                } else {
                    // this might mean a problem in the regex above. Unit tests required.
                    throw new InvalidSyntaxException(Collect.getInstance().getApplication().getString(R.string.ext_search_bad_function_error, function));
                }
            } catch (XPathSyntaxException e) {
                throw new InvalidSyntaxException(Collect.getInstance().getApplication().getString(R.string.ext_search_generic_error, appearance), e);
            }
        } else {
            return null;
        }
    }

    @SuppressWarnings("unchecked")
    public static Vector<SelectChoice> populateExternalChoices(FormEntryPrompt formEntryPrompt, XPathFuncExpr xPathFuncExpr) {
        try {
            Vector<SelectChoice> selectChoices = formEntryPrompt.getSelectChoices();
            Vector<SelectChoice> returnedChoices = new Vector<SelectChoice>();
            for (SelectChoice selectChoice : selectChoices) {
                String value = selectChoice.getValue();
                if (isAnInteger(value)) {
                    // treat this as a static choice
                    returnedChoices.add(selectChoice);
                } else {
                    String displayColumns = formEntryPrompt.getSelectChoiceText(selectChoice);
                    String imageColumn = formEntryPrompt.getSpecialFormSelectChoiceText(selectChoice, FormEntryCaption.TEXT_FORM_IMAGE);
                    if (imageColumn != null && imageColumn.startsWith(JR_IMAGES_PREFIX)) {
                        imageColumn = imageColumn.substring(JR_IMAGES_PREFIX.length());
                    }
//                    if (displayColumns == null || displayColumns.trim().length() == 0) {
//                        throw new InvalidSyntaxException("The label column in the choices sheet appears to be empty (or has been calculated as empty).");
//                    }

                    ExternalDataManager externalDataManager = Collect.getInstance().getExternalDataManager();
                    FormInstance formInstance = Collect.getInstance().getFormController().getFormDef().getInstance();
                    EvaluationContext baseEvaluationContext = new EvaluationContext(formInstance);
                    EvaluationContext evaluationContext = new EvaluationContext(baseEvaluationContext, formEntryPrompt.getIndex().getReference());
                    // we can only add only the appropriate by querying the xPathFuncExpr.id.name
                    evaluationContext.addFunctionHandler(new ExternalDataHandlerSearch(externalDataManager, displayColumns, value, imageColumn));

                    Object eval = xPathFuncExpr.eval(formInstance, evaluationContext);
                    if (eval.getClass().isAssignableFrom(Vector.class)) {
                        Vector<SelectChoice> dynamicChoices = (Vector<SelectChoice>) eval;
                        for (SelectChoice dynamicChoice : dynamicChoices) {
                            returnedChoices.add(dynamicChoice);
                        }
                    } else {
                        throw new ExternalDataException(Collect.getInstance().getApplication().getString(R.string.ext_search_return_error, eval.getClass().getName()));
                    }
                }
            }
            return returnedChoices;
        } catch (Exception e) {
            throw new ExternalDataException(e.getMessage(), e);
        }
    }

    /**
     * We could simple return new String(displayColumns + "," + valueColumn) but we want to handle the cases
     * where the displayColumns (valueColumn) contain more commas than needed, in the middle, start or end.
     *
     * @param valueColumn    single string to appear first.
     * @param displayColumns comma-separated string
     * @return A {@link java.util.LinkedHashMap} that contains the SQL columns as keys, and the CSV columns as values
     */
    public static LinkedHashMap<String, String> createMapWithDisplayingColumns(String valueColumn, String displayColumns) {
        valueColumn = valueColumn.trim();

        LinkedHashMap<String, String> columns = new LinkedHashMap<String, String>();

        columns.put(toSafeColumnName(valueColumn), valueColumn);

        if (displayColumns != null && displayColumns.trim().length() > 0) {
            displayColumns = displayColumns.trim();

            List<String> commaSplitParts = splitTrimmed(displayColumns, COLUMN_SEPARATOR, FALLBACK_COLUMN_SEPARATOR);

            for (String commaSplitPart : commaSplitParts) {
                columns.put(toSafeColumnName(commaSplitPart), commaSplitPart);
            }
        }

        return columns;
    }

    public static List<String> createListOfColumns(String columnString) {
        List<String> values = new ArrayList<String>();

        List<String> commaSplitParts = splitTrimmed(columnString, COLUMN_SEPARATOR, FALLBACK_COLUMN_SEPARATOR);

        for (String commaSplitPart : commaSplitParts) {
            values.add(toSafeColumnName(commaSplitPart));
        }

        return values;
    }

    protected static List<String> splitTrimmed(String displayColumns, String separator, String fallbackSeparator) {
        List<String> commaSplitParts = splitTrimmed(displayColumns, separator);

        // SCTO-584: Fall back to a space-separated list
        if (commaSplitParts.size() == 1 && displayColumns.contains(fallbackSeparator)) {
            commaSplitParts = splitTrimmed(displayColumns, fallbackSeparator);
        }
        return commaSplitParts;
    }

    protected static List<String> splitTrimmed(String text, String separator) {
        List<String> parts = new ArrayList<String>();
        StringTokenizer st = new StringTokenizer(text, separator);
        while (st.hasMoreTokens()) {
            String token = st.nextToken().trim();
            if (token.length() > 0) {
                parts.add(token);
            }
        }
        return parts;
    }

    public static boolean containsAnyData(String[] row) {
        if (row == null || row.length == 0) {
            return false;
        }
        for (String value : row) {
            if (value != null && value.trim().length() > 0) {
                return true;
            }
        }
        return false;
    }

    public static String[] fillUpNullValues(String[] row, String[] headerRow) {
        String[] fullRow = new String[headerRow.length];

        for (int i = 0; i < fullRow.length; i++) {
            if (i < row.length) {
                String value = row[i];
                if (value == null) {
                    value = "";
                }
                fullRow[i] = value;
            } else {
                fullRow[i] = "";
            }
        }

        return fullRow;
    }

    public static String nullSafe(String value) {
        return value == null ? "" : value;
    }

    public static boolean isAnInteger(String value) {
        if (value == null) {
            return false;
        }

        value = value.trim();

        try {
            Integer.parseInt(value);
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }
}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.external;

import java.io.File;
import java.util.Map;

/**
 * Author: Meletis Margaritis
 * Date: 30/04/13
 * Time: 13:52
 */
public interface ExternalDataReader {

    void doImport(Map<String, File> externalDataMap);
}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.external;

/**
 * This class handles all DB connections for the function handlers
 * <p/>
 * Author: Meletis Margaritis
 * Date: 14/05/13
 * Time: 17:17
 */
public interface ExternalDataManager {

    /**
     * Returns an object of {@link ExternalSQLiteOpenHelper}
     *
     * @param dataSetName the name of the imported .csv
     * @param required    if true, a runtime exception ({@link org.odk.collect.android.exception.ExternalDataException}) will be thrown.
     *                    if false null will be returned
     * @return an object of {@link ExternalSQLiteOpenHelper}
     */
    ExternalSQLiteOpenHelper getDatabase(String dataSetName, boolean required);

    void close();
}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.external;

import org.javarosa.core.model.condition.IFunctionHandler;

/**
 * Author: Meletis Margaritis
 * Date: 30/04/13
 * Time: 09:42
 */
public interface ExternalDataHandler extends IFunctionHandler {

    void setExternalDataManager(ExternalDataManager externalDataManager);
}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.external;

import android.util.Log;

import org.javarosa.core.model.Constants;
import org.javarosa.core.model.FormDef;
import org.javarosa.core.model.QuestionDef;
import org.javarosa.core.model.SelectChoice;
import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.SelectMultiData;
import org.javarosa.core.model.data.SelectOneData;
import org.javarosa.core.model.data.helper.Selection;
import org.javarosa.core.model.instance.TreeElement;
import org.javarosa.core.model.instance.utils.DefaultAnswerResolver;
import org.javarosa.core.model.utils.DateUtils;
import org.javarosa.xform.parse.XFormParser;
import org.javarosa.xform.util.XFormAnswerDataSerializer;
import org.javarosa.xpath.expr.XPathFuncExpr;

import java.util.Vector;

/**
 * Author: Meletis Margaritis
 * Date: 17/05/13
 * Time: 16:51
 */
public class ExternalAnswerResolver extends DefaultAnswerResolver {

    @Override
    @SuppressWarnings("unchecked")
    public IAnswerData resolveAnswer(String textVal, TreeElement treeElement, FormDef formDef) {
        QuestionDef questionDef = XFormParser.ghettoGetQuestionDef(treeElement.getDataType(), formDef, treeElement.getRef());
        if (questionDef != null && (questionDef.getControlType() == Constants.CONTROL_SELECT_ONE || questionDef.getControlType() == Constants.CONTROL_SELECT_MULTI)) {
            boolean containsSearchExpression = false;

            XPathFuncExpr xPathExpression = null;
            try {
                xPathExpression = ExternalDataUtil.getSearchXPathExpression(questionDef.getAppearanceAttr());
            } catch (Exception e) {
                Log.e(ExternalDataUtil.LOGGER_NAME, e.getMessage(), e);
                // there is a search expression, but has syntax errors
                containsSearchExpression = true;
            }

            if (xPathExpression != null || containsSearchExpression) {
                // that means that we have dynamic selects

                // read the static choices from the options sheet
                Vector<SelectChoice> staticChoices = questionDef.getChoices();
                for (int index = 0; index < staticChoices.size(); index++) {
                    SelectChoice selectChoice = staticChoices.elementAt(index);
                    String selectChoiceValue = selectChoice.getValue();
                    if (ExternalDataUtil.isAnInteger(selectChoiceValue)) {

                        Selection selection = selectChoice.selection();

                        switch (questionDef.getControlType()) {
                            case Constants.CONTROL_SELECT_ONE: {
                                if (selectChoiceValue.equals(textVal)) {
                                    // This means that the user selected a static selection.
                                    //
                                    // Although (for select1 fields) the default implementation will catch this and return the right thing
                                    // (if we call super.resolveAnswer(textVal, treeElement, formDef))
                                    // we just need to make sure, so we will override that.
                                    if (questionDef.getControlType() == Constants.CONTROL_SELECT_ONE) {
                                        // we don't need another, just return the static choice.
                                        return new SelectOneData(selection);
                                    }
                                }
                            }
                            case Constants.CONTROL_SELECT_MULTI: {
                                // we should search in a potential comma-separated string of values for a match
                                // copied from org.javarosa.xform.util.XFormAnswerDataParser.getSelections()
                                Vector<String> textValues = DateUtils.split(textVal, XFormAnswerDataSerializer.DELIMITER, true);
                                if (textValues.contains(textVal)) {
                                    // this means that the user has selected AT LEAST the static choice.
                                    if (selectChoiceValue.equals(textVal)) {
                                        // this means that the user selected ONLY the static answer, so just return that
                                        Vector<Selection> customSelections = new Vector<Selection>();
                                        customSelections.add(selection);
                                        return new SelectMultiData(customSelections);
                                    } else {
                                        // we will ignore it for now since we will return that selection together with the dynamic ones.
                                    }
                                }
                                break;
                            }
                            default: {
                                // There is a bug if we get here, so let's throw an Exception
                                throw createBugRuntimeException(treeElement, textVal);
                            }
                        }

                    } else {
                        switch (questionDef.getControlType()) {
                            case Constants.CONTROL_SELECT_ONE: {
                                // the default implementation will search for the "textVal" (saved answer) inside the static choices.
                                // Since we know that there isn't such, we just wrap the textVal in a virtual choice in order to
                                // create a SelectOneData object to be used as the IAnswer to the TreeElement.
                                // (the caller of this function is searching for such an answer to populate the in-memory model.)
                                SelectChoice customSelectChoice = new SelectChoice(textVal, textVal, false);
                                customSelectChoice.setIndex(index);
                                return new SelectOneData(customSelectChoice.selection());
                            }
                            case Constants.CONTROL_SELECT_MULTI: {
                                // we should create multiple selections and add them to the pile
                                Vector<SelectChoice> customSelectChoices = createCustomSelectChoices(textVal);
                                Vector<Selection> customSelections = new Vector<Selection>();
                                for (SelectChoice customSelectChoice : customSelectChoices) {
                                    customSelections.add(customSelectChoice.selection());
                                }
                                return new SelectMultiData(customSelections);
                            }
                            default: {
                                // There is a bug if we get here, so let's throw an Exception
                                throw createBugRuntimeException(treeElement, textVal);
                            }
                        }

                    }
                }

                // if we get there then that means that we have a bug
                throw createBugRuntimeException(treeElement, textVal);
            }
        }
        // default behavior matches original behavior (for static selects, etc.)
        return super.resolveAnswer(textVal, treeElement, formDef);
    }

    private RuntimeException createBugRuntimeException(TreeElement treeElement, String textVal) {
        return new RuntimeException("The appearance column of the field " + treeElement.getName() + " contains a search() call and the field type is " + treeElement.getDataType() + " and the saved answer is " + textVal);
    }

    @SuppressWarnings("unchecked")
    protected Vector<SelectChoice> createCustomSelectChoices(String completeTextValue) {
        // copied from org.javarosa.xform.util.XFormAnswerDataParser.getSelections()
        Vector<String> textValues = DateUtils.split(completeTextValue, XFormAnswerDataSerializer.DELIMITER, true);

        int index = 0;
        Vector<SelectChoice> customSelectChoices = new Vector<SelectChoice>();
        for (String textValue : textValues) {
            SelectChoice selectChoice = new SelectChoice(textValue, textValue, false);
            selectChoice.setIndex(index++);
            customSelectChoices.add(selectChoice);
        }

        return customSelectChoices;
    }
}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.external;

import android.util.Log;

import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.exception.ExternalDataException;

import java.io.File;
import java.util.HashMap;
import java.util.Map;

/**
 * Author: Meletis Margaritis
 * Date: 14/05/13
 * Time: 17:19
 */
public class ExternalDataManagerImpl implements ExternalDataManager {

    private Map<String, ExternalSQLiteOpenHelper> dbMap = new HashMap<String, ExternalSQLiteOpenHelper>();

    private final File mediaFolder;

    public ExternalDataManagerImpl(File mediaFolder) {
        this.mediaFolder = mediaFolder;
    }

    @Override
    public ExternalSQLiteOpenHelper getDatabase(String dataSetName, boolean required) {
        ExternalSQLiteOpenHelper sqLiteOpenHelper = dbMap.get(dataSetName);
        if (sqLiteOpenHelper == null) {
            if (mediaFolder == null) {
                String msg = Collect.getInstance().getApplication().getString(R.string.ext_not_initialized_error);
                Log.e(ExternalDataUtil.LOGGER_NAME, msg);
                if (required) {
                    throw new ExternalDataException(msg);
                } else {
                    return null;
                }
            } else {
                File dbFile = new File(mediaFolder, dataSetName + ".db");
                if (!dbFile.exists()) {
                    String msg = Collect.getInstance().getApplication().getString(R.string.ext_import_csv_missing_error, dataSetName, dataSetName);
                    Log.e(ExternalDataUtil.LOGGER_NAME, msg);
                    if (required) {
                        throw new ExternalDataException(msg);
                    } else {
                        return null;
                    }
                } else {
                    sqLiteOpenHelper = new ExternalSQLiteOpenHelper(dbFile);
                    dbMap.put(dataSetName, sqLiteOpenHelper);
                }
            }
        }
        return sqLiteOpenHelper;
    }

    @Override
    public void close() {
        if (dbMap != null) {
            for (ExternalSQLiteOpenHelper externalSQLiteOpenHelper : dbMap.values()) {
                Log.w(ExternalDataUtil.LOGGER_NAME, "Closing database handler:" + externalSQLiteOpenHelper.toString());
                externalSQLiteOpenHelper.close();
            }
        }
    }
}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.external.handler;

/**
 * Author: Meletis Margaritis
 * Date: 20/05/13
 * Time: 12:22
 */
enum ExternalDataSearchType {

    CONTAINS("contains") {
        @Override
        protected String getSingleLikeArgument(String queriedValue) {
            return '%' + queriedValue + '%';
        }
    },

    MATCHES("matches") {
        @Override
        protected String getSingleLikeArgument(String queriedValue) {
            return queriedValue;
        }
    },

    STARTS("startsWith") {
        @Override
        protected String getSingleLikeArgument(String queriedValue) {
            return queriedValue + '%';
        }
    },

    ENDS("endsWith") {
        @Override
        protected String getSingleLikeArgument(String queriedValue) {
            return '%' + queriedValue;
        }
    };

    private final String keyword;

    ExternalDataSearchType(String keyword) {
        this.keyword = keyword;
    }

    public String getKeyword() {
        return keyword;
    }

    public static ExternalDataSearchType getByKeyword(String keyword, ExternalDataSearchType fallback) {
        if (keyword == null) {
            return fallback;
        }
        for (ExternalDataSearchType externalDataSearchType : ExternalDataSearchType.values()) {
            if (externalDataSearchType.getKeyword().trim().toLowerCase().equals(keyword.trim().toLowerCase())) {
                return externalDataSearchType;
            }
        }

        return fallback;
    }

    public String[] constructLikeArguments(String queriedValue, int times) {
        String[] args = new String[times];
        for (int i = 0; i < times; i++) {
            args[i] = getSingleLikeArgument(queriedValue);
        }
        return args;
    }

    protected abstract String getSingleLikeArgument(String queriedValue);
}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.external.handler;

import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;

import org.javarosa.core.model.SelectChoice;
import org.javarosa.core.model.condition.EvaluationContext;
import org.javarosa.xpath.expr.XPathFuncExpr;
import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.exception.ExternalDataException;
import org.odk.collect.android.external.ExternalDataManager;
import org.odk.collect.android.external.ExternalDataUtil;
import org.odk.collect.android.external.ExternalSQLiteOpenHelper;
import org.odk.collect.android.external.ExternalSelectChoice;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Set;
import java.util.Vector;

/**
 * Author: Meletis Margaritis
 * Date: 16/05/13
 * Time: 10:42
 */
public class ExternalDataHandlerSearch extends ExternalDataHandlerBase {

    public static final String HANDLER_NAME = "search";

    private final String displayColumns;
    private final String valueColumn;
    private final String imageColumn;

    public ExternalDataHandlerSearch(ExternalDataManager externalDataManager, String displayColumns, String valueColumn, String imageColumn) {
        super(externalDataManager);
        this.displayColumns = displayColumns;
        this.valueColumn = valueColumn;
        this.imageColumn = imageColumn;
    }

    public String getDisplayColumns() {
        return displayColumns;
    }

    public String getValueColumn() {
        return valueColumn;
    }

    public String getImageColumn() {
        return imageColumn;
    }

    @Override
    public String getName() {
        return HANDLER_NAME;
    }

    @Override
    public Vector getPrototypes() {
        return new Vector();
    }

    @Override
    public boolean rawArgs() {
        return true;
    }

    @Override
    public boolean realTime() {
        return false;
    }

    @Override
    public Object eval(Object[] args, EvaluationContext ec) {
        if (args == null || (args.length != 1 && args.length != 4 && args.length != 6)) {
            // we should never get here since it is already handled in ExternalDataUtil.getSearchXPathExpression(String appearance)
            throw new ExternalDataException(Collect.getInstance().getApplication().getString(R.string.ext_search_wrong_arguments_error));
        }

        String dataSetName = XPathFuncExpr.toString(args[0]);

        String searchType = null;

        String queriedColumnsParam = null;
        List<String> queriedColumns = null;
        String queriedValue = null;
        if (args.length >= 4) {
            searchType = XPathFuncExpr.toString(args[1]);
            queriedColumnsParam = XPathFuncExpr.toString(args[2]);
            queriedValue = XPathFuncExpr.toString(args[3]);
        }

        ExternalDataSearchType externalDataSearchType = ExternalDataSearchType.getByKeyword(searchType, ExternalDataSearchType.CONTAINS);

        boolean searchRows = false;
        boolean useFilter = false;

        if (queriedColumnsParam != null && queriedColumnsParam.trim().length() > 0) {
            searchRows = true;
            queriedColumns = ExternalDataUtil.createListOfColumns(queriedColumnsParam);
        }

        String filterColumn = null;
        String filterValue = null;
        if (args.length == 6) {
            filterColumn = XPathFuncExpr.toString(args[4]);
            filterValue = XPathFuncExpr.toString(args[5]);
            useFilter = true;
        }

        // SCTO-545
        dataSetName = normalize(dataSetName);

        Cursor c = null;
        try {
            ExternalSQLiteOpenHelper sqLiteOpenHelper = getExternalDataManager().getDatabase(dataSetName, true);

            SQLiteDatabase db = sqLiteOpenHelper.getReadableDatabase();
            LinkedHashMap<String, String> selectColumnMap = ExternalDataUtil.createMapWithDisplayingColumns(getValueColumn(), getDisplayColumns());

            List<String> columnsToFetch = new ArrayList<String>(selectColumnMap.keySet());
            String safeImageColumn = null;
            if (getImageColumn() != null && getImageColumn().trim().length() > 0) {
                safeImageColumn = ExternalDataUtil.toSafeColumnName(getImageColumn());
                columnsToFetch.add(safeImageColumn);
            }

            String[] sqlColumns = columnsToFetch.toArray(new String[columnsToFetch.size()]);

            String selection;
            String[] selectionArgs;

            if (searchRows && useFilter) {
                selection = "( " + createLikeExpression(queriedColumns) + " ) AND " + ExternalDataUtil.toSafeColumnName(filterColumn) + "=? ";
                String[] likeArgs = externalDataSearchType.constructLikeArguments(queriedValue, queriedColumns.size());
                selectionArgs = new String[likeArgs.length + 1];
                System.arraycopy(likeArgs, 0, selectionArgs, 0, likeArgs.length);
                selectionArgs[selectionArgs.length - 1] = filterValue;
            } else if (searchRows) {
                selection = createLikeExpression(queriedColumns);
                selectionArgs = externalDataSearchType.constructLikeArguments(queriedValue, queriedColumns.size());
            } else if (useFilter) {
                selection = ExternalDataUtil.toSafeColumnName(filterColumn) + "=? ";
                selectionArgs = new String[]{filterValue};
            } else {
                selection = null;
                selectionArgs = null;
            }

            try {
                c = db.query(ExternalDataUtil.EXTERNAL_DATA_TABLE_NAME, sqlColumns, selection, selectionArgs, null, null, ExternalDataUtil.SORT_COLUMN_NAME);
            } catch (Exception e) {
                c = db.query(ExternalDataUtil.EXTERNAL_DATA_TABLE_NAME, sqlColumns, selection, selectionArgs, null, null, null);
            }

            return createDynamicSelectChoices(c, selectColumnMap, safeImageColumn);
        } finally {
            if (c != null) {
                c.close();
            }
        }
    }

    protected Vector<SelectChoice> createDynamicSelectChoices(Cursor c, LinkedHashMap<String, String> selectColumnMap, String safeImageColumn) {
        List<String> columnsToExcludeFromLabels = new ArrayList<String>();
        if (safeImageColumn != null) {
            columnsToExcludeFromLabels.add(safeImageColumn);
        }

        Vector<SelectChoice> selectChoices = new Vector<SelectChoice>();
        if (c.getCount() > 0) {
            c.moveToPosition(-1);
            int index = 0;
            Set<String> uniqueValues = new HashSet<String>();
            while (c.moveToNext()) {

                // the value is always the first column
                String value = c.getString(0);
                if (!uniqueValues.contains(value)) {
                    String label = buildLabel(c, selectColumnMap, columnsToExcludeFromLabels);

                    ExternalSelectChoice selectChoice;
                    if (label.trim().length() == 0) {
                        selectChoice = new ExternalSelectChoice(value, value, false);
                    } else {
                        selectChoice = new ExternalSelectChoice(label, value, false);
                    }
                    selectChoice.setIndex(index);

                    if (safeImageColumn != null && safeImageColumn.trim().length() > 0) {
                        String image = c.getString(c.getColumnIndex(safeImageColumn));
                        if (image != null && image.trim().length() > 0) {
                            selectChoice.setImage(ExternalDataUtil.JR_IMAGES_PREFIX + image);
                        }
                    }

                    selectChoices.add(selectChoice);

                    index++;

                    uniqueValues.add(value);
                }
            }
        }
        return selectChoices;
    }

    protected String createLikeExpression(List<String> queriedColumns) {
        StringBuilder sb = new StringBuilder();
        for (String queriedColumn : queriedColumns) {
            if (sb.length() > 0) {
                sb.append(" OR ");
            }
            sb.append(queriedColumn).append(" LIKE ? ");
        }
        return sb.toString();
    }

    /**
     * So here are examples of labels with one, two, and three columns:
     * <p/>
     * col1value
     * col1value (col2name: col2value)
     * col1value (col2name: col2value) (col3name: col3value)
     *
     * @param c
     * @param selectColumnMap
     * @param columnsToExcludeFromLabels
     * @return
     */
    protected String buildLabel(Cursor c, LinkedHashMap<String, String> selectColumnMap, List<String> columnsToExcludeFromLabels) {
        StringBuilder sb = new StringBuilder();
        // we start at 1 since 0 is the "value" column
        for (int columnIndex = 1; columnIndex < c.getColumnCount(); columnIndex++) {
            String columnName = c.getColumnName(columnIndex);
            if (columnsToExcludeFromLabels.contains(columnName)) {
                continue;
            }

            String value = c.getString(columnIndex);

            if (columnIndex == 1) {
                sb.append(value);
                continue;
            }
            if (c.getColumnCount() - columnsToExcludeFromLabels.size() == 2) {
                break;
            }
            if (columnIndex > 1) {
                sb.append(" ");
            }
            sb.append("(");
            sb.append(selectColumnMap.get(columnName));
            sb.append(": ");
            sb.append(value);
            sb.append(")");
        }
        return sb.toString();
    }
}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.external.handler;

import org.odk.collect.android.external.ExternalDataHandler;
import org.odk.collect.android.external.ExternalDataManager;

/**
 * Author: Meletis Margaritis
 * Date: 16/05/13
 * Time: 10:42
 */
public abstract class ExternalDataHandlerBase implements ExternalDataHandler {

    private ExternalDataManager externalDataManager;

    public ExternalDataManager getExternalDataManager() {
        return externalDataManager;
    }

    public void setExternalDataManager(ExternalDataManager externalDataManager) {
        this.externalDataManager = externalDataManager;
    }

    protected ExternalDataHandlerBase(ExternalDataManager externalDataManager) {
        this.setExternalDataManager(externalDataManager);
    }

    /**
     * SCTO-545
     *
     * @param dataSetName the user-supplied data-set in the function
     * @return the normalized data-set name.
     */
    protected String normalize(String dataSetName) {
        dataSetName = dataSetName.toLowerCase();
        if (dataSetName.endsWith(".csv")) {
            dataSetName = dataSetName.substring(0, dataSetName.lastIndexOf(".csv"));
        }
        return dataSetName;
    }
}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.external.handler;

import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.util.Log;

import org.javarosa.core.model.condition.EvaluationContext;
import org.javarosa.xpath.expr.XPathFuncExpr;
import org.odk.collect.android.external.ExternalDataManager;
import org.odk.collect.android.external.ExternalDataUtil;
import org.odk.collect.android.external.ExternalSQLiteOpenHelper;

import java.util.Vector;

/**
 * Author: Meletis Margaritis
 * Date: 25/04/13
 * Time: 13:50
 */
public class ExternalDataHandlerPull extends ExternalDataHandlerBase {

    public static final String HANDLER_NAME = "pulldata";

    public ExternalDataHandlerPull(ExternalDataManager externalDataManager) {
        super(externalDataManager);
    }

    @Override
    public String getName() {
        return HANDLER_NAME;
    }

    @Override
    public Vector getPrototypes() {
        return new Vector();
    }

    @Override
    public boolean rawArgs() {
        return true;
    }

    @Override
    public boolean realTime() {
        return false;
    }

    @Override
    public Object eval(Object[] args, EvaluationContext ec) {
        if (args.length != 4) {
            Log.e(ExternalDataUtil.LOGGER_NAME, "4 arguments are needed to evaluate the " + HANDLER_NAME + " function");
            return "";
        }

        String dataSetName = XPathFuncExpr.toString(args[0]);
        String queriedColumn = XPathFuncExpr.toString(args[1]);
        String referenceColumn = XPathFuncExpr.toString(args[2]);
        String referenceValue = XPathFuncExpr.toString(args[3]);

        // SCTO-545
        dataSetName = normalize(dataSetName);

        Cursor c = null;
        try {

            ExternalSQLiteOpenHelper sqLiteOpenHelper = getExternalDataManager().getDatabase(dataSetName, false);
            if (sqLiteOpenHelper == null) {
                return "";
            }

            SQLiteDatabase db = sqLiteOpenHelper.getReadableDatabase();
            String[] columns = {ExternalDataUtil.toSafeColumnName(queriedColumn)};
            String selection = ExternalDataUtil.toSafeColumnName(referenceColumn) + "=?";
            String[] selectionArgs = {referenceValue};

            c = db.query(ExternalDataUtil.EXTERNAL_DATA_TABLE_NAME, columns, selection, selectionArgs, null, null, null);
            if (c.getCount() > 0) {
                c.moveToFirst();
                return ExternalDataUtil.nullSafe(c.getString(0));
            } else {
                Log.e(ExternalDataUtil.LOGGER_NAME, "Could not find a value in " + queriedColumn + " where the column " + referenceColumn + " has the value " + referenceValue);
                return "";
            }
        } catch (Exception e) {
            Log.e(ExternalDataUtil.LOGGER_NAME, e.getMessage());
            return "";
        } finally {
            if (c != null) {
                c.close();
            }
        }
    }
}

package org.odk.collect.android.views;

import android.content.Context;
import android.content.DialogInterface;
import android.os.Bundle;
import android.preference.ListPreference;
import android.util.AttributeSet;

public class DynamicListPreference extends ListPreference {

	// control whether dialog should show or not
	private boolean showDialog = false;

	public DynamicListPreference(Context context, AttributeSet attrs) {
		super(context, attrs);
	}

	public DynamicListPreference(Context context) {
		super(context);
	}

	public DynamicListPreference(Context context, boolean show) {
		super(context);
		showDialog = show;
	}

	// This is just to simulate that the user 'clicked' on the preference.
	public void show() {
		showDialog(null);
	}
	
	public boolean shouldShow() {
		return showDialog;
	}

	@Override
	protected void showDialog(Bundle state) {
		if (showDialog) {
			super.showDialog(state);
		} else {
			// we don't want the dialog to show sometimes
			// like immediately after click, so we don't until we've generated
			// the
			// list choices
			return;
		}
	}

	public void setShowDialog(boolean show) {
		showDialog = show;
	}

	@Override
	public void onClick(DialogInterface dialog, int which) {
		super.onClick(dialog, which);

		// causes list to refresh next time dialog is requested
		if (which == DialogInterface.BUTTON_NEGATIVE) {
			setShowDialog(false);
		}
	}

	
	

}

// Copyright 2015 The Project Buendia Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at: http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distrib-
// uted under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
// OR CONDITIONS OF ANY KIND, either express or implied.  See the License for
// specific language governing permissions and limitations under the License.

package org.odk.collect.android.views;

import android.content.Context;
import android.util.AttributeSet;
import android.view.View;
import android.widget.RadioGroup;
import android.widget.TextView;

/**
 * WrappingRadioGroup is a {@link RadioGroup} that wraps when its choices would otherwise cause a
 * line to overflow.
 */
public class WrappingRadioGroup extends RadioGroup {
    /** Padding between container and radio buttons. */
    public static final int PADDING = 0;
    /** Padding between radio buttons. */
    public static final int BUTTON_PADDING = 8;

    public WrappingRadioGroup(Context context) {
        super(context);
    }

    public WrappingRadioGroup(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        setPadding(PADDING, PADDING, PADDING, PADDING);

        final int width = MeasureSpec.getSize(widthMeasureSpec);

        // Ensure that radio buttons are displayed on the correct lines.
        final int childCount = getChildCount();
        int x = PADDING;
        int y = PADDING;
        int maxButtonHeightForLine = 0;
        for (int i = 0; i < childCount; i++) {
            View child = getChildAt(i);
            final int buttonWidth = getButtonWidth(child);
            final int buttonHeight = getButtonHeight(child);

            // If the button would overflow, go to the next line.
            if (x + buttonWidth > width) {
                x = PADDING;
                y += ((maxButtonHeightForLine > 0) ? maxButtonHeightForLine : buttonHeight)
                        + BUTTON_PADDING;
                maxButtonHeightForLine = buttonHeight;
            }

            // Go to next button position (the top right corner of the current button).
            x += buttonWidth;
            maxButtonHeightForLine = Math.max(maxButtonHeightForLine, buttonHeight);
        }

        // Height is the total height of all lines including top and bottom padding as well as
        // the bottom padding of the buttons on the last line.
        int newHeightMeasureSpec = MeasureSpec.makeMeasureSpec(
                maxButtonHeightForLine + y + PADDING + BUTTON_PADDING, MeasureSpec.EXACTLY);
        super.onMeasure(widthMeasureSpec, newHeightMeasureSpec);
    }

    @Override
    public void onLayout(boolean changed, int left, int top, int right, int bottom) {
        final int width = getMeasuredWidth();

        // Ensure that radio buttons are displayed on the correct lines.
        final int childCount = getChildCount();
        int x = PADDING;
        int y = PADDING;
        int maxButtonHeightForLine = 0;
        for (int i = 0; i < childCount; i++) {
            View child = getChildAt(i);
            final int buttonWidth = getButtonWidth(child);
            final int buttonHeight = getButtonHeight(child);

            // If the button would overflow, go to the next line.
            if (x + buttonWidth > width) {
                x = PADDING;
                y += ((maxButtonHeightForLine > 0) ? maxButtonHeightForLine : buttonHeight)
                        + BUTTON_PADDING;
                maxButtonHeightForLine = buttonHeight;
            }

            // Layout this button and go to the next position.
            child.layout(x, y, x + buttonWidth, y + buttonHeight);
            x += buttonWidth;
            maxButtonHeightForLine = Math.max(maxButtonHeightForLine, buttonHeight);
        }
    }

    /** Given an un-inflated button, gets the expected width. */
    private int getButtonWidth(View button) {
        TextView textView = (TextView)button;
        textView.measure(0, 0);
        return textView.getMeasuredWidth();
    }

    /** Given an un-inflated button, gets the expected height. */
    private int getButtonHeight(View button) {
        TextView textView = (TextView)button;
        textView.measure(0, 0);
        return textView.getMeasuredHeight();
    }
}

/*
 * Copyright (C) 2009 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.views;

import android.content.Context;
import android.util.AttributeSet;
import android.widget.CheckBox;
import android.widget.Checkable;
import android.widget.RelativeLayout;

import org.odk.collect.android.R;

public class TwoItemMultipleChoiceView extends RelativeLayout implements Checkable {

    public TwoItemMultipleChoiceView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }


    public TwoItemMultipleChoiceView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }


    public TwoItemMultipleChoiceView(Context context) {
        super(context);
    }


    @Override
    public boolean isChecked() {
        CheckBox c = (CheckBox) findViewById(R.id.checkbox);
        return c.isChecked();
    }


    @Override
    public void setChecked(boolean checked) {
        CheckBox c = (CheckBox) findViewById(R.id.checkbox);
        c.setChecked(checked);
    }


    @Override
    public void toggle() {
        CheckBox c = (CheckBox) findViewById(R.id.checkbox);
        c.setChecked(!c.isChecked());
    }

}

/*
 * Copyright (C) 2011 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.views;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Context;
import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Color;
import android.net.Uri;
import android.util.Log;
import android.view.Display;
import android.view.View;
import android.view.WindowManager;
import android.widget.CheckBox;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.ImageView.ScaleType;
import android.widget.RadioButton;
import android.widget.RelativeLayout;
import android.widget.TextView;
import android.widget.Toast;

import org.javarosa.core.model.FormIndex;
import org.javarosa.core.reference.InvalidReferenceException;
import org.javarosa.core.reference.ReferenceManager;
import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.utilities.FileUtils;
import org.odk.collect.android.widgets.QuestionWidget;

import java.io.File;

/**
 * This layout is used anywhere we can have image/audio/video/text. TODO: It would probably be nice
 * to put this in a layout.xml file of some sort at some point.
 * 
 * @author carlhartung
 */
public class MediaLayout extends RelativeLayout {
    private static final String t = "AVTLayout";

    private String mSelectionDesignator;
    private FormIndex mIndex;
    private TextView mView_Text;
    private AudioButton mAudioButton;
    private ImageButton mVideoButton;
    private ImageView mImageView;
    private TextView mMissingImage;
    
    private String mVideoURI = null;


    public MediaLayout(Context c) {
        super(c);
        mView_Text = null;
        mAudioButton = null;
        mImageView = null;
        mMissingImage = null;
        mVideoButton = null;
        mIndex = null;
    }

    public void playAudio() {
    	if ( mAudioButton != null ) {
    		mAudioButton.playAudio();
    	}
    }

    public void playVideo() {
    	if ( mVideoURI != null ) {
            String videoFilename = "";
            try {
                videoFilename =
                    ReferenceManager._().DeriveReference(mVideoURI).getLocalURI();
            } catch (InvalidReferenceException e) {
                Log.e(t, "Invalid reference exception");
                e.printStackTrace();
            }

            File videoFile = new File(videoFilename);
            if (!videoFile.exists()) {
                // We should have a video clip, but the file doesn't exist.
                String errorMsg =
                    getContext().getString(R.string.file_missing, videoFilename);
                Log.e(t, errorMsg);
                Toast.makeText(getContext(), errorMsg, Toast.LENGTH_LONG).show();
                return;
            }

            Intent i = new Intent("android.intent.action.VIEW");
            i.setDataAndType(Uri.fromFile(videoFile), "video/*");
            try {
                ((Activity) getContext()).startActivity(i);
            } catch (ActivityNotFoundException e) {
                Toast.makeText(getContext(),
                    getContext().getString(R.string.activity_not_found, "view video"),
                    Toast.LENGTH_SHORT).show();
            }
    	}
    }

    public void setAVT(FormIndex index, String selectionDesignator, TextView text, String audioURI, String imageURI, String videoURI,
            final String bigImageURI) {
    	mSelectionDesignator = selectionDesignator;
    	mIndex = index;
        mView_Text = text;
        mView_Text.setId(QuestionWidget.newUniqueId());
        mVideoURI = videoURI;

        // Layout configurations for our elements in the relative layout
        RelativeLayout.LayoutParams textParams =
            new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
        RelativeLayout.LayoutParams audioParams =
            new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
        RelativeLayout.LayoutParams imageParams =
            new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
        RelativeLayout.LayoutParams videoParams =
            new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);

        // First set up the audio button
        if (audioURI != null) {
            // An audio file is specified
            mAudioButton = new AudioButton(getContext(), mIndex, mSelectionDesignator, audioURI);
            mAudioButton.setId(QuestionWidget.newUniqueId()); // random ID to be used by the
                                                                      // relative layout.
        } else {
            // No audio file specified, so ignore.
        }

        // Then set up the video button
        if (videoURI != null) {
            // An video file is specified
            mVideoButton = new ImageButton(getContext());
            Bitmap b =
                    BitmapFactory.decodeResource(getContext().getResources(),
                        android.R.drawable.ic_media_play);
            mVideoButton.setImageBitmap(b);
            mVideoButton.setOnClickListener(new OnClickListener() {

                @Override
                public void onClick(View v) {
                	Collect.getInstance().getActivityLogger().logInstanceAction(this, "onClick", "playVideoPrompt"+mSelectionDesignator, mIndex);
                	MediaLayout.this.playVideo();
                }

            });
            mVideoButton.setId(QuestionWidget.newUniqueId());
        } else {
            // No video file specified, so ignore.
        }

        // Now set up the image view
        String errorMsg = null;
        final int imageId = QuestionWidget.newUniqueId();
        if (imageURI != null) {
            try {
                String imageFilename = ReferenceManager._().DeriveReference(imageURI).getLocalURI();
                final File imageFile = new File(imageFilename);
                if (imageFile.exists()) {
                    Display display =
                        ((WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE))
                                .getDefaultDisplay();
                    int screenWidth = display.getWidth();
                    int screenHeight = display.getHeight();
                    Bitmap b = FileUtils.getBitmapScaledToDisplay(imageFile, screenHeight, screenWidth);
                    if (b != null) {
                        mImageView = new ImageView(getContext());
                        mImageView.setPadding(2, 2, 2, 2);
                        mImageView.setBackgroundColor(Color.WHITE);
                        mImageView.setImageBitmap(b);
                        mImageView.setId(imageId);

                        if (bigImageURI != null) {
                            mImageView.setOnClickListener(new OnClickListener() {
                            	String bigImageFilename = ReferenceManager._()
                                        .DeriveReference(bigImageURI).getLocalURI();
                                File bigImage = new File(bigImageFilename);


                                @Override
                                public void onClick(View v) {
                                	Collect.getInstance().getActivityLogger().logInstanceAction(this, "onClick", "showImagePromptBigImage"+mSelectionDesignator, mIndex);

                                    Intent i = new Intent("android.intent.action.VIEW");
                                    i.setDataAndType(Uri.fromFile(bigImage), "image/*");
                                    try {
                                        getContext().startActivity(i);
                                    } catch (ActivityNotFoundException e) {
                                        Toast.makeText(
                                            getContext(),
                                            getContext().getString(R.string.activity_not_found,
                                                "view image"), Toast.LENGTH_SHORT).show();
                                    }
                                }
                            });
                        }
                    } else {
                        // Loading the image failed, so it's likely a bad file.
                        errorMsg = getContext().getString(R.string.file_invalid, imageFile);
                    }
                } else {
                    // We should have an image, but the file doesn't exist.
                    errorMsg = getContext().getString(R.string.file_missing, imageFile);
                }

                if (errorMsg != null) {
                    // errorMsg is only set when an error has occurred
                    Log.e(t, errorMsg);
                    mMissingImage = new TextView(getContext());
                    mMissingImage.setText(errorMsg);
                    mMissingImage.setPadding(10, 10, 10, 10);
                    mMissingImage.setId(imageId);
                }
            } catch (InvalidReferenceException e) {
                Log.e(t, "image invalid reference exception");
                e.printStackTrace();
            }
        } else {
            // There's no imageURI listed, so just ignore it.
        }

        // e.g., for TextView that flag will be true
        boolean isNotAMultipleChoiceField = !RadioButton.class.isAssignableFrom(text.getClass()) && !CheckBox.class.isAssignableFrom(text.getClass());

        // Determine the layout constraints...
        // Assumes LTR, TTB reading bias!
        if (mView_Text.getText().length() == 0 && (mImageView != null || mMissingImage != null)) {
            // No text; has image. The image is treated as question/choice icon.
            // The Text view may just have a radio button or checkbox. It
            // needs to remain in the layout even though it is blank.
            //
            // The image view, as created above, will dynamically resize and
            // center itself. We want it to resize but left-align itself
            // in the resized area and we want a white background, as otherwise
            // it will show a grey bar to the right of the image icon.
            if (mImageView != null) {
                mImageView.setScaleType(ScaleType.FIT_START);
            }
            //
            // In this case, we have:
            // Text upper left; image upper, left edge aligned with text right edge;
            // audio upper right; video below audio on right.
            textParams.addRule(RelativeLayout.ALIGN_PARENT_TOP);
            textParams.addRule(RelativeLayout.ALIGN_PARENT_LEFT);
            if (isNotAMultipleChoiceField) {
                imageParams.addRule(RelativeLayout.CENTER_HORIZONTAL);
            } else {
                imageParams.addRule(RelativeLayout.RIGHT_OF, mView_Text.getId());
            }
            imageParams.addRule(RelativeLayout.ALIGN_PARENT_TOP);
            if (mAudioButton != null && mVideoButton == null) {
                audioParams.addRule(RelativeLayout.ALIGN_PARENT_TOP);
                audioParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
                imageParams.addRule(RelativeLayout.LEFT_OF, mAudioButton.getId());
            } else if (mAudioButton == null && mVideoButton != null) {
                videoParams.addRule(RelativeLayout.ALIGN_PARENT_TOP);
                videoParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
                imageParams.addRule(RelativeLayout.LEFT_OF, mVideoButton.getId());
            } else if (mAudioButton != null && mVideoButton != null) {
                audioParams.addRule(RelativeLayout.ALIGN_PARENT_TOP);
                audioParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
                imageParams.addRule(RelativeLayout.LEFT_OF, mAudioButton.getId());
                videoParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
                videoParams.addRule(RelativeLayout.BELOW, mAudioButton.getId());
                imageParams.addRule(RelativeLayout.LEFT_OF, mVideoButton.getId());
            } else {
                // the image will implicitly scale down to fit within parent...
                // no need to bound it by the width of the parent...
                if (!isNotAMultipleChoiceField) {
                    imageParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
                }
            }
            imageParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);
        } else {
            // We have a non-blank text label -- image is below the text.
            // In this case, we want the image to be centered...
            if (mImageView != null) {
                mImageView.setScaleType(ScaleType.FIT_START);
            }
            //
            // Text upper left; audio upper right; video below audio on right.
            // image below text, audio and video buttons; left-aligned with text.
            textParams.addRule(RelativeLayout.ALIGN_PARENT_LEFT);
            textParams.addRule(RelativeLayout.ALIGN_PARENT_TOP);
            if (mAudioButton != null && mVideoButton == null) {
                audioParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
                textParams.addRule(RelativeLayout.LEFT_OF, mAudioButton.getId());
          } else if (mAudioButton == null && mVideoButton != null) {
                videoParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
                textParams.addRule(RelativeLayout.LEFT_OF, mVideoButton.getId());
            } else if (mAudioButton != null && mVideoButton != null) {
                audioParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
                textParams.addRule(RelativeLayout.LEFT_OF, mAudioButton.getId());
                videoParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
                videoParams.addRule(RelativeLayout.BELOW, mAudioButton.getId());
            } else {
                textParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
            }

            if (mImageView != null || mMissingImage != null) {
                imageParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);
                imageParams.addRule(RelativeLayout.CENTER_HORIZONTAL);
                imageParams.addRule(RelativeLayout.BELOW, mView_Text.getId());
            }
        }

        addView(mView_Text, textParams);
        if (mAudioButton != null)
            addView(mAudioButton, audioParams);
        if (mVideoButton != null)
            addView(mVideoButton, videoParams);
        if (mImageView != null)
            addView(mImageView, imageParams);
        else if (mMissingImage != null)
            addView(mMissingImage, imageParams);
    }


    /**
     * This adds a divider at the bottom of this layout. Used to separate fields in lists.
     * 
     * @param v
     */
    public void addDivider(ImageView v) {
        RelativeLayout.LayoutParams dividerParams =
            new RelativeLayout.LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT);
        if (mImageView != null) {
            dividerParams.addRule(RelativeLayout.BELOW, mImageView.getId());
        } else if (mMissingImage != null) {
            dividerParams.addRule(RelativeLayout.BELOW, mMissingImage.getId());
        } else if (mVideoButton != null) {
            dividerParams.addRule(RelativeLayout.BELOW, mVideoButton.getId());
        } else if (mAudioButton != null) {
            dividerParams.addRule(RelativeLayout.BELOW, mAudioButton.getId());
        } else if (mView_Text != null) {
            // No picture
            dividerParams.addRule(RelativeLayout.BELOW, mView_Text.getId());
        } else {
            Log.e(t, "Tried to add divider to uninitialized ATVWidget");
            return;
        }
        addView(v, dividerParams);
    }


    @Override
    protected void onWindowVisibilityChanged(int visibility) {
        super.onWindowVisibilityChanged(visibility);
        if (visibility != View.VISIBLE) {
            if (mAudioButton != null) {
                mAudioButton.stopPlaying();
            }
        }
    }

}

/*
 * Copyright (C) 2009 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.views;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.util.AttributeSet;
import android.util.Log;
import android.view.View;
import android.view.animation.Animation;
import android.view.animation.AnimationUtils;

import org.odk.collect.android.R;

/**
 * Builds view for arrow animation
 * 
 * @author Carl Hartung (carlhartung@gmail.com)
 */
public class ArrowAnimationView extends View {

    private final static String t = "ArrowAnimationView";

    private Animation mAnimation;
    private Bitmap mArrow;

    private int mImgXOffset;


    public ArrowAnimationView(Context context, AttributeSet attrs) {
        super(context, attrs);
        Log.i(t, "called constructor");
        init();
    }


    public ArrowAnimationView(Context context) {
        super(context);
        init();
    }


    private void init() {
        mArrow = BitmapFactory.decodeResource(getResources(), R.drawable.left_arrow);
        mImgXOffset = mArrow.getWidth() / 2;
    }


    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        if (mAnimation == null) {
            createAnim(canvas);
        }

        int centerX = canvas.getWidth() / 2;

        canvas.drawBitmap(mArrow, centerX - mImgXOffset, (float) mArrow.getHeight() / 4, null);
    }


    private void createAnim(Canvas canvas) {
        mAnimation = AnimationUtils.loadAnimation(getContext(), R.anim.start_arrow);
        startAnimation(mAnimation);
    }
}

/*
 * Copyright (C) 2009 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.views;

import android.content.Context;
import android.graphics.drawable.Drawable;
import android.view.Gravity;
import android.widget.ImageView;
import android.widget.RelativeLayout;
import android.widget.TextView;

import org.odk.collect.android.logic.HierarchyElement;

public class HierarchyElementView extends RelativeLayout {

    private TextView mPrimaryTextView;
    private TextView mSecondaryTextView;
    private ImageView mIcon;


    public HierarchyElementView(Context context, HierarchyElement it) {
        super(context);

        setColor(it.getColor());

        mIcon = new ImageView(context);
        mIcon.setImageDrawable(it.getIcon());
        mIcon.setId(1);
        mIcon.setPadding(0, 0, dipToPx(4), 0);

        addView(mIcon, new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT,
                LayoutParams.WRAP_CONTENT));

        mPrimaryTextView = new TextView(context);
        mPrimaryTextView.setTextAppearance(context, android.R.style.TextAppearance_Large);
        mPrimaryTextView.setText(it.getPrimaryText());
        mPrimaryTextView.setId(2);
        mPrimaryTextView.setGravity(Gravity.CENTER_VERTICAL);
        LayoutParams l =
            new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
        l.addRule(RelativeLayout.RIGHT_OF, mIcon.getId());
        addView(mPrimaryTextView, l);

        mSecondaryTextView = new TextView(context);
        mSecondaryTextView.setText(it.getSecondaryText());
        mSecondaryTextView.setTextAppearance(context, android.R.style.TextAppearance_Small);
        mSecondaryTextView.setGravity(Gravity.CENTER_VERTICAL);

        LayoutParams lp =
            new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
        lp.addRule(RelativeLayout.BELOW, mPrimaryTextView.getId());
        lp.addRule(RelativeLayout.RIGHT_OF, mIcon.getId());
        addView(mSecondaryTextView, lp);

        setPadding(dipToPx(8), dipToPx(4), dipToPx(8), dipToPx(8));

    }


    public void setPrimaryText(String text) {
        mPrimaryTextView.setText(text);
    }


    public void setSecondaryText(String text) {
        mSecondaryTextView.setText(text);
    }


    public void setIcon(Drawable icon) {
        mIcon.setImageDrawable(icon);
    }


    public void setColor(int color) {
        setBackgroundColor(color);
    }


    public void showSecondary(boolean bool) {
        if (bool) {
            mSecondaryTextView.setVisibility(VISIBLE);
            setMinimumHeight(dipToPx(64));

        } else {
            mSecondaryTextView.setVisibility(GONE);
            setMinimumHeight(dipToPx(32));

        }
    }
    
    public int dipToPx(int dip) {
        return (int) (dip * getResources().getDisplayMetrics().density + 0.5f);
    }

}

/*
 * Copyright (C) 2011 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.views;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.TableLayout;
import android.widget.TextView;
import android.widget.Toast;

import org.javarosa.core.model.Constants;
import org.javarosa.core.model.FormIndex;
import org.javarosa.core.model.IFormElement;
import org.javarosa.core.model.QuestionDef;
import org.javarosa.core.model.SelectChoice;
import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.instance.TreeReference;
import org.javarosa.form.api.FormEntryCaption;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.R;
import org.odk.collect.android.activities.FormEntryActivity;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.exception.ExternalParamsException;
import org.odk.collect.android.exception.JavaRosaException;
import org.odk.collect.android.external.ExternalAppsUtils;
import org.odk.collect.android.logic.FormController;
import org.odk.collect.android.model.Preset;
import org.odk.collect.android.utilities.Utils;
import org.odk.collect.android.widgets.IBinaryWidget;
import org.odk.collect.android.widgets.QuestionWidget;
import org.odk.collect.android.widgets.WidgetFactory;
import org.odk.collect.android.widgets2.Widget2Factory;
import org.odk.collect.android.widgets2.common.Appearance;
import org.odk.collect.android.widgets2.group.WidgetGroup;
import org.odk.collect.android.widgets2.group.WidgetGroupBuilder;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * This class is
 *
 * @author carlhartung
 */
public class ODKView extends LinearLayout {

	// starter random number for view IDs
    private final static int VIEW_ID = 12345;

    private final static String t = "ODKView";

    private LinearLayout mView;
    private LinearLayout.LayoutParams mLayout;
    private ArrayList<QuestionWidget> mWidgets;
    private WidgetGroup mWidgetGroup;
    private Handler h = null;

    public final static String FIELD_LIST = "field-list";

    public ODKView(Context context, final FormEntryPrompt[] questionPrompts,
            FormEntryCaption[] groups, boolean advancingPage) {
        this(context, questionPrompts, groups, advancingPage, null /*fields*/);
    }

    public ODKView(Context context, final FormEntryPrompt[] questionPrompts,
                   FormEntryCaption[] groups, boolean advancingPage, Preset preset) {
        super(context);

        mWidgets = new ArrayList<QuestionWidget>();

        mView = new LinearLayout(getContext());
        mView.setOrientation(LinearLayout.VERTICAL);
        mView.setGravity(Gravity.TOP);
        mView.setPadding(0, 7, 0, 0);

        mLayout =
            new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT);
//        mLayout.setMargins(10, 0, 10, 0);

        // display which group you are in as well as the question

        addGroupText(groups);

        // when the grouped fields are populated by an external app, this will get true.
        boolean readOnlyOverride = false;

        if (groups != null && groups.length > 0) {
            WidgetGroupBuilder<?, ?> builder =
                    Widget2Factory.INSTANCE.createGroupBuilder(context, groups[groups.length - 1]);
            if (builder != null) {
                int id = 0;
                for (FormEntryPrompt p : questionPrompts) {
                    builder.createAndAddWidget(
                            context,
                            p,
                            Appearance.fromString(p.getAppearanceHint()),
                            readOnlyOverride,
                            VIEW_ID + id++,
                            preset);
                }
                mWidgetGroup = builder.build(context);
                mView.addView((View) mWidgetGroup);
                addView(mView);
                return;
            }
        }

        // get the group we are showing -- it will be the last of the groups in the groups list
        if (groups != null && groups.length > 0) {
            final FormEntryCaption c = groups[groups.length - 1];
            final String intentString = c.getFormElement().getAdditionalAttribute(null, "intent");
            if (intentString != null && intentString.length() != 0) {

                readOnlyOverride = true;

                final String buttonText;
                final String errorString;
                String v = c.getSpecialFormQuestionText("buttonText");
                buttonText = (v != null) ? v : context.getString(R.string.launch_app);
                v = c.getSpecialFormQuestionText("noAppErrorString");
                errorString = (v != null) ? v : context.getString(R.string.no_app);

                TableLayout.LayoutParams params = new TableLayout.LayoutParams();
                params.setMargins(7, 5, 7, 5);

                // set button formatting
                Button mLaunchIntentButton = new Button(getContext());
                mLaunchIntentButton.setId(QuestionWidget.newUniqueId());
                mLaunchIntentButton.setText(Utils.localize(buttonText, context));
                mLaunchIntentButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, Collect.getQuestionFontsize() + 2);
                mLaunchIntentButton.setPadding(20, 20, 20, 20);
                mLaunchIntentButton.setLayoutParams(params);

                mLaunchIntentButton.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        String intentName = ExternalAppsUtils.extractIntentName(intentString);
                        Map<String, String> parameters = ExternalAppsUtils.extractParameters(intentString);

                        Intent i = new Intent(intentName);
                        try {
                            ExternalAppsUtils.populateParameters(i, parameters, c.getIndex().getReference());

                            for (FormEntryPrompt p : questionPrompts) {
                                IFormElement formElement = p.getFormElement();
                                if (formElement instanceof QuestionDef) {
                                    TreeReference reference = (TreeReference) formElement.getBind().getReference();
                                    IAnswerData answerValue = p.getAnswerValue();
                                    Object value = answerValue == null ? null : answerValue.getValue();
                                    switch (p.getDataType()) {
                                        case Constants.DATATYPE_TEXT:
                                        case Constants.DATATYPE_INTEGER:
                                        case Constants.DATATYPE_DECIMAL:
                                            i.putExtra(reference.getNameLast(), (Serializable) value);
                                            break;
                                    }
                                }
                            }

                            ((Activity) getContext()).startActivityForResult(i, FormEntryActivity.EX_GROUP_CAPTURE);
                        } catch (ExternalParamsException e) {
                            Log.e("ExternalParamsException", e.getMessage(), e);

                            Toast.makeText(getContext(),
                                    e.getMessage(), Toast.LENGTH_SHORT)
                                    .show();
                        } catch (ActivityNotFoundException e) {
                            Log.e("ActivityNotFoundException", e.getMessage(), e);

                            Toast.makeText(getContext(),
                                    errorString, Toast.LENGTH_SHORT)
                                    .show();
                        }
                    }
                });

                View divider = new View(getContext());
                divider.setBackgroundResource(R.drawable.divider);
                divider.setMinimumHeight((int) TypedValue.applyDimension(
                        TypedValue.COMPLEX_UNIT_DIP, 9, getResources().getDisplayMetrics()));
                mView.addView(divider);

//                mView.addView(
//                        LayoutInflater.from(getContext()).inflate(R.layout.template_divider, null));

                mView.addView(mLaunchIntentButton, mLayout);
            }
        }

        boolean first = true;
        int id = 0;
        for (FormEntryPrompt p : questionPrompts) {
            if (!first) {

                View divider = new View(getContext());
                divider.setBackgroundResource(R.drawable.divider);
                divider.setMinimumHeight((int) TypedValue.applyDimension(
                        TypedValue.COMPLEX_UNIT_DIP, 9, getResources().getDisplayMetrics()));
//                divider.setLay
//                mView.addView(
//                        LayoutInflater.from(getContext()).inflate(R.layout.template_divider, null));
                mView.addView(divider);
            } else {
                first = false;
            }

            // if question or answer type is not supported, use text widget
            QuestionWidget qw =
                    Widget2Factory.INSTANCE.create(getContext(), p, readOnlyOverride);
            if (qw == null) {
                qw = WidgetFactory.createWidgetFromPrompt(p, getContext(), readOnlyOverride);
            }

            qw.setId(VIEW_ID + id++);

            mWidgets.add(qw);

            // The encounter properties (encounter_datetime, location_id, and
            // provider_id) are special.  We preset them according to the values
            // passed to us, and hide them if they are preset.  In particular,
            // the location_id and provider_id widgets use UUIDs as the item
            // labels because we need to identify them in order to preselect
            // them -- so we should always hide the location and provider widgets.

            String refName = p.getIndex().getReference().getNameLast();
            if (refName.equals("encounter.encounter_datetime")) {
                if (preset.encounterDatetime != null) {
                    if (qw.forceSetAnswer(preset.encounterDatetime)) {
                        continue;
                    }
                }
            }
            if (refName.equals("encounter.location_id")) {
                preselect(qw, preset.locationUuid);
                continue;
            }
            if (refName.equals("encounter.provider_id")) {
                preselect(qw, preset.providerUuid);
                continue;
            }

            mView.addView(qw, mLayout);
        }

        addView(mView);

        // see if there is an autoplay option.
        // Only execute it during forward swipes through the form
        if ( advancingPage && mWidgets.size() == 1 ) {
	        final String playOption = mWidgets.get(0).getPrompt().getFormElement().getAdditionalAttribute(null, "autoplay");
	        if ( playOption != null ) {
	        	h = new Handler();
	        	h.postDelayed(new Runnable() {
						@Override
						public void run() {
				        	if ( playOption.equalsIgnoreCase("audio") ) {
				        		mWidgets.get(0).playAudio();
				        	} else if ( playOption.equalsIgnoreCase("video") ) {
				        		mWidgets.get(0).playVideo();
				        	}
						}
					}, 150);
	        }
        }
    }

    /**
     * Preselects the option with the given label text for the given
     * question.  If there is no matching option, preselects the
     * first option.  When this function returns, something will
     * be preselected.
     */
    protected void preselect(QuestionWidget widget, String label) {
        if (widget.forceSetAnswer(label)) return;

        // Couldn't find a match, so just preselect the first option.
        List<SelectChoice> choices = widget.getPrompt().getSelectChoices();
        if (choices.isEmpty()) {
            throw new IllegalStateException(String.format(
                "Form did not provide any choices for \"%s\"",
                widget.getPrompt().getShortText()
            ));
        }
        boolean success = widget.forceSetAnswer(choices.get(0).getLabelInnerText());
        if (!success) {
            throw new IllegalStateException(String.format(
                "\"%s\" widget failed to preselect its first choice",
                widget.getPrompt().getShortText()
            ));
        }
    }

    /**
     * http://code.google.com/p/android/issues/detail?id=8488
     */
    public void recycleDrawables() {
    	this.destroyDrawingCache();
    	mView.destroyDrawingCache();
    	for ( QuestionWidget q : mWidgets) {
    		q.recycleDrawables();
    	}
    }

    protected void onScrollChanged(int l, int t, int oldl, int oldt) {
    	Collect.getInstance().getActivityLogger().logScrollAction(this, t - oldt);
    }

    /**
     * @return a HashMap of answers entered by the user for this set of widgets
     */
    public LinkedHashMap<FormIndex, IAnswerData> getAnswers() {
        LinkedHashMap<FormIndex, IAnswerData> answers = new LinkedHashMap<FormIndex, IAnswerData>();

        for (QuestionWidget widget : mWidgetGroup != null ? mWidgetGroup.getWidgets() : mWidgets) {
            FormEntryPrompt p = widget.getPrompt();
            answers.put(p.getIndex(), widget.getAnswer());
        }
//
//
//        Iterator<QuestionWidget> i = mWidgets.iterator();
//        while (i.hasNext()) {
//            /*
//             * The FormEntryPrompt has the FormIndex, which is where the answer gets stored. The
//             * QuestionWidget has the answer the user has entered.
//             */
//            QuestionWidget q = i.next();
//            FormEntryPrompt p = q.getPrompt();
//            answers.put(p.getIndex(), q.getAnswer());
//        }

        return answers;
    }


    /**
     * // * Add a TextView containing the hierarchy of groups to which the question belongs. //
     */
    private void addGroupText(FormEntryCaption[] groups) {
        StringBuilder s = new StringBuilder("");
        String t = "";
        int i;
        // list all groups in one string
        for (FormEntryCaption g : groups) {
            i = g.getMultiplicity() + 1;
            t = g.getLongText();
            if (t != null) {
                s.append(Utils.localize(t, getContext()));
                if (g.repeats() && i > 0) {
                    s.append(" (" + i + ")");
                }
                s.append(" > ");
            }

            // if any of the groups are invisible, ignore them (and all above)
            Appearance appearance = Appearance.fromString(g.getAppearanceHint());
            if (appearance.hasQualifier("invisible")) {
                s.setLength(0);
            }
        }

        // If any groups exist, add a TextView that contains the group name.
        if (s.length() > 0) {
            TextView tv = (TextView) LayoutInflater.from(getContext())
                    .inflate(R.layout.template_text_view_group, null);
            tv.setText(s.substring(0, s.length() - 3));
            if (tv.getText().length() > 0) mView.addView(tv, mLayout);
        }
    }


    public void setFocus(Context context) {
        if (mWidgets.size() > 0) {
            mWidgets.get(0).setFocus(context);
        }
    }


    /**
     * Called when another activity returns information to answer this question.
     *
     * @param answer
     */
    public void setBinaryData(Object answer) {
        boolean set = false;
        for (QuestionWidget q : mWidgets) {
            if (q instanceof IBinaryWidget) {
                if (((IBinaryWidget) q).isWaitingForBinaryData()) {
                    try {
                        ((IBinaryWidget) q).setBinaryData(answer);
                    } catch (Exception e) {
                        Log.e(t, e.getMessage(), e);
                        Toast.makeText(getContext(), getContext().getString(R.string.error_attaching_binary_file, e.getMessage()), Toast.LENGTH_LONG).show();
                    }
                    set = true;
                    break;
                }
            }
        }

        if (!set) {
            Log.w(t, "Attempting to return data to a widget or set of widgets not looking for data");
        }
    }

    public void setDataForFields(Bundle bundle) throws JavaRosaException {
        if (bundle == null) {
            return;
        }
        FormController formController = Collect.getInstance().getFormController();
        Set<String> keys = bundle.keySet();
        for (String key : keys) {
            for (QuestionWidget questionWidget : mWidgets) {
                FormEntryPrompt prompt = questionWidget.getPrompt();
                TreeReference treeReference = (TreeReference) prompt.getFormElement().getBind().getReference();
                if (treeReference.getNameLast().equals(key)) {

                    switch (prompt.getDataType()) {
                        case Constants.DATATYPE_TEXT:
                            formController.saveAnswer(prompt.getIndex(), ExternalAppsUtils.asStringData(bundle.get(key)));
                            break;
                        case Constants.DATATYPE_INTEGER:
                            formController.saveAnswer(prompt.getIndex(), ExternalAppsUtils.asIntegerData(bundle.get(key)));
                            break;
                        case Constants.DATATYPE_DECIMAL:
                            formController.saveAnswer(prompt.getIndex(), ExternalAppsUtils.asDecimalData(bundle.get(key)));
                            break;
                        default:
                            throw new RuntimeException(getContext().getString(R.string.ext_assign_value_error, treeReference.toString(false)));
                    }

                    break;
                }
            }
        }
    }

    public void cancelWaitingForBinaryData() {
        int count = 0;
        for (QuestionWidget q : mWidgets) {
            if (q instanceof IBinaryWidget) {
                if (((IBinaryWidget) q).isWaitingForBinaryData()) {
                    ((IBinaryWidget) q).cancelWaitingForBinaryData();
                    ++count;
                }
            }
        }

        if (count != 1) {
            Log.w(t, "Attempting to cancel waiting for binary data to a widget or set of widgets not looking for data");
        }
    }

    public boolean suppressFlingGesture(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
        for (QuestionWidget q : mWidgets) {
        	if ( q.suppressFlingGesture(e1, e2, velocityX, velocityY) ) {
        		return true;
        	}
        }
        return false;
    }

    /**
     * @return true if the answer was cleared, false otherwise.
     */
    public boolean clearAnswer() {
        // If there's only one widget, clear the answer.
        // If there are more, then force a long-press to clear the answer.
        if (mWidgets.size() == 1 && !mWidgets.get(0).getPrompt().isReadOnly()) {
            mWidgets.get(0).clearAnswer();
            return true;
        } else {
            return false;
        }
    }


    public ArrayList<QuestionWidget> getWidgets() {
        return mWidgets;
    }


    @Override
    public void setOnFocusChangeListener(OnFocusChangeListener l) {
        for (int i = 0; i < mWidgets.size(); i++) {
            QuestionWidget qw = mWidgets.get(i);
            qw.setOnFocusChangeListener(l);
        }
    }

    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        for (QuestionWidget qw : mWidgets) {
            qw.cancelLongPress();
        }
    }
}

/*
 * Copyright (C) 2013 University of Washington
 *
 * http://creativecommons.org/licenses/by-sa/3.0/ -- code is based upon an answer on Stack Overflow:
 * http://stackoverflow.com/questions/8481844/gridview-height-gets-cut
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.views;

import android.content.Context;
import android.util.AttributeSet;
import android.view.ViewGroup;
import android.widget.GridView;

/**
 * From Stack Overflow: http://stackoverflow.com/questions/8481844/gridview-height-gets-cut
 * Changed to always be expanded, since widgets are always embedded in a scroll view.
 *
 * @author tacone based on answer by Neil Traft
 * @author mitchellsundt@gmail.com
 *
 */
public class ExpandedHeightGridView extends GridView
{

    public ExpandedHeightGridView(Context context)
    {
        super(context);
    }

    public ExpandedHeightGridView(Context context, AttributeSet attrs)
    {
        super(context, attrs);
    }

    public ExpandedHeightGridView(Context context, AttributeSet attrs,
            int defStyle)
    {
        super(context, attrs, defStyle);
    }

    @Override
    public void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
    {
        // HACK! TAKE THAT ANDROID!
        // Calculate entire height by providing a very large height hint.
        // But do not use the highest 2 bits of this integer; those are
        // reserved for the MeasureSpec mode.
        int expandSpec = MeasureSpec.makeMeasureSpec(
                Integer.MAX_VALUE >> 2, MeasureSpec.AT_MOST);
        super.onMeasure(widthMeasureSpec, expandSpec);

        ViewGroup.LayoutParams params = getLayoutParams();
        params.height = getMeasuredHeight();
    }
}

/*
 * Copyright (C) 2011 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.views;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.media.MediaPlayer;
import android.media.MediaPlayer.OnCompletionListener;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ImageButton;
import android.widget.Toast;

import org.javarosa.core.model.FormIndex;
import org.javarosa.core.reference.InvalidReferenceException;
import org.javarosa.core.reference.ReferenceManager;
import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;

import java.io.File;
import java.io.IOException;

/**
 * @author ctsims
 * @author carlhartung
 */
public class AudioButton extends ImageButton implements OnClickListener {
    private final static String t = "AudioButton";

    /**
     * Useful class for handling the playing and stopping of audio prompts.
     * This is used here, and also in the GridMultiWidget and GridWidget
     * to play prompts as items are selected.
     * 
     * @author mitchellsundt@gmail.com
     *
     */
    public static class AudioHandler {
        private FormIndex index;
        private String selectionDesignator;
        private String URI;
        private MediaPlayer player;

        public AudioHandler(FormIndex index, String selectionDesignator, String URI) {
            this.index = index;
            this.selectionDesignator = selectionDesignator;
            this.URI = URI;
            player = null;
        }
        public void playAudio(Context c) {
        	Collect.getInstance().getActivityLogger().logInstanceAction(this, "onClick.playAudioPrompt", selectionDesignator, index);
            if (URI == null) {
                // No audio file specified
                Log.e(t, "No audio file was specified");
                Toast.makeText(c, c.getString(R.string.audio_file_error),
                    Toast.LENGTH_LONG).show();
                return;
            }

            String audioFilename = "";
            try {
                audioFilename = ReferenceManager._().DeriveReference(URI).getLocalURI();
            } catch (InvalidReferenceException e) {
                Log.e(t, "Invalid reference exception");
                e.printStackTrace();
            }

            File audioFile = new File(audioFilename);
            if (!audioFile.exists()) {
                // We should have an audio clip, but the file doesn't exist.
                String errorMsg = c.getString(R.string.file_missing, audioFile);
                Log.e(t, errorMsg);
                Toast.makeText(c, errorMsg, Toast.LENGTH_LONG).show();
                return;
            }

            // In case we're currently playing sounds.
            stopPlaying();

            player = new MediaPlayer();
            try {
                player.setDataSource(audioFilename);
                player.prepare();
                player.start();
                player.setOnCompletionListener(new OnCompletionListener() {
                    @Override
                    public void onCompletion(MediaPlayer mediaPlayer) {
                        mediaPlayer.release();
                    }

                });
            } catch (IOException e) {
                String errorMsg = c.getString(R.string.audio_file_invalid);
                Log.e(t, errorMsg);
                Toast.makeText(c, errorMsg, Toast.LENGTH_LONG).show();
                e.printStackTrace();
            }
        	
        }

        public void stopPlaying() {
            if (player != null) {
                player.release();
            }
        }
    }

    AudioHandler handler; 
    
    public AudioButton(Context context, FormIndex index, String selectionDesignator, String URI) {
        super(context);
        this.setOnClickListener(this);
        handler = new AudioHandler( index, selectionDesignator, URI);
        Bitmap b =
            BitmapFactory.decodeResource(context.getResources(),
                android.R.drawable.ic_lock_silent_mode_off);
        this.setImageBitmap(b);
    }

    public void playAudio() {
    	handler.playAudio(getContext());
    }

    @Override
    public void onClick(View v) {
    	playAudio();
    }


    public void stopPlaying() {
        handler.stopPlaying();
    }
}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.exception;

/**
 *
 * Author: Meletis Margaritis
 * Date: 30/09/13
 * Time: 11:39
 */
public class EncryptionException extends Exception {

    public EncryptionException(String detailMessage, Throwable throwable) {
        super(detailMessage, throwable);
    }
}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.exception;

/**
 * Author: Meletis Margaritis
 * Date: 01/05/13
 * Time: 10:57
 */
public class ExternalDataException extends RuntimeException {

    public ExternalDataException(String detailMessage) {
        super(detailMessage);
    }

    public ExternalDataException(String detailMessage, Throwable throwable) {
        super(detailMessage, throwable);
    }
}

package org.odk.collect.android.exception;

public class FormException extends Exception {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	
	public FormException (String msg) {
		super(msg);
	}

}

package org.odk.collect.android.exception;

public class GeoPointNotFoundException extends Exception {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	
	public GeoPointNotFoundException (String msg) {
		super(msg);
	}

}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.exception;

/**
 * Author: Meletis Margaritis
 * Date: 16/5/2013
 * Time: 2:15 
 */
public class InvalidSyntaxException extends RuntimeException {

    public InvalidSyntaxException(String detailMessage) {
        super(detailMessage);
    }

    public InvalidSyntaxException(String detailMessage, Throwable throwable) {
        super(detailMessage, throwable);
    }
}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.exception;

/**
 *
 * Author: Meletis Margaritis
 * Date: 30/07/13
 * Time: 12:27
 */
public class ExternalParamsException extends Exception {

    public ExternalParamsException(String detailMessage, Throwable throwable) {
        super(detailMessage, throwable);
    }
}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.exception;

/**
 * This exception wraps all exceptions that come from JR.
 *
 * Author: Meletis Margaritis
 * Date: 2/13/14
 * Time: 11:39 AM
 */
public class JavaRosaException extends Exception {

    public JavaRosaException(Throwable throwable) {
        super(throwable.getMessage() == null ? throwable.getClass().getSimpleName() : throwable.getMessage(), throwable);
    }
}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.exception;

import java.io.File;

/**
 * Author: Meletis Margaritis
 * Date: 3/6/2013
 * Time: 11:57 
 */
public class TaskCancelledException extends Exception {

    private File file;

    public TaskCancelledException(File file, String detailMessage) {
        super(detailMessage);
        this.file = file;
    }

    public File getFile() {
        return file;
    }
}

/*
 * Copyright (C) 2009 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.listeners;

import org.odk.collect.android.logic.FormDetails;

import java.util.HashMap;

/**
 * @author Carl Hartung (carlhartung@gmail.com)
 */
public interface FormListDownloaderListener {
    void formListDownloadingComplete(HashMap<String, FormDetails> value);
}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.listeners;

import android.net.Uri;

import java.util.HashMap;

/**
 * @author Carl Hartung (carlhartung@gmail.com)
 */
public interface InstanceUploaderListener {
    void uploadingComplete(HashMap<String, String> result);
    void progressUpdate(int progress, int total);
    void authRequest(Uri url, HashMap<String, String> doneSoFar);
}

/*
 * Copyright (C) 2012 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.listeners;

/**
 * Callback interface invoked upon the completion of a DeleteInstancesTask
 *  
 * @author norman86@gmail.com
 * @author mitchellsundt@gmail.com
 */
public interface DeleteInstancesListener {
	void deleteComplete(int deletedInstances);
}

/*
 * Copyright (C) 2012 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.listeners;

/**
 * Callback interface invoked upon completion of a DeleteFormsTask
 * 
 * @author norman86@gmail.com
 * @author mitchellsundt@gmail.com
 */
public interface DeleteFormsListener {
	void deleteComplete(int deletedForms);
}

/*
 * Copyright (C) 2012 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.listeners;

import java.util.HashMap;

/**
 */
public interface GoogleDriveFormDownloadListener {
	void formDownloadComplete(HashMap<String, Object> results);
}

/*
 * Copyright (C) 2012 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.listeners;

import java.util.HashMap;

/**
 */
public interface TaskListener {
	void taskComplete(HashMap<String, Object> results);
}

/*
 * Copyright (C) 2009 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.listeners;

import org.odk.collect.android.logic.FormDetails;

import java.util.HashMap;


/**
 * @author Carl Hartung (carlhartung@gmail.com)
 */
public interface FormDownloaderListener {
    void formsDownloadingComplete(HashMap<FormDetails, String> result);
    void progressUpdate(String currentFile, int progress, int total);
}

/*
 * Copyright (C) 2009 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.listeners;

import org.odk.collect.android.tasks.ProgressNotifier;
import org.odk.collect.android.tasks.SaveResult;

/**
 * @author Carl Hartung (carlhartung@gmail.com)
 */
public interface FormSavedListener extends ProgressNotifier {
    void savingComplete(SaveResult saveStatus);
}

/*
 * Copyright (C) 2009 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.listeners;

import org.odk.collect.android.tasks.FormLoaderTask;
import org.odk.collect.android.tasks.ProgressNotifier;

/**
 * @author Carl Hartung (carlhartung@gmail.com)
 */
public interface FormLoaderListener extends ProgressNotifier {
    void loadingComplete(FormLoaderTask task);
    void loadingError(String errorMsg);
}

/*
 * Copyright (C) 2014 University of Washington
 *
 * Originally developed by Dobility, Inc. (as part of SurveyCTO)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.listeners;

/**
 *
 * Author: Meletis Margaritis
 * Date: 27/6/2013
 * Time: 7:15 
 */
public interface SavePointListener {

    void onSavePointError(String errorMessage);
}

/*
 * Copyright (C) 2009 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.listeners;


/**
 * @author Carl Hartung (carlhartung@gmail.com)
 */
public interface DiskSyncListener {
    void SyncComplete(String result);
}

/*
 * Copyright (C) 2011 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.listeners;

public interface AdvanceToNextListener {

        void advance(); //Move on to the next question
}
/*
 * Copyright (C) 2011 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.util.Log;
import android.util.TypedValue;
import android.view.Display;
import android.view.Gravity;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.view.inputmethod.InputMethodManager;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.BaseAdapter;
import android.widget.GridView;
import android.widget.ImageView;
import android.widget.ImageView.ScaleType;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.TextView;

import org.javarosa.core.model.SelectChoice;
import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.SelectMultiData;
import org.javarosa.core.model.data.helper.Selection;
import org.javarosa.core.reference.InvalidReferenceException;
import org.javarosa.core.reference.ReferenceManager;
import org.javarosa.form.api.FormEntryCaption;
import org.javarosa.form.api.FormEntryPrompt;
import org.javarosa.xpath.expr.XPathFuncExpr;
import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.external.ExternalDataUtil;
import org.odk.collect.android.external.ExternalSelectChoice;
import org.odk.collect.android.utilities.FileUtils;
import org.odk.collect.android.views.AudioButton.AudioHandler;
import org.odk.collect.android.views.ExpandedHeightGridView;

import java.io.File;
import java.util.Vector;

/**
 * GridWidget handles multiple selection fields using a grid of icons. The user clicks the desired
 * icon and the background changes from black to orange. If text, audio or video are specified in
 * the select answers they are ignored. This is almost identical to GridWidget, except multiple
 * icons can be selected simultaneously.
 *
 * @author Jeff Beorse (jeff@beorse.net)
 */
public class GridMultiWidget extends QuestionWidget {

    // The RGB value for the orange background
    public static final int orangeRedVal = 255;
    public static final int orangeGreenVal = 140;
    public static final int orangeBlueVal = 0;

    private static final int HORIZONTAL_PADDING = 7;
    private static final int VERTICAL_PADDING = 5;
    private static final int SPACING = 2;
    private static final int IMAGE_PADDING = 8;
    private static final int SCROLL_WIDTH = 16;

    Vector<SelectChoice> mItems;

    // The possible select choices
    String[] choices;

    // The Gridview that will hold the icons
    ExpandedHeightGridView gridview;

    // Defines which icon is selected
    boolean[] selected;

    // The image views for each of the icons
    View[] imageViews;
    AudioHandler[] audioHandlers;

    // need to remember the last click position for audio treatment
    int lastClickPosition = 0;

    // The number of columns in the grid, can be user defined (<= 0 if unspecified)
    int numColumns;

    int resizeWidth;

    @SuppressWarnings("unchecked")
    public GridMultiWidget(Context context, FormEntryPrompt prompt, int numColumns) {
        super(context, prompt);

        // SurveyCTO-added support for dynamic select content (from .csv files)
        XPathFuncExpr xPathFuncExpr = ExternalDataUtil.getSearchXPathExpression(prompt.getAppearanceHint());
        if (xPathFuncExpr != null) {
            mItems = ExternalDataUtil.populateExternalChoices(prompt, xPathFuncExpr);
        } else {
            mItems = prompt.getSelectChoices();
        }
        mPrompt = prompt;

        selected = new boolean[mItems.size()];
        choices = new String[mItems.size()];
        gridview = new ExpandedHeightGridView(context);
        imageViews = new View[mItems.size()];
        audioHandlers = new AudioHandler[mItems.size()];
        // The max width of an icon in a given column. Used to line
        // up the columns and automatically fit the columns in when
        // they are chosen automatically
        int maxColumnWidth = -1;
        int maxCellHeight = -1;
        this.numColumns = numColumns;
        for (int i = 0; i < mItems.size(); i++) {
            imageViews[i] = new ImageView(getContext());
        }

        Display display =
                ((WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE))
                        .getDefaultDisplay();
        int screenWidth = display.getWidth();
        int screenHeight = display.getHeight();

        if ( display.getOrientation() % 2 == 1 ) {
        	// rotated 90 degrees...
        	int temp = screenWidth;
        	screenWidth = screenHeight;
        	screenHeight = temp;
        }

        if ( numColumns > 0 ) {
        	resizeWidth = ((screenWidth - 2*HORIZONTAL_PADDING - SCROLL_WIDTH - (IMAGE_PADDING+SPACING)*numColumns) / numColumns );
        }

        // Build view
        for (int i = 0; i < mItems.size(); i++) {
            SelectChoice sc = mItems.get(i);

            int curHeight = -1;

            // Create an audioHandler iff there is an audio prompt associated with this selection.
            String audioURI =
            		prompt.getSpecialFormSelectChoiceText(sc, FormEntryCaption.TEXT_FORM_AUDIO);
            if ( audioURI != null) {
            	audioHandlers[i] = new AudioHandler(prompt.getIndex(), sc.getValue(), audioURI);
            } else {
            	audioHandlers[i] = null;
            }
            // Read the image sizes and set maxColumnWidth. This allows us to make sure all of our
            // columns are going to fit
            String imageURI;
            if (mItems.get(i) instanceof ExternalSelectChoice) {
                imageURI = ((ExternalSelectChoice) sc).getImage();
            } else {
                imageURI = prompt.getSpecialFormSelectChoiceText(sc, FormEntryCaption.TEXT_FORM_IMAGE);
            }

            String errorMsg = null;
            if (imageURI != null) {
                choices[i] = imageURI;

                String imageFilename;
                try {
                	imageFilename = ReferenceManager._().DeriveReference(imageURI).getLocalURI();
                    final File imageFile = new File(imageFilename);
                    if (imageFile.exists()) {
                        Bitmap b =
                            FileUtils
                                    .getBitmapScaledToDisplay(imageFile, screenHeight, screenWidth);
                        if (b != null) {

                            if (b.getWidth() > maxColumnWidth) {
                                maxColumnWidth = b.getWidth();
                            }

                            ImageView imageView = (ImageView) imageViews[i];

                            imageView.setBackgroundColor(Color.WHITE);

	                        if ( numColumns > 0 ) {
	                        	int resizeHeight = (b.getHeight() * resizeWidth) / b.getWidth();
	                        	b = Bitmap.createScaledBitmap(b, resizeWidth, resizeHeight, false);
	                        }

	                        imageView.setPadding(IMAGE_PADDING, IMAGE_PADDING, IMAGE_PADDING, IMAGE_PADDING);
	                        imageView.setImageBitmap(b);
	                        imageView.setLayoutParams(new ListView.LayoutParams(ListView.LayoutParams.WRAP_CONTENT, ListView.LayoutParams.WRAP_CONTENT));
	                        imageView.setScaleType(ScaleType.FIT_XY);

	                        imageView.measure(0, 0);
	                        curHeight = imageView.getMeasuredHeight();
                        } else {
                            // Loading the image failed, so it's likely a bad file.
                            errorMsg = getContext().getString(R.string.file_invalid, imageFile);
                        }
                    } else {
                        // We should have an image, but the file doesn't exist.
                        errorMsg = getContext().getString(R.string.file_missing, imageFile);
                    }
                } catch (InvalidReferenceException e) {
                    Log.e("GridMultiWidget", "image invalid reference exception");
                    e.printStackTrace();
                }
            } else {
            	errorMsg = "";
            }

            if (errorMsg != null) {
                choices[i] = prompt.getSelectChoiceText(sc);

                TextView missingImage = new TextView(getContext());
                missingImage.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
                missingImage.setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);
                missingImage.setPadding(IMAGE_PADDING, IMAGE_PADDING, IMAGE_PADDING, IMAGE_PADDING);

                if ( choices[i] != null && choices[i].length() != 0 ) {
	                missingImage.setText(choices[i]);
                } else {
	                // errorMsg is only set when an error has occurred
	                Log.e("GridMultiWidget", errorMsg);
	                missingImage.setText(errorMsg);
                }

                if ( numColumns > 0 ) {
                	maxColumnWidth = resizeWidth;
                	// force the max width to find the needed height...
                	missingImage.setMaxWidth(resizeWidth);
                	missingImage.measure(MeasureSpec.makeMeasureSpec(resizeWidth, MeasureSpec.EXACTLY), 0);
                    curHeight = missingImage.getMeasuredHeight();
                } else {
                	missingImage.measure(0, 0);
                    int width = missingImage.getMeasuredWidth();
                    if (width > maxColumnWidth) {
                        maxColumnWidth = width;
                    }
                    curHeight = missingImage.getMeasuredHeight();
                }
                imageViews[i] = missingImage;
            }

            // if we get a taller image/text, force all cells to be that height
            // could also set cell heights on a per-row basis if user feedback requests it.
            if ( curHeight > maxCellHeight ) {
            	maxCellHeight = curHeight;
            	for ( int j = 0 ; j < i ; j++ ) {
            		imageViews[j].setMinimumHeight(maxCellHeight);
            	}
            }
            imageViews[i].setMinimumHeight(maxCellHeight);
        }

        // Read the screen dimensions and fit the grid view to them. It is important that the grid
        // knows how far out it can stretch.

        if ( numColumns > 0 ) {
            // gridview.setNumColumns(numColumns);
            gridview.setNumColumns(GridView.AUTO_FIT);
        } else {
        	resizeWidth = maxColumnWidth;
            gridview.setNumColumns(GridView.AUTO_FIT);
        }

    	gridview.setColumnWidth(resizeWidth);

    	gridview.setPadding(HORIZONTAL_PADDING, VERTICAL_PADDING, HORIZONTAL_PADDING, VERTICAL_PADDING);
        gridview.setHorizontalSpacing(SPACING);
        gridview.setVerticalSpacing(SPACING);
        gridview.setGravity(Gravity.CENTER);
        gridview.setScrollContainer(false);
        gridview.setStretchMode(GridView.NO_STRETCH);

        gridview.setOnItemClickListener(new OnItemClickListener() {
            public void onItemClick(AdapterView<?> parent, View v, int position, long id) {
                if (selected[position]) {
                    selected[position] = false;
                	if ( audioHandlers[position] != null) {
                		audioHandlers[position].stopPlaying();
                	}
                    imageViews[position].setBackgroundColor(Color.WHITE);
                   	Collect.getInstance().getActivityLogger().logInstanceAction(this, "onItemClick.deselect",
                			mItems.get(position).getValue(), mPrompt.getIndex());

                } else {
                    selected[position] = true;
                	if ( audioHandlers[lastClickPosition] != null) {
                		audioHandlers[lastClickPosition].stopPlaying();
                	}
                    imageViews[position].setBackgroundColor(Color.rgb(orangeRedVal, orangeGreenVal,
                        orangeBlueVal));
                   	Collect.getInstance().getActivityLogger().logInstanceAction(this, "onItemClick.select",
                			mItems.get(position).getValue(), mPrompt.getIndex());
                	if ( audioHandlers[position] != null) {
                		audioHandlers[position].playAudio(getContext());
                	}
            		lastClickPosition = position;
                }

            }
        });

        // Fill in answer
        IAnswerData answer = prompt.getAnswerValue();
        Vector<Selection> ve;
        if ((answer == null) || (answer.getValue() == null)) {
            ve = new Vector<Selection>();
        } else {
            ve = (Vector<Selection>) answer.getValue();
        }

        for (int i = 0; i < choices.length; ++i) {

            String value = mItems.get(i).getValue();
            boolean found = false;
            for (Selection s : ve) {
                if (value.equals(s.getValue())) {
                    found = true;
                    break;
                }
            }

            selected[i] = found;
            if (selected[i]) {
                imageViews[i].setBackgroundColor(Color.rgb(orangeRedVal, orangeGreenVal,
                    orangeBlueVal));
            } else {
                imageViews[i].setBackgroundColor(Color.WHITE);
            }
        }

        // Use the custom image adapter and initialize the grid view
        ImageAdapter ia = new ImageAdapter(getContext(), choices);
        gridview.setAdapter(ia);
        addView(gridview,  new LinearLayout.LayoutParams(LinearLayout.LayoutParams.FILL_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT));
    }


    @Override
    public IAnswerData getAnswer() {
        Vector<Selection> vc = new Vector<Selection>();
        for (int i = 0; i < mItems.size(); i++) {
            if (selected[i]) {
                SelectChoice sc = mItems.get(i);
                vc.add(new Selection(sc));
            }
        }

        if (vc.size() == 0) {
            return null;
        } else {
            return new SelectMultiData(vc);
        }
    }


    @Override
    public void clearAnswer() {
        for (int i = 0; i < mItems.size(); ++i) {
            selected[i] = false;
            imageViews[i].setBackgroundColor(Color.WHITE);
        }

    }


    @Override
    public void setFocus(Context context) {
        // Hide the soft keyboard if it's showing.
        InputMethodManager inputManager =
            (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
        inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);

    }

    // Custom image adapter. Most of the code is copied from
    // media layout for using a picture.
    private class ImageAdapter extends BaseAdapter {
        private String[] choices;


        public ImageAdapter(Context c, String[] choices) {
            this.choices = choices;
        }


        public int getCount() {
            return choices.length;
        }


        public Object getItem(int position) {
            return null;
        }


        public long getItemId(int position) {
            return 0;
        }


        // create a new ImageView for each item referenced by the Adapter
        public View getView(int position, View convertView, ViewGroup parent) {
           	if ( position < imageViews.length ) {
        		return imageViews[position];
        	} else {
        		return convertView;
        	}
        }
    }


    @Override
    public void setOnLongClickListener(OnLongClickListener l) {
        gridview.setOnLongClickListener(l);
    }


    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        gridview.cancelLongPress();
    }
}

/*
 * Copyright (C) 2013 Nafundi
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.View;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.TableLayout;
import android.widget.TextView;

import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.StringData;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.R;
import org.odk.collect.android.activities.BearingActivity;
import org.odk.collect.android.activities.FormEntryActivity;
import org.odk.collect.android.application.Collect;

/**
 * BearingWidget is the widget that allows the user to get a compass heading.
 * 
 * @author Carl Hartung (chartung@nafundi.com)
 */
public class BearingWidget extends QuestionWidget implements IBinaryWidget {
    private Button mGetBearingButton;
    private TextView mStringAnswer;
    private TextView mAnswerDisplay;

    public BearingWidget(Context context, FormEntryPrompt prompt) {
        super(context, prompt);

        setOrientation(LinearLayout.VERTICAL);

        TableLayout.LayoutParams params = new TableLayout.LayoutParams();
        params.setMargins(7, 5, 7, 5);

        mGetBearingButton = new Button(getContext());
        mGetBearingButton.setId(QuestionWidget.newUniqueId());
        mGetBearingButton.setPadding(20, 20, 20, 20);
        mGetBearingButton.setText(getContext()
                .getString(R.string.get_bearing));
        mGetBearingButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP,
                mAnswerFontsize);
        mGetBearingButton.setEnabled(!prompt.isReadOnly());
        mGetBearingButton.setLayoutParams(params);
        if (prompt.isReadOnly()) {
            mGetBearingButton.setVisibility(View.GONE);
        }

        mStringAnswer = new TextView(getContext());
        mStringAnswer.setId(QuestionWidget.newUniqueId());

        mAnswerDisplay = new TextView(getContext());
        mAnswerDisplay.setId(QuestionWidget.newUniqueId());
        mAnswerDisplay
                .setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
        mAnswerDisplay.setGravity(Gravity.CENTER);

        String s = prompt.getAnswerText();
        if (s != null && !s.equals("")) {
            mGetBearingButton.setText(getContext().getString(
                    R.string.replace_bearing));
            setBinaryData(s);
        }

        // when you press the button
        mGetBearingButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Collect.getInstance()
                        .getActivityLogger()
                        .logInstanceAction(this, "recordBearing", "click",
                                mPrompt.getIndex());
                Intent i = null;
                i = new Intent(getContext(), BearingActivity.class);

                Collect.getInstance().getFormController()
                        .setIndexWaitingForData(mPrompt.getIndex());
                ((Activity) getContext()).startActivityForResult(i,
                        FormEntryActivity.BEARING_CAPTURE);
            }
        });

        addView(mGetBearingButton);
        addView(mAnswerDisplay);
    }

    @Override
    public void clearAnswer() {
        mStringAnswer.setText(null);
        mAnswerDisplay.setText(null);
        mGetBearingButton.setText(getContext()
                .getString(R.string.get_bearing));

    }

    @Override
    public IAnswerData getAnswer() {
        String s = mStringAnswer.getText().toString();
        if (s == null || s.equals("")) {
            return null;
        } else {
            return new StringData(s);
        }
    }

    @Override
    public void setFocus(Context context) {
        // Hide the soft keyboard if it's showing.
        InputMethodManager inputManager = (InputMethodManager) context
                .getSystemService(Context.INPUT_METHOD_SERVICE);
        inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
    }

    @Override
    public void setBinaryData(Object answer) {
        String s = (String) answer;
        mStringAnswer.setText(s);

        mAnswerDisplay.setText(s);
        Collect.getInstance().getFormController().setIndexWaitingForData(null);
    }

    @Override
    public boolean isWaitingForBinaryData() {
        return mPrompt.getIndex().equals(
                Collect.getInstance().getFormController()
                        .getIndexWaitingForData());
    }

    @Override
    public void cancelWaitingForBinaryData() {
        Collect.getInstance().getFormController().setIndexWaitingForData(null);
    }

    @Override
    public void setOnLongClickListener(OnLongClickListener l) {
        mGetBearingButton.setOnLongClickListener(l);
        mStringAnswer.setOnLongClickListener(l);
        mAnswerDisplay.setOnLongClickListener(l);
    }

    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        mGetBearingButton.cancelLongPress();
        mStringAnswer.cancelLongPress();
        mAnswerDisplay.cancelLongPress();
    }

}

/*
 * Copyright (C) 2011 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Typeface;
import android.util.Log;
import android.util.TypedValue;
import android.view.Display;
import android.view.Gravity;
import android.view.WindowManager;
import android.view.inputmethod.InputMethodManager;
import android.widget.ImageView;
import android.widget.ImageView.ScaleType;
import android.widget.LinearLayout;
import android.widget.RelativeLayout;
import android.widget.TextView;

import org.javarosa.core.model.SelectChoice;
import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.reference.InvalidReferenceException;
import org.javarosa.core.reference.ReferenceManager;
import org.javarosa.form.api.FormEntryCaption;
import org.javarosa.form.api.FormEntryPrompt;
import org.javarosa.xpath.expr.XPathFuncExpr;
import org.odk.collect.android.R;
import org.odk.collect.android.external.ExternalDataUtil;
import org.odk.collect.android.external.ExternalSelectChoice;
import org.odk.collect.android.utilities.FileUtils;

import java.io.File;
import java.util.Vector;

/**
 * The Label Widget does not return an answer. The purpose of this widget is to be the top entry in
 * a field-list with a bunch of list widgets below. This widget provides the labels, so that the
 * list widgets can hide their labels and reduce the screen clutter. This class is essentially
 * ListWidget with all the answer generating code removed.
 * 
 * @author Jeff Beorse
 */
public class LabelWidget extends QuestionWidget {
    private static final String t = "LabelWidget";

    LinearLayout buttonLayout;
    LinearLayout questionLayout;
    Vector<SelectChoice> mItems;

    private TextView mQuestionText;
    private TextView mMissingImage;
    private ImageView mImageView;
    private TextView label;


    public LabelWidget(Context context, FormEntryPrompt prompt) {
        super(context, prompt);

        // SurveyCTO-added support for dynamic select content (from .csv files)
        XPathFuncExpr xPathFuncExpr = ExternalDataUtil.getSearchXPathExpression(prompt.getAppearanceHint());
        if (xPathFuncExpr != null) {
            mItems = ExternalDataUtil.populateExternalChoices(prompt, xPathFuncExpr);
        } else {
            mItems = prompt.getSelectChoices();
        }
        mPrompt = prompt;

        buttonLayout = new LinearLayout(context);

        if (mItems != null) {
            for (int i = 0; i < mItems.size(); i++) {

                String imageURI;
                if (mItems.get(i) instanceof ExternalSelectChoice) {
                    imageURI = ((ExternalSelectChoice) mItems.get(i)).getImage();
                } else {
                    imageURI = prompt.getSpecialFormSelectChoiceText(mItems.get(i), FormEntryCaption.TEXT_FORM_IMAGE);
                }

                // build image view (if an image is provided)
                mImageView = null;
                mMissingImage = null;

                final int labelId = QuestionWidget.newUniqueId();

                // Now set up the image view
                String errorMsg = null;
                if (imageURI != null) {
                    try {
                        String imageFilename =
                            ReferenceManager._().DeriveReference(imageURI).getLocalURI();
                        final File imageFile = new File(imageFilename);
                        if (imageFile.exists()) {
                            Bitmap b = null;
                            try {
                                Display display =
                                    ((WindowManager) getContext().getSystemService(
                                        Context.WINDOW_SERVICE)).getDefaultDisplay();
                                int screenWidth = display.getWidth();
                                int screenHeight = display.getHeight();
                                b =
                                    FileUtils.getBitmapScaledToDisplay(imageFile, screenHeight,
                                        screenWidth);
                            } catch (OutOfMemoryError e) {
                                errorMsg = "ERROR: " + e.getMessage();
                            }

                            if (b != null) {
                                mImageView = new ImageView(getContext());
                                mImageView.setPadding(2, 2, 2, 2);
                                mImageView.setAdjustViewBounds(true);
                                mImageView.setImageBitmap(b);
                                mImageView.setId(labelId);
                            } else if (errorMsg == null) {
                                // An error hasn't been logged and loading the image failed, so it's
                                // likely
                                // a bad file.
                                errorMsg = getContext().getString(R.string.file_invalid, imageFile);

                            }
                        } else if (errorMsg == null) {
                            // An error hasn't been logged. We should have an image, but the file
                            // doesn't
                            // exist.
                            errorMsg = getContext().getString(R.string.file_missing, imageFile);
                        }

                        if (errorMsg != null) {
                            // errorMsg is only set when an error has occured
                            Log.e(t, errorMsg);
                            mMissingImage = new TextView(getContext());
                            mMissingImage.setText(errorMsg);

                            mMissingImage.setPadding(2, 2, 2, 2);
                            mMissingImage.setId(labelId);
                        }
                    } catch (InvalidReferenceException e) {
                        Log.e(t, "image invalid reference exception");
                        e.printStackTrace();
                    }
                } else {
                    // There's no imageURI listed, so just ignore it.
                }

                // build text label. Don't assign the text to the built in label to he
                // button because it aligns horizontally, and we want the label on top
                label = new TextView(getContext());
                label.setText(prompt.getSelectChoiceText(mItems.get(i)));
                label.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mQuestionFontsize);
                label.setGravity(Gravity.CENTER_HORIZONTAL);

                // answer layout holds the label text/image on top and the radio button on bottom
                RelativeLayout answer = new RelativeLayout(getContext());
                RelativeLayout.LayoutParams headerParams =
                        new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
                headerParams.addRule(RelativeLayout.ALIGN_PARENT_TOP);
                headerParams.addRule(RelativeLayout.CENTER_HORIZONTAL);
                
                if (mImageView != null) {
                	mImageView.setScaleType(ScaleType.CENTER);
                    answer.addView(mImageView, headerParams);
                } else if (mMissingImage != null) {
                    answer.addView(mMissingImage, headerParams);
                } else {
                	label.setId(labelId);
                    answer.addView(label, headerParams);
                }
                answer.setPadding(4, 0, 4, 0);

                // Each button gets equal weight
                LinearLayout.LayoutParams answerParams =
                    new LinearLayout.LayoutParams(LayoutParams.FILL_PARENT,
                            LayoutParams.WRAP_CONTENT);
                answerParams.weight = 1;

                buttonLayout.addView(answer, answerParams);

            }
        }

        // Align the buttons so that they appear horizonally and are right justified
        // buttonLayout.setGravity(Gravity.RIGHT);
        buttonLayout.setOrientation(LinearLayout.HORIZONTAL);
        // LinearLayout.LayoutParams params = new
        // LinearLayout.LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT);
        // buttonLayout.setLayoutParams(params);

        // The buttons take up the right half of the screen
        LinearLayout.LayoutParams buttonParams =
            new LinearLayout.LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT);
        buttonParams.weight = 1;

        questionLayout.addView(buttonLayout, buttonParams);
        addView(questionLayout);

    }


    @Override
    public void clearAnswer() {
        // Do nothing, no answers to clear
    }


    @Override
    public IAnswerData getAnswer() {
        return null;
    }


    @Override
    public void setFocus(Context context) {
        // Hide the soft keyboard if it's showing.
        InputMethodManager inputManager =
            (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
        inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
    }


    // Override QuestionWidget's add question text. Build it the same
    // but add it to the relative layout
    protected void addQuestionText(FormEntryPrompt p) {

        // Add the text view. Textview always exists, regardless of whether there's text.
        mQuestionText = new TextView(getContext());
        mQuestionText.setText(p.getLongText());
        mQuestionText.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mQuestionFontsize);
        mQuestionText.setTypeface(null, Typeface.BOLD);
        mQuestionText.setPadding(0, 0, 0, 7);
        mQuestionText.setId(QuestionWidget.newUniqueId()); // assign random id

        // Wrap to the size of the parent view
        mQuestionText.setHorizontallyScrolling(false);

        if (p.getLongText() == null) {
            mQuestionText.setVisibility(GONE);
        }

        // Put the question text on the left half of the screen
        LinearLayout.LayoutParams labelParams =
            new LinearLayout.LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT);
        labelParams.weight = 1;

        questionLayout = new LinearLayout(getContext());
        questionLayout.setOrientation(LinearLayout.HORIZONTAL);

        questionLayout.addView(mQuestionText, labelParams);
    }


    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        mQuestionText.cancelLongPress();

        if (mMissingImage != null) {
            mMissingImage.cancelLongPress();
        }
        if (mImageView != null) {
            mImageView.cancelLongPress();
        }
        if (label != null) {
            label.cancelLongPress();
        }
    }


    @Override
    public void setOnLongClickListener(OnLongClickListener l) {
        mQuestionText.setOnLongClickListener(l);
        if (mMissingImage != null) {
            mMissingImage.setOnLongClickListener(l);
        }
        if (mImageView != null) {
            mImageView.setOnLongClickListener(l);
        }
        if (label != null) {
            label.setOnLongClickListener(l);
        }
    }

}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.annotation.SuppressLint;
import android.content.Context;
import android.os.Build;
import android.view.Gravity;
import android.view.View;
import android.view.inputmethod.InputMethodManager;
import android.widget.CalendarView;
import android.widget.DatePicker;
import android.widget.HorizontalScrollView;
import android.widget.LinearLayout;
import android.widget.TimePicker;

import org.javarosa.core.model.data.DateTimeData;
import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.form.api.FormEntryPrompt;
import org.joda.time.DateTime;
import org.odk.collect.android.application.Collect;

import java.lang.reflect.Field;
import java.util.Calendar;
import java.util.Date;

/**
 * Displays a DatePicker widget. DateWidget handles leap years and does not allow dates that do not
 * exist.
 *
 * @author Carl Hartung (carlhartung@gmail.com)
 * @author Yaw Anokwa (yanokwa@gmail.com)
 */
public class DateTimeWidget extends QuestionWidget {

    private DatePicker mDatePicker;
    private TimePicker mTimePicker;
    private DatePicker.OnDateChangedListener mDateListener;
    private boolean hideDay = false;
    private boolean hideMonth = false;
    private boolean showCalendar = false;
	private HorizontalScrollView scrollView = null;
	private boolean changed = false;

    public DateTimeWidget(Context context, FormEntryPrompt prompt) {
        super(context, prompt);

        mDatePicker = new DatePicker(getContext());
        mDatePicker.setId(QuestionWidget.newUniqueId());
        mDatePicker.setFocusable(!prompt.isReadOnly());
        mDatePicker.setEnabled(!prompt.isReadOnly());

        mTimePicker = new TimePicker(getContext());
        mTimePicker.setId(QuestionWidget.newUniqueId());
        mTimePicker.setFocusable(!prompt.isReadOnly());
        mTimePicker.setEnabled(!prompt.isReadOnly());

        String clockType =
            android.provider.Settings.System.getString(context.getContentResolver(),
                android.provider.Settings.System.TIME_12_24);
        if (clockType == null || clockType.equalsIgnoreCase("24")) {
            mTimePicker.setIs24HourView(true);
        }

        hideDayFieldIfNotInFormat(prompt);

        mDateListener = new DatePicker.OnDateChangedListener() {
            @Override
            public void onDateChanged(DatePicker view, int year, int month, int day) {
                changed = true;
                if (mPrompt.isReadOnly()) {
                    setAnswer();
                } else {
                    // handle leap years and number of days in month
                    // TODO
                    // http://code.google.com/p/android/issues/detail?id=2081
                	// in older versions of android (1.6ish) the datepicker lets you pick bad dates
                    // in newer versions, calling updateDate() calls onDatechangedListener(), causing an
                    // endless loop.
                    Calendar c = Calendar.getInstance();
                    c.set(year, month, 1);
                    int max = c.getActualMaximum(Calendar.DAY_OF_MONTH);
                    if (day > max) {
                        if (! (mDatePicker.getDayOfMonth()==day && mDatePicker.getMonth()==month && mDatePicker.getYear()==year) ) {
                        	Collect.getInstance().getActivityLogger().logInstanceAction(DateTimeWidget.this, "onDateChanged",
                        			String.format("%1$04d-%2$02d-%3$02d",year, month, max), mPrompt.getIndex());
                            mDatePicker.updateDate(year, month, max);
                        }
                    } else {
                        if (! (mDatePicker.getDayOfMonth()==day && mDatePicker.getMonth()==month && mDatePicker.getYear()==year) ) {
                        	Collect.getInstance().getActivityLogger().logInstanceAction(DateTimeWidget.this, "onDateChanged",
                        			String.format("%1$04d-%2$02d-%3$02d",year, month, day), mPrompt.getIndex());
                            mDatePicker.updateDate(year, month, day);
                        }
                    }
                }
            }
        };

        mTimePicker.setOnTimeChangedListener(new TimePicker.OnTimeChangedListener() {
			@Override
			public void onTimeChanged(TimePicker view, int hourOfDay, int minute) {
                changed = true;
            	Collect.getInstance().getActivityLogger().logInstanceAction(DateTimeWidget.this, "onTimeChanged",
            			String.format("%1$02d:%2$02d",hourOfDay, minute), mPrompt.getIndex());
			}
		});

        setGravity(Gravity.LEFT);
        if ( showCalendar ) {
        	scrollView = new HorizontalScrollView(context);
        	LinearLayout ll = new LinearLayout(context);
            ll.setGravity(Gravity.CENTER);
        	ll.addView(mDatePicker);
            ll.addView(mTimePicker);
        	ll.setPadding(10, 10, 10, 10);
        	scrollView.addView(ll);
        	addView(scrollView);
        } else {
        	addView(mDatePicker);
            addView(mTimePicker);
        }

        // If there's an answer, use it.
        setAnswer();
    }

    /**
     * Shared between DateWidget and DateTimeWidget.
     * There are extra appearance settings that do not apply for dateTime...
     * TODO: move this into utilities or base class?
     *
     * @param prompt
     */
	@SuppressLint("NewApi")
	private void hideDayFieldIfNotInFormat(FormEntryPrompt prompt) {
        String appearance = prompt.getQuestion().getAppearanceAttr();
        // NOTE(ping): Force no calendar, date and time only.
        appearance = "date-time";

        if ( appearance == null ) {
        	if ( Build.VERSION.SDK_INT >= 11 ) {
        		showCalendar = true;
	        	this.mDatePicker.setCalendarViewShown(true);
	        	if ( Build.VERSION.SDK_INT >= 12 ) {
	        		CalendarView cv = this.mDatePicker.getCalendarView();
		        	cv.setShowWeekNumber(false);
	        	}
	        	this.mDatePicker.setSpinnersShown(true);
	        	hideDay = true;
	        	hideMonth = false;
        	} else {
        		return;
        	}
        } else if ( "month-year".equals(appearance) ) {
        	hideDay = true;
        	if ( Build.VERSION.SDK_INT >= 11 ) {
	        	this.mDatePicker.setCalendarViewShown(false);
	        	this.mDatePicker.setSpinnersShown(true);
        	}
        } else if ( "year".equals(appearance) ) {
        	hideMonth = true;
        	if ( Build.VERSION.SDK_INT >= 11 ) {
	        	this.mDatePicker.setCalendarViewShown(false);
	        	this.mDatePicker.setSpinnersShown(true);
        	}
        } else if ("no-calendar".equals(appearance) ) {
            if (Build.VERSION.SDK_INT >= 11) {
                this.mDatePicker.setCalendarViewShown(false);
                this.mDatePicker.setSpinnersShown(true);
            }
        } else if ("date-time".equals(appearance)) {
            showCalendar = true;
            this.mDatePicker.setCalendarViewShown(false);
            this.mDatePicker.setSpinnersShown(true);
        } else {
            if ( Build.VERSION.SDK_INT >= 11 ) {
                showCalendar = true;
                this.mDatePicker.setCalendarViewShown(true);
                if ( Build.VERSION.SDK_INT >= 12 ) {
                    CalendarView cv = this.mDatePicker.getCalendarView();
                    cv.setShowWeekNumber(false);
                }
                this.mDatePicker.setSpinnersShown(true);
                hideDay = true;
                hideMonth = false;
            }
        }

        if ( hideMonth || hideDay ) {
		    for (Field datePickerDialogField : this.mDatePicker.getClass().getDeclaredFields()) {
		        if ("mDayPicker".equals(datePickerDialogField.getName()) ||
		                "mDaySpinner".equals(datePickerDialogField.getName())) {
		            datePickerDialogField.setAccessible(true);
		            Object dayPicker = new Object();
		            try {
		                dayPicker = datePickerDialogField.get(this.mDatePicker);
		            } catch (Exception e) {
		                e.printStackTrace();
		            }
		            ((View) dayPicker).setVisibility(View.GONE);
		        }
		        if ( hideMonth ) {
			        if ("mMonthPicker".equals(datePickerDialogField.getName()) ||
			                "mMonthSpinner".equals(datePickerDialogField.getName())) {
			            datePickerDialogField.setAccessible(true);
			            Object monthPicker = new Object();
			            try {
			            	monthPicker = datePickerDialogField.get(this.mDatePicker);
			            } catch (Exception e) {
			                e.printStackTrace();
			            }
			            ((View) monthPicker).setVisibility(View.GONE);
			        }
		        }
		    }
        }
    }

    private void setAnswer() {

        if (mPrompt.getAnswerValue() != null) {

            DateTime ldt =
                new DateTime(
                        ((Date) ((DateTimeData) mPrompt.getAnswerValue()).getValue()).getTime());
            mDatePicker.init(ldt.getYear(), ldt.getMonthOfYear() - 1, ldt.getDayOfMonth(),
                mDateListener);
            mTimePicker.setCurrentHour(ldt.getHourOfDay());
            mTimePicker.setCurrentMinute(ldt.getMinuteOfHour());

        } else {
            // create time widget with current time as of right now
            clearAnswer();
        }
    }

    @Override
    public boolean forceSetAnswer(Object answer) {
        if (!(answer instanceof DateTime)) {
            return false;
        }

        DateTime typedAnswer = (DateTime) answer;
        mDatePicker.init(
                typedAnswer.getYear(),
                typedAnswer.getMonthOfYear() - 1,
                typedAnswer.getDayOfMonth(),
                mDateListener);
        mTimePicker.setCurrentHour(typedAnswer.getHourOfDay());
        mTimePicker.setCurrentMinute(typedAnswer.getMinuteOfHour());

        return true;
    }

    /**
     * Resets date to today.
     */
    @Override
    public void clearAnswer() {
        DateTime ldt = new DateTime();
        mDatePicker.init(ldt.getYear(), ldt.getMonthOfYear() - 1, ldt.getDayOfMonth(),
            mDateListener);
        mTimePicker.setCurrentHour(ldt.getHourOfDay());
        mTimePicker.setCurrentMinute(ldt.getMinuteOfHour());
    }


    @Override
    public IAnswerData getAnswer() {
    	if ( showCalendar ) {
    		scrollView.clearChildFocus(mDatePicker);
    	}
    	clearFocus();
        DateTime ldt =
            new DateTime(mDatePicker.getYear(), mDatePicker.getMonth() + 1,
                    mDatePicker.getDayOfMonth(), mTimePicker.getCurrentHour(),
                    mTimePicker.getCurrentMinute(), 0);

        // If the user hasn't touched anything, use the current time.
        // The widget has no seconds, so without this we would be unable
        // to tell which submission occurred later or earlier for two
        // submissions up to a minute apart.
        if (!changed) {
            ldt = DateTime.now();
        }

        //DateTime utc = ldt.withZone(DateTimeZone.forID("UTC"));
        return new DateTimeData(ldt.toDate());
    }


    @Override
    public void setFocus(Context context) {
        // Hide the soft keyboard if it's showing.
        InputMethodManager inputManager =
            (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
        inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
    }


    @Override
    public void setOnLongClickListener(OnLongClickListener l) {
        mDatePicker.setOnLongClickListener(l);
        mTimePicker.setOnLongClickListener(l);
    }


    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        mDatePicker.cancelLongPress();
        mTimePicker.cancelLongPress();
    }

}

/*
 * Copyright (C) 2012 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.graphics.Rect;
import android.net.Uri;
import android.provider.MediaStore.Images;
import android.util.Log;
import android.util.TypedValue;
import android.view.Display;
import android.view.MotionEvent;
import android.view.View;
import android.view.WindowManager;
import android.view.inputmethod.InputMethodManager;
import android.webkit.WebSettings;
import android.webkit.WebView;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.TableLayout;
import android.widget.TextView;
import android.widget.Toast;

import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.StringData;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.R;
import org.odk.collect.android.activities.FormEntryActivity;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.utilities.MediaUtils;

import java.io.File;
import java.util.Date;

/**
 * Widget that allows user to take pictures, sounds or video and add them to the
 * form.
 * 
 * @author Carl Hartung (carlhartung@gmail.com)
 * @author Yaw Anokwa (yanokwa@gmail.com)
 */
public class ImageWebViewWidget extends QuestionWidget implements IBinaryWidget {
	private final static String t = "MediaWidget";

	private Button mCaptureButton;
	private Button mChooseButton;
	private WebView mImageDisplay;

	private String mBinaryName;

	private String mInstanceFolder;

	private TextView mErrorTextView;

	private String constructImageElement() {
		File f = new File(mInstanceFolder + File.separator + mBinaryName);

		Display display = ((WindowManager) getContext().getSystemService(
				Context.WINDOW_SERVICE)).getDefaultDisplay();
		int screenWidth = display.getWidth();
		// int screenHeight = display.getHeight();

		String imgElement = f.exists() ? ("<img align=\"middle\" src=\"file:///"
				+ f.getAbsolutePath()
				+
				// Appending the time stamp to the filename is a hack to prevent
				// caching.
				"?"
				+ new Date().getTime()
				+ "\" width=\""
				+ Integer.toString(screenWidth - 10) + "\" >")
				: "";

		return imgElement;
	}

	public boolean suppressFlingGesture(MotionEvent e1, MotionEvent e2,
			float velocityX, float velocityY) {
		if (mImageDisplay == null
				|| mImageDisplay.getVisibility() != View.VISIBLE) {
			return false;
		}

		Rect rect = new Rect();
		mImageDisplay.getHitRect(rect);

		// Log.i(t, "hitRect: " + rect.left + "," + rect.top + " : " +
		// rect.right + "," + rect.bottom );
		// Log.i(t, "e1 Raw, Clean: " + e1.getRawX() + "," + e1.getRawY() +
		// " : " + e1.getX() + "," + e1.getY());
		// Log.i(t, "e2 Raw, Clean: " + e2.getRawX() + "," + e2.getRawY() +
		// " : " + e2.getX() + "," + e2.getY());

		// starts in WebView
		if (rect.contains((int) e1.getRawX(), (int) e1.getRawY())) {
			return true;
		}

		// ends in WebView
		if (rect.contains((int) e2.getRawX(), (int) e2.getRawY())) {
			return true;
		}

		// transits WebView
		if (rect.contains((int) ((e1.getRawX() + e2.getRawX()) / 2.0),
				(int) ((e1.getRawY() + e2.getRawY()) / 2.0))) {
			return true;
		}
		// Log.i(t, "NOT SUPPRESSED");
		return false;
	}

	public ImageWebViewWidget(Context context, FormEntryPrompt prompt) {
		super(context, prompt);

		mInstanceFolder = Collect.getInstance().getFormController()
				.getInstancePath().getParent();

		setOrientation(LinearLayout.VERTICAL);

		TableLayout.LayoutParams params = new TableLayout.LayoutParams();
		params.setMargins(7, 5, 7, 5);

		mErrorTextView = new TextView(context);
		mErrorTextView.setId(QuestionWidget.newUniqueId());
		mErrorTextView.setText("Selected file is not a valid image");

		// setup capture button
		mCaptureButton = new Button(getContext());
		mCaptureButton.setId(QuestionWidget.newUniqueId());
		mCaptureButton.setText(getContext().getString(R.string.capture_image));
		mCaptureButton
				.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
		mCaptureButton.setPadding(20, 20, 20, 20);
		mCaptureButton.setEnabled(!prompt.isReadOnly());
		mCaptureButton.setLayoutParams(params);

		// launch capture intent on click
		mCaptureButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				Collect.getInstance()
						.getActivityLogger()
						.logInstanceAction(this, "captureButton", "click",
								mPrompt.getIndex());
				mErrorTextView.setVisibility(View.GONE);
				Intent i = new Intent(
						android.provider.MediaStore.ACTION_IMAGE_CAPTURE);
				// We give the camera an absolute filename/path where to put the
				// picture because of bug:
				// http://code.google.com/p/android/issues/detail?id=1480
				// The bug appears to be fixed in Android 2.0+, but as of feb 2,
				// 2010, G1 phones only run 1.6. Without specifying the path the
				// images returned by the camera in 1.6 (and earlier) are ~1/4
				// the size. boo.

				// if this gets modified, the onActivityResult in
				// FormEntyActivity will also need to be updated.
				i.putExtra(android.provider.MediaStore.EXTRA_OUTPUT,
						Uri.fromFile(new File(Collect.getInstance().getTmpFilePath())));
				try {
					Collect.getInstance().getFormController()
							.setIndexWaitingForData(mPrompt.getIndex());
					((Activity) getContext()).startActivityForResult(i,
							FormEntryActivity.IMAGE_CAPTURE);
				} catch (ActivityNotFoundException e) {
					Toast.makeText(
							getContext(),
							getContext().getString(R.string.activity_not_found,
									"image capture"), Toast.LENGTH_SHORT)
							.show();
					Collect.getInstance().getFormController()
							.setIndexWaitingForData(null);
				}

			}
		});

		// setup chooser button
		mChooseButton = new Button(getContext());
		mChooseButton.setId(QuestionWidget.newUniqueId());
		mChooseButton.setText(getContext().getString(R.string.choose_image));
		mChooseButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
		mChooseButton.setPadding(20, 20, 20, 20);
		mChooseButton.setEnabled(!prompt.isReadOnly());
		mChooseButton.setLayoutParams(params);

		// launch capture intent on click
		mChooseButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				Collect.getInstance()
						.getActivityLogger()
						.logInstanceAction(this, "chooseButton", "click",
								mPrompt.getIndex());
				mErrorTextView.setVisibility(View.GONE);
				Intent i = new Intent(Intent.ACTION_GET_CONTENT);
				i.setType("image/*");

				try {
					Collect.getInstance().getFormController()
							.setIndexWaitingForData(mPrompt.getIndex());
					((Activity) getContext()).startActivityForResult(i,
							FormEntryActivity.IMAGE_CHOOSER);
				} catch (ActivityNotFoundException e) {
					Toast.makeText(
							getContext(),
							getContext().getString(R.string.activity_not_found,
									"choose image"), Toast.LENGTH_SHORT).show();
					Collect.getInstance().getFormController()
							.setIndexWaitingForData(null);
				}

			}
		});

		// finish complex layout
		addView(mCaptureButton);
		addView(mChooseButton);
		addView(mErrorTextView);

		// and hide the capture and choose button if read-only
		if (prompt.isReadOnly()) {
			mCaptureButton.setVisibility(View.GONE);
			mChooseButton.setVisibility(View.GONE);
		}
		mErrorTextView.setVisibility(View.GONE);

		// retrieve answer from data model and update ui
		mBinaryName = prompt.getAnswerText();

		// Only add the imageView if the user has taken a picture
		if (mBinaryName != null) {
			mImageDisplay = new WebView(getContext());
			mImageDisplay.setId(QuestionWidget.newUniqueId());
			mImageDisplay.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);
			mImageDisplay.getSettings().setBuiltInZoomControls(true);
			mImageDisplay.getSettings().setDefaultZoom(
					WebSettings.ZoomDensity.FAR);
			mImageDisplay.setVisibility(View.VISIBLE);
			mImageDisplay.setLayoutParams(params);

			// HTML is used to display the image.
			String html = "<body>" + constructImageElement() + "</body>";

			mImageDisplay.loadDataWithBaseURL("file:///" + mInstanceFolder
					+ File.separator, html, "text/html", "utf-8", "");
			addView(mImageDisplay);
		}
	}

    private void deleteMedia() {
        // get the file path and delete the file
    	String name = mBinaryName;
        // clean up variables
    	mBinaryName = null;
    	// delete from media provider
        int del = MediaUtils.deleteImageFileFromMediaProvider(mInstanceFolder + File.separator + name);
        Log.i(t, "Deleted " + del + " rows from media content provider");
    }

	@Override
	public void clearAnswer() {
		// remove the file
		deleteMedia();

		if (mImageDisplay != null) {
			// update HTML to not hold image file reference.
			String html = "<body></body>";
			mImageDisplay.loadDataWithBaseURL("file:///" + mInstanceFolder
					+ File.separator, html, "text/html", "utf-8", "");

			mImageDisplay.setVisibility(View.INVISIBLE);
		}

		mErrorTextView.setVisibility(View.GONE);

		// reset buttons
		mCaptureButton.setText(getContext().getString(R.string.capture_image));
	}

	@Override
	public IAnswerData getAnswer() {
		if (mBinaryName != null) {
			return new StringData(mBinaryName.toString());
		} else {
			return null;
		}
	}

	
    @Override
    public void setBinaryData(Object newImageObj) {
        // you are replacing an answer. delete the previous image using the
        // content provider.
        if (mBinaryName != null) {
            deleteMedia();
        }

        File newImage = (File) newImageObj;
        if (newImage.exists()) {
            // Add the new image to the Media content provider so that the
            // viewing is fast in Android 2.0+
        	ContentValues values = new ContentValues(6);
            values.put(Images.Media.TITLE, newImage.getName());
            values.put(Images.Media.DISPLAY_NAME, newImage.getName());
            values.put(Images.Media.DATE_TAKEN, System.currentTimeMillis());
            values.put(Images.Media.MIME_TYPE, "image/jpeg");
            values.put(Images.Media.DATA, newImage.getAbsolutePath());

            Uri imageURI = getContext().getContentResolver().insert(
            		Images.Media.EXTERNAL_CONTENT_URI, values);
            Log.i(t, "Inserting image returned uri = " + imageURI.toString());

            mBinaryName = newImage.getName();
            Log.i(t, "Setting current answer to " + newImage.getName());
        } else {
            Log.e(t, "NO IMAGE EXISTS at: " + newImage.getAbsolutePath());
        }

    	Collect.getInstance().getFormController().setIndexWaitingForData(null);
    }

	@Override
	public void setFocus(Context context) {
		// Hide the soft keyboard if it's showing.
		InputMethodManager inputManager = (InputMethodManager) context
				.getSystemService(Context.INPUT_METHOD_SERVICE);
		inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
	}

	@Override
	public boolean isWaitingForBinaryData() {
		return mPrompt.getIndex().equals(
				Collect.getInstance().getFormController()
						.getIndexWaitingForData());
	}

	@Override
	public void cancelWaitingForBinaryData() {
		Collect.getInstance().getFormController().setIndexWaitingForData(null);
	}

	@Override
	public void setOnLongClickListener(OnLongClickListener l) {
		mCaptureButton.setOnLongClickListener(l);
		mChooseButton.setOnLongClickListener(l);
	}

	@Override
	public void cancelLongPress() {
		super.cancelLongPress();
		mCaptureButton.cancelLongPress();
		mChooseButton.cancelLongPress();
	}

}

/*
 * Copyright (C) 2009 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.content.Context;
import android.util.TypedValue;
import android.view.inputmethod.InputMethodManager;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.ImageView;
import android.widget.LinearLayout;

import org.javarosa.core.model.SelectChoice;
import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.SelectMultiData;
import org.javarosa.core.model.data.helper.Selection;
import org.javarosa.form.api.FormEntryCaption;
import org.javarosa.form.api.FormEntryPrompt;
import org.javarosa.xpath.expr.XPathFuncExpr;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.external.ExternalDataUtil;
import org.odk.collect.android.external.ExternalSelectChoice;
import org.odk.collect.android.views.MediaLayout;

import java.util.ArrayList;
import java.util.Vector;

/**
 * SelctMultiWidget handles multiple selection fields using checkboxes.
 * 
 * @author Carl Hartung (carlhartung@gmail.com)
 * @author Yaw Anokwa (yanokwa@gmail.com)
 */
public class SelectMultiWidget extends QuestionWidget {
    private boolean mCheckboxInit = true;
    Vector<SelectChoice> mItems;

    private ArrayList<CheckBox> mCheckboxes;


    @SuppressWarnings("unchecked")
    public SelectMultiWidget(Context context, FormEntryPrompt prompt) {
        super(context, prompt);
        mPrompt = prompt;
        mCheckboxes = new ArrayList<CheckBox>();

        // SurveyCTO-added support for dynamic select content (from .csv files)
        XPathFuncExpr xPathFuncExpr = ExternalDataUtil.getSearchXPathExpression(prompt.getAppearanceHint());
        if (xPathFuncExpr != null) {
            mItems = ExternalDataUtil.populateExternalChoices(prompt, xPathFuncExpr);
        } else {
            mItems = prompt.getSelectChoices();
        }

        setOrientation(LinearLayout.VERTICAL);

        Vector<Selection> ve = new Vector<Selection>();
        if (prompt.getAnswerValue() != null) {
            ve = (Vector<Selection>) prompt.getAnswerValue().getValue();
        }

        if (mItems != null) {
            for (int i = 0; i < mItems.size(); i++) {
                // no checkbox group so id by answer + offset
                CheckBox c = new CheckBox(getContext());
                c.setTag(Integer.valueOf(i));
                c.setId(QuestionWidget.newUniqueId());
                c.setText(prompt.getSelectChoiceText(mItems.get(i)));
                c.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
                c.setFocusable(!prompt.isReadOnly());
                c.setEnabled(!prompt.isReadOnly());
                
                for (int vi = 0; vi < ve.size(); vi++) {
                    // match based on value, not key
                    if (mItems.get(i).getValue().equals(ve.elementAt(vi).getValue())) {
                        c.setChecked(true);
                        break;
                    }

                }
                mCheckboxes.add(c);
                // when clicked, check for readonly before toggling
                c.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
                    @Override
                    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
                        if (!mCheckboxInit && mPrompt.isReadOnly()) {
                            if (buttonView.isChecked()) {
                                buttonView.setChecked(false);
                               	Collect.getInstance().getActivityLogger().logInstanceAction(this, "onItemClick.deselect", 
                            			mItems.get((Integer)buttonView.getTag()).getValue(), mPrompt.getIndex());
                            } else {
                                buttonView.setChecked(true);
                               	Collect.getInstance().getActivityLogger().logInstanceAction(this, "onItemClick.select", 
                            			mItems.get((Integer)buttonView.getTag()).getValue(), mPrompt.getIndex());
                            }
                        }
                    }
                });

                String audioURI = null;
                audioURI =
                    prompt.getSpecialFormSelectChoiceText(mItems.get(i),
                        FormEntryCaption.TEXT_FORM_AUDIO);

                String imageURI;
                if (mItems.get(i) instanceof ExternalSelectChoice) {
                    imageURI = ((ExternalSelectChoice) mItems.get(i)).getImage();
                } else {
                    imageURI = prompt.getSpecialFormSelectChoiceText(mItems.get(i), FormEntryCaption.TEXT_FORM_IMAGE);
                }

                String videoURI = null;
                videoURI = prompt.getSpecialFormSelectChoiceText(mItems.get(i), "video");

                String bigImageURI = null;
                bigImageURI = prompt.getSpecialFormSelectChoiceText(mItems.get(i), "big-image");

                MediaLayout mediaLayout = new MediaLayout(getContext());
                mediaLayout.setAVT(prompt.getIndex(), "." + Integer.toString(i), c, audioURI, imageURI, videoURI, bigImageURI);
                addView(mediaLayout);

                // Last, add the dividing line between elements (except for the last element)
                ImageView divider = new ImageView(getContext());
                divider.setBackgroundResource(android.R.drawable.divider_horizontal_bright);
                if (i != mItems.size() - 1) {
                    addView(divider);
                }

            }
        }

        mCheckboxInit = false;

    }


    @Override
    public void clearAnswer() {
    	for ( CheckBox c : mCheckboxes ) {
    		if ( c.isChecked() ) {
    			c.setChecked(false);
    		}
    	}
    }


    @Override
    public IAnswerData getAnswer() {
        Vector<Selection> vc = new Vector<Selection>();
        for ( int i = 0; i < mCheckboxes.size() ; ++i ) {
        	CheckBox c = mCheckboxes.get(i);
        	if ( c.isChecked() ) {
        		vc.add(new Selection(mItems.get(i)));
        	}
        }

        if (vc.size() == 0) {
            return null;
        } else {
            return new SelectMultiData(vc);
        }

    }


    @Override
    public void setFocus(Context context) {
        // Hide the soft keyboard if it's showing.
        InputMethodManager inputManager =
            (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
        inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
    }


    @Override
    public void setOnLongClickListener(OnLongClickListener l) {
        for (CheckBox c : mCheckboxes) {
            c.setOnLongClickListener(l);
        }
    }


    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        for (CheckBox c : mCheckboxes) {
            c.cancelLongPress();
        }
    }

}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.content.Context;
import android.text.Editable;
import android.text.TextWatcher;
import android.text.method.TextKeyListener;
import android.text.method.TextKeyListener.Capitalize;
import android.util.Log;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.inputmethod.InputMethodManager;
import android.widget.EditText;
import android.widget.TableLayout;

import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.StringData;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;

/**
 * The most basic widget that allows for entry of any text.
 *
 * @author Carl Hartung (carlhartung@gmail.com)
 * @author Yaw Anokwa (yanokwa@gmail.com)
 */
public class StringWidget extends QuestionWidget {
	private static final String ROWS = "rows";

    boolean mReadOnly = false;
    protected EditText mAnswer;

    public StringWidget(Context context, FormEntryPrompt prompt, boolean readOnlyOverride) {
    	this(context, prompt, readOnlyOverride, true);
    	setupChangeListener();
    }

    protected StringWidget(Context context, FormEntryPrompt prompt, boolean readOnlyOverride, boolean derived) {
        super(context, prompt);
        mAnswer =
                (EditText) LayoutInflater.from(context).inflate(R.layout.template_edit_text, null);
        mAnswer.setId(QuestionWidget.newUniqueId());
        mReadOnly = prompt.isReadOnly() || readOnlyOverride;

//        mAnswer.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);

//        TableLayout.LayoutParams params = new TableLayout.LayoutParams();
//        params.width = LayoutParams.MATCH_PARENT;
//        params.height = LayoutParams.WRAP_CONTENT;

        /**
         * If a 'rows' attribute is on the input tag, set the minimum number of lines
         * to display in the field to that value.
         *
         * I.e.,
         * <input ref="foo" rows="5">
         *   ...
         * </input>
         *
         * will set the height of the EditText box to 5 rows high.
         */
        String height = prompt.getQuestion().getAdditionalAttribute(null, ROWS);
        if (height == null || height.equals("1")) {
            mAnswer.setSingleLine();
        } else {
            mAnswer.setSingleLine(false);
            mAnswer.setHorizontallyScrolling(false);
        }

        if ( height != null && height.length() != 0 ) {
        	try {
	        	int rows = Integer.valueOf(height);
	        	mAnswer.setMinLines(rows);
	        	mAnswer.setGravity(Gravity.TOP); // to write test starting at the top of the edit area
        	} catch (Exception e) {
        		Log.e(this.getClass().getName(), "Unable to process the rows setting for the answer field: " + e.toString());
        	}
        }

//        params.setMargins(7, 5, 7, 5);
//        mAnswer.setLayoutParams(params);

        // capitalize the first letter of the sentence
        mAnswer.setKeyListener(new TextKeyListener(Capitalize.SENTENCES, false));

        // needed to make long read only text scroll
//        mAnswer.setHorizontallyScrolling(false);
//        mAnswer.setSingleLine(false);

        String s = prompt.getAnswerText();
        if (s != null) {
            mAnswer.setText(s);
        }

        if (mReadOnly) {
            mAnswer.setBackgroundDrawable(null);
            mAnswer.setFocusable(false);
            mAnswer.setClickable(false);
        }

        addView(mAnswer);
    }

    protected void setupChangeListener() {
        mAnswer.addTextChangedListener(new TextWatcher() {
        	private String oldText = "";

			@Override
			public void afterTextChanged(Editable s) {
				if (!s.toString().equals(oldText)) {
					Collect.getInstance().getActivityLogger()
						.logInstanceAction(this, "answerTextChanged", s.toString(),	getPrompt().getIndex());
				}
			}

			@Override
			public void beforeTextChanged(CharSequence s, int start, int count,
					int after) {
				oldText = s.toString();
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before,
					int count) { }
        });
    }

    @Override
    public void clearAnswer() {
        mAnswer.setText(null);
    }


    @Override
    public IAnswerData getAnswer() {
    	clearFocus();
    	String s = mAnswer.getText().toString();
        if (s == null || s.equals("")) {
            return null;
        } else {
            return new StringData(s);
        }
    }


    @Override
    public void setFocus(Context context) {
        // Put focus on text input field and display soft keyboard if appropriate.
        mAnswer.requestFocus();
        InputMethodManager inputManager =
            (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
        if (!mReadOnly) {
            inputManager.showSoftInput(mAnswer, 0);
            /*
             * If you do a multi-question screen after a "add another group" dialog, this won't
             * automatically pop up. It's an Android issue.
             *
             * That is, if I have an edit text in an activity, and pop a dialog, and in that
             * dialog's button's OnClick() I call edittext.requestFocus() and
             * showSoftInput(edittext, 0), showSoftinput() returns false. However, if the edittext
             * is focused before the dialog pops up, everything works fine. great.
             */
        } else {
            inputManager.hideSoftInputFromWindow(mAnswer.getWindowToken(), 0);
        }
    }


    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (event.isAltPressed() == true) {
            return false;
        }
        return super.onKeyDown(keyCode, event);
    }


    @Override
    public void setOnLongClickListener(OnLongClickListener l) {
        mAnswer.setOnLongClickListener(l);
    }


    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        mAnswer.cancelLongPress();
    }

}

/*
 * Copyright (C) 2009 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.content.Context;
import android.content.res.Configuration;
import android.text.InputFilter;
import android.text.InputType;
import android.text.method.DigitsKeyListener;
import android.util.TypedValue;

import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.IntegerData;
import org.javarosa.form.api.FormEntryPrompt;

/**
 * Widget that restricts values to integers.
 * 
 * @author Carl Hartung (carlhartung@gmail.com)
 */
public class IntegerWidget extends StringWidget {

	private Integer getIntegerAnswerValue() {
		IAnswerData dataHolder = mPrompt.getAnswerValue();
		Integer d = null;
        if (dataHolder != null) {
        	Object dataValue = dataHolder.getValue();
        	if ( dataValue != null ) {
        		if (dataValue instanceof Double){
	                d =  Integer.valueOf(((Double) dataValue).intValue());
	            } else {
	                d =  (Integer)dataValue;
	            }
        	}
        }
        return d;
	}

    public IntegerWidget(Context context, FormEntryPrompt prompt, boolean readOnlyOverride) {
        super(context, prompt, readOnlyOverride, true);

        mAnswer.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
        mAnswer.setInputType(InputType.TYPE_NUMBER_FLAG_SIGNED);
//
//        // needed to make long readonly text scroll
//        mAnswer.setHorizontallyScrolling(false);
//        mAnswer.setSingleLine(false);

        // only allows numbers and no periods
        mAnswer.setRawInputType(Configuration.KEYBOARD_12KEY);
        mAnswer.setKeyListener(new DigitsKeyListener(true, false));

        // ints can only hold 2,147,483,648. we allow 999,999,999
        InputFilter[] fa = new InputFilter[1];
        fa[0] = new InputFilter.LengthFilter(9);
        mAnswer.setFilters(fa);

        if (prompt.isReadOnly()) {
            setBackgroundDrawable(null);
            setFocusable(false);
            setClickable(false);
        }

        Integer i = getIntegerAnswerValue();

        if (i != null) {
            mAnswer.setText(i.toString());
        }
        
        setupChangeListener();
    }


    @Override
    public IAnswerData getAnswer() {
    	clearFocus();
    	String s = mAnswer.getText().toString();
        if (s == null || s.equals("")) {
            return null;
        } else {
            try {
                return new IntegerData(Integer.parseInt(s));
            } catch (Exception NumberFormatException) {
                return null;
            }
        }
    }

}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.content.Context;
import android.graphics.Color;
import android.graphics.Typeface;
import android.util.TypedValue;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.inputmethod.InputMethodManager;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemSelectedListener;
import android.widget.ArrayAdapter;
import android.widget.Spinner;
import android.widget.TextView;

import org.javarosa.core.model.SelectChoice;
import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.SelectOneData;
import org.javarosa.core.model.data.helper.Selection;
import org.javarosa.form.api.FormEntryPrompt;
import org.javarosa.xpath.expr.XPathFuncExpr;
import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.external.ExternalDataUtil;
import org.odk.collect.android.utilities.Utils;

import java.util.Vector;

/**
 * SpinnerWidget handles select-one fields. Instead of a list of buttons it uses a spinner, wherein
 * the user clicks a button and the choices pop up in a dialogue box. The goal is to be more
 * compact. If images, audio, or video are specified in the select answers they are ignored.
 *
 * @author Jeff Beorse (jeff@beorse.net)
 */
public class SpinnerWidget extends QuestionWidget {
    Vector<SelectChoice> mItems;
    Spinner spinner;
    String[] choices;
    private static final int BROWN = 0xFF936931;


    public SpinnerWidget(Context context, FormEntryPrompt prompt) {
        super(context, prompt);

        // SurveyCTO-added support for dynamic select content (from .csv files)
        XPathFuncExpr xPathFuncExpr = ExternalDataUtil.getSearchXPathExpression(prompt.getAppearanceHint());
        if (xPathFuncExpr != null) {
            mItems = ExternalDataUtil.populateExternalChoices(prompt, xPathFuncExpr);
        } else {
            mItems = prompt.getSelectChoices();
        }

        spinner = new Spinner(context);
        choices = new String[mItems.size()+1];
        for (int i = 0; i < mItems.size(); i++) {
            choices[i] = prompt.getSelectChoiceText(mItems.get(i));
        }
        choices[mItems.size()] = getContext().getString(R.string.select_one);

        // The spinner requires a custom adapter. It is defined below
        SpinnerAdapter adapter =
            new SpinnerAdapter(getContext(), android.R.layout.simple_spinner_item, choices,
                    TypedValue.COMPLEX_UNIT_DIP, mQuestionFontsize);

        spinner.setAdapter(adapter);
        spinner.setPrompt(Utils.localize(prompt.getQuestionText(), context));
        spinner.setEnabled(!prompt.isReadOnly());
        spinner.setFocusable(!prompt.isReadOnly());

        // Fill in previous answer
        String s = null;
        if (prompt.getAnswerValue() != null) {
            s = ((Selection) prompt.getAnswerValue().getValue()).getValue();
        }

        spinner.setSelection(mItems.size());
        if (s != null) {
            for (int i = 0; i < mItems.size(); ++i) {
                String sMatch = mItems.get(i).getValue();
                if (sMatch.equals(s)) {
                    spinner.setSelection(i);
                }
            }
        }

        spinner.setOnItemSelectedListener(new OnItemSelectedListener() {

			@Override
			public void onItemSelected(AdapterView<?> parent, View view,
					int position, long id) {
				if ( position == mItems.size() ) {
					Collect.getInstance().getActivityLogger().logInstanceAction(this, "onCheckedChanged.clearValue",
		    			"", mPrompt.getIndex());
				} else {
					Collect.getInstance().getActivityLogger().logInstanceAction(this, "onCheckedChanged",
			    			mItems.get(position).getValue(), mPrompt.getIndex());
				}
			}

			@Override
			public void onNothingSelected(AdapterView<?> arg0) {

			}});

        addView(spinner);

    }


    @Override
    public IAnswerData getAnswer() {
    	clearFocus();
        int i = spinner.getSelectedItemPosition();
        if (i == -1 || i == mItems.size()) {
            return null;
        } else {
            SelectChoice sc = mItems.elementAt(i);
            return new SelectOneData(new Selection(sc));
        }
    }


    @Override
    public void clearAnswer() {
        // It seems that spinners cannot return a null answer. This resets the answer
        // to its original value, but it is not null.
        spinner.setSelection(mItems.size());
    }


    @Override
    public void setFocus(Context context) {
        // Hide the soft keyboard if it's showing.
        InputMethodManager inputManager =
            (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
        inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);

    }

    // Defines how to display the select answers
    private class SpinnerAdapter extends ArrayAdapter<String> {
        Context context;
        String[] items = new String[] {};
        int textUnit;
        float textSize;


        public SpinnerAdapter(final Context context, final int textViewResourceId,
                final String[] objects, int textUnit, float textSize) {
            super(context, textViewResourceId, objects);
            this.items = objects;
            this.context = context;
            this.textUnit = textUnit;
            this.textSize = textSize;
        }


        @Override
        // Defines the text view parameters for the drop down list entries
        public View getDropDownView(int position, View convertView, ViewGroup parent) {

            if (convertView == null) {
                LayoutInflater inflater = LayoutInflater.from(context);
                convertView = inflater.inflate(R.layout.custom_spinner_item, parent, false);
            }

            TextView tv = (TextView) convertView.findViewById(android.R.id.text1);
            tv.setTextSize(textUnit, textSize);
            tv.setBackgroundColor(Color.WHITE);
        	tv.setPadding(10, 10, 10, 10); // Are these values OK?
            if (position == items.length-1) {
            	tv.setText(parent.getContext().getString(R.string.clear_answer));
            	tv.setTextColor(BROWN);
        		tv.setTypeface(null, Typeface.NORMAL);
            	if (spinner.getSelectedItemPosition() == position) {
            		tv.setBackgroundColor(Color.LTGRAY);
            	}
            } else {
                tv.setText(items[position]);
                tv.setTextColor(Color.BLACK);
            	tv.setTypeface(null, (spinner.getSelectedItemPosition() == position)
            							? Typeface.BOLD : Typeface.NORMAL);
            }
            return convertView;
        }


        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            if (convertView == null) {
                LayoutInflater inflater = LayoutInflater.from(context);
                convertView = inflater.inflate(android.R.layout.simple_spinner_item, parent, false);
            }

            TextView tv = (TextView) convertView.findViewById(android.R.id.text1);
            tv.setText(items[position]);
            tv.setTextSize(textUnit, textSize);
            tv.setTextColor(Color.BLACK);
        	tv.setTypeface(null, Typeface.BOLD);
            if (position == items.length-1) {
            	tv.setTextColor(BROWN);
            	tv.setTypeface(null, Typeface.NORMAL);
            }
            return convertView;
        }

    }


    @Override
    public void setOnLongClickListener(OnLongClickListener l) {
        spinner.setOnLongClickListener(l);
    }


    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        spinner.cancelLongPress();
    }

}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.annotation.SuppressLint;
import android.content.Context;
import android.os.Build;
import android.view.Gravity;
import android.view.View;
import android.view.inputmethod.InputMethodManager;
import android.widget.CalendarView;
import android.widget.DatePicker;
import android.widget.FrameLayout;
import android.widget.HorizontalScrollView;
import android.widget.LinearLayout;

import org.javarosa.core.model.data.DateData;
import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.form.api.FormEntryPrompt;
import org.joda.time.DateTime;
import org.odk.collect.android.application.Collect;

import java.lang.reflect.Field;
import java.util.Calendar;
import java.util.Date;

/**
 * Displays a DatePicker widget. DateWidget handles leap years and does not allow dates that do not
 * exist.
 *
 * @author Carl Hartung (carlhartung@gmail.com)
 * @author Yaw Anokwa (yanokwa@gmail.com)
 */
public class DateWidget extends QuestionWidget {

    private DatePicker mDatePicker;
    private DatePicker.OnDateChangedListener mDateListener;
    private boolean hideDay = false;
    private boolean hideMonth = false;
    private boolean showCalendar = false;
	private HorizontalScrollView scrollView = null;


    public DateWidget(Context context, FormEntryPrompt prompt) {
        super(context, prompt);

        mDatePicker = new DatePicker(getContext());
        mDatePicker.setId(QuestionWidget.newUniqueId());
        mDatePicker.setFocusable(!prompt.isReadOnly());
        mDatePicker.setEnabled(!prompt.isReadOnly());

        hideDayFieldIfNotInFormat(prompt);

        mDateListener = new DatePicker.OnDateChangedListener() {
            @Override
            public void onDateChanged(DatePicker view, int year, int month, int day) {
                if (mPrompt.isReadOnly()) {
                    setAnswer();
                } else {
                    // TODO support dates <1900 >2100
                    // handle leap years and number of days in month
                    // http://code.google.com/p/android/issues/detail?id=2081
                    Calendar c = Calendar.getInstance();
                    c.set(year, month, 1);
                    int max = c.getActualMaximum(Calendar.DAY_OF_MONTH);
                    // in older versions of android (1.6ish) the datepicker lets you pick bad dates
                    // in newer versions, calling updateDate() calls onDatechangedListener(), causing an
                    // endless loop.
                    if (day > max) {
                        if (! (mDatePicker.getDayOfMonth()==day && mDatePicker.getMonth()==month && mDatePicker.getYear()==year) ) {
                        	Collect.getInstance().getActivityLogger().logInstanceAction(DateWidget.this, "onDateChanged",
                        			String.format("%1$04d-%2$02d-%3$02d",year, month, max), mPrompt.getIndex());
                            mDatePicker.updateDate(year, month, max);
                        }
                    } else {
                        if (! (mDatePicker.getDayOfMonth()==day && mDatePicker.getMonth()==month && mDatePicker.getYear()==year) ) {
                        	Collect.getInstance().getActivityLogger().logInstanceAction(DateWidget.this, "onDateChanged",
                        			String.format("%1$04d-%2$02d-%3$02d",year, month, day), mPrompt.getIndex());
                            mDatePicker.updateDate(year, month, day);
                        }
                    }
                }
            }
        };

        setGravity(Gravity.LEFT);
        if ( showCalendar ) {
        	scrollView = new HorizontalScrollView(context);
        	LinearLayout ll = new LinearLayout(context);
        	ll.addView(mDatePicker);
        	ll.setPadding(10, 10, 10, 10);
        	scrollView.addView(ll);
        	addView(scrollView);
        } else {
        	addView(mDatePicker);
        }

        // If there's an answer, use it.
        setAnswer();
    }

    /**
     * Shared between DateWidget and DateTimeWidget.
     * There are extra appearance settings that do not apply for dateTime...
     * TODO: move this into utilities or base class?
     *
     * @param prompt
     */
	@SuppressLint("NewApi")
	private void hideDayFieldIfNotInFormat(FormEntryPrompt prompt) {
        String appearance = prompt.getQuestion().getAppearanceAttr();
        if ( appearance == null ) {
//        	if ( Build.VERSION.SDK_INT >= 11 ) {
//        		showCalendar = true;
//	        	this.mDatePicker.setCalendarViewShown(true);
//	        	if ( Build.VERSION.SDK_INT >= 12 ) {
//	        		CalendarView cv = this.mDatePicker.getCalendarView();
//		        	cv.setShowWeekNumber(false);
//	        	}
//	        	this.mDatePicker.setSpinnersShown(true);
//	        	hideDay = true;
//	        	hideMonth = false;
//        	} else {
//        		return;
//        	}
            if ( Build.VERSION.SDK_INT >= 11 ) {
                this.mDatePicker.setCalendarViewShown(false);
                this.mDatePicker.setSpinnersShown(true);
            }
        } else if ( "month-year".equals(appearance) ) {
        	hideDay = true;
        	if ( Build.VERSION.SDK_INT >= 11 ) {
	        	this.mDatePicker.setCalendarViewShown(false);
	        	this.mDatePicker.setSpinnersShown(true);
        	}
        } else if ( "year".equals(appearance) ) {
        	hideMonth = true;
        	if ( Build.VERSION.SDK_INT >= 11 ) {
	        	this.mDatePicker.setCalendarViewShown(false);
	        	this.mDatePicker.setSpinnersShown(true);
        	}
        } else if ("no-calendar".equals(appearance) ) {
        	if ( Build.VERSION.SDK_INT >= 11 ) {
	        	this.mDatePicker.setCalendarViewShown(false);
	        	this.mDatePicker.setSpinnersShown(true);
        	}
        } else {
        	if ( Build.VERSION.SDK_INT >= 11 ) {
        		showCalendar = true;
	        	this.mDatePicker.setCalendarViewShown(true);
	        	if ( Build.VERSION.SDK_INT >= 12 ) {
	        		CalendarView cv = this.mDatePicker.getCalendarView();
	        		cv.setShowWeekNumber(false);
	        	}
	        	this.mDatePicker.setSpinnersShown(true);
	        	hideDay = true;
	        	hideMonth = false;
        	}
        }

        if ( hideMonth || hideDay ) {
		    for (Field datePickerDialogField : this.mDatePicker.getClass().getDeclaredFields()) {
		        if ("mDayPicker".equals(datePickerDialogField.getName()) ||
		                "mDaySpinner".equals(datePickerDialogField.getName())) {
		            datePickerDialogField.setAccessible(true);
		            Object dayPicker = new Object();
		            try {
		                dayPicker = datePickerDialogField.get(this.mDatePicker);
		            } catch (Exception e) {
		                e.printStackTrace();
		            }
		            ((View) dayPicker).setVisibility(View.GONE);
		        }
		        if ( hideMonth ) {
			        if ("mMonthPicker".equals(datePickerDialogField.getName()) ||
			                "mMonthSpinner".equals(datePickerDialogField.getName())) {
			            datePickerDialogField.setAccessible(true);
			            Object monthPicker = new Object();
			            try {
			            	monthPicker = datePickerDialogField.get(this.mDatePicker);
			            } catch (Exception e) {
			                e.printStackTrace();
			            }
			            ((View) monthPicker).setVisibility(View.GONE);
			        }
		        }
		    }
        }
    }

    private void setAnswer() {

        if (mPrompt.getAnswerValue() != null) {
            DateTime ldt =
                new DateTime(((Date) ((DateData) mPrompt.getAnswerValue()).getValue()).getTime());
            mDatePicker.init(ldt.getYear(), ldt.getMonthOfYear() - 1, ldt.getDayOfMonth(),
                mDateListener);
        } else {
            // create date widget with current time as of right now
            clearAnswer();
        }
    }


    /**
     * Resets date to today.
     */
    @Override
    public void clearAnswer() {
        DateTime ldt = new DateTime();
        mDatePicker.init(ldt.getYear(), ldt.getMonthOfYear() - 1, ldt.getDayOfMonth(),
            mDateListener);
    }


    @Override
    public IAnswerData getAnswer() {
    	if ( showCalendar ) {
    		scrollView.clearChildFocus(mDatePicker);
    	}
    	clearFocus();
        DateTime ldt =
            new DateTime(mDatePicker.getYear(), (!showCalendar && hideMonth) ? 1 : mDatePicker.getMonth() + 1,
                    (!showCalendar && (hideMonth || hideDay)) ? 1 : mDatePicker.getDayOfMonth(), 0, 0);
        // DateTime utc = ldt.withZone(DateTimeZone.forID("UTC"));
        return new DateData(ldt.toDate());
    }


    @Override
    public void setFocus(Context context) {
        // Hide the soft keyboard if it's showing.
        InputMethodManager inputManager =
            (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
        inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
    }


    @Override
    public void setOnLongClickListener(OnLongClickListener l) {
        mDatePicker.setOnLongClickListener(l);
    }


    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        mDatePicker.cancelLongPress();
    }

}

/*
 * Copyright (C) 2009 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.graphics.Bitmap;
import android.net.Uri;
import android.provider.MediaStore.Images;
import android.util.Log;
import android.util.TypedValue;
import android.view.Display;
import android.view.View;
import android.view.WindowManager;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TableLayout;
import android.widget.TextView;
import android.widget.Toast;

import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.StringData;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.R;
import org.odk.collect.android.activities.FormEntryActivity;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.utilities.FileUtils;
import org.odk.collect.android.utilities.MediaUtils;

import java.io.File;

/**
 * Widget that allows user to take pictures, sounds or video and add them to the form.
 * 
 * @author Carl Hartung (carlhartung@gmail.com)
 * @author Yaw Anokwa (yanokwa@gmail.com)
 */
public class ImageWidget extends QuestionWidget implements IBinaryWidget {
    private final static String t = "MediaWidget";

    private Button mCaptureButton;
    private Button mChooseButton;
    private ImageView mImageView;

    private String mBinaryName;

    private String mInstanceFolder;
    
    private TextView mErrorTextView;


    public ImageWidget(Context context, FormEntryPrompt prompt) {
        super(context, prompt);

        mInstanceFolder =
                Collect.getInstance().getFormController().getInstancePath().getParent();

        setOrientation(LinearLayout.VERTICAL);

        TableLayout.LayoutParams params = new TableLayout.LayoutParams();
        params.setMargins(7, 5, 7, 5);
        
        mErrorTextView = new TextView(context);
        mErrorTextView.setId(QuestionWidget.newUniqueId());
        mErrorTextView.setText("Selected file is not a valid image");

        // setup capture button
        mCaptureButton = new Button(getContext());
        mCaptureButton.setId(QuestionWidget.newUniqueId());
        mCaptureButton.setText(getContext().getString(R.string.capture_image));
        mCaptureButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
        mCaptureButton.setPadding(20, 20, 20, 20);
        mCaptureButton.setEnabled(!prompt.isReadOnly());
        mCaptureButton.setLayoutParams(params);

        // launch capture intent on click
        mCaptureButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
               	Collect.getInstance().getActivityLogger().logInstanceAction(this, "captureButton", 
            			"click", mPrompt.getIndex());
                mErrorTextView.setVisibility(View.GONE);
                Intent i = new Intent(android.provider.MediaStore.ACTION_IMAGE_CAPTURE);
                // We give the camera an absolute filename/path where to put the
                // picture because of bug:
                // http://code.google.com/p/android/issues/detail?id=1480
                // The bug appears to be fixed in Android 2.0+, but as of feb 2,
                // 2010, G1 phones only run 1.6. Without specifying the path the
                // images returned by the camera in 1.6 (and earlier) are ~1/4
                // the size. boo.

                // if this gets modified, the onActivityResult in
                // FormEntyActivity will also need to be updated.
                i.putExtra(android.provider.MediaStore.EXTRA_OUTPUT,
                    Uri.fromFile(new File(Collect.getInstance().getTmpFilePath())));
                try {
                	Collect.getInstance().getFormController().setIndexWaitingForData(mPrompt.getIndex());
                    ((Activity) getContext()).startActivityForResult(i,
                        FormEntryActivity.IMAGE_CAPTURE);
                } catch (ActivityNotFoundException e) {
                    Toast.makeText(getContext(),
                        getContext().getString(R.string.activity_not_found, "image capture"),
                        Toast.LENGTH_SHORT).show();
                	Collect.getInstance().getFormController().setIndexWaitingForData(null);
                }

            }
        });

        // setup chooser button
        mChooseButton = new Button(getContext());
        mChooseButton.setId(QuestionWidget.newUniqueId());
        mChooseButton.setText(getContext().getString(R.string.choose_image));
        mChooseButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
        mChooseButton.setPadding(20, 20, 20, 20);
        mChooseButton.setEnabled(!prompt.isReadOnly());
        mChooseButton.setLayoutParams(params);

        // launch capture intent on click
        mChooseButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
               	Collect.getInstance().getActivityLogger().logInstanceAction(this, "chooseButton", 
            			"click", mPrompt.getIndex());
                mErrorTextView.setVisibility(View.GONE);
                Intent i = new Intent(Intent.ACTION_GET_CONTENT);
                i.setType("image/*");

                try {
					Collect.getInstance().getFormController()
							.setIndexWaitingForData(mPrompt.getIndex());
                    ((Activity) getContext()).startActivityForResult(i,
                        FormEntryActivity.IMAGE_CHOOSER);
                } catch (ActivityNotFoundException e) {
                    Toast.makeText(getContext(),
                        getContext().getString(R.string.activity_not_found, "choose image"),
                        Toast.LENGTH_SHORT).show();
                	Collect.getInstance().getFormController().setIndexWaitingForData(null);
                }

            }
        });

        // finish complex layout
        addView(mCaptureButton);
        addView(mChooseButton);
        addView(mErrorTextView);
     
        // and hide the capture and choose button if read-only
        if ( prompt.isReadOnly() ) {
        	mCaptureButton.setVisibility(View.GONE);
        	mChooseButton.setVisibility(View.GONE);
        }
        mErrorTextView.setVisibility(View.GONE);

        // retrieve answer from data model and update ui
        mBinaryName = prompt.getAnswerText();

        // Only add the imageView if the user has taken a picture
        if (mBinaryName != null) {
            mImageView = new ImageView(getContext());
            mImageView.setId(QuestionWidget.newUniqueId());
            Display display =
                ((WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE))
                        .getDefaultDisplay();
            int screenWidth = display.getWidth();
            int screenHeight = display.getHeight();

            File f = new File(mInstanceFolder + File.separator + mBinaryName);

            if (f.exists()) {
                Bitmap bmp = FileUtils.getBitmapScaledToDisplay(f, screenHeight, screenWidth);
                if (bmp == null) {
                    mErrorTextView.setVisibility(View.VISIBLE);
                }
                mImageView.setImageBitmap(bmp);
            } else {
                mImageView.setImageBitmap(null);
            }

            mImageView.setPadding(10, 10, 10, 10);
            mImageView.setAdjustViewBounds(true);
            mImageView.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                   	Collect.getInstance().getActivityLogger().logInstanceAction(this, "viewButton", 
                			"click", mPrompt.getIndex());
                    Intent i = new Intent("android.intent.action.VIEW");
                    Uri uri = MediaUtils.getImageUriFromMediaProvider(mInstanceFolder + File.separator + mBinaryName);
                	if ( uri != null ) {
                        Log.i(t,"setting view path to: " + uri);
                        i.setDataAndType(uri, "image/*");
                        try {
                            getContext().startActivity(i);
                        } catch (ActivityNotFoundException e) {
                            Toast.makeText(getContext(),
                                getContext().getString(R.string.activity_not_found, "view image"),
                                Toast.LENGTH_SHORT).show();
                        }
                    }
                }
            });

            addView(mImageView);
        }
    }


    private void deleteMedia() {
        // get the file path and delete the file
    	String name = mBinaryName;
        // clean up variables
    	mBinaryName = null;
    	// delete from media provider
        int del = MediaUtils.deleteImageFileFromMediaProvider(mInstanceFolder + File.separator + name);
        Log.i(t, "Deleted " + del + " rows from media content provider");
    }


    @Override
    public void clearAnswer() {
        // remove the file
        deleteMedia();
        mImageView.setImageBitmap(null);
        mErrorTextView.setVisibility(View.GONE);

        // reset buttons
        mCaptureButton.setText(getContext().getString(R.string.capture_image));
    }


    @Override
    public IAnswerData getAnswer() {
        if (mBinaryName != null) {
            return new StringData(mBinaryName.toString());
        } else {
            return null;
        }
    }


    @Override
    public void setBinaryData(Object newImageObj) {
        // you are replacing an answer. delete the previous image using the
        // content provider.
        if (mBinaryName != null) {
            deleteMedia();
        }

        File newImage = (File) newImageObj;
        if (newImage.exists()) {
            // Add the new image to the Media content provider so that the
            // viewing is fast in Android 2.0+
        	ContentValues values = new ContentValues(6);
            values.put(Images.Media.TITLE, newImage.getName());
            values.put(Images.Media.DISPLAY_NAME, newImage.getName());
            values.put(Images.Media.DATE_TAKEN, System.currentTimeMillis());
            values.put(Images.Media.MIME_TYPE, "image/jpeg");
            values.put(Images.Media.DATA, newImage.getAbsolutePath());

            Uri imageURI = getContext().getContentResolver().insert(
            		Images.Media.EXTERNAL_CONTENT_URI, values);
            Log.i(t, "Inserting image returned uri = " + imageURI.toString());

            mBinaryName = newImage.getName();
            Log.i(t, "Setting current answer to " + newImage.getName());
        } else {
            Log.e(t, "NO IMAGE EXISTS at: " + newImage.getAbsolutePath());
        }

    	Collect.getInstance().getFormController().setIndexWaitingForData(null);
    }

    @Override
    public void setFocus(Context context) {
        // Hide the soft keyboard if it's showing.
        InputMethodManager inputManager =
            (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
        inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
    }


    @Override
    public boolean isWaitingForBinaryData() {
    	return mPrompt.getIndex().equals(Collect.getInstance().getFormController().getIndexWaitingForData());
    }


    @Override
	public void cancelWaitingForBinaryData() {
    	Collect.getInstance().getFormController().setIndexWaitingForData(null);
	}


    @Override
    public void setOnLongClickListener(OnLongClickListener l) {
        mCaptureButton.setOnLongClickListener(l);
        mChooseButton.setOnLongClickListener(l);
        if (mImageView != null) {
            mImageView.setOnLongClickListener(l);
        }
    }


    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        mCaptureButton.cancelLongPress();
        mChooseButton.cancelLongPress();
        if (mImageView != null) {
            mImageView.cancelLongPress();
        }
    }

}

/*
 * Copyright (C) 2013 Nafundi LLC
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.View;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.TableLayout;
import android.widget.TextView;
import android.widget.Toast;

import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.StringData;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;

/**
 * Widget that allows user to open URLs from within the form
 * 
 * @author Yaw Anokwa (yanokwa@gmail.com)
 */
public class UrlWidget extends QuestionWidget {
    private Button mOpenUrlButton;
    private TextView mStringAnswer;

    public UrlWidget(Context context, FormEntryPrompt prompt) {
        super(context, prompt);
        setOrientation(LinearLayout.VERTICAL);

        TableLayout.LayoutParams params = new TableLayout.LayoutParams();
        params.setMargins(7, 5, 7, 5);

        // set button formatting
        mOpenUrlButton = new Button(getContext());
        mOpenUrlButton.setId(QuestionWidget.newUniqueId());
        mOpenUrlButton.setText(getContext().getString(R.string.open_url));
        mOpenUrlButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP,
                mAnswerFontsize);
        mOpenUrlButton.setPadding(20, 20, 20, 20);
        mOpenUrlButton.setEnabled(!prompt.isReadOnly());
        mOpenUrlButton.setLayoutParams(params);

        mOpenUrlButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Collect.getInstance()
                        .getActivityLogger()
                        .logInstanceAction(this, "openUrl", "click",
                                mPrompt.getIndex());

                if (mStringAnswer != null & mStringAnswer.getText() != null
                        && !"".equalsIgnoreCase((String) mStringAnswer.getText())) {
                    Intent i = new Intent(Intent.ACTION_VIEW);
                    i.setData(Uri.parse((String) mStringAnswer.getText()));
                    getContext().startActivity(i);
                } else {
                    Toast.makeText(getContext(), "No URL set", Toast.LENGTH_SHORT).show();
                }
            }
        });

        // set text formatting
        mStringAnswer = new TextView(getContext());
        mStringAnswer.setId(QuestionWidget.newUniqueId());
        mStringAnswer.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
        mStringAnswer.setGravity(Gravity.CENTER);

        String s = prompt.getAnswerText();
        if (s != null) {
            mStringAnswer.setText(s);
        }
        // finish complex layout
        addView(mOpenUrlButton);
        addView(mStringAnswer);
    }

    @Override
    public void clearAnswer() {
        Toast.makeText(getContext(), "URL is readonly", Toast.LENGTH_SHORT).show();
    }

    @Override
    public IAnswerData getAnswer() {
        String s = mStringAnswer.getText().toString();
        if (s == null || s.equals("")) {
            return null;
        } else {
            return new StringData(s);
        }
    }

    @Override
    public void setFocus(Context context) {
        // Hide the soft keyboard if it's showing.
        InputMethodManager inputManager = (InputMethodManager) context
                .getSystemService(Context.INPUT_METHOD_SERVICE);
        inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
    }

    @Override
    public void setOnLongClickListener(OnLongClickListener l) {
    }

    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        mOpenUrlButton.cancelLongPress();
        mStringAnswer.cancelLongPress();
    }

}

/*
 * Copyright (C) 2012 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Context;
import android.content.Intent;
import android.text.InputFilter;
import android.text.InputType;
import android.text.method.DigitsKeyListener;

import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.IntegerData;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.activities.FormEntryActivity;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.external.ExternalAppsUtils;


/**
 * Launch an external app to supply an integer value. If the app
 * does not launch, enable the text area for regular data entry.
 *
 * See {@link org.odk.collect.android.widgets.ExStringWidget} for usage.
 *
 * @author mitchellsundt@gmail.com
 *
 */
public class ExIntegerWidget extends ExStringWidget {

	private Integer getIntegerAnswerValue() {
		IAnswerData dataHolder = mPrompt.getAnswerValue();
		Integer d = null;
        if (dataHolder != null) {
        	Object dataValue = dataHolder.getValue();
        	if ( dataValue != null ) {
        		if (dataValue instanceof Double){
	                d =  Integer.valueOf(((Double) dataValue).intValue());
	            } else {
	                d =  (Integer)dataValue;
	            }
        	}
        }
        return d;
	}

    public ExIntegerWidget(Context context, FormEntryPrompt prompt) {
        super(context, prompt);

        mAnswer.setInputType(InputType.TYPE_NUMBER_FLAG_SIGNED);

        // only allows numbers and no periods
        mAnswer.setKeyListener(new DigitsKeyListener(true, false));

        // ints can only hold 2,147,483,648. we allow 999,999,999
        InputFilter[] fa = new InputFilter[1];
        fa[0] = new InputFilter.LengthFilter(9);
        mAnswer.setFilters(fa);

        Integer i = getIntegerAnswerValue();

        if (i != null) {
            mAnswer.setText(i.toString());
        }
    }


    @Override
    protected void fireActivity(Intent i) throws ActivityNotFoundException {
    	i.putExtra("value", getIntegerAnswerValue());
       	Collect.getInstance().getActivityLogger().logInstanceAction(this, "launchIntent",
    			i.getAction(), mPrompt.getIndex());
        ((Activity) getContext()).startActivityForResult(i,
                FormEntryActivity.EX_INT_CAPTURE);
    }


    @Override
    public IAnswerData getAnswer() {
        String s = mAnswer.getText().toString();
        if (s == null || s.equals("")) {
            return null;
        } else {
            try {
                return new IntegerData(Integer.parseInt(s));
            } catch (Exception NumberFormatException) {
                return null;
            }
        }
    }


    /**
     * Allows answer to be set externally in {@Link FormEntryActivity}.
     */
    @Override
    public void setBinaryData(Object answer) {
        IntegerData integerData = ExternalAppsUtils.asIntegerData(answer);
    	mAnswer.setText( integerData == null ? null : integerData.getValue().toString());
    	Collect.getInstance().getFormController().setIndexWaitingForData(null);
    }

}

/*
 * Copyright (C) 2011 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.content.Context;
import android.graphics.Color;
import android.view.Gravity;
import android.view.inputmethod.InputMethodManager;
import android.widget.ArrayAdapter;
import android.widget.AutoCompleteTextView;
import android.widget.Filter;
import android.widget.Filterable;
import android.widget.Toast;

import org.javarosa.core.model.SelectChoice;
import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.SelectOneData;
import org.javarosa.core.model.data.helper.Selection;
import org.javarosa.form.api.FormEntryPrompt;
import org.javarosa.xpath.expr.XPathFuncExpr;
import org.odk.collect.android.external.ExternalDataUtil;

import java.util.ArrayList;
import java.util.Locale;
import java.util.Vector;

/**
 * AutoCompleteWidget handles select-one fields using an autocomplete text box. The user types part
 * of the desired selection and suggestions appear in a list below. The full list of possible
 * answers is not displayed to the user. The goal is to be more compact; this question type is best
 * suited for select one questions with a large number of possible answers. If images, audio, or
 * video are specified in the select answers they are ignored.
 *
 * @author Jeff Beorse (jeff@beorse.net)
 */
public class AutoCompleteWidget extends QuestionWidget {

    AutoCompleteAdapter choices;
    AutoCompleteTextView autocomplete;

    Vector<SelectChoice> mItems;

    // Defines which filter to use to display autocomplete possibilities
    String filterType;

    // The various filter types
    String match_substring = "substring";
    String match_prefix = "prefix";
    String match_chars = "chars";


    public AutoCompleteWidget(Context context, FormEntryPrompt prompt, String filterType) {
        super(context, prompt);

        // SurveyCTO-added support for dynamic select content (from .csv files)
        XPathFuncExpr xPathFuncExpr = ExternalDataUtil.getSearchXPathExpression(prompt.getAppearanceHint());
        if (xPathFuncExpr != null) {
            mItems = ExternalDataUtil.populateExternalChoices(prompt, xPathFuncExpr);
        } else {
            mItems = prompt.getSelectChoices();
        }

        mPrompt = prompt;

        choices = new AutoCompleteAdapter(getContext(), android.R.layout.simple_list_item_1);
        autocomplete = new AutoCompleteTextView(getContext());

        // Default to matching substring
        if (filterType != null) {
            this.filterType = filterType;
        } else {
            this.filterType = match_substring;
        }

        for (SelectChoice sc : mItems) {
            choices.add(prompt.getSelectChoiceText(sc));
        }
        choices.setDropDownViewResource(android.R.layout.simple_dropdown_item_1line);

        autocomplete.setAdapter(choices);
        autocomplete.setTextColor(Color.BLACK);
        setGravity(Gravity.LEFT);

        // Fill in answer
        String s = null;
        if (mPrompt.getAnswerValue() != null) {
            s = ((Selection) mPrompt.getAnswerValue().getValue()).getValue();
        }

        for (int i = 0; i < mItems.size(); ++i) {
            String sMatch = mItems.get(i).getValue();

            if (sMatch.equals(s)) {
                autocomplete.setText(mItems.get(i).getLabelInnerText());
            }
        }

        addView(autocomplete);

    }


    @Override
    public IAnswerData getAnswer() {
    	clearFocus();
    	String response = autocomplete.getText().toString();
        for (SelectChoice sc : mItems) {
            if (response.equals(mPrompt.getSelectChoiceText(sc))) {
                return new SelectOneData(new Selection(sc));
            }
        }

        // If the user has typed text into the autocomplete box that doesn't match any answer, warn
        // them that their
        // solution didn't count.
        if (!response.equals("")) {
            Toast.makeText(getContext(),
                "Warning: \"" + response + "\" does not match any answers. No answer recorded.",
                Toast.LENGTH_LONG).show();
        }
        return null;
    }


    @Override
    public void clearAnswer() {
        autocomplete.setText("");
    }


    @Override
    public void setFocus(Context context) {
        // Hide the soft keyboard if it's showing.
        InputMethodManager inputManager =
            (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
        inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);

    }

    private class AutoCompleteAdapter extends ArrayAdapter<String> implements Filterable {

        private ItemsFilter mFilter;
        public ArrayList<String> mItems;


        public AutoCompleteAdapter(Context context, int textViewResourceId) {
            super(context, textViewResourceId);
            mItems = new ArrayList<String>();
        }


        @Override
        public void add(String toAdd) {
            super.add(toAdd);
            mItems.add(toAdd);
        }


        @Override
        public int getCount() {
            return mItems.size();
        }


        @Override
        public String getItem(int position) {
            return mItems.get(position);
        }


        @Override
        public int getPosition(String item) {
            return mItems.indexOf(item);
        }


        public Filter getFilter() {
            if (mFilter == null) {
                mFilter = new ItemsFilter(mItems);
            }
            return mFilter;
        }


        @Override
        public long getItemId(int position) {
            return position;
        }

        private class ItemsFilter extends Filter {
            final ArrayList<String> mItemsArray;


            public ItemsFilter(ArrayList<String> list) {
                if (list == null) {
                    mItemsArray = new ArrayList<String>();
                } else {
                    mItemsArray = new ArrayList<String>(list);
                }
            }


            @Override
            protected FilterResults performFiltering(CharSequence prefix) {
                // Initiate our results object
                FilterResults results = new FilterResults();

                // If the adapter array is empty, check the actual items array and use it
                if (mItems == null) {
                    mItems = new ArrayList<String>(mItemsArray);
                }

                // No prefix is sent to filter by so we're going to send back the original array
                if (prefix == null || prefix.length() == 0) {
                    results.values = mItemsArray;
                    results.count = mItemsArray.size();
                } else {
                    // Compare lower case strings
                    String prefixString = prefix.toString().toLowerCase(Locale.getDefault());

                    // Local to here so we're not changing actual array
                    final ArrayList<String> items = mItems;
                    final int count = items.size();
                    final ArrayList<String> newItems = new ArrayList<String>(count);

                    for (int i = 0; i < count; i++) {
                        final String item = items.get(i);
                        String item_compare = item.toLowerCase(Locale.getDefault());

                        // Match the strings using the filter specified
                        if (filterType.equals(match_substring)
                                && (item_compare.startsWith(prefixString) || item_compare
                                        .contains(prefixString))) {
                            newItems.add(item);
                        } else if (filterType.equals(match_prefix)
                                && item_compare.startsWith(prefixString)) {
                            newItems.add(item);
                        } else if (filterType.equals(match_chars)) {
                            char[] toMatch = prefixString.toCharArray();

                            boolean matches = true;
                            for (int j = 0; j < toMatch.length; j++) {
                                int index = item_compare.indexOf(toMatch[j]);
                                if (index > -1) {
                                    item_compare =
                                        item_compare.substring(0, index)
                                                + item_compare.substring(index + 1);
                                } else {
                                    matches = false;
                                    break;
                                }
                            }

                            if (matches) {
                                newItems.add(item);
                            }

                        } else {
                            // Default to substring
                            if (item_compare.startsWith(prefixString)
                                    || item_compare.contains(prefixString)) {
                                newItems.add(item);
                            }
                        }
                    }

                    // Set and return
                    results.values = newItems;
                    results.count = newItems.size();
                }

                return results;
            }


            @SuppressWarnings("unchecked")
            @Override
            protected void publishResults(CharSequence constraint, FilterResults results) {
                mItems = (ArrayList<String>) results.values;
                // Let the adapter know about the updated list
                if (results.count > 0) {
                    notifyDataSetChanged();
                } else {
                    notifyDataSetInvalidated();
                }

            }

        }

    }


    @Override
    public void setOnLongClickListener(OnLongClickListener l) {
        autocomplete.setOnLongClickListener(l);
    }


    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        autocomplete.cancelLongPress();
    }

}

/*
 * Copyright (C) 2011 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.util.Log;
import android.util.TypedValue;
import android.view.Display;
import android.view.Gravity;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.view.inputmethod.InputMethodManager;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.BaseAdapter;
import android.widget.GridView;
import android.widget.ImageView;
import android.widget.ImageView.ScaleType;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.TextView;

import org.javarosa.core.model.SelectChoice;
import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.SelectOneData;
import org.javarosa.core.model.data.helper.Selection;
import org.javarosa.core.reference.InvalidReferenceException;
import org.javarosa.core.reference.ReferenceManager;
import org.javarosa.form.api.FormEntryCaption;
import org.javarosa.form.api.FormEntryPrompt;
import org.javarosa.xpath.expr.XPathFuncExpr;
import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.external.ExternalDataUtil;
import org.odk.collect.android.external.ExternalSelectChoice;
import org.odk.collect.android.listeners.AdvanceToNextListener;
import org.odk.collect.android.utilities.FileUtils;
import org.odk.collect.android.views.AudioButton.AudioHandler;
import org.odk.collect.android.views.ExpandedHeightGridView;

import java.io.File;
import java.util.Vector;

/**
 * GridWidget handles select-one fields using a grid of icons. The user clicks the desired icon and
 * the background changes from black to orange. If text, audio, or video are specified in the select
 * answers they are ignored.
 *
 * @author Jeff Beorse (jeff@beorse.net)
 */
public class GridWidget extends QuestionWidget {

    // The RGB value for the orange background
    public static final int orangeRedVal = 255;
    public static final int orangeGreenVal = 140;
    public static final int orangeBlueVal = 0;

    private static final int HORIZONTAL_PADDING = 7;
    private static final int VERTICAL_PADDING = 5;
    private static final int SPACING = 2;
    private static final int IMAGE_PADDING = 8;
    private static final int SCROLL_WIDTH = 16;

    Vector<SelectChoice> mItems;

    // The possible select choices
    String[] choices;

    // The Gridview that will hold the icons
    ExpandedHeightGridView gridview;

    // Defines which icon is selected
    boolean[] selected;

    // The image views for each of the icons
    View[] imageViews;
    AudioHandler[] audioHandlers;

    // The number of columns in the grid, can be user defined (<= 0 if unspecified)
    int numColumns;

    // Whether to advance immediately after the image is clicked
    boolean quickAdvance;

    AdvanceToNextListener listener;

    int resizeWidth;

    public GridWidget(Context context, FormEntryPrompt prompt, int numColumns,
            final boolean quickAdvance) {
        super(context, prompt);

        // SurveyCTO-added support for dynamic select content (from .csv files)
        XPathFuncExpr xPathFuncExpr = ExternalDataUtil.getSearchXPathExpression(prompt.getAppearanceHint());
        if (xPathFuncExpr != null) {
            mItems = ExternalDataUtil.populateExternalChoices(prompt, xPathFuncExpr);
        } else {
            mItems = prompt.getSelectChoices();
        }
        mPrompt = prompt;
        listener = (AdvanceToNextListener) context;

        selected = new boolean[mItems.size()];
        choices = new String[mItems.size()];
        gridview = new ExpandedHeightGridView(context);
        imageViews = new View[mItems.size()];
        audioHandlers = new AudioHandler[mItems.size()];
        // The max width of an icon in a given column. Used to line
        // up the columns and automatically fit the columns in when
        // they are chosen automatically
        int maxColumnWidth = -1;
        int maxCellHeight = -1;
        this.numColumns = numColumns;
        for (int i = 0; i < mItems.size(); i++) {
            imageViews[i] = new ImageView(getContext());
        }
        this.quickAdvance = quickAdvance;

        Display display =
                ((WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE))
                        .getDefaultDisplay();
        int screenWidth = display.getWidth();
        int screenHeight = display.getHeight();

        if ( display.getOrientation() % 2 == 1 ) {
        	// rotated 90 degrees...
        	int temp = screenWidth;
        	screenWidth = screenHeight;
        	screenHeight = temp;
        }

        if ( numColumns > 0 ) {
        	resizeWidth = ((screenWidth - 2*HORIZONTAL_PADDING - SCROLL_WIDTH - (IMAGE_PADDING+SPACING)*numColumns) / numColumns );
        }

        // Build view
        for (int i = 0; i < mItems.size(); i++) {
            SelectChoice sc = mItems.get(i);

            int curHeight = -1;

            // Create an audioHandler iff there is an audio prompt associated with this selection.
            String audioURI =
            		prompt.getSpecialFormSelectChoiceText(sc, FormEntryCaption.TEXT_FORM_AUDIO);
            if ( audioURI != null) {
            	audioHandlers[i] = new AudioHandler(prompt.getIndex(), sc.getValue(), audioURI);
            } else {
            	audioHandlers[i] = null;
            }
            // Read the image sizes and set maxColumnWidth. This allows us to make sure all of our
            // columns are going to fit
            String imageURI;
            if (mItems.get(i) instanceof ExternalSelectChoice) {
                imageURI = ((ExternalSelectChoice) sc).getImage();
            } else {
                imageURI = prompt.getSpecialFormSelectChoiceText(sc, FormEntryCaption.TEXT_FORM_IMAGE);
            }

            String errorMsg = null;
            if (imageURI != null) {
                choices[i] = imageURI;

                String imageFilename;
                try {
                	imageFilename = ReferenceManager._().DeriveReference(imageURI).getLocalURI();
                    final File imageFile = new File(imageFilename);
                    if (imageFile.exists()) {
                        Bitmap b =
                            FileUtils
                                    .getBitmapScaledToDisplay(imageFile, screenHeight, screenWidth);
                        if (b != null) {

                            if (b.getWidth() > maxColumnWidth) {
                                maxColumnWidth = b.getWidth();
                            }

                            ImageView imageView = (ImageView) imageViews[i];

                            imageView.setBackgroundColor(Color.WHITE);

	                        if ( numColumns > 0 ) {
	                        	int resizeHeight = (b.getHeight() * resizeWidth) / b.getWidth();
	                        	b = Bitmap.createScaledBitmap(b, resizeWidth, resizeHeight, false);
	                        }

	                        imageView.setPadding(IMAGE_PADDING, IMAGE_PADDING, IMAGE_PADDING, IMAGE_PADDING);
	                        imageView.setImageBitmap(b);
	                        imageView.setLayoutParams(new ListView.LayoutParams(ListView.LayoutParams.WRAP_CONTENT, ListView.LayoutParams.WRAP_CONTENT));
	                        imageView.setScaleType(ScaleType.FIT_XY);

	                        imageView.measure(0, 0);
	                        curHeight = imageView.getMeasuredHeight();
                        } else {
                            // Loading the image failed, so it's likely a bad file.
                            errorMsg = getContext().getString(R.string.file_invalid, imageFile);
                        }
                    } else {
                        // We should have an image, but the file doesn't exist.
                        errorMsg = getContext().getString(R.string.file_missing, imageFile);
                    }
                } catch (InvalidReferenceException e) {
                    Log.e("GridWidget", "image invalid reference exception");
                    e.printStackTrace();
                }
            } else {
            	errorMsg = "";
            }

            if (errorMsg != null) {
                choices[i] = prompt.getSelectChoiceText(sc);

                TextView missingImage = new TextView(getContext());
                missingImage.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
                missingImage.setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);
                missingImage.setPadding(IMAGE_PADDING, IMAGE_PADDING, IMAGE_PADDING, IMAGE_PADDING);

                if ( choices[i] != null && choices[i].length() != 0 ) {
	                missingImage.setText(choices[i]);
                } else {
	                // errorMsg is only set when an error has occurred
	                Log.e("GridWidget", errorMsg);
	                missingImage.setText(errorMsg);
                }

                if ( numColumns > 0 ) {
                	maxColumnWidth = resizeWidth;
                	// force max width to find needed height...
                	missingImage.setMaxWidth(resizeWidth);
                	missingImage.measure(MeasureSpec.makeMeasureSpec(resizeWidth, MeasureSpec.EXACTLY), 0);
                	curHeight = missingImage.getMeasuredHeight();
                } else {
                	missingImage.measure(0, 0);
                    int width = missingImage.getMeasuredWidth();
                    if (width > maxColumnWidth) {
                        maxColumnWidth = width;
                    }
                	curHeight = missingImage.getMeasuredHeight();
                }
                imageViews[i] = missingImage;
            }

            // if we get a taller image/text, force all cells to be that height
            // could also set cell heights on a per-row basis if user feedback requests it.
            if ( curHeight > maxCellHeight ) {
            	maxCellHeight = curHeight;
            	for ( int j = 0 ; j < i ; j++ ) {
            		imageViews[j].setMinimumHeight(maxCellHeight);
            	}
            }
            imageViews[i].setMinimumHeight(maxCellHeight);
        }

        // Read the screen dimensions and fit the grid view to them. It is important that the grid
        // knows how far out it can stretch.

        if ( numColumns > 0 ) {
            // gridview.setNumColumns(numColumns);
            gridview.setNumColumns(GridView.AUTO_FIT);
        } else {
        	resizeWidth = maxColumnWidth;
            gridview.setNumColumns(GridView.AUTO_FIT);
        }

    	gridview.setColumnWidth(resizeWidth);

    	gridview.setPadding(HORIZONTAL_PADDING, VERTICAL_PADDING, HORIZONTAL_PADDING, VERTICAL_PADDING);
        gridview.setHorizontalSpacing(SPACING);
        gridview.setVerticalSpacing(SPACING);
        gridview.setGravity(Gravity.CENTER);
        gridview.setScrollContainer(false);
        gridview.setStretchMode(GridView.NO_STRETCH);

        gridview.setOnItemClickListener(new OnItemClickListener() {
            public void onItemClick(AdapterView<?> parent, View v, int position, long id) {

                // Imitate the behavior of a radio button. Clear all buttons
                // and then check the one clicked by the user. Update the
                // background color accordingly
                for (int i = 0; i < selected.length; i++) {
                	// if we have an audio handler, be sure audio is stopped.
                	if ( selected[i] && (audioHandlers[i] != null)) {
                		audioHandlers[i].stopPlaying();
                	}
                    selected[i] = false;
                    if (imageViews[i] != null) {
                        imageViews[i].setBackgroundColor(Color.WHITE);
                    }
                }
                selected[position] = true;
               	Collect.getInstance().getActivityLogger().logInstanceAction(this, "onItemClick.select",
            			mItems.get(position).getValue(), mPrompt.getIndex());
                imageViews[position].setBackgroundColor(Color.rgb(orangeRedVal, orangeGreenVal,
                    orangeBlueVal));
                if (quickAdvance) {
                    listener.advance();
                } else if ( audioHandlers[position] != null ) {
                	audioHandlers[position].playAudio(getContext());
                }
            }
        });

        // Fill in answer
        String s = null;
        if (prompt.getAnswerValue() != null) {
            s = ((Selection) prompt.getAnswerValue().getValue()).getValue();
        }

        for (int i = 0; i < mItems.size(); ++i) {
            String sMatch = mItems.get(i).getValue();

            selected[i] = sMatch.equals(s);
            if (selected[i]) {
                imageViews[i].setBackgroundColor(Color.rgb(orangeRedVal, orangeGreenVal,
                    orangeBlueVal));
            } else {
                imageViews[i].setBackgroundColor(Color.WHITE);
            }
        }

        // Use the custom image adapter and initialize the grid view
        ImageAdapter ia = new ImageAdapter(getContext(), choices);
        gridview.setAdapter(ia);
        addView(gridview,  new LinearLayout.LayoutParams(LinearLayout.LayoutParams.FILL_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT));
    }


    @Override
    public IAnswerData getAnswer() {
        for (int i = 0; i < choices.length; ++i) {
            if (selected[i]) {
                SelectChoice sc = mItems.elementAt(i);
                return new SelectOneData(new Selection(sc));
            }
        }
        return null;
    }


    @Override
    public void clearAnswer() {
        for (int i = 0; i < mItems.size(); ++i) {
            selected[i] = false;
            imageViews[i].setBackgroundColor(Color.WHITE);
        }

    }


    @Override
    public void setFocus(Context context) {
        // Hide the soft keyboard if it's showing.
        InputMethodManager inputManager =
            (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
        inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);

    }

    // Custom image adapter. Most of the code is copied from
    // media layout for using a picture.
    private class ImageAdapter extends BaseAdapter {
        private String[] choices;


        public ImageAdapter(Context c, String[] choices) {
            this.choices = choices;
        }


        public int getCount() {
            return choices.length;
        }


        public Object getItem(int position) {
            return null;
        }


        public long getItemId(int position) {
            return 0;
        }


        // create a new ImageView for each item referenced by the Adapter
        public View getView(int position, View convertView, ViewGroup parent) {
        	if ( position < imageViews.length ) {
        		return imageViews[position];
        	} else {
        		return convertView;
        	}
        }
    }


    @Override
    public void setOnLongClickListener(OnLongClickListener l) {
        gridview.setOnLongClickListener(l);
    }


    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        gridview.cancelLongPress();
    }
}

/*
 * Copyright (C) 2009 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.content.Context;
import android.util.TypedValue;
import android.view.inputmethod.InputMethodManager;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.RadioButton;

import org.javarosa.core.model.SelectChoice;
import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.SelectOneData;
import org.javarosa.core.model.data.helper.Selection;
import org.javarosa.form.api.FormEntryCaption;
import org.javarosa.form.api.FormEntryPrompt;
import org.javarosa.xpath.expr.XPathFuncExpr;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.external.ExternalDataUtil;
import org.odk.collect.android.external.ExternalSelectChoice;
import org.odk.collect.android.views.MediaLayout;

import java.util.ArrayList;
import java.util.Vector;

/**
 * SelectOneWidgets handles select-one fields using radio buttons.
 * 
 * @author Carl Hartung (carlhartung@gmail.com)
 * @author Yaw Anokwa (yanokwa@gmail.com)
 */
public class SelectOneWidget extends QuestionWidget implements
		OnCheckedChangeListener {

	Vector<SelectChoice> mItems; // may take a while to compute
	ArrayList<RadioButton> buttons;

	public SelectOneWidget(Context context, FormEntryPrompt prompt) {
		super(context, prompt);

        // SurveyCTO-added support for dynamic select content (from .csv files)
        XPathFuncExpr xPathFuncExpr = ExternalDataUtil.getSearchXPathExpression(prompt.getAppearanceHint());
        if (xPathFuncExpr != null) {
            mItems = ExternalDataUtil.populateExternalChoices(prompt, xPathFuncExpr);
        } else {
            mItems = prompt.getSelectChoices();
        }
		buttons = new ArrayList<RadioButton>();

		// Layout holds the vertical list of buttons
		LinearLayout buttonLayout = new LinearLayout(context);

		String s = null;
		if (prompt.getAnswerValue() != null) {
			s = ((Selection) prompt.getAnswerValue().getValue()).getValue();
		}

		if (mItems != null) {
			for (int i = 0; i < mItems.size(); i++) {
				RadioButton r = new RadioButton(getContext());
				r.setText(prompt.getSelectChoiceText(mItems.get(i)));
				r.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
				r.setTag(Integer.valueOf(i));
				r.setId(QuestionWidget.newUniqueId());
				r.setEnabled(!prompt.isReadOnly());
				r.setFocusable(!prompt.isReadOnly());

				buttons.add(r);

				if (mItems.get(i).getValue().equals(s)) {
					r.setChecked(true);
				}

				r.setOnCheckedChangeListener(this);

				String audioURI = null;
				audioURI = prompt.getSpecialFormSelectChoiceText(mItems.get(i),
						FormEntryCaption.TEXT_FORM_AUDIO);

                String imageURI;
                if (mItems.get(i) instanceof ExternalSelectChoice) {
                    imageURI = ((ExternalSelectChoice) mItems.get(i)).getImage();
                } else {
                    imageURI = prompt.getSpecialFormSelectChoiceText(mItems.get(i), FormEntryCaption.TEXT_FORM_IMAGE);
                }

				String videoURI = null;
				videoURI = prompt.getSpecialFormSelectChoiceText(mItems.get(i),
						"video");

				String bigImageURI = null;
				bigImageURI = prompt.getSpecialFormSelectChoiceText(
						mItems.get(i), "big-image");

				MediaLayout mediaLayout = new MediaLayout(getContext());
				mediaLayout.setAVT(prompt.getIndex(), "." + Integer.toString(i), r, audioURI, imageURI,
						videoURI, bigImageURI);

				if (i != mItems.size() - 1) {
					// Last, add the dividing line (except for the last element)
					ImageView divider = new ImageView(getContext());
					divider.setBackgroundResource(android.R.drawable.divider_horizontal_bright);
					mediaLayout.addDivider(divider);
				}
				buttonLayout.addView(mediaLayout);
			}
		}
		buttonLayout.setOrientation(LinearLayout.VERTICAL);

		// The buttons take up the right half of the screen
		LayoutParams buttonParams = new LayoutParams(LayoutParams.FILL_PARENT,
				LayoutParams.WRAP_CONTENT);

		addView(buttonLayout, buttonParams);
	}

	@Override
	public void clearAnswer() {
		for (RadioButton button : this.buttons) {
			if (button.isChecked()) {
				button.setChecked(false);
				return;
			}
		}
	}

	@Override
	public IAnswerData getAnswer() {
		int i = getCheckedId();
		if (i == -1) {
			return null;
		} else {
			SelectChoice sc = mItems.elementAt(i);
			return new SelectOneData(new Selection(sc));
		}
	}

	@Override
	public void setFocus(Context context) {
		// Hide the soft keyboard if it's showing.
		InputMethodManager inputManager = (InputMethodManager) context
				.getSystemService(Context.INPUT_METHOD_SERVICE);
		inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
	}

	public int getCheckedId() {
		for (int i = 0; i < buttons.size(); ++i) {
			RadioButton button = buttons.get(i);
			if (button.isChecked()) {
				return i;
			}
		}
		return -1;
	}

	@Override
	public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
		if (!isChecked) {
			// If it got unchecked, we don't care.
			return;
		}

		for (RadioButton button : buttons ) {
			if (button.isChecked() && !(buttonView == button)) {
				button.setChecked(false);
			}
		}
		
       	Collect.getInstance().getActivityLogger().logInstanceAction(this, "onCheckedChanged", 
    			mItems.get((Integer)buttonView.getTag()).getValue(), mPrompt.getIndex());
	}

	@Override
	public void setOnLongClickListener(OnLongClickListener l) {
		for (RadioButton r : buttons) {
			r.setOnLongClickListener(l);
		}
	}

	@Override
	public void cancelLongPress() {
		super.cancelLongPress();
		for (RadioButton button : this.buttons) {
			button.cancelLongPress();
		}
	}

}

/*
 * Copyright (C) 2009 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.content.Context;
import android.view.Gravity;
import android.view.inputmethod.InputMethodManager;
import android.widget.TimePicker;

import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.TimeData;
import org.javarosa.form.api.FormEntryPrompt;
import org.joda.time.DateTime;
import org.odk.collect.android.application.Collect;

import java.util.Date;

/**
 * Displays a TimePicker widget.
 * 
 * @author Carl Hartung (carlhartung@gmail.com)
 */
public class TimeWidget extends QuestionWidget {

    private TimePicker mTimePicker;


    public TimeWidget(Context context, final FormEntryPrompt prompt) {
        super(context, prompt);

        mTimePicker = new TimePicker(getContext());
        mTimePicker.setId(QuestionWidget.newUniqueId());
        mTimePicker.setFocusable(!prompt.isReadOnly());
        mTimePicker.setEnabled(!prompt.isReadOnly());

        String clockType =
            android.provider.Settings.System.getString(context.getContentResolver(),
                android.provider.Settings.System.TIME_12_24);
        if (clockType == null || clockType.equalsIgnoreCase("24")) {
            mTimePicker.setIs24HourView(true);
        }

        // If there's an answer, use it.
        if (prompt.getAnswerValue() != null) {

            // create a new date time from date object using default time zone
            DateTime ldt =
                new DateTime(((Date) ((TimeData) prompt.getAnswerValue()).getValue()).getTime());
            System.out.println("retrieving:" + ldt);

            mTimePicker.setCurrentHour(ldt.getHourOfDay());
            mTimePicker.setCurrentMinute(ldt.getMinuteOfHour());

        } else {
            // create time widget with current time as of right now
            clearAnswer();
        }

        mTimePicker.setOnTimeChangedListener(new TimePicker.OnTimeChangedListener() {
			@Override
			public void onTimeChanged(TimePicker view, int hourOfDay, int minute) {
            	Collect.getInstance().getActivityLogger().logInstanceAction(TimeWidget.this, "onTimeChanged", 
            			String.format("%1$02d:%2$02d",hourOfDay, minute), mPrompt.getIndex());
			}
		});

        setGravity(Gravity.LEFT);
        addView(mTimePicker);

    }


    /**
     * Resets time to today.
     */
    @Override
    public void clearAnswer() {
        DateTime ldt = new DateTime();
        mTimePicker.setCurrentHour(ldt.getHourOfDay());
        mTimePicker.setCurrentMinute(ldt.getMinuteOfHour());
    }


    @Override
    public IAnswerData getAnswer() {
    	clearFocus();
        // use picker time, convert to today's date, store as utc
        DateTime ldt =
            (new DateTime()).withTime(mTimePicker.getCurrentHour(), mTimePicker.getCurrentMinute(),
                0, 0);
        //DateTime utc = ldt.withZone(DateTimeZone.forID("UTC"));
        System.out.println("storing:" + ldt);
        return new TimeData(ldt.toDate());
    }


    @Override
    public void setFocus(Context context) {
        // Hide the soft keyboard if it's showing.
        InputMethodManager inputManager =
            (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
        inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
    }


    @Override
    public void setOnLongClickListener(OnLongClickListener l) {
        mTimePicker.setOnLongClickListener(l);
    }


    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        mTimePicker.cancelLongPress();
    }

}

/*
 * Copyright (C) 2009 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Context;
import android.content.Intent;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.View;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.TableLayout;
import android.widget.TextView;
import android.widget.Toast;

import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.StringData;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.R;
import org.odk.collect.android.activities.FormEntryActivity;
import org.odk.collect.android.application.Collect;

/**
 * Widget that allows user to scan barcodes and add them to the form.
 * 
 * @author Yaw Anokwa (yanokwa@gmail.com)
 */
public class BarcodeWidget extends QuestionWidget implements IBinaryWidget {
	private Button mGetBarcodeButton;
	private TextView mStringAnswer;

	public BarcodeWidget(Context context, FormEntryPrompt prompt) {
		super(context, prompt);
		setOrientation(LinearLayout.VERTICAL);

		TableLayout.LayoutParams params = new TableLayout.LayoutParams();
		params.setMargins(7, 5, 7, 5);

		// set button formatting
		mGetBarcodeButton = new Button(getContext());
		mGetBarcodeButton.setId(QuestionWidget.newUniqueId());
		mGetBarcodeButton.setText(getContext().getString(R.string.get_barcode));
		mGetBarcodeButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP,
				mAnswerFontsize);
		mGetBarcodeButton.setPadding(20, 20, 20, 20);
		mGetBarcodeButton.setEnabled(!prompt.isReadOnly());
		mGetBarcodeButton.setLayoutParams(params);

		// launch barcode capture intent on click
		mGetBarcodeButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				Collect.getInstance()
						.getActivityLogger()
						.logInstanceAction(this, "recordBarcode", "click",
								mPrompt.getIndex());
				Intent i = new Intent("com.google.zxing.client.android.SCAN");
				try {
					Collect.getInstance().getFormController()
							.setIndexWaitingForData(mPrompt.getIndex());
					((Activity) getContext()).startActivityForResult(i,
							FormEntryActivity.BARCODE_CAPTURE);
				} catch (ActivityNotFoundException e) {
					Toast.makeText(
							getContext(),
							getContext().getString(
									R.string.barcode_scanner_error),
							Toast.LENGTH_SHORT).show();
					Collect.getInstance().getFormController()
							.setIndexWaitingForData(null);
				}
			}
		});

		// set text formatting
		mStringAnswer = new TextView(getContext());
		mStringAnswer.setId(QuestionWidget.newUniqueId());
		mStringAnswer.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
		mStringAnswer.setGravity(Gravity.CENTER);

		String s = prompt.getAnswerText();
		if (s != null) {
			mGetBarcodeButton.setText(getContext().getString(
					R.string.replace_barcode));
			mStringAnswer.setText(s);
		}
		// finish complex layout
		addView(mGetBarcodeButton);
		addView(mStringAnswer);
	}

	@Override
	public void clearAnswer() {
		mStringAnswer.setText(null);
		mGetBarcodeButton.setText(getContext().getString(R.string.get_barcode));
	}

	@Override
	public IAnswerData getAnswer() {
		String s = mStringAnswer.getText().toString();
		if (s == null || s.equals("")) {
			return null;
		} else {
			return new StringData(s);
		}
	}

	/**
	 * Allows answer to be set externally in {@Link FormEntryActivity}.
	 */
	@Override
	public void setBinaryData(Object answer) {
		mStringAnswer.setText((String) answer);
		Collect.getInstance().getFormController().setIndexWaitingForData(null);
	}

	@Override
	public void setFocus(Context context) {
		// Hide the soft keyboard if it's showing.
		InputMethodManager inputManager = (InputMethodManager) context
				.getSystemService(Context.INPUT_METHOD_SERVICE);
		inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
	}

	@Override
	public boolean isWaitingForBinaryData() {
		return mPrompt.getIndex().equals(
				Collect.getInstance().getFormController()
						.getIndexWaitingForData());
	}

	@Override
	public void cancelWaitingForBinaryData() {
		Collect.getInstance().getFormController().setIndexWaitingForData(null);
	}

	@Override
	public void setOnLongClickListener(OnLongClickListener l) {
		mStringAnswer.setOnLongClickListener(l);
		mGetBarcodeButton.setOnLongClickListener(l);
	}

	@Override
	public void cancelLongPress() {
		super.cancelLongPress();
		mGetBarcodeButton.cancelLongPress();
		mStringAnswer.cancelLongPress();
	}

}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.provider.MediaStore.Audio;
import android.util.Log;
import android.util.TypedValue;
import android.view.View;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.TableLayout;
import android.widget.Toast;

import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.StringData;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.R;
import org.odk.collect.android.activities.FormEntryActivity;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.utilities.FileUtils;
import org.odk.collect.android.utilities.MediaUtils;

import java.io.File;

/**
 * Widget that allows user to take pictures, sounds or video and add them to the
 * form.
 *
 * @author Carl Hartung (carlhartung@gmail.com)
 * @author Yaw Anokwa (yanokwa@gmail.com)
 */

public class AudioWidget extends QuestionWidget implements IBinaryWidget {
	private final static String t = "MediaWidget";

	private Button mCaptureButton;
	private Button mPlayButton;
	private Button mChooseButton;

	private String mBinaryName;
	private String mInstanceFolder;

	public AudioWidget(Context context, FormEntryPrompt prompt) {
		super(context, prompt);

		mInstanceFolder = Collect.getInstance().getFormController()
				.getInstancePath().getParent();

		setOrientation(LinearLayout.VERTICAL);

		TableLayout.LayoutParams params = new TableLayout.LayoutParams();
		params.setMargins(7, 5, 7, 5);

		// setup capture button
		mCaptureButton = new Button(getContext());
		mCaptureButton.setId(QuestionWidget.newUniqueId());
		mCaptureButton.setText(getContext().getString(R.string.capture_audio));
		mCaptureButton
				.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
		mCaptureButton.setPadding(20, 20, 20, 20);
		mCaptureButton.setEnabled(!prompt.isReadOnly());
		mCaptureButton.setLayoutParams(params);

		// launch capture intent on click
		mCaptureButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				Collect.getInstance()
						.getActivityLogger()
						.logInstanceAction(this, "captureButton", "click",
								mPrompt.getIndex());
				Intent i = new Intent(
						android.provider.MediaStore.Audio.Media.RECORD_SOUND_ACTION);
				i.putExtra(
						android.provider.MediaStore.EXTRA_OUTPUT,
						android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI
								.toString());
				try {
					Collect.getInstance().getFormController()
							.setIndexWaitingForData(mPrompt.getIndex());
					((Activity) getContext()).startActivityForResult(i,
							FormEntryActivity.AUDIO_CAPTURE);
				} catch (ActivityNotFoundException e) {
					Toast.makeText(
							getContext(),
							getContext().getString(R.string.activity_not_found,
									"audio capture"), Toast.LENGTH_SHORT)
							.show();
					Collect.getInstance().getFormController()
							.setIndexWaitingForData(null);
				}

			}
		});

		// setup capture button
		mChooseButton = new Button(getContext());
		mChooseButton.setId(QuestionWidget.newUniqueId());
		mChooseButton.setText(getContext().getString(R.string.choose_sound));
		mChooseButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
		mChooseButton.setPadding(20, 20, 20, 20);
		mChooseButton.setEnabled(!prompt.isReadOnly());
		mChooseButton.setLayoutParams(params);

		// launch capture intent on click
		mChooseButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				Collect.getInstance()
						.getActivityLogger()
						.logInstanceAction(this, "chooseButton", "click",
								mPrompt.getIndex());
				Intent i = new Intent(Intent.ACTION_GET_CONTENT);
				i.setType("audio/*");
				try {
					Collect.getInstance().getFormController()
							.setIndexWaitingForData(mPrompt.getIndex());
					((Activity) getContext()).startActivityForResult(i,
							FormEntryActivity.AUDIO_CHOOSER);
				} catch (ActivityNotFoundException e) {
					Toast.makeText(
							getContext(),
							getContext().getString(R.string.activity_not_found,
									"choose audio"), Toast.LENGTH_SHORT).show();
					Collect.getInstance().getFormController()
							.setIndexWaitingForData(null);
				}

			}
		});

		// setup play button
		mPlayButton = new Button(getContext());
		mPlayButton.setId(QuestionWidget.newUniqueId());
		mPlayButton.setText(getContext().getString(R.string.play_audio));
		mPlayButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
		mPlayButton.setPadding(20, 20, 20, 20);
		mPlayButton.setLayoutParams(params);

		// on play, launch the appropriate viewer
		mPlayButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				Collect.getInstance()
						.getActivityLogger()
						.logInstanceAction(this, "playButton", "click",
								mPrompt.getIndex());
				Intent i = new Intent("android.intent.action.VIEW");
				File f = new File(mInstanceFolder + File.separator
						+ mBinaryName);
				i.setDataAndType(Uri.fromFile(f), "audio/*");
				try {
					((Activity) getContext()).startActivity(i);
				} catch (ActivityNotFoundException e) {
					Toast.makeText(
							getContext(),
							getContext().getString(R.string.activity_not_found,
									"play audio"), Toast.LENGTH_SHORT).show();
				}

			}
		});

		// retrieve answer from data model and update ui
		mBinaryName = prompt.getAnswerText();
		if (mBinaryName != null) {
			mPlayButton.setEnabled(true);
		} else {
			mPlayButton.setEnabled(false);
		}

		// finish complex layout
		addView(mCaptureButton);
		addView(mChooseButton);
		addView(mPlayButton);

		// and hide the capture and choose button if read-only
		if (mPrompt.isReadOnly()) {
			mCaptureButton.setVisibility(View.GONE);
			mChooseButton.setVisibility(View.GONE);
		}
	}


    private void deleteMedia() {
        // get the file path and delete the file
    	String name = mBinaryName;
        // clean up variables
    	mBinaryName = null;
    	// delete from media provider
        int del = MediaUtils.deleteAudioFileFromMediaProvider(mInstanceFolder + File.separator + name);
        Log.i(t, "Deleted " + del + " rows from media content provider");
    }

	@Override
	public void clearAnswer() {
		// remove the file
		deleteMedia();

		// reset buttons
		mPlayButton.setEnabled(false);
	}

	@Override
	public IAnswerData getAnswer() {
		if (mBinaryName != null) {
			return new StringData(mBinaryName.toString());
		} else {
			return null;
		}
	}

	@Override
	public void setBinaryData(Object binaryuri) {
		// when replacing an answer. remove the current media.
		if (mBinaryName != null) {
			deleteMedia();
		}

		// get the file path and create a copy in the instance folder
		String binaryPath = MediaUtils.getPathFromUri(this.getContext(), (Uri) binaryuri, Audio.Media.DATA);
		String extension = binaryPath.substring(binaryPath.lastIndexOf("."));
		String destAudioPath = mInstanceFolder + File.separator
				+ System.currentTimeMillis() + extension;

		File source = new File(binaryPath);
		File newAudio = new File(destAudioPath);
		FileUtils.copyFile(source, newAudio);

		if (newAudio.exists()) {
			// Add the copy to the content provier
			ContentValues values = new ContentValues(6);
			values.put(Audio.Media.TITLE, newAudio.getName());
			values.put(Audio.Media.DISPLAY_NAME, newAudio.getName());
			values.put(Audio.Media.DATE_ADDED, System.currentTimeMillis());
			values.put(Audio.Media.DATA, newAudio.getAbsolutePath());

			Uri AudioURI = getContext().getContentResolver().insert(
					Audio.Media.EXTERNAL_CONTENT_URI, values);
			Log.i(t, "Inserting AUDIO returned uri = " + AudioURI.toString());
			mBinaryName = newAudio.getName();
            Log.i(t, "Setting current answer to " + newAudio.getName());
		} else {
			Log.e(t, "Inserting Audio file FAILED");
		}

		Collect.getInstance().getFormController().setIndexWaitingForData(null);
	}

	@Override
	public void setFocus(Context context) {
		// Hide the soft keyboard if it's showing.
		InputMethodManager inputManager = (InputMethodManager) context
				.getSystemService(Context.INPUT_METHOD_SERVICE);
		inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
	}

	@Override
	public boolean isWaitingForBinaryData() {
		return mPrompt.getIndex().equals(
				Collect.getInstance().getFormController()
						.getIndexWaitingForData());
	}

	@Override
	public void cancelWaitingForBinaryData() {
		Collect.getInstance().getFormController().setIndexWaitingForData(null);
	}

	@Override
	public void setOnLongClickListener(OnLongClickListener l) {
		mCaptureButton.setOnLongClickListener(l);
		mChooseButton.setOnLongClickListener(l);
		mPlayButton.setOnLongClickListener(l);
	}

	@Override
	public void cancelLongPress() {
		super.cancelLongPress();
		mCaptureButton.cancelLongPress();
		mChooseButton.cancelLongPress();
		mPlayButton.cancelLongPress();
	}

}

/*
 * Copyright (C) 2011 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.util.TypedValue;
import android.view.View;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.TextView;

import org.javarosa.core.model.SelectChoice;
import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.SelectMultiData;
import org.javarosa.core.model.data.helper.Selection;
import org.javarosa.form.api.FormEntryPrompt;
import org.javarosa.xpath.expr.XPathFuncExpr;
import org.odk.collect.android.R;
import org.odk.collect.android.external.ExternalDataUtil;
import org.odk.collect.android.utilities.Utils;

import java.util.Vector;

/**
 * SpinnerMultiWidget, like SelectMultiWidget handles multiple selection fields using checkboxes,
 * but the user clicks a button to see the checkboxes. The goal is to be more compact. If images,
 * audio, or video are specified in the select answers they are ignored. WARNING: There is a bug in
 * android versions previous to 2.0 that affects this widget. You can find the report here:
 * http://code.google.com/p/android/issues/detail?id=922 This bug causes text to be white in alert
 * boxes, which makes the select options invisible in this widget. For this reason, this widget
 * should not be used on phones with android versions lower than 2.0.
 *
 * @author Jeff Beorse (jeff@beorse.net)
 */
public class SpinnerMultiWidget extends QuestionWidget {

    Vector<SelectChoice> mItems;

    // The possible select answers
    CharSequence[] answer_items;

    // The button to push to display the answers to choose from
    Button button;

    // Defines which answers are selected
    boolean[] selections;

    // The alert box that contains the answer selection view
    AlertDialog.Builder alert_builder;

    // Displays the current selections below the button
    TextView selectionText;


    @SuppressWarnings("unchecked")
    public SpinnerMultiWidget(final Context context, FormEntryPrompt prompt) {
        super(context, prompt);

        // SurveyCTO-added support for dynamic select content (from .csv files)
        XPathFuncExpr xPathFuncExpr = ExternalDataUtil.getSearchXPathExpression(prompt.getAppearanceHint());
        if (xPathFuncExpr != null) {
            mItems = ExternalDataUtil.populateExternalChoices(prompt, xPathFuncExpr);
        } else {
            mItems = prompt.getSelectChoices();
        }

        mPrompt = prompt;

        selections = new boolean[mItems.size()];
        answer_items = new CharSequence[mItems.size()];
        alert_builder = new AlertDialog.Builder(context);
        button = new Button(context);
        selectionText = new TextView(getContext());

        // Build View
        for (int i = 0; i < mItems.size(); i++) {
            answer_items[i] = prompt.getSelectChoiceText(mItems.get(i));
        }

        selectionText.setText(context.getString(R.string.selected));
        selectionText.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mQuestionFontsize);
        selectionText.setVisibility(View.GONE);

        button.setText(context.getString(R.string.select_answer));
        button.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mQuestionFontsize);
        button.setPadding(0, 0, 0, 7);

        // Give the button a click listener. This defines the alert as well. All the
        // click and selection behavior is defined here.
        button.setOnClickListener(new View.OnClickListener() {
            public void onClick(View v) {
                alert_builder.setTitle(Utils.localize(mPrompt.getQuestionText(), context)).setPositiveButton(R.string.ok,
                    new DialogInterface.OnClickListener() {
                        public void onClick(DialogInterface dialog, int id) {
                            boolean first = true;
                            selectionText.setText("");
                            for (int i = 0; i < selections.length; i++) {
                                if (selections[i]) {

                                    if (first) {
                                        first = false;
                                        selectionText.setText(context.getString(R.string.selected)
                                                + answer_items[i].toString());
                                        selectionText.setVisibility(View.VISIBLE);
                                    } else {
                                        selectionText.setText(selectionText.getText() + ", "
                                                + answer_items[i].toString());
                                    }
                                }
                            }
                        }
                    });

                alert_builder.setMultiChoiceItems(answer_items, selections,
                    new DialogInterface.OnMultiChoiceClickListener() {

                        @Override
                        public void onClick(DialogInterface dialog, int which, boolean isChecked) {
                            selections[which] = isChecked;
                        }
                    });
                AlertDialog alert = alert_builder.create();
                alert.show();
            }
        });

        // Fill in previous answers
        Vector<Selection> ve = new Vector<Selection>();
        if (prompt.getAnswerValue() != null) {
            ve = (Vector<Selection>) prompt.getAnswerValue().getValue();
        }

        if (ve != null) {
            boolean first = true;
            for (int i = 0; i < selections.length; ++i) {

                String value = mItems.get(i).getValue();
                boolean found = false;
                for (Selection s : ve) {
                    if (value.equals(s.getValue())) {
                        found = true;
                        break;
                    }
                }

                selections[i] = found;

                if (found) {
                    if (first) {
                        first = false;
                        selectionText.setText(context.getString(R.string.selected)
                                + answer_items[i].toString());
                        selectionText.setVisibility(View.VISIBLE);
                    } else {
                        selectionText.setText(selectionText.getText() + ", "
                                + answer_items[i].toString());
                    }
                }

            }
        }

        addView(button);
        addView(selectionText);

    }


    @Override
    public IAnswerData getAnswer() {
    	clearFocus();
        Vector<Selection> vc = new Vector<Selection>();
        for (int i = 0; i < mItems.size(); i++) {
            if (selections[i]) {
                SelectChoice sc = mItems.get(i);
                vc.add(new Selection(sc));
            }
        }
        if (vc.size() == 0) {
            return null;
        } else {
            return new SelectMultiData(vc);
        }

    }


    @Override
    public void clearAnswer() {
        selectionText.setText(R.string.selected);
        selectionText.setVisibility(View.GONE);
        for (int i = 0; i < selections.length; i++) {
            selections[i] = false;
        }
    }


    @Override
    public void setFocus(Context context) {
        // Hide the soft keyboard if it's showing.
        InputMethodManager inputManager =
            (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
        inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);

    }


    @Override
    public void setOnLongClickListener(OnLongClickListener l) {
        button.setOnLongClickListener(l);
    }


    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        button.cancelLongPress();
    }

}

/*
 * Copyright (C) 2012 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.graphics.Bitmap;
import android.net.Uri;
import android.provider.MediaStore.Images;
import android.util.Log;
import android.util.TypedValue;
import android.view.Display;
import android.view.View;
import android.view.WindowManager;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TableLayout;
import android.widget.TextView;
import android.widget.Toast;

import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.StringData;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.R;
import org.odk.collect.android.activities.DrawActivity;
import org.odk.collect.android.activities.FormEntryActivity;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.utilities.FileUtils;
import org.odk.collect.android.utilities.MediaUtils;

import java.io.File;

/**
 * Image widget that supports annotations on the image.
 * 
 * @author BehrAtherton@gmail.com
 * @author Carl Hartung (carlhartung@gmail.com)
 * @author Yaw Anokwa (yanokwa@gmail.com)
 * 
 */
public class AnnotateWidget extends QuestionWidget implements IBinaryWidget {
	private final static String t = "AnnotateWidget";

	private Button mCaptureButton;
	private Button mChooseButton;
	private Button mAnnotateButton;
	private ImageView mImageView;

	private String mBinaryName;

	private String mInstanceFolder;

	private TextView mErrorTextView;

	public AnnotateWidget(Context context, FormEntryPrompt prompt) {
		super(context, prompt);

		mInstanceFolder = Collect.getInstance().getFormController()
				.getInstancePath().getParent();

		setOrientation(LinearLayout.VERTICAL);

		TableLayout.LayoutParams params = new TableLayout.LayoutParams();
		params.setMargins(7, 5, 7, 5);

		mErrorTextView = new TextView(context);
		mErrorTextView.setId(QuestionWidget.newUniqueId());
		mErrorTextView.setText("Selected file is not a valid image");

		// setup capture button
		mCaptureButton = new Button(getContext());
		mCaptureButton.setId(QuestionWidget.newUniqueId());
		mCaptureButton.setText(getContext().getString(R.string.capture_image));
		mCaptureButton
				.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
		mCaptureButton.setPadding(20, 20, 20, 20);
		mCaptureButton.setEnabled(!prompt.isReadOnly());
		mCaptureButton.setLayoutParams(params);

		// launch capture intent on click
		mCaptureButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				Collect.getInstance()
						.getActivityLogger()
						.logInstanceAction(this, "captureButton", "click",
								mPrompt.getIndex());
				mErrorTextView.setVisibility(View.GONE);
				Intent i = new Intent(
						android.provider.MediaStore.ACTION_IMAGE_CAPTURE);
				// We give the camera an absolute filename/path where to put the
				// picture because of bug:
				// http://code.google.com/p/android/issues/detail?id=1480
				// The bug appears to be fixed in Android 2.0+, but as of feb 2,
				// 2010, G1 phones only run 1.6. Without specifying the path the
				// images returned by the camera in 1.6 (and earlier) are ~1/4
				// the size. boo.

				// if this gets modified, the onActivityResult in
				// FormEntyActivity will also need to be updated.
				i.putExtra(android.provider.MediaStore.EXTRA_OUTPUT,
						Uri.fromFile(new File(Collect.getInstance().getTmpFilePath())));
				try {
					Collect.getInstance().getFormController()
							.setIndexWaitingForData(mPrompt.getIndex());
					((Activity) getContext()).startActivityForResult(i,
							FormEntryActivity.IMAGE_CAPTURE);
				} catch (ActivityNotFoundException e) {
					Toast.makeText(
							getContext(),
							getContext().getString(R.string.activity_not_found,
									"image capture"), Toast.LENGTH_SHORT)
							.show();
					Collect.getInstance().getFormController()
							.setIndexWaitingForData(null);
				}

			}
		});

		// setup chooser button
		mChooseButton = new Button(getContext());
		mChooseButton.setId(QuestionWidget.newUniqueId());
		mChooseButton.setText(getContext().getString(R.string.choose_image));
		mChooseButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
		mChooseButton.setPadding(20, 20, 20, 20);
		mChooseButton.setEnabled(!prompt.isReadOnly());
		mChooseButton.setLayoutParams(params);

		// launch capture intent on click
		mChooseButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				Collect.getInstance()
						.getActivityLogger()
						.logInstanceAction(this, "chooseButton", "click",
								mPrompt.getIndex());
				mErrorTextView.setVisibility(View.GONE);
				Intent i = new Intent(Intent.ACTION_GET_CONTENT);
				i.setType("image/*");

				try {
					Collect.getInstance().getFormController()
							.setIndexWaitingForData(mPrompt.getIndex());
					((Activity) getContext()).startActivityForResult(i,
							FormEntryActivity.IMAGE_CHOOSER);
				} catch (ActivityNotFoundException e) {
					Toast.makeText(
							getContext(),
							getContext().getString(R.string.activity_not_found,
									"choose image"), Toast.LENGTH_SHORT).show();
					Collect.getInstance().getFormController()
							.setIndexWaitingForData(null);
				}

			}
		});

		// setup Blank Image Button
		mAnnotateButton = new Button(getContext());
		mAnnotateButton.setId(QuestionWidget.newUniqueId());
		mAnnotateButton.setText(getContext().getString(R.string.markup_image));
		mAnnotateButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP,
				mAnswerFontsize);
		mAnnotateButton.setPadding(20, 20, 20, 20);
		mAnnotateButton.setEnabled(false);
		mAnnotateButton.setLayoutParams(params);
		// launch capture intent on click
		mAnnotateButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				Collect.getInstance()
						.getActivityLogger()
						.logInstanceAction(this, "annotateButton", "click",
								mPrompt.getIndex());
				launchAnnotateActivity();
			}
		});

		// finish complex layout
		addView(mCaptureButton);
		addView(mChooseButton);
		addView(mAnnotateButton);
		addView(mErrorTextView);

		// and hide the capture, choose and annotate button if read-only
		if (prompt.isReadOnly()) {
			mCaptureButton.setVisibility(View.GONE);
			mChooseButton.setVisibility(View.GONE);
			mAnnotateButton.setVisibility(View.GONE);
		}
		mErrorTextView.setVisibility(View.GONE);

		// retrieve answer from data model and update ui
		mBinaryName = prompt.getAnswerText();

		// Only add the imageView if the user has taken a picture
		if (mBinaryName != null) {
			if (!prompt.isReadOnly()) {
				mAnnotateButton.setEnabled(true);
			}
			mImageView = new ImageView(getContext());
			mImageView.setId(QuestionWidget.newUniqueId());
			Display display = ((WindowManager) getContext().getSystemService(
					Context.WINDOW_SERVICE)).getDefaultDisplay();
			int screenWidth = display.getWidth();
			int screenHeight = display.getHeight();

			File f = new File(mInstanceFolder + File.separator + mBinaryName);

			if (f.exists()) {
				Bitmap bmp = FileUtils.getBitmapScaledToDisplay(f,
						screenHeight, screenWidth);
				if (bmp == null) {
					mErrorTextView.setVisibility(View.VISIBLE);
				}
				mImageView.setImageBitmap(bmp);
			} else {
				mImageView.setImageBitmap(null);
			}

			mImageView.setPadding(10, 10, 10, 10);
			mImageView.setAdjustViewBounds(true);
			mImageView.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					Collect.getInstance()
							.getActivityLogger()
							.logInstanceAction(this, "viewImage", "click",
									mPrompt.getIndex());
					launchAnnotateActivity();
				}
			});

			addView(mImageView);
		}
	}

	private void launchAnnotateActivity() {
		mErrorTextView.setVisibility(View.GONE);
		Intent i = new Intent(getContext(), DrawActivity.class);
		i.putExtra(DrawActivity.OPTION, DrawActivity.OPTION_ANNOTATE);
		// copy...
		if (mBinaryName != null) {
			File f = new File(mInstanceFolder + File.separator + mBinaryName);
			i.putExtra(DrawActivity.REF_IMAGE, Uri.fromFile(f));
		}
		i.putExtra(DrawActivity.EXTRA_OUTPUT,
				Uri.fromFile(new File(Collect.getInstance().getTmpFilePath())));

		try {
			Collect.getInstance().getFormController()
					.setIndexWaitingForData(mPrompt.getIndex());
			((Activity) getContext()).startActivityForResult(i,
					FormEntryActivity.ANNOTATE_IMAGE);
		} catch (ActivityNotFoundException e) {
			Toast.makeText(
					getContext(),
					getContext().getString(R.string.activity_not_found,
							"annotate image"), Toast.LENGTH_SHORT).show();
			Collect.getInstance().getFormController()
					.setIndexWaitingForData(null);
		}
	}

	private void deleteMedia() {
		// get the file path and delete the file
		String name = mBinaryName;
		// clean up variables
		mBinaryName = null;
		// delete from media provider
		int del = MediaUtils.deleteImageFileFromMediaProvider(mInstanceFolder
				+ File.separator + name);
		Log.i(t, "Deleted " + del + " rows from media content provider");
	}

	@Override
	public void clearAnswer() {
		// remove the file
		deleteMedia();
		mImageView.setImageBitmap(null);
		mErrorTextView.setVisibility(View.GONE);
		if (!mPrompt.isReadOnly()) {
			mAnnotateButton.setEnabled(false);
		}

		// reset buttons
		mCaptureButton.setText(getContext().getString(R.string.capture_image));
	}

	@Override
	public IAnswerData getAnswer() {
		if (mBinaryName != null) {
			return new StringData(mBinaryName.toString());
		} else {
			return null;
		}
	}

	@Override
	public void setBinaryData(Object newImageObj) {
		// you are replacing an answer. delete the previous image using the
		// content provider.
		if (mBinaryName != null) {
			deleteMedia();
		}

		File newImage = (File) newImageObj;
		if (newImage.exists()) {
			// Add the new image to the Media content provider so that the
			// viewing is fast in Android 2.0+
			ContentValues values = new ContentValues(6);
			values.put(Images.Media.TITLE, newImage.getName());
			values.put(Images.Media.DISPLAY_NAME, newImage.getName());
			values.put(Images.Media.DATE_TAKEN, System.currentTimeMillis());
			values.put(Images.Media.MIME_TYPE, "image/jpeg");
			values.put(Images.Media.DATA, newImage.getAbsolutePath());

			Uri imageURI = getContext().getContentResolver().insert(
					Images.Media.EXTERNAL_CONTENT_URI, values);
			Log.i(t, "Inserting image returned uri = " + imageURI.toString());

			mBinaryName = newImage.getName();
			Log.i(t, "Setting current answer to " + newImage.getName());
		} else {
			Log.e(t, "NO IMAGE EXISTS at: " + newImage.getAbsolutePath());
		}

		Collect.getInstance().getFormController().setIndexWaitingForData(null);
	}

	@Override
	public void setFocus(Context context) {
		// Hide the soft keyboard if it's showing.
		InputMethodManager inputManager = (InputMethodManager) context
				.getSystemService(Context.INPUT_METHOD_SERVICE);
		inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
	}

	@Override
	public boolean isWaitingForBinaryData() {
		return mPrompt.getIndex().equals(
				Collect.getInstance().getFormController()
						.getIndexWaitingForData());
	}

	@Override
	public void cancelWaitingForBinaryData() {
		Collect.getInstance().getFormController().setIndexWaitingForData(null);
	}

	@Override
	public void setOnLongClickListener(OnLongClickListener l) {
		mCaptureButton.setOnLongClickListener(l);
		mChooseButton.setOnLongClickListener(l);
		mAnnotateButton.setOnLongClickListener(l);
		if (mImageView != null) {
			mImageView.setOnLongClickListener(l);
		}
	}

	@Override
	public void cancelLongPress() {
		super.cancelLongPress();
		mCaptureButton.cancelLongPress();
		mChooseButton.cancelLongPress();
		mAnnotateButton.cancelLongPress();
		if (mImageView != null) {
			mImageView.cancelLongPress();
		}
	}

}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.content.Context;
import android.database.Cursor;
import android.view.KeyEvent;
import android.view.inputmethod.InputMethodManager;
import android.widget.CompoundButton;
import android.widget.RadioButton;
import android.widget.RadioGroup;
import android.widget.TextView;

import org.javarosa.core.model.FormDef;
import org.javarosa.core.model.condition.EvaluationContext;
import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.StringData;
import org.javarosa.core.model.instance.TreeElement;
import org.javarosa.form.api.FormEntryPrompt;
import org.javarosa.xpath.XPathNodeset;
import org.javarosa.xpath.XPathParseTool;
import org.javarosa.xpath.expr.XPathExpression;
import org.javarosa.xpath.parser.XPathSyntaxException;
import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.database.ItemsetDbAdapter;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;

/**
 * The most basic widget that allows for entry of any text.
 *
 * @author Carl Hartung (carlhartung@gmail.com)
 * @author Yaw Anokwa (yanokwa@gmail.com)
 */
public class ItemsetWidget extends QuestionWidget implements
        android.widget.CompoundButton.OnCheckedChangeListener {

    private static String tag = "ItemsetWidget";

    boolean mReadOnly;
    protected RadioGroup mButtons;
    private String mAnswer = null;
    // Hashmap linking label:value
    private HashMap<String, String> mAnswers;

    public ItemsetWidget(Context context, FormEntryPrompt prompt, boolean readOnlyOverride) {
        this(context, prompt, readOnlyOverride, true);
    }

    protected ItemsetWidget(Context context, FormEntryPrompt prompt, boolean readOnlyOverride,
            boolean derived) {
        super(context, prompt);
        mButtons = new RadioGroup(context);
        mButtons.setId(QuestionWidget.newUniqueId());
        mReadOnly = prompt.isReadOnly() || readOnlyOverride;
        mAnswers = new HashMap<String, String>();

        String currentAnswer = prompt.getAnswerText();

        // the format of the query should be something like this:
        // query="instance('cities')/root/item[state=/data/state and county=/data/county]"

        // "query" is what we're using to notify that this is an
        // itemset widget.
        String nodesetStr = prompt.getQuestion().getAdditionalAttribute(null, "query");

        // parse out the list name, between the ''
        String list_name = nodesetStr.substring(nodesetStr.indexOf("'") + 1,
                nodesetStr.lastIndexOf("'"));

        // isolate the string between between the [ ] characters
        String queryString = nodesetStr.substring(nodesetStr.indexOf("[") + 1,
                nodesetStr.lastIndexOf("]"));

        StringBuilder selection = new StringBuilder();
        // add the list name as the first argument, which will always be there
        selection.append("list_name=?");

        // check to see if there are any arguments
        if (queryString.indexOf("=") != -1) {
            selection.append(" and ");
        }

        // can't just split on 'and' or 'or' because they have different
        // behavior, so loop through and break them off until we don't have any
        // more
        // must include the spaces in indexOf so we don't match words like
        // "land"
        int andIndex = -1;
        int orIndex = -1;
        ArrayList<String> arguments = new ArrayList<String>();
        while ((andIndex = queryString.indexOf(" and ")) != -1
                || (orIndex = queryString.indexOf(" or ")) != -1) {
            if (andIndex != -1) {
                String subString = queryString.substring(0, andIndex);
                String pair[] = subString.split("=");
                if (pair.length == 2) {
                    selection.append(pair[0].trim() + "=? and ");
                    arguments.add(pair[1].trim());
                } else {
                    // parse error
                }
                // move string forward to after " and "
                queryString = queryString.substring(andIndex + 5, queryString.length());
                andIndex = -1;
            } else if (orIndex != -1) {
                String subString = queryString.substring(0, orIndex);
                String pair[] = subString.split("=");
                if (pair.length == 2) {
                    selection.append(pair[0].trim() + "=? or ");
                    arguments.add(pair[1].trim());
                } else {
                    // parse error
                }

                // move string forward to after " or "
                queryString = queryString.substring(orIndex + 4, queryString.length());
                orIndex = -1;
            }
        }

        // parse the last segment (or only segment if there are no 'and' or 'or'
        // clauses
        String pair[] = queryString.split("=");
        if (pair.length == 2) {
            selection.append(pair[0].trim() + "=?");
            arguments.add(pair[1].trim());
        }
        if (pair.length == 1) {
            // this is probably okay, because then you just list all items in
            // the list
        } else {
            // parse error
        }

        // +1 is for the list_name
        String[] selectionArgs = new String[arguments.size() + 1];

        boolean nullArgs = false; // can't have any null arguments
        selectionArgs[0] = list_name; // first argument is always listname

        // loop through the arguments, evaluate any expressions
        // and build the query string for the DB
        for (int i = 0; i < arguments.size(); i++) {
            XPathExpression xpr = null;
            try {
                xpr = XPathParseTool.parseXPath(arguments.get(i));
            } catch (XPathSyntaxException e) {
                e.printStackTrace();
                TextView error = new TextView(context);
                error.setText("XPathParser Exception:  \"" + arguments.get(i) + "\"");
                addView(error);
                break;
            }

            if (xpr != null) {
                FormDef form = Collect.getInstance().getFormController().getFormDef();
                TreeElement mTreeElement = form.getMainInstance().resolveReference(prompt.getIndex().getReference());
                EvaluationContext ec = new EvaluationContext(form.exprEvalContext,
                        mTreeElement.getRef());
                Object value = xpr.eval(form.getMainInstance(), ec);

                if (value == null) {
                    nullArgs = true;
                } else {
	                if (value instanceof XPathNodeset) {
	                    XPathNodeset xpn = (XPathNodeset) value;
	                    value = xpn.getValAt(0);
	                }

	                selectionArgs[i + 1] = value.toString();
                }
            }
        }

        File itemsetFile = new File(Collect.getInstance().getFormController().getMediaFolder().getAbsolutePath() + "/itemsets.csv");
        if (nullArgs) {
            // we can't try to query with null values else it blows up
            // so just leave the screen blank
            // TODO: put an error?
        } else if (itemsetFile.exists()) {
            ItemsetDbAdapter ida = new ItemsetDbAdapter();
            ida.open();

            // name of the itemset table for this form
            String pathHash = ItemsetDbAdapter.getMd5FromString(itemsetFile.getAbsolutePath()); 
            try {
                Cursor c = ida.query(pathHash, selection.toString(), selectionArgs);
                if (c != null) {
                    c.move(-1);
                    while (c.moveToNext()) {
                        String label = "";
                        String val = "";
                        // try to get the value associated with the label:lang
                        // string if that doen't exist, then just use label
                        String lang = "";
                        if (Collect.getInstance().getFormController().getLanguages() != null
                                && Collect.getInstance().getFormController().getLanguages().length > 0) {
                            lang = Collect.getInstance().getFormController().getLanguage();
                        }

                        // apparently you only need the double quotes in the
                        // column name when creating the column with a :
                        // included
                        String labelLang = "label" + "::" + lang;
                        int langCol = c.getColumnIndex(labelLang);
                        if (langCol == -1) {
                            label = c.getString(c.getColumnIndex("label"));
                        } else {
                            label = c.getString(c.getColumnIndex(labelLang));
                        }

                        // the actual value is stored in name
                        val = c.getString(c.getColumnIndex("name"));
                        mAnswers.put(label, val);

                        RadioButton rb = new RadioButton(context);
                        rb.setOnCheckedChangeListener(this);
                        rb.setText(label);
                        rb.setTextSize(mAnswerFontsize);
                        mButtons.addView(rb);
                        // have to add it to the radiogroup before checking it,
                        // else it lets two buttons be checked...
                        if (currentAnswer != null
                                && val.compareTo(currentAnswer) == 0) {
                            rb.setChecked(true);
                        }
                    }
                    c.close();
                }
            } finally {
                ida.close();
            }

            addView(mButtons);
        } else {
            TextView error = new TextView(context);
            error.setText(getContext().getString(R.string.file_missing, itemsetFile.getAbsolutePath()));
            addView(error);
        }

    }

    @Override
    public void clearAnswer() {
        mButtons.clearCheck();
        mAnswer = null;
    }

    @Override
    public IAnswerData getAnswer() {
        if (mAnswer == null) {
            return null;
        } else {
            return new StringData(mAnswer);
        }
    }

    @Override
    public void setFocus(Context context) {
        // Hide the soft keyboard if it's showing.
        InputMethodManager inputManager = (InputMethodManager) context
                .getSystemService(Context.INPUT_METHOD_SERVICE);
        inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (event.isAltPressed() == true) {
            return false;
        }
        return super.onKeyDown(keyCode, event);
    }

    @Override
    public void setOnLongClickListener(OnLongClickListener l) {
        mButtons.setOnLongClickListener(l);
        for (int i = 0; i < mButtons.getChildCount(); i++) {
            mButtons.getChildAt(i).setOnLongClickListener(l);
        }
    }

    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        mButtons.cancelLongPress();
        for (int i = 0; i < mButtons.getChildCount(); i++) {
            mButtons.getChildAt(i).cancelLongPress();
        }
    }

    @Override
    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
        if (isChecked) {
            mAnswer = mAnswers.get((String) buttonView.getText());
        }
    }

}

/*
 * Copyright (C) 2009 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

/**
 * Interface implemented by widgets that need binary data.
 * 
 * @author Carl Hartung (carlhartung@gmail.com)
 */
public interface IBinaryWidget {
    public void setBinaryData(Object answer);
    public void cancelWaitingForBinaryData();
    public boolean isWaitingForBinaryData();
}

/*TODO carlhartung:  we might want to move this into the QuestionWidget abstract class? 
 * 
 */

/*
 * Copyright (C) 2012 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Context;
import android.content.Intent;
import android.text.InputFilter;
import android.text.InputType;
import android.text.method.DigitsKeyListener;

import org.javarosa.core.model.data.DecimalData;
import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.activities.FormEntryActivity;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.external.ExternalAppsUtils;

import java.text.NumberFormat;


/**
 * Launch an external app to supply a decimal value. If the app
 * does not launch, enable the text area for regular data entry.
 *
 * See {@link org.odk.collect.android.widgets.ExStringWidget} for usage.
 *
 * @author mitchellsundt@gmail.com
 *
 */
public class ExDecimalWidget extends ExStringWidget {

	private Double getDoubleAnswerValue() {
		IAnswerData dataHolder = mPrompt.getAnswerValue();
        Double d = null;
        if (dataHolder != null) {
        	Object dataValue = dataHolder.getValue();
        	if ( dataValue != null ) {
        		if (dataValue instanceof Integer){
	                d =  Double.valueOf(((Integer)dataValue).intValue());
	            } else {
	                d =  (Double) dataValue;
	            }
        	}
        }
        return d;
	}

    public ExDecimalWidget(Context context, FormEntryPrompt prompt) {
        super(context, prompt);

        mAnswer.setInputType(InputType.TYPE_NUMBER_FLAG_DECIMAL);

        // only allows numbers and no periods
        mAnswer.setKeyListener(new DigitsKeyListener(true, true));

        // only 15 characters allowed
        InputFilter[] fa = new InputFilter[1];
        fa[0] = new InputFilter.LengthFilter(15);
        mAnswer.setFilters(fa);

        Double d = getDoubleAnswerValue();

        // apparently an attempt at rounding to no more than 15 digit precision???
        NumberFormat nf = NumberFormat.getNumberInstance();
        nf.setMaximumFractionDigits(15);
        nf.setMaximumIntegerDigits(15);
        nf.setGroupingUsed(false);
        if (d != null) {
        	// truncate to 15 digits max...
            String dString = nf.format(d);
            d = Double.parseDouble(dString.replace(',', '.')); // in case , is decimal pt
            mAnswer.setText(d.toString());
        }
    }


    @Override
    protected void fireActivity(Intent i) throws ActivityNotFoundException {
    	i.putExtra("value", getDoubleAnswerValue());
       	Collect.getInstance().getActivityLogger().logInstanceAction(this, "launchIntent",
    			i.getAction(), mPrompt.getIndex());
        ((Activity) getContext()).startActivityForResult(i,
                FormEntryActivity.EX_DECIMAL_CAPTURE);
    }


    @Override
    public IAnswerData getAnswer() {
        String s = mAnswer.getText().toString();
        if (s == null || s.equals("")) {
            return null;
        } else {
            try {
                return new DecimalData(Double.valueOf(s).doubleValue());
            } catch (Exception NumberFormatException) {
                return null;
            }
        }
    }


    /**
     * Allows answer to be set externally in {@Link FormEntryActivity}.
     */
    @Override
    public void setBinaryData(Object answer) {
        DecimalData decimalData = ExternalAppsUtils.asDecimalData(answer);
        mAnswer.setText( decimalData == null ? null : decimalData.getValue().toString());
    	Collect.getInstance().getFormController().setIndexWaitingForData(null);
    }

}

/*
 * Copyright (C) 2012 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.TypedValue;
import android.view.KeyEvent;
import android.view.View;
import android.widget.Button;
import android.widget.TableLayout;
import android.widget.Toast;

import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;


/**
 * <p>Use the ODK Sensors framework to print data to a connected printer.</p>
 *
 * <p>The default button text is "Print Label"
 *
 * <p>You may override the button text and the error text that is
 * displayed when the app is missing by using jr:itext() values. The
 * special itext form values are 'buttonText' and 'noPrinterErrorString',
 * respectively.</p>
 *
 * <p>To use via XLSForm, specify a 'note' type with a 'calculation' that defines
 * the data to be printed and with an 'appearance' as described below.
 *
 * <p>Within the XForms XML, to use this widget, define an appearance on the
 * &lt;input/&gt; tag that begins "printer:" and then contains the intent
 * action to launch. That intent starts the printer app. The data to print
 * is sent via a broadcast intent to intentname.data The printer then pops
 * a UI to initiate the actual printing (or change the destination printer).
 * </p>
 *
 * <p>Implementation-wise, this widget is an ExStringWidget that is read-only.</p>
 *
 * <p>The ODK Sensors Zebra printer uses this appearance (intent):</p>
 * <pre>
 * "printer:org.opendatakit.sensors.ZebraPrinter"
 * </pre>
 *
 * <p>The data that is printed should be defined in the calculate attribute
 * of the bind. The structure of that string is a &lt;br&gt; separated list
 * of values consisting of:</p>
 * <ul><li>numeric barcode to emit (optional)</li>
 * <li>string qrcode to emit (optional)</li>
 * <li>text line 1 (optional)</li>
 * <li>additional text line (repeat as needed)</li></ul>
 *
 * <p>E.g., if you wanted to emit a barcode of 123, a qrcode of "mycode" and
 * two text lines of "line 1" and "line 2", you would define the calculate
 * as:</p>
 *
 * <pre>
 *  &lt;bind nodeset="/printerForm/printme" type="string" readonly="true()"
 *     calculate="concat('123','&lt;br&gt;','mycode','&lt;br&gt;','line 1','&lt;br&gt;','line 2')" /&gt;
 * </pre>
 *
 * <p>Depending upon what you supply, the printer may print just a
 * barcode, just a qrcode, just text, or some combination of all 3.</p>
 *
 * <p>Despite using &lt;br&gt; as a separator, the supplied Zebra
 * printer does not recognize html.</p>
 *
 * <pre>
 * &lt;input appearance="ex:change.uw.android.TEXTANSWER" ref="/printerForm/printme" &gt;
 * </pre>
 * <p>or, to customize the button text and error strings with itext:
 * <pre>
 *      ...
 *      &lt;bind nodeset="/printerForm/printme" type="string" readonly="true()" calculate="concat('&lt;br&gt;',
 *       /printerForm/some_text ,'&lt;br&gt;Text: ', /printerForm/shortened_text ,'&lt;br&gt;Integer: ',
 *       /printerForm/a_integer ,'&lt;br&gt;Decimal: ', /printerForm/a_decimal )"/&gt;
 *      ...
 *      &lt;itext&gt;
 *        &lt;translation lang="English"&gt;
 *          &lt;text id="printAnswer"&gt;
 *            &lt;value form="short"&gt;Print your label&lt;/value&gt;
 *            &lt;value form="long"&gt;Print your label&lt;/value&gt;
 *            &lt;value form="buttonText"&gt;Print now&lt;/value&gt;
 *            &lt;value form="noPrinterErrorString"&gt;ODK Sensors Zebra Printer is not installed!
 *             Please install ODK Sensors Framework and ODK Sensors Zebra Printer from Google Play.&lt;/value&gt;
 *          &lt;/text&gt;
 *        &lt;/translation&gt;
 *      &lt;/itext&gt;
 *    ...
 *    &lt;input appearance="printer:org.opendatakit.sensors.ZebraPrinter" ref="/form/printme"&gt;
 *      &lt;label ref="jr:itext('printAnswer')"/&gt;
 *    &lt;/input&gt;
 * </pre>
 *
 * @author mitchellsundt@gmail.com
 *
 */
public class ExPrinterWidget extends QuestionWidget implements IBinaryWidget {

    private Button mLaunchIntentButton;

    public ExPrinterWidget(Context context, FormEntryPrompt prompt) {
        super(context, prompt);

        TableLayout.LayoutParams params = new TableLayout.LayoutParams();
        params.setMargins(7, 5, 7, 5);

        String appearance = prompt.getAppearanceHint();
        String[] attrs = appearance.split(":");
        final String intentName = (attrs.length < 2 || attrs[1].length() == 0) ? "org.opendatakit.sensors.ZebraPrinter" : attrs[1];
        final String buttonText;
        final String errorString;
    	String v = mPrompt.getSpecialFormQuestionText("buttonText");
    	buttonText = (v != null) ? v : context.getString(R.string.launch_printer);
    	v = mPrompt.getSpecialFormQuestionText("noPrinterErrorString");
    	errorString = (v != null) ? v : context.getString(R.string.no_printer);

        // set button formatting
        mLaunchIntentButton = new Button(getContext());
        mLaunchIntentButton.setId(QuestionWidget.newUniqueId());
        mLaunchIntentButton.setText(buttonText);
        mLaunchIntentButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
        mLaunchIntentButton.setPadding(20, 20, 20, 20);
        mLaunchIntentButton.setLayoutParams(params);

        mLaunchIntentButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                try {
                	Collect.getInstance().getFormController().setIndexWaitingForData(mPrompt.getIndex());
                	firePrintingActivity(intentName);
                } catch (ActivityNotFoundException e) {
                	Collect.getInstance().getFormController().setIndexWaitingForData(null);
                    Toast.makeText(getContext(),
                    		errorString, Toast.LENGTH_SHORT)
                            .show();
                }
            }
        });

        // finish complex layout
        addView(mLaunchIntentButton);
    }

    protected void firePrintingActivity(String intentName) throws ActivityNotFoundException {

        String s = mPrompt.getAnswerText();

       	Collect.getInstance().getActivityLogger().logInstanceAction(this, "launchPrinter",
       			intentName, mPrompt.getIndex());
       	Intent i = new Intent(intentName);
       	((Activity) getContext()).startActivity(i);

       	String[] splits;
       	if ( s != null ) {
       		splits = s.split("<br>");
       	} else {
       		splits = null;
       	}

    	Bundle printDataBundle = new Bundle();

    	String e;
    	if (splits != null) {
    		if ( splits.length >= 1 ) {
    			e = splits[0];
    			if ( e.length() > 0) {
    				printDataBundle.putString("BARCODE", e);
    			}
    		}
    		if ( splits.length >= 2 ) {
    			e = splits[1];
    			if ( e.length() > 0) {
    				printDataBundle.putString("QRCODE", e);
    			}
    		}
    		if ( splits.length > 2 ) {
	    		String[] text = new String[splits.length-2];
	    		for ( int j = 2 ; j < splits.length ; ++j ) {
	    			e = splits[j];
	    			text[j-2] = e;
	    		}
				printDataBundle.putStringArray("TEXT-STRINGS", text);
    		}
    	}

    	//send the printDataBundle to the activity via broadcast intent
    	Intent bcastIntent = new Intent(intentName + ".data");
    	bcastIntent.putExtra("DATA", printDataBundle);
    	((Activity) getContext()).sendBroadcast(bcastIntent);
    }

    @Override
    public void clearAnswer() {
    }


    @Override
    public IAnswerData getAnswer() {
    	return mPrompt.getAnswerValue();
    }


    /**
     * Allows answer to be set externally in {@Link FormEntryActivity}.
     */
    @Override
    public void setBinaryData(Object answer) {
    	Collect.getInstance().getFormController().setIndexWaitingForData(null);
    }

    @Override
    public void setFocus(Context context) {
        // focus on launch button
        mLaunchIntentButton.requestFocus();
    }


    @Override
    public boolean isWaitingForBinaryData() {
        return mPrompt.getIndex().equals(Collect.getInstance().getFormController().getIndexWaitingForData());
    }

	@Override
	public void cancelWaitingForBinaryData() {
    	Collect.getInstance().getFormController().setIndexWaitingForData(null);
	}

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (event.isAltPressed() == true) {
            return false;
        }
        return super.onKeyDown(keyCode, event);
    }

    @Override
    public void setOnLongClickListener(OnLongClickListener l) {
        mLaunchIntentButton.setOnLongClickListener(l);
    }

    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        mLaunchIntentButton.cancelLongPress();
    }


}

/*
 * Copyright (C) 2011 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;

import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.utilities.Utils;
import org.odk.collect.android.views.MediaLayout;

import java.util.ArrayList;
import java.util.List;

public abstract class QuestionWidget extends LinearLayout {

    @SuppressWarnings("unused")
    private final static String t = "QuestionWidget";

	private static int idGenerator = 1211322;

	/**
	 * Generate a unique ID to keep Android UI happy when the screen orientation
	 * changes.
	 *
	 * @return
	 */
	public static int newUniqueId() {
		return ++idGenerator;
	}

    private LinearLayout.LayoutParams mLayoutParams;
    protected FormEntryPrompt mPrompt;

    protected final int mQuestionFontsize;
    protected final int mAnswerFontsize;

    private TextView mQuestionText;
    private MediaLayout mediaLayout;
    private TextView mHelpText;


    public QuestionWidget(Context context, FormEntryPrompt p) {
        super(context);

        mQuestionFontsize = Collect.getQuestionFontsize();

        // Make the answer field fairly large.
        mAnswerFontsize = mQuestionFontsize * 2;

        mPrompt = p;

        setOrientation(LinearLayout.VERTICAL);
        setGravity(Gravity.TOP);
        setPadding(0, 7, 0, 0);

        mLayoutParams =
            new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT);
        mLayoutParams.setMargins(10, 10, 10, 0);

        addQuestionText(p);
//        addHelpText(p);
    }

    public void playAudio() {
    	mediaLayout.playAudio();
    }

    public void playVideo() {
    	mediaLayout.playVideo();
    }

    public FormEntryPrompt getPrompt() {
        return mPrompt;
    }

   	// http://code.google.com/p/android/issues/detail?id=8488
    private void recycleDrawablesRecursive(ViewGroup viewGroup, List<ImageView> images) {

        int childCount = viewGroup.getChildCount();
        for(int index = 0; index < childCount; index++)
        {
          View child = viewGroup.getChildAt(index);
          if ( child instanceof ImageView ) {
        	  images.add((ImageView)child);
          } else if ( child instanceof ViewGroup ) {
        	  recycleDrawablesRecursive((ViewGroup) child, images);
          }
        }
        viewGroup.destroyDrawingCache();
    }

   	// http://code.google.com/p/android/issues/detail?id=8488
    public void recycleDrawables() {
    	List<ImageView> images = new ArrayList<ImageView>();
    	// collect all the image views
    	recycleDrawablesRecursive(this, images);
    	for ( ImageView imageView : images ) {
    		imageView.destroyDrawingCache();
    		Drawable d = imageView.getDrawable();
    		if ( d != null && d instanceof BitmapDrawable) {
    			imageView.setImageDrawable(null);
    			BitmapDrawable bd = (BitmapDrawable) d;
    			Bitmap bmp = bd.getBitmap();
    			if ( bmp != null ) {
    				bmp.recycle();
    			}
    		}
    	}
    }

    public boolean forceSetAnswer(Object answer) {
        return false;
    }

    // Abstract methods
    public abstract IAnswerData getAnswer();


    public abstract void clearAnswer();


    public abstract void setFocus(Context context);


    public abstract void setOnLongClickListener(OnLongClickListener l);

    /**
     * Override this to implement fling gesture suppression (e.g. for embedded WebView treatments).
     * @param e1
     * @param e2
     * @param velocityX
     * @param velocityY
     * @return true if the fling gesture should be suppressed
     */
    public boolean suppressFlingGesture(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
    	return false;
    }

    /**
     * Add a Views containing the question text, audio (if applicable), and image (if applicable).
     * To satisfy the RelativeLayout constraints, we add the audio first if it exists, then the
     * TextView to fit the rest of the space, then the image if applicable.
     */
    protected void addQuestionText(FormEntryPrompt p) {
        String imageURI = p.getImageText();
        String audioURI = p.getAudioText();
        String videoURI = p.getSpecialFormQuestionText("video");

        // shown when image is clicked
        String bigImageURI = p.getSpecialFormQuestionText("big-image");

        String promptText = p.getLongText();
        // Add the text view. Textview always exists, regardless of whether there's text.
        mQuestionText = (TextView) LayoutInflater.from(getContext())
                .inflate(R.layout.template_text_view_question, null);

        // TODO: Un-unscreamify once server work is done.

        mQuestionText.setText(promptText == null ? "" : Utils.localize(promptText, getContext()));

//        mQuestionText.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mQuestionFontsize);
//        mQuestionText.setTypeface(null, Typeface.BOLD);
//        mQuestionText.setPadding(0, 0, 0, 7);
        mQuestionText.setId(QuestionWidget.newUniqueId()); // assign random id

        // Wrap to the size of the parent view
//        mQuestionText.setHorizontallyScrolling(false);
//        mQuestionText.setLayoutParams(mLayoutParams);

        if (promptText == null || promptText.length() == 0) {
            mQuestionText.setVisibility(GONE);
        }

        // Create the layout for audio, image, text
        mediaLayout = new MediaLayout(getContext());
        mediaLayout.setAVT(p.getIndex(), "", mQuestionText, audioURI, imageURI, videoURI, bigImageURI);

        addView(mediaLayout, mLayoutParams);
    }

//
//    /**
//     * Add a TextView containing the help text.
//     */
//    private void addHelpText(FormEntryPrompt p) {
//
//        String s = p.getHelpText();
//
//        if (s != null && !s.equals("")) {
//            mHelpText = new TextView(getContext());
//            mHelpText.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mQuestionFontsize - 3);
//            mHelpText.setPadding(0, -5, 0, 7);
//            // wrap to the widget of view
//            mHelpText.setHorizontallyScrolling(false);
//            mHelpText.setText(s);
//            mHelpText.setTypeface(null, Typeface.ITALIC);
//
//            addView(mHelpText, mLayoutParams);
//        }
//    }
//

    /**
     * Every subclassed widget should override this, adding any views they may contain, and calling
     * super.cancelLongPress()
     */
    public void cancelLongPress() {
        super.cancelLongPress();
        if (mQuestionText != null) {
            mQuestionText.cancelLongPress();
        }
        if (mHelpText != null) {
            mHelpText.cancelLongPress();
        }
    }

}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.View;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.TableLayout;
import android.widget.TextView;

import org.javarosa.core.model.data.GeoPointData;
import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.R;
import org.odk.collect.android.activities.FormEntryActivity;
import org.odk.collect.android.activities.GeoPointActivity;
import org.odk.collect.android.application.Collect;

import java.text.DecimalFormat;

/**
 * GeoPointWidget is the widget that allows the user to get GPS readings.
 *
 * @author Carl Hartung (carlhartung@gmail.com)
 * @author Yaw Anokwa (yanokwa@gmail.com)
 */
public class GeoPointWidget extends QuestionWidget implements IBinaryWidget {
	public static final String LOCATION = "gp";
	public static final String ACCURACY_THRESHOLD = "accuracyThreshold";
	public static final String READ_ONLY = "readOnly";

	public static final double DEFAULT_LOCATION_ACCURACY = 5.0;

	private Button mGetLocationButton;

	private TextView mStringAnswer;
	private TextView mAnswerDisplay;
	private final boolean mReadOnly;
	private String mAppearance;
	private double mAccuracyThreshold;

	public GeoPointWidget(Context context, FormEntryPrompt prompt) {
		super(context, prompt);

		// Determine the activity threshold to use
		String acc = prompt.getQuestion().getAdditionalAttribute(null, ACCURACY_THRESHOLD);
		if ( acc != null && acc.length() != 0 ) {
			mAccuracyThreshold = Double.parseDouble(acc);
		} else {
			mAccuracyThreshold = DEFAULT_LOCATION_ACCURACY;
		}

		// Determine whether or not to use the plain, maps, or mapsV2 activity
		mAppearance = prompt.getAppearanceHint();

		mReadOnly = prompt.isReadOnly();

		// assemble the widget...
		setOrientation(LinearLayout.VERTICAL);
		TableLayout.LayoutParams params = new TableLayout.LayoutParams();
		params.setMargins(7, 5, 7, 5);

		mStringAnswer = new TextView(getContext());
		mStringAnswer.setId(QuestionWidget.newUniqueId());

		mAnswerDisplay = new TextView(getContext());
		mAnswerDisplay.setId(QuestionWidget.newUniqueId());
		mAnswerDisplay
				.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
		mAnswerDisplay.setGravity(Gravity.CENTER);

		mGetLocationButton = new Button(getContext());
		mGetLocationButton.setId(QuestionWidget.newUniqueId());
		mGetLocationButton.setPadding(20, 20, 20, 20);
		mGetLocationButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP,
				mAnswerFontsize);
		mGetLocationButton.setEnabled(!prompt.isReadOnly());
		mGetLocationButton.setLayoutParams(params);

		// when you press the button
		mGetLocationButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				Collect.getInstance()
						.getActivityLogger()
						.logInstanceAction(this, "recordLocation", "click",
								mPrompt.getIndex());
				Intent i = null;
			    i = new Intent(getContext(), GeoPointActivity.class);

				String s = mStringAnswer.getText().toString();
				if ( s.length() != 0 ) {
					String[] sa = s.split(" ");
					double gp[] = new double[4];
					gp[0] = Double.valueOf(sa[0]).doubleValue();
					gp[1] = Double.valueOf(sa[1]).doubleValue();
					gp[2] = Double.valueOf(sa[2]).doubleValue();
					gp[3] = Double.valueOf(sa[3]).doubleValue();
					i.putExtra(LOCATION, gp);
				}
				i.putExtra(READ_ONLY, mReadOnly);
				i.putExtra(ACCURACY_THRESHOLD, mAccuracyThreshold);
				Collect.getInstance().getFormController()
						.setIndexWaitingForData(mPrompt.getIndex());
				((Activity) getContext()).startActivityForResult(i,
						FormEntryActivity.LOCATION_CAPTURE);
			}
		});

		// finish complex layout
		// control what gets shown with setVisibility(View.GONE)
		addView(mGetLocationButton);
		addView(mAnswerDisplay);

		// figure out what text and buttons to enable or to show...
		boolean dataAvailable = false;
		String s = prompt.getAnswerText();
		if (s != null && !s.equals("")) {
			dataAvailable = true;
			setBinaryData(s);
		}
		updateButtonLabelsAndVisibility(dataAvailable);

	}

	private void updateButtonLabelsAndVisibility(boolean dataAvailable) {
        // if it is read-only, hide the get-location button...
        if ( mReadOnly ) {
            mGetLocationButton.setVisibility(View.GONE);
        } else {
            mGetLocationButton.setVisibility(View.VISIBLE);
            mGetLocationButton.setText(getContext()
                    .getString(dataAvailable ?
                            R.string.replace_location : R.string.get_location));
        }

	}

	@Override
	public void clearAnswer() {
		mStringAnswer.setText(null);
		mAnswerDisplay.setText(null);
		updateButtonLabelsAndVisibility(false);
	}

	@Override
	public IAnswerData getAnswer() {
		String s = mStringAnswer.getText().toString();
		if (s == null || s.equals("")) {
			return null;
		} else {
			try {
				// segment lat and lon
				String[] sa = s.split(" ");
				double gp[] = new double[4];
				gp[0] = Double.valueOf(sa[0]).doubleValue();
				gp[1] = Double.valueOf(sa[1]).doubleValue();
				gp[2] = Double.valueOf(sa[2]).doubleValue();
				gp[3] = Double.valueOf(sa[3]).doubleValue();

				return new GeoPointData(gp);
			} catch (Exception NumberFormatException) {
				return null;
			}
		}
	}

	private String truncateDouble(String s) {
		DecimalFormat df = new DecimalFormat("#.##");
		return df.format(Double.valueOf(s));
	}

	private String formatGps(double coordinates, String type) {
		String location = Double.toString(coordinates);
		String degreeSign = "\u00B0";
		String degree = location.substring(0, location.indexOf("."))
				+ degreeSign;
		location = "0." + location.substring(location.indexOf(".") + 1);
		double temp = Double.valueOf(location) * 60;
		location = Double.toString(temp);
		String mins = location.substring(0, location.indexOf(".")) + "'";

		location = "0." + location.substring(location.indexOf(".") + 1);
		temp = Double.valueOf(location) * 60;
		location = Double.toString(temp);
		String secs = location.substring(0, location.indexOf(".")) + '"';
		if (type.equalsIgnoreCase("lon")) {
			if (degree.startsWith("-")) {
				degree = "W " + degree.replace("-", "") + mins + secs;
			} else
				degree = "E " + degree.replace("-", "") + mins + secs;
		} else {
			if (degree.startsWith("-")) {
				degree = "S " + degree.replace("-", "") + mins + secs;
			} else
				degree = "N " + degree.replace("-", "") + mins + secs;
		}
		return degree;
	}

	@Override
	public void setFocus(Context context) {
		// Hide the soft keyboard if it's showing.
		InputMethodManager inputManager = (InputMethodManager) context
				.getSystemService(Context.INPUT_METHOD_SERVICE);
		inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
	}

	@Override
	public void setBinaryData(Object answer) {
		String s = (String) answer;
		mStringAnswer.setText(s);

		String[] sa = s.split(" ");
		mAnswerDisplay.setText(getContext().getString(R.string.latitude) + ": "
				+ formatGps(Double.parseDouble(sa[0]), "lat") + "\n"
				+ getContext().getString(R.string.longitude) + ": "
				+ formatGps(Double.parseDouble(sa[1]), "lon") + "\n"
				+ getContext().getString(R.string.altitude) + ": "
				+ truncateDouble(sa[2]) + "m\n"
				+ getContext().getString(R.string.accuracy) + ": "
				+ truncateDouble(sa[3]) + "m");
		Collect.getInstance().getFormController().setIndexWaitingForData(null);
		updateButtonLabelsAndVisibility(true);
	}

	@Override
	public boolean isWaitingForBinaryData() {
		return mPrompt.getIndex().equals(
				Collect.getInstance().getFormController()
						.getIndexWaitingForData());
	}

	@Override
	public void cancelWaitingForBinaryData() {
		Collect.getInstance().getFormController().setIndexWaitingForData(null);
	}

	@Override
	public void setOnLongClickListener(OnLongClickListener l) {
		mGetLocationButton.setOnLongClickListener(l);
		mStringAnswer.setOnLongClickListener(l);
		mAnswerDisplay.setOnLongClickListener(l);
	}

	@Override
	public void cancelLongPress() {
		super.cancelLongPress();
		mGetLocationButton.cancelLongPress();
		mStringAnswer.cancelLongPress();
		mAnswerDisplay.cancelLongPress();
	}

}

/*
 * Copyright (C) 2013 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.ComponentName;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.graphics.Bitmap;
import android.net.Uri;
import android.provider.MediaStore.Images;
import android.util.Log;
import android.util.TypedValue;
import android.view.Display;
import android.view.View;
import android.view.WindowManager;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TableLayout;
import android.widget.TextView;
import android.widget.Toast;

import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.StringData;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.R;
import org.odk.collect.android.activities.FormEntryActivity;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.utilities.FileUtils;
import org.odk.collect.android.utilities.MediaUtils;

import java.io.File;

/**
 * Widget that allows user to invoke the aligned-image camera to take pictures and add them to the form.
 * Modified to launch the Aligned-image camera app.
 *
 * @author Carl Hartung (carlhartung@gmail.com)
 * @author Yaw Anokwa (yanokwa@gmail.com)
 * @author mitchellsundt@gmail.com
 * @author Mitchell Tyler Lee
 */
public class AlignedImageWidget extends QuestionWidget implements IBinaryWidget {
    private static final String ODK_CAMERA_TAKE_PICTURE_INTENT_COMPONENT = "org.opendatakit.camera.TakePicture";

	private static final String ODK_CAMERA_INTENT_PACKAGE = "org.opendatakit.camera";

	private static final String RETAKE_OPTION_EXTRA = "retakeOption";

	private static final String DIMENSIONS_EXTRA = "dimensions";

	private static final String FILE_PATH_EXTRA = "filePath";

	private final static String t = "AlignedImageWidget";

    private Button mCaptureButton;
    private Button mChooseButton;
    private ImageView mImageView;

    private String mBinaryName;

    private String mInstanceFolder;

    private TextView mErrorTextView;

    private int iArray[] = new int[6];

    public AlignedImageWidget(Context context, FormEntryPrompt prompt) {
        super(context, prompt);

        String appearance = prompt.getAppearanceHint();
        String alignments = appearance.substring(appearance.indexOf(":") + 1);
        String[] splits = alignments.split(" ");
        if ( splits.length != 6 ) {
        	Log.w(t, "Only have " + splits.length + " alignment values");
        }
        for ( int i = 0 ; i < 6 ; ++i ) {
        	if ( splits.length < i ) {
        		iArray[i] = 0;
        	} else {
        		iArray[i] = Integer.valueOf(splits[i]);
        	}
        }

        mInstanceFolder =
                Collect.getInstance().getFormController().getInstancePath().getParent();

        setOrientation(LinearLayout.VERTICAL);

        TableLayout.LayoutParams params = new TableLayout.LayoutParams();
        params.setMargins(7, 5, 7, 5);

        mErrorTextView = new TextView(context);
        mErrorTextView.setId(QuestionWidget.newUniqueId());
        mErrorTextView.setText("Selected file is not a valid image");

        // setup capture button
        mCaptureButton = new Button(getContext());
        mCaptureButton.setId(QuestionWidget.newUniqueId());
        mCaptureButton.setText(getContext().getString(R.string.capture_image));
        mCaptureButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
        mCaptureButton.setPadding(20, 20, 20, 20);
        mCaptureButton.setEnabled(!prompt.isReadOnly());
        mCaptureButton.setLayoutParams(params);

        // launch capture intent on click
        mCaptureButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
               	Collect.getInstance().getActivityLogger().logInstanceAction(this, "captureButton",
            			"click", mPrompt.getIndex());
                mErrorTextView.setVisibility(View.GONE);

                Intent i = new Intent();
                i.setComponent(new ComponentName(ODK_CAMERA_INTENT_PACKAGE,
                					ODK_CAMERA_TAKE_PICTURE_INTENT_COMPONENT));
                i.putExtra(FILE_PATH_EXTRA, Collect.getInstance().getCachePath());
                i.putExtra(DIMENSIONS_EXTRA, iArray);
                i.putExtra(RETAKE_OPTION_EXTRA, false);

                // We give the camera an absolute filename/path where to put the
                // picture because of bug:
                // http://code.google.com/p/android/issues/detail?id=1480
                // The bug appears to be fixed in Android 2.0+, but as of feb 2,
                // 2010, G1 phones only run 1.6. Without specifying the path the
                // images returned by the camera in 1.6 (and earlier) are ~1/4
                // the size. boo.

                // if this gets modified, the onActivityResult in
                // FormEntyActivity will also need to be updated.
                try {
                	Collect.getInstance().getFormController().setIndexWaitingForData(mPrompt.getIndex());
                    ((Activity) getContext()).startActivityForResult(i,
                        FormEntryActivity.ALIGNED_IMAGE);
                } catch (ActivityNotFoundException e) {
                    Toast.makeText(getContext(),
                        getContext().getString(R.string.activity_not_found, "aligned image capture"),
                        Toast.LENGTH_SHORT).show();
                	Collect.getInstance().getFormController().setIndexWaitingForData(null);
                }

            }
        });

        // setup chooser button
        mChooseButton = new Button(getContext());
        mChooseButton.setId(QuestionWidget.newUniqueId());
        mChooseButton.setText(getContext().getString(R.string.choose_image));
        mChooseButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
        mChooseButton.setPadding(20, 20, 20, 20);
        mChooseButton.setEnabled(!prompt.isReadOnly());
        mChooseButton.setLayoutParams(params);

        // launch capture intent on click
        mChooseButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
               	Collect.getInstance().getActivityLogger().logInstanceAction(this, "chooseButton",
            			"click", mPrompt.getIndex());
                mErrorTextView.setVisibility(View.GONE);
                Intent i = new Intent(Intent.ACTION_GET_CONTENT);
                i.setType("image/*");

                try {
					Collect.getInstance().getFormController()
							.setIndexWaitingForData(mPrompt.getIndex());
                    ((Activity) getContext()).startActivityForResult(i,
                        FormEntryActivity.IMAGE_CHOOSER);
                } catch (ActivityNotFoundException e) {
                    Toast.makeText(getContext(),
                        getContext().getString(R.string.activity_not_found, "choose image"),
                        Toast.LENGTH_SHORT).show();
                	Collect.getInstance().getFormController().setIndexWaitingForData(null);
                }

            }
        });

        // finish complex layout
        addView(mCaptureButton);
        addView(mChooseButton);
        addView(mErrorTextView);

        // and hide the capture and choose button if read-only
        if ( prompt.isReadOnly() ) {
        	mCaptureButton.setVisibility(View.GONE);
        	mChooseButton.setVisibility(View.GONE);
        }
        mErrorTextView.setVisibility(View.GONE);

        // retrieve answer from data model and update ui
        mBinaryName = prompt.getAnswerText();

        // Only add the imageView if the user has taken a picture
        if (mBinaryName != null) {
            mImageView = new ImageView(getContext());
            mImageView.setId(QuestionWidget.newUniqueId());
            Display display =
                ((WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE))
                        .getDefaultDisplay();
            int screenWidth = display.getWidth();
            int screenHeight = display.getHeight();

            File f = new File(mInstanceFolder + File.separator + mBinaryName);

            if (f.exists()) {
                Bitmap bmp = FileUtils.getBitmapScaledToDisplay(f, screenHeight, screenWidth);
                if (bmp == null) {
                    mErrorTextView.setVisibility(View.VISIBLE);
                }
                mImageView.setImageBitmap(bmp);
            } else {
                mImageView.setImageBitmap(null);
            }

            mImageView.setPadding(10, 10, 10, 10);
            mImageView.setAdjustViewBounds(true);
            mImageView.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                   	Collect.getInstance().getActivityLogger().logInstanceAction(this, "viewButton",
                			"click", mPrompt.getIndex());
                    Intent i = new Intent("android.intent.action.VIEW");
                    Uri uri = MediaUtils.getImageUriFromMediaProvider(mInstanceFolder + File.separator + mBinaryName);
                	if ( uri != null ) {
                        Log.i(t,"setting view path to: " + uri);
                        i.setDataAndType(uri, "image/*");
                        try {
                            getContext().startActivity(i);
                        } catch (ActivityNotFoundException e) {
                            Toast.makeText(getContext(),
                                getContext().getString(R.string.activity_not_found, "view image"),
                                Toast.LENGTH_SHORT).show();
                        }
                    }
                }
            });

            addView(mImageView);
        }
    }


    private void deleteMedia() {
        // get the file path and delete the file
    	String name = mBinaryName;
        // clean up variables
    	mBinaryName = null;
    	// delete from media provider
        int del = MediaUtils.deleteImageFileFromMediaProvider(mInstanceFolder + File.separator + name);
        Log.i(t, "Deleted " + del + " rows from media content provider");
    }


    @Override
    public void clearAnswer() {
        // remove the file
        deleteMedia();
        mImageView.setImageBitmap(null);
        mErrorTextView.setVisibility(View.GONE);

        // reset buttons
        mCaptureButton.setText(getContext().getString(R.string.capture_image));
    }


    @Override
    public IAnswerData getAnswer() {
        if (mBinaryName != null) {
            return new StringData(mBinaryName.toString());
        } else {
            return null;
        }
    }


    @Override
    public void setBinaryData(Object newImageObj) {
        // you are replacing an answer. delete the previous image using the
        // content provider.
        if (mBinaryName != null) {
            deleteMedia();
        }

        File newImage = (File) newImageObj;
        if (newImage.exists()) {
            // Add the new image to the Media content provider so that the
            // viewing is fast in Android 2.0+
        	ContentValues values = new ContentValues(6);
            values.put(Images.Media.TITLE, newImage.getName());
            values.put(Images.Media.DISPLAY_NAME, newImage.getName());
            values.put(Images.Media.DATE_TAKEN, System.currentTimeMillis());
            values.put(Images.Media.MIME_TYPE, "image/jpeg");
            values.put(Images.Media.DATA, newImage.getAbsolutePath());

            Uri imageURI = getContext().getContentResolver().insert(
            		Images.Media.EXTERNAL_CONTENT_URI, values);
            Log.i(t, "Inserting image returned uri = " + imageURI.toString());

            mBinaryName = newImage.getName();
            Log.i(t, "Setting current answer to " + newImage.getName());
        } else {
            Log.e(t, "NO IMAGE EXISTS at: " + newImage.getAbsolutePath());
        }

    	Collect.getInstance().getFormController().setIndexWaitingForData(null);
    }

    @Override
    public void setFocus(Context context) {
        // Hide the soft keyboard if it's showing.
        InputMethodManager inputManager =
            (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
        inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
    }


    @Override
    public boolean isWaitingForBinaryData() {
    	return mPrompt.getIndex().equals(Collect.getInstance().getFormController().getIndexWaitingForData());
    }


    @Override
	public void cancelWaitingForBinaryData() {
    	Collect.getInstance().getFormController().setIndexWaitingForData(null);
	}


    @Override
    public void setOnLongClickListener(OnLongClickListener l) {
        mCaptureButton.setOnLongClickListener(l);
        mChooseButton.setOnLongClickListener(l);
        if (mImageView != null) {
            mImageView.setOnLongClickListener(l);
        }
    }


    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        mCaptureButton.cancelLongPress();
        mChooseButton.cancelLongPress();
        if (mImageView != null) {
            mImageView.cancelLongPress();
        }
    }

}

/*
 * Copyright (C) 2009 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.content.Context;
import android.content.res.Configuration;
import android.text.InputType;
import android.text.method.DigitsKeyListener;
import android.util.TypedValue;

import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.StringData;
import org.javarosa.form.api.FormEntryPrompt;

/**
 * Widget that restricts values to integers.
 * 
 * @author Carl Hartung (carlhartung@gmail.com)
 */
public class StringNumberWidget extends StringWidget {

    public StringNumberWidget(Context context, FormEntryPrompt prompt, boolean readOnlyOverride) {
        super(context, prompt, readOnlyOverride, true);

        mAnswer.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
        mAnswer.setInputType(InputType.TYPE_NUMBER_FLAG_SIGNED);
//
//        // needed to make long readonly text scroll
//        mAnswer.setHorizontallyScrolling(false);
//        mAnswer.setSingleLine(false);

        mAnswer.setRawInputType(Configuration.KEYBOARD_12KEY);
        mAnswer.setKeyListener(new DigitsKeyListener() {
            @Override
            protected char[] getAcceptedChars() {
                char[] accepted = {
                        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', '-', '+', ' ', ','
                };
                return accepted;
            }
        });

        if (prompt.isReadOnly()) {
            setBackgroundDrawable(null);
            setFocusable(false);
            setClickable(false);
        }

        String s = null;
        if (prompt.getAnswerValue() != null)
            s = (String) prompt.getAnswerValue().getValue();

        if (s != null) {
            mAnswer.setText(s);
        }
        
        setupChangeListener();
    }


    @Override
    public IAnswerData getAnswer() {
    	clearFocus();
    	String s = mAnswer.getText().toString();
        if (s == null || s.equals("")) {
            return null;
        } else {
            try {
                return new StringData(s);
            } catch (Exception NumberFormatException) {
                return null;
            }
        }
    }

}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.net.Uri;
import android.os.Build;
import android.os.Environment;
import android.preference.PreferenceManager;
import android.provider.MediaStore.Video;
import android.util.Log;
import android.util.TypedValue;
import android.view.View;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.TableLayout;
import android.widget.Toast;

import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.StringData;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.R;
import org.odk.collect.android.activities.FormEntryActivity;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.preferences.PreferencesActivity;
import org.odk.collect.android.utilities.FileUtils;
import org.odk.collect.android.utilities.MediaUtils;

import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

/**
 * Widget that allows user to take pictures, sounds or video and add them to the
 * form.
 *
 * @author Carl Hartung (carlhartung@gmail.com)
 * @author Yaw Anokwa (yanokwa@gmail.com)
 */
public class VideoWidget extends QuestionWidget implements IBinaryWidget {
	private final static String t = "MediaWidget";

	private Button mCaptureButton;
	private Button mPlayButton;
	private Button mChooseButton;

	private String mBinaryName;

	private String mInstanceFolder;

	public static final boolean DEFAULT_HIGH_RESOLUTION = true;
	
	private static final String NEXUS7 = "Nexus 7";
	private static final String DIRECTORY_PICTURES = "Pictures";
	public static final int MEDIA_TYPE_IMAGE = 1;
	public static final int MEDIA_TYPE_VIDEO = 2;
	private Uri nexus7Uri;

	public VideoWidget(Context context, FormEntryPrompt prompt) {
		super(context, prompt);

		mInstanceFolder = Collect.getInstance().getFormController()
				.getInstancePath().getParent();

		setOrientation(LinearLayout.VERTICAL);

		TableLayout.LayoutParams params = new TableLayout.LayoutParams();
		params.setMargins(7, 5, 7, 5);
		// setup capture button
		mCaptureButton = new Button(getContext());
		mCaptureButton.setId(QuestionWidget.newUniqueId());
		mCaptureButton.setText(getContext().getString(R.string.capture_video));
		mCaptureButton
				.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
		mCaptureButton.setPadding(20, 20, 20, 20);
		mCaptureButton.setEnabled(!prompt.isReadOnly());
		mCaptureButton.setLayoutParams(params);

		// launch capture intent on click
		mCaptureButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				SharedPreferences settings =
                        PreferenceManager.getDefaultSharedPreferences(
                                Collect.getInstance().getApplication());
				Collect.getInstance()
						.getActivityLogger()
						.logInstanceAction(VideoWidget.this, "captureButton",
								"click", mPrompt.getIndex());
				Intent i = new Intent(
						android.provider.MediaStore.ACTION_VIDEO_CAPTURE);
				
				// Need to have this ugly code to account for 
				// a bug in the Nexus 7 on 4.3 not returning the mediaUri in the data
				// of the intent - using the MediaStore.EXTRA_OUTPUT to get the data
				// Have it saving to an intermediate location instead of final destination
				// to allow the current location to catch issues with the intermediate file
				Log.i(t, "The build of this device is " + android.os.Build.MODEL);
				if (NEXUS7.equals(android.os.Build.MODEL) && Build.VERSION.SDK_INT == 18) {
					nexus7Uri = getOutputMediaFileUri(MEDIA_TYPE_VIDEO);  
					i.putExtra(android.provider.MediaStore.EXTRA_OUTPUT, nexus7Uri);
				} else {
					i.putExtra(android.provider.MediaStore.EXTRA_OUTPUT,
						Video.Media.EXTERNAL_CONTENT_URI.toString());
				}
				
				// request high resolution if configured for that...
				boolean high_resolution = settings.getBoolean(PreferencesActivity.KEY_HIGH_RESOLUTION,
		                VideoWidget.DEFAULT_HIGH_RESOLUTION);
				if(high_resolution) {
					i.putExtra(android.provider.MediaStore.EXTRA_VIDEO_QUALITY,1);
				}
				try {
					Collect.getInstance().getFormController()
							.setIndexWaitingForData(mPrompt.getIndex());
					((Activity) getContext()).startActivityForResult(i,
							FormEntryActivity.VIDEO_CAPTURE);
				} catch (ActivityNotFoundException e) {
					Toast.makeText(
							getContext(),
							getContext().getString(R.string.activity_not_found,
									"capture video"), Toast.LENGTH_SHORT)
							.show();
					Collect.getInstance().getFormController()
							.setIndexWaitingForData(null);
				}

			}
		});

		// setup capture button
		mChooseButton = new Button(getContext());
		mChooseButton.setId(QuestionWidget.newUniqueId());
		mChooseButton.setText(getContext().getString(R.string.choose_video));
		mChooseButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
		mChooseButton.setPadding(20, 20, 20, 20);
		mChooseButton.setEnabled(!prompt.isReadOnly());
		mChooseButton.setLayoutParams(params);

		// launch capture intent on click
		mChooseButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				Collect.getInstance()
						.getActivityLogger()
						.logInstanceAction(VideoWidget.this, "chooseButton",
								"click", mPrompt.getIndex());
				Intent i = new Intent(Intent.ACTION_GET_CONTENT);
				i.setType("video/*");
				// Intent i =
				// new Intent(Intent.ACTION_PICK,
				// android.provider.MediaStore.Video.Media.EXTERNAL_CONTENT_URI);
				try {
					Collect.getInstance().getFormController()
							.setIndexWaitingForData(mPrompt.getIndex());
					((Activity) getContext()).startActivityForResult(i,
							FormEntryActivity.VIDEO_CHOOSER);
				} catch (ActivityNotFoundException e) {
					Toast.makeText(
							getContext(),
							getContext().getString(R.string.activity_not_found,
									"choose video "), Toast.LENGTH_SHORT)
							.show();
					Collect.getInstance().getFormController()
							.setIndexWaitingForData(null);
				}

			}
		});

		// setup play button
		mPlayButton = new Button(getContext());
		mPlayButton.setId(QuestionWidget.newUniqueId());
		mPlayButton.setText(getContext().getString(R.string.play_video));
		mPlayButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
		mPlayButton.setPadding(20, 20, 20, 20);
		mPlayButton.setLayoutParams(params);

		// on play, launch the appropriate viewer
		mPlayButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				Collect.getInstance()
						.getActivityLogger()
						.logInstanceAction(VideoWidget.this, "playButton",
								"click", mPrompt.getIndex());
				Intent i = new Intent("android.intent.action.VIEW");
				File f = new File(mInstanceFolder + File.separator
						+ mBinaryName);
				i.setDataAndType(Uri.fromFile(f), "video/*");
				try {
					((Activity) getContext()).startActivity(i);
				} catch (ActivityNotFoundException e) {
					Toast.makeText(
							getContext(),
							getContext().getString(R.string.activity_not_found,
									"video video"), Toast.LENGTH_SHORT).show();
				}
			}
		});

		// retrieve answer from data model and update ui
		mBinaryName = prompt.getAnswerText();
		if (mBinaryName != null) {
			mPlayButton.setEnabled(true);
		} else {
			mPlayButton.setEnabled(false);
		}

		// finish complex layout
		addView(mCaptureButton);
		addView(mChooseButton);
		addView(mPlayButton);

		// and hide the capture and choose button if read-only
		if (mPrompt.isReadOnly()) {
			mCaptureButton.setVisibility(View.GONE);
			mChooseButton.setVisibility(View.GONE);
		}

	}

    private void deleteMedia() {
        // get the file path and delete the file
    	String name = mBinaryName;
        // clean up variables
    	mBinaryName = null;
    	// delete from media provider
        int del = MediaUtils.deleteVideoFileFromMediaProvider(mInstanceFolder + File.separator + name);
        Log.i(t, "Deleted " + del + " rows from media content provider");
    }

	@Override
	public void clearAnswer() {
		// remove the file
		deleteMedia();

		// reset buttons
		mPlayButton.setEnabled(false);
	}

	@Override
	public IAnswerData getAnswer() {
		if (mBinaryName != null) {
			return new StringData(mBinaryName.toString());
		} else {
			return null;
		}
	}

	@Override
	public void setBinaryData(Object binaryuri) {
		// you are replacing an answer. remove the media.
		if (mBinaryName != null) {
			deleteMedia();
		}

		// get the file path and create a copy in the instance folder
		String binaryPath = MediaUtils.getPathFromUri(this.getContext(), (Uri) binaryuri, Video.Media.DATA);
		String extension = binaryPath.substring(binaryPath.lastIndexOf("."));
		String destVideoPath = mInstanceFolder + File.separator
				+ System.currentTimeMillis() + extension;

		File source = new File(binaryPath);
		File newVideo = new File(destVideoPath);
		FileUtils.copyFile(source, newVideo);

		if (newVideo.exists()) {
			// Add the copy to the content provier
			ContentValues values = new ContentValues(6);
			values.put(Video.Media.TITLE, newVideo.getName());
			values.put(Video.Media.DISPLAY_NAME, newVideo.getName());
			values.put(Video.Media.DATE_ADDED, System.currentTimeMillis());
			values.put(Video.Media.DATA, newVideo.getAbsolutePath());

			Uri VideoURI = getContext().getContentResolver().insert(
					Video.Media.EXTERNAL_CONTENT_URI, values);
			Log.i(t, "Inserting VIDEO returned uri = " + VideoURI.toString());
		} else {
			Log.e(t, "Inserting Video file FAILED");
		}

		mBinaryName = newVideo.getName();
		Collect.getInstance().getFormController().setIndexWaitingForData(null);
		
		// Need to have this ugly code to account for 
		// a bug in the Nexus 7 on 4.3 not returning the mediaUri in the data
		// of the intent - uri in this case is a file 
		if (NEXUS7.equals(android.os.Build.MODEL) && Build.VERSION.SDK_INT == 18) {
			Uri mediaUri = (Uri)binaryuri;
			File fileToDelete = new File(mediaUri.getPath());
			int delCount = fileToDelete.delete() ? 1 : 0;
			Log.i(t, "Deleting original capture of file: " + mediaUri.toString() + " count: " + delCount);
		} 
	}

	@Override
	public void setFocus(Context context) {
		// Hide the soft keyboard if it's showing.
		InputMethodManager inputManager = (InputMethodManager) context
				.getSystemService(Context.INPUT_METHOD_SERVICE);
		inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
	}

	@Override
	public boolean isWaitingForBinaryData() {
		return mPrompt.getIndex().equals(
				Collect.getInstance().getFormController()
						.getIndexWaitingForData());
	}

	@Override
	public void cancelWaitingForBinaryData() {
		Collect.getInstance().getFormController().setIndexWaitingForData(null);
	}

	@Override
	public void setOnLongClickListener(OnLongClickListener l) {
		mCaptureButton.setOnLongClickListener(l);
		mChooseButton.setOnLongClickListener(l);
		mPlayButton.setOnLongClickListener(l);
	}

	@Override
	public void cancelLongPress() {
		super.cancelLongPress();
		mCaptureButton.cancelLongPress();
		mChooseButton.cancelLongPress();
		mPlayButton.cancelLongPress();
	}
	
	/*
	 * Create a file Uri for saving an image or video 
	 * For Nexus 7 fix ... 
	 * See http://developer.android.com/guide/topics/media/camera.html for more info
	 */
	private static Uri getOutputMediaFileUri(int type){
		return Uri.fromFile(getOutputMediaFile(type));
	}

	/*
	 *  Create a File for saving an image or video 
	 *  For Nexus 7 fix ... 
	 *  See http://developer.android.com/guide/topics/media/camera.html for more info
	 */
	private static File getOutputMediaFile(int type){
		// To be safe, you should check that the SDCard is mounted
		// using Environment.getExternalStorageState() before doing this.

		File mediaStorageDir = new File(Environment.getExternalStorageDirectory(), DIRECTORY_PICTURES);
		// This location works best if you want the created images to be shared
		// between applications and persist after your app has been uninstalled.

		// Create the storage directory if it does not exist
		if (! mediaStorageDir.exists()){
			if (! mediaStorageDir.mkdirs()){
				Log.d(t, "failed to create directory");
				return null;
			}
		}

		// Create a media file name
		String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmssSSSZ", Locale.US).format(new Date());
		File mediaFile;
		if (type == MEDIA_TYPE_IMAGE){
			mediaFile = new File(mediaStorageDir.getPath() + File.separator +
					"IMG_"+ timeStamp + ".jpg");
		} else if(type == MEDIA_TYPE_VIDEO) {
			mediaFile = new File(mediaStorageDir.getPath() + File.separator +
					"VID_"+ timeStamp + ".mp4");
		} else {
			return null;
		}

		return mediaFile;
	}

}

/*
 * Copyright (C) 2011 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.util.TypedValue;
import android.view.LayoutInflater;
import android.view.inputmethod.InputMethodManager;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.RadioButton;
import android.widget.RelativeLayout;

import org.javarosa.core.model.SelectChoice;
import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.SelectOneData;
import org.javarosa.core.model.data.helper.Selection;
import org.javarosa.form.api.FormEntryCaption;
import org.javarosa.form.api.FormEntryPrompt;
import org.javarosa.xpath.expr.XPathFuncExpr;
import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.external.ExternalDataUtil;
import org.odk.collect.android.external.ExternalSelectChoice;
import org.odk.collect.android.listeners.AdvanceToNextListener;
import org.odk.collect.android.views.MediaLayout;

import java.util.ArrayList;
import java.util.Vector;

/**
 * SelectOneWidgets handles select-one fields using radio buttons. Unlike the classic
 * SelectOneWidget, when a user clicks an option they are then immediately advanced to the next
 * question.
 * 
 * @author Jeff Beorse (jeff@beorse.net)
 */
public class SelectOneAutoAdvanceWidget extends QuestionWidget implements OnCheckedChangeListener {
	Vector<SelectChoice> mItems; // may take a while to compute
    ArrayList<RadioButton> buttons;
    AdvanceToNextListener listener;


    public SelectOneAutoAdvanceWidget(Context context, FormEntryPrompt prompt) {
        super(context, prompt);

        LayoutInflater inflater = LayoutInflater.from(getContext());

        // SurveyCTO-added support for dynamic select content (from .csv files)
        XPathFuncExpr xPathFuncExpr = ExternalDataUtil.getSearchXPathExpression(prompt.getAppearanceHint());
        if (xPathFuncExpr != null) {
            mItems = ExternalDataUtil.populateExternalChoices(prompt, xPathFuncExpr);
        } else {
            mItems = prompt.getSelectChoices();
        }

        buttons = new ArrayList<RadioButton>();
        listener = (AdvanceToNextListener) context;

        String s = null;
        if (prompt.getAnswerValue() != null) {
            s = ((Selection) prompt.getAnswerValue().getValue()).getValue();
        }

        // use this for recycle
        Bitmap b = BitmapFactory.decodeResource(getContext().getResources(),
               								R.drawable.expander_ic_right);

        if (mItems != null) {
            for (int i = 0; i < mItems.size(); i++) {

                RelativeLayout thisParentLayout =
                    (RelativeLayout) inflater.inflate(R.layout.quick_select_layout, null);

                LinearLayout questionLayout = (LinearLayout) thisParentLayout.getChildAt(0);
                ImageView rightArrow = (ImageView) thisParentLayout.getChildAt(1);

                RadioButton r = new RadioButton(getContext());
                r.setText(prompt.getSelectChoiceText(mItems.get(i)));
                r.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
                r.setTag(Integer.valueOf(i));
                r.setId(QuestionWidget.newUniqueId());
                r.setEnabled(!prompt.isReadOnly());
                r.setFocusable(!prompt.isReadOnly());

                rightArrow.setImageBitmap(b);

                buttons.add(r);

                if (mItems.get(i).getValue().equals(s)) {
                    r.setChecked(true);
                }

                r.setOnCheckedChangeListener(this);

                String audioURI = null;
                audioURI =
                    prompt.getSpecialFormSelectChoiceText(mItems.get(i),
                        FormEntryCaption.TEXT_FORM_AUDIO);

                String imageURI;
                if (mItems.get(i) instanceof ExternalSelectChoice) {
                    imageURI = ((ExternalSelectChoice) mItems.get(i)).getImage();
                } else {
                    imageURI = prompt.getSpecialFormSelectChoiceText(mItems.get(i), FormEntryCaption.TEXT_FORM_IMAGE);
                }

                String videoURI = null;
                videoURI = prompt.getSpecialFormSelectChoiceText(mItems.get(i), "video");

                String bigImageURI = null;
                bigImageURI = prompt.getSpecialFormSelectChoiceText(mItems.get(i), "big-image");

                MediaLayout mediaLayout = new MediaLayout(getContext());
                mediaLayout.setAVT(prompt.getIndex(), "", r, audioURI, imageURI, videoURI, bigImageURI);

                if (i != mItems.size() - 1) {
	                // Last, add the dividing line (except for the last element)
	                ImageView divider = new ImageView(getContext());
	                divider.setBackgroundResource(android.R.drawable.divider_horizontal_bright);
                    mediaLayout.addDivider(divider);
                }
                questionLayout.addView(mediaLayout);
                addView(thisParentLayout);
            }
        }
    }


    @Override
    public void clearAnswer() {
        for (RadioButton button : this.buttons) {
            if (button.isChecked()) {
                button.setChecked(false);
                return;
            }
        }
    }


    @Override
    public IAnswerData getAnswer() {
        int i = getCheckedId();
        if (i == -1) {
            return null;
        } else {
            SelectChoice sc = mItems.elementAt(i);
            return new SelectOneData(new Selection(sc));
        }
    }


    @Override
    public void setFocus(Context context) {
        // Hide the soft keyboard if it's showing.
        InputMethodManager inputManager =
            (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
        inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
    }


    public int getCheckedId() {
    	for (int i = 0; i < buttons.size(); ++i) {
    		RadioButton button = buttons.get(i);
            if (button.isChecked()) {
                return i;
            }
        }
        return -1;
    }


    @Override
    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
        if (!buttonView.isPressed()) {
            return;
        }
        if (!isChecked) {
            // If it got unchecked, we don't care.
            return;
        }

        for (RadioButton button : this.buttons) {
            if (button.isChecked() && !(buttonView == button)) {
                button.setChecked(false);
            }
        }
       	Collect.getInstance().getActivityLogger().logInstanceAction(this, "onCheckedChanged", 
    			mItems.get((Integer)buttonView.getTag()).getValue(), mPrompt.getIndex());

       	listener.advance();
    }


    @Override
    public void setOnLongClickListener(OnLongClickListener l) {
        for (RadioButton r : buttons) {
            r.setOnLongClickListener(l);
        }
    }


    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        for (RadioButton r : buttons) {
            r.cancelLongPress();
        }
    }

}

/*
 * Copyright (C) 2012 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.graphics.Bitmap;
import android.net.Uri;
import android.provider.MediaStore.Images;
import android.util.Log;
import android.util.TypedValue;
import android.view.Display;
import android.view.View;
import android.view.WindowManager;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TableLayout;
import android.widget.TextView;
import android.widget.Toast;

import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.StringData;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.R;
import org.odk.collect.android.activities.DrawActivity;
import org.odk.collect.android.activities.FormEntryActivity;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.utilities.FileUtils;
import org.odk.collect.android.utilities.MediaUtils;

import java.io.File;

/**
 * Signature widget.
 * 
 * @author BehrAtherton@gmail.com
 *
 */
public class SignatureWidget extends QuestionWidget implements IBinaryWidget {
    private final static String t = "SignatureWidget";

    private Button mSignButton;
    private String mBinaryName;
    private String mInstanceFolder;
    private ImageView mImageView;
    private TextView mErrorTextView;

	public SignatureWidget(Context context, FormEntryPrompt prompt) {
		super(context, prompt);
		
		mInstanceFolder = 
				Collect.getInstance().getFormController().getInstancePath().getParent();

		setOrientation(LinearLayout.VERTICAL);
		
		TableLayout.LayoutParams params = new TableLayout.LayoutParams();
        params.setMargins(7, 5, 7, 5);
		
        mErrorTextView = new TextView(context);
        mErrorTextView.setId(QuestionWidget.newUniqueId());
        mErrorTextView.setText("Selected file is not a valid image");

        // setup Blank Image Button
		mSignButton = new Button(getContext());
		mSignButton.setId(QuestionWidget.newUniqueId());
        mSignButton.setText(getContext().getString(R.string.sign_button));
        mSignButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
        mSignButton.setPadding(20, 20, 20, 20);
        mSignButton.setEnabled(!prompt.isReadOnly());
        mSignButton.setLayoutParams(params);
        // launch capture intent on click
        mSignButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
				Collect.getInstance()
						.getActivityLogger()
						.logInstanceAction(this, "signButton", "click",
								mPrompt.getIndex());
            	launchSignatureActivity();
            }
        });
        
        
        // finish complex layout
        addView(mSignButton);
        addView(mErrorTextView);
     
        // and hide the sign button if read-only
        if ( prompt.isReadOnly() ) {
        	mSignButton.setVisibility(View.GONE);
        }
        mErrorTextView.setVisibility(View.GONE);

        // retrieve answer from data model and update ui
        mBinaryName = prompt.getAnswerText();

        // Only add the imageView if the user has signed
        if (mBinaryName != null) {
            mImageView = new ImageView(getContext());
            mImageView.setId(QuestionWidget.newUniqueId());
            Display display =
                ((WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE))
                        .getDefaultDisplay();
            int screenWidth = display.getWidth();
            int screenHeight = display.getHeight();

            File f = new File(mInstanceFolder + File.separator + mBinaryName);

            if (f.exists()) {
                Bitmap bmp = FileUtils.getBitmapScaledToDisplay(f, screenHeight, screenWidth);
                if (bmp == null) {
                    mErrorTextView.setVisibility(View.VISIBLE);
                }
                mImageView.setImageBitmap(bmp);
            } else {
                mImageView.setImageBitmap(null);
            }

            mImageView.setPadding(10, 10, 10, 10);
            mImageView.setAdjustViewBounds(true);
            mImageView.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                   	Collect.getInstance().getActivityLogger().logInstanceAction(this, "viewImage", 
                			"click", mPrompt.getIndex());
                   	launchSignatureActivity();
                }
            });

            addView(mImageView);
        }

	}
	
	private void launchSignatureActivity() {
        mErrorTextView.setVisibility(View.GONE);
    	Intent i = new Intent(getContext(), DrawActivity.class);
    	i.putExtra(DrawActivity.OPTION, DrawActivity.OPTION_SIGNATURE);
        // copy...
        if ( mBinaryName != null ) {
        	File f = new File(mInstanceFolder + File.separator + mBinaryName);
        	i.putExtra(DrawActivity.REF_IMAGE, Uri.fromFile(f));
        }
    	i.putExtra(DrawActivity.EXTRA_OUTPUT, 
    			Uri.fromFile(new File(Collect.getInstance().getTmpFilePath())));
    	
    	try {
	    	Collect.getInstance().getFormController().setIndexWaitingForData(mPrompt.getIndex());
	    	((Activity) getContext()).startActivityForResult(i, FormEntryActivity.SIGNATURE_CAPTURE);
    	}
    	catch (ActivityNotFoundException e) {
            Toast.makeText(getContext(),
                getContext().getString(R.string.activity_not_found, "signature capture"),
                Toast.LENGTH_SHORT).show();
        	Collect.getInstance().getFormController().setIndexWaitingForData(null);
        }
	}
	
    private void deleteMedia() {
        // get the file path and delete the file
    	String name = mBinaryName;
        // clean up variables
    	mBinaryName = null;
    	// delete from media provider
        int del = MediaUtils.deleteImageFileFromMediaProvider(mInstanceFolder + File.separator + name);
        Log.i(t, "Deleted " + del + " rows from media content provider");
    }


	@Override
	public void clearAnswer() {
        // remove the file
        deleteMedia();
        mImageView.setImageBitmap(null);
        mErrorTextView.setVisibility(View.GONE);

        // reset buttons
        mSignButton.setText(getContext().getString(R.string.sign_button));
	}

	
	@Override
	public IAnswerData getAnswer() {
        if (mBinaryName != null) {
            return new StringData(mBinaryName.toString());
        } else {
            return null;
        }
	}

	
	@Override
	public void setBinaryData(Object answer) {
        // you are replacing an answer. delete the previous image using the
        // content provider.
        if (mBinaryName != null) {
            deleteMedia();
        }

        File newImage = (File) answer;
        if (newImage.exists()) {
            // Add the new image to the Media content provider so that the
            // viewing is fast in Android 2.0+
        	ContentValues values = new ContentValues(6);
            values.put(Images.Media.TITLE, newImage.getName());
            values.put(Images.Media.DISPLAY_NAME, newImage.getName());
            values.put(Images.Media.DATE_TAKEN, System.currentTimeMillis());
            values.put(Images.Media.MIME_TYPE, "image/jpeg");
            values.put(Images.Media.DATA, newImage.getAbsolutePath());

            Uri imageURI = getContext().getContentResolver().insert(
            		Images.Media.EXTERNAL_CONTENT_URI, values);
            Log.i(t, "Inserting image returned uri = " + imageURI.toString());

            mBinaryName = newImage.getName();
            Log.i(t, "Setting current answer to " + newImage.getName());
        } else {
            Log.e(t, "NO IMAGE EXISTS at: " + newImage.getAbsolutePath());
        }

    	Collect.getInstance().getFormController().setIndexWaitingForData(null);
	}

	@Override
	public void setFocus(Context context) {
		// Hide the soft keyboard if it's showing.
        InputMethodManager inputManager =
            (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
        inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
	}


	@Override
	public boolean isWaitingForBinaryData() {
		return mPrompt.getIndex().equals(Collect.getInstance().getFormController().getIndexWaitingForData());
	}

	@Override
	public void cancelWaitingForBinaryData() {
		Collect.getInstance().getFormController().setIndexWaitingForData(null);
	}
	
	@Override
	public void setOnLongClickListener(OnLongClickListener l) {
        mSignButton.setOnLongClickListener(l);
        if (mImageView != null) {
            mImageView.setOnLongClickListener(l);
        }
	}


    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        mSignButton.cancelLongPress();
        if (mImageView != null) {
            mImageView.cancelLongPress();
        }
    }

}

/*
 * Copyright (C) 2012 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Context;
import android.content.Intent;
import android.graphics.drawable.Drawable;
import android.text.method.TextKeyListener;
import android.text.method.TextKeyListener.Capitalize;
import android.util.Log;
import android.util.TypedValue;
import android.view.KeyEvent;
import android.view.View;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TableLayout;
import android.widget.Toast;

import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.StringData;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.R;
import org.odk.collect.android.activities.FormEntryActivity;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.exception.ExternalParamsException;
import org.odk.collect.android.external.ExternalAppsUtils;

import java.util.Map;


/**
 * <p>Launch an external app to supply a string value. If the app
 * does not launch, enable the text area for regular data entry.</p>
 *
 * <p>The default button text is "Launch"
 *
 * <p>You may override the button text and the error text that is
 * displayed when the app is missing by using jr:itext() values.
 *
 * <p>To use this widget, define an appearance on the &lt;input/&gt;
 * tag that begins "ex:" and then contains the intent action to lauch.
 *
 * <p>e.g.,
 *
 * <pre>
 * &lt;input appearance="ex:change.uw.android.TEXTANSWER" ref="/form/passPhrase" &gt;
 * </pre>
 * <p>or, to customize the button text and error strings with itext:
 * <pre>
 *      ...
 *      &lt;bind nodeset="/form/passPhrase" type="string" /&gt;
 *      ...
 *      &lt;itext&gt;
 *        &lt;translation lang="English"&gt;
 *          &lt;text id="textAnswer"&gt;
 *            &lt;value form="short"&gt;Text question&lt;/value&gt;
 *            &lt;value form="long"&gt;Enter your pass phrase&lt;/value&gt;
 *            &lt;value form="buttonText"&gt;Get Pass Phrase&lt;/value&gt;
 *            &lt;value form="noAppErrorString"&gt;Pass Phrase Tool is not installed!
 *             Please proceed to manually enter pass phrase.&lt;/value&gt;
 *          &lt;/text&gt;
 *        &lt;/translation&gt;
 *      &lt;/itext&gt;
 *    ...
 *    &lt;input appearance="ex:change.uw.android.TEXTANSWER" ref="/form/passPhrase"&gt;
 *      &lt;label ref="jr:itext('textAnswer')"/&gt;
 *    &lt;/input&gt;
 * </pre>
 *
 * @author mitchellsundt@gmail.com
 *
 */
public class ExStringWidget extends QuestionWidget implements IBinaryWidget {

    private final String t = getClass().getName();

    private boolean mHasExApp = true;
    private Button mLaunchIntentButton;
    private Drawable mTextBackground;

    protected EditText mAnswer;

    public ExStringWidget(Context context, FormEntryPrompt prompt) {
        super(context, prompt);

        TableLayout.LayoutParams params = new TableLayout.LayoutParams();
        params.setMargins(7, 5, 7, 5);

        // set text formatting
        mAnswer = new EditText(context);
        mAnswer.setId(QuestionWidget.newUniqueId());
        mAnswer.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
        mAnswer.setLayoutParams(params);
        mTextBackground = mAnswer.getBackground();
        mAnswer.setBackgroundDrawable(null);

        // capitalize nothing
        mAnswer.setKeyListener(new TextKeyListener(Capitalize.NONE, false));

        // needed to make long read only text scroll
        mAnswer.setHorizontallyScrolling(false);
        mAnswer.setSingleLine(false);

        String s = prompt.getAnswerText();
        if (s != null) {
            mAnswer.setText(s);
        }

        if (mPrompt.isReadOnly()) {
        	mAnswer.setBackgroundDrawable(null);
        }

        if (mPrompt.isReadOnly() || mHasExApp) {
            mAnswer.setFocusable(false);
            mAnswer.setClickable(false);
        }

        String appearance = prompt.getAppearanceHint();
        String[] attrs = appearance.split(":");
        final String intentName = ExternalAppsUtils.extractIntentName(attrs[1]);
        final Map<String, String> exParams = ExternalAppsUtils.extractParameters(attrs[1]);
        final String buttonText;
        final String errorString;
    	String v = mPrompt.getSpecialFormQuestionText("buttonText");
    	buttonText = (v != null) ? v : context.getString(R.string.launch_app);
    	v = mPrompt.getSpecialFormQuestionText("noAppErrorString");
    	errorString = (v != null) ? v : context.getString(R.string.no_app);

        // set button formatting
        mLaunchIntentButton = new Button(getContext());
        mLaunchIntentButton.setId(QuestionWidget.newUniqueId());
        mLaunchIntentButton.setText(buttonText);
        mLaunchIntentButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
        mLaunchIntentButton.setPadding(20, 20, 20, 20);
        mLaunchIntentButton.setEnabled(!mPrompt.isReadOnly());
        mLaunchIntentButton.setLayoutParams(params);

        mLaunchIntentButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Intent i = new Intent(intentName);
                try {
                    ExternalAppsUtils.populateParameters(i, exParams, mPrompt.getIndex().getReference());

                    Collect.getInstance().getFormController().setIndexWaitingForData(mPrompt.getIndex());
                	fireActivity(i);
                } catch (ExternalParamsException e) {
                    Log.e(t, e.getMessage(), e);
                    onException(e.getMessage());
                } catch (ActivityNotFoundException e) {
                    Log.e(t, e.getMessage(), e);
                    onException(errorString);
                }
            }

            private void onException(String toastText) {
                mHasExApp = false;
                if ( !mPrompt.isReadOnly() ) {
                    mAnswer.setBackgroundDrawable(mTextBackground);
                    mAnswer.setFocusable(true);
                    mAnswer.setFocusableInTouchMode(true);
                    mAnswer.setClickable(true);
                }
                mLaunchIntentButton.setEnabled(false);
                mLaunchIntentButton.setFocusable(false);
                Collect.getInstance().getFormController().setIndexWaitingForData(null);
                Toast.makeText(getContext(),
                        toastText, Toast.LENGTH_SHORT)
                        .show();
                ExStringWidget.this.mAnswer.requestFocus();
            }
        });

        // finish complex layout
        addView(mLaunchIntentButton);
        addView(mAnswer);
    }

    protected void fireActivity(Intent i) throws ActivityNotFoundException {
    	i.putExtra("value", mPrompt.getAnswerText());
       	Collect.getInstance().getActivityLogger().logInstanceAction(this, "launchIntent",
    			i.getAction(), mPrompt.getIndex());
        ((Activity) getContext()).startActivityForResult(i,
                FormEntryActivity.EX_STRING_CAPTURE);
    }

    @Override
    public void clearAnswer() {
    	mAnswer.setText(null);
    }


    @Override
    public IAnswerData getAnswer() {
        String s = mAnswer.getText().toString();
        if (s == null || s.equals("")) {
            return null;
        } else {
            return new StringData(s);
        }
    }


    /**
     * Allows answer to be set externally in {@Link FormEntryActivity}.
     */
    @Override
    public void setBinaryData(Object answer) {
        StringData stringData = ExternalAppsUtils.asStringData(answer);
        mAnswer.setText(stringData == null ? null : stringData.getValue().toString());
    	Collect.getInstance().getFormController().setIndexWaitingForData(null);
    }

    @Override
    public void setFocus(Context context) {
        // Put focus on text input field and display soft keyboard if appropriate.
        InputMethodManager inputManager =
            (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
    	if ( mHasExApp ) {
    		// hide keyboard
            inputManager.hideSoftInputFromWindow(mAnswer.getWindowToken(), 0);
            // focus on launch button
            mLaunchIntentButton.requestFocus();
    	} else {
            if (!mPrompt.isReadOnly()) {
	            mAnswer.requestFocus();
	            inputManager.showSoftInput(mAnswer, 0);
	            /*
	             * If you do a multi-question screen after a "add another group" dialog, this won't
	             * automatically pop up. It's an Android issue.
	             *
	             * That is, if I have an edit text in an activity, and pop a dialog, and in that
	             * dialog's button's OnClick() I call edittext.requestFocus() and
	             * showSoftInput(edittext, 0), showSoftinput() returns false. However, if the edittext
	             * is focused before the dialog pops up, everything works fine. great.
	             */
	        } else {
	            inputManager.hideSoftInputFromWindow(mAnswer.getWindowToken(), 0);
	        }
    	}
    }


    @Override
    public boolean isWaitingForBinaryData() {
        return mPrompt.getIndex().equals(Collect.getInstance().getFormController().getIndexWaitingForData());
    }

	@Override
	public void cancelWaitingForBinaryData() {
    	Collect.getInstance().getFormController().setIndexWaitingForData(null);
	}

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (event.isAltPressed() == true) {
            return false;
        }
        return super.onKeyDown(keyCode, event);
    }

    @Override
    public void setOnLongClickListener(OnLongClickListener l) {
    	mAnswer.setOnLongClickListener(l);
        mLaunchIntentButton.setOnLongClickListener(l);
    }


    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        mAnswer.cancelLongPress();
        mLaunchIntentButton.cancelLongPress();
    }


}

/*
 * Copyright (C) 2012 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.graphics.Bitmap;
import android.net.Uri;
import android.provider.MediaStore.Images;
import android.util.Log;
import android.util.TypedValue;
import android.view.Display;
import android.view.View;
import android.view.WindowManager;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TableLayout;
import android.widget.TextView;
import android.widget.Toast;

import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.StringData;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.R;
import org.odk.collect.android.activities.DrawActivity;
import org.odk.collect.android.activities.FormEntryActivity;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.utilities.FileUtils;
import org.odk.collect.android.utilities.MediaUtils;

import java.io.File;

/**
 * Free drawing widget.
 * 
 * @author BehrAtherton@gmail.com
 * 
 */
public class DrawWidget extends QuestionWidget implements IBinaryWidget {
	private final static String t = "DrawWidget";

	private Button mDrawButton;
	private String mBinaryName;
	private String mInstanceFolder;
	private ImageView mImageView;
	private TextView mErrorTextView;

	public DrawWidget(Context context, FormEntryPrompt prompt) {
		super(context, prompt);

		mErrorTextView = new TextView(context);
		mErrorTextView.setId(QuestionWidget.newUniqueId());
		mErrorTextView.setText("Selected file is not a valid image");

		mInstanceFolder = Collect.getInstance().getFormController()
				.getInstancePath().getParent();

		setOrientation(LinearLayout.VERTICAL);
		TableLayout.LayoutParams params = new TableLayout.LayoutParams();
		params.setMargins(7, 5, 7, 5);
		// setup Blank Image Button
		mDrawButton = new Button(getContext());
		mDrawButton.setId(QuestionWidget.newUniqueId());
		mDrawButton.setText(getContext().getString(R.string.draw_image));
		mDrawButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
		mDrawButton.setPadding(20, 20, 20, 20);
		mDrawButton.setEnabled(!prompt.isReadOnly());
		mDrawButton.setLayoutParams(params);
		// launch capture intent on click
		mDrawButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				Collect.getInstance()
						.getActivityLogger()
						.logInstanceAction(this, "drawButton", "click",
								mPrompt.getIndex());
				launchDrawActivity();
			}
		});

		// finish complex layout
		addView(mDrawButton);
		addView(mErrorTextView);

		if (mPrompt.isReadOnly()) {
			mDrawButton.setVisibility(View.GONE);
		}
		mErrorTextView.setVisibility(View.GONE);

		// retrieve answer from data model and update ui
		mBinaryName = prompt.getAnswerText();

		// Only add the imageView if the user has signed
		if (mBinaryName != null) {
			mImageView = new ImageView(getContext());
			mImageView.setId(QuestionWidget.newUniqueId());
			Display display = ((WindowManager) getContext().getSystemService(
					Context.WINDOW_SERVICE)).getDefaultDisplay();
			int screenWidth = display.getWidth();
			int screenHeight = display.getHeight();

			File f = new File(mInstanceFolder + File.separator + mBinaryName);

			if (f.exists()) {
				Bitmap bmp = FileUtils.getBitmapScaledToDisplay(f,
						screenHeight, screenWidth);
				if (bmp == null) {
					mErrorTextView.setVisibility(View.VISIBLE);
				}
				mImageView.setImageBitmap(bmp);
			} else {
				mImageView.setImageBitmap(null);
			}

			mImageView.setPadding(10, 10, 10, 10);
			mImageView.setAdjustViewBounds(true);
			mImageView.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					Collect.getInstance()
							.getActivityLogger()
							.logInstanceAction(this, "viewImage", "click",
									mPrompt.getIndex());
					launchDrawActivity();
				}
			});

			addView(mImageView);
		}

	}

	private void launchDrawActivity() {
		mErrorTextView.setVisibility(View.GONE);
		Intent i = new Intent(getContext(), DrawActivity.class);
		i.putExtra(DrawActivity.OPTION, DrawActivity.OPTION_DRAW);
		// copy...
		if (mBinaryName != null) {
			File f = new File(mInstanceFolder + File.separator + mBinaryName);
			i.putExtra(DrawActivity.REF_IMAGE, Uri.fromFile(f));
		}
		i.putExtra(DrawActivity.EXTRA_OUTPUT,
				Uri.fromFile(new File(Collect.getInstance().getTmpFilePath())));

		try {
			Collect.getInstance().getFormController()
					.setIndexWaitingForData(mPrompt.getIndex());
			((Activity) getContext()).startActivityForResult(i,
					FormEntryActivity.DRAW_IMAGE);
		} catch (ActivityNotFoundException e) {
			Toast.makeText(
					getContext(),
					getContext().getString(R.string.activity_not_found,
							"draw image"), Toast.LENGTH_SHORT).show();
			Collect.getInstance().getFormController()
					.setIndexWaitingForData(null);
		}
	}

	private void deleteMedia() {
		// get the file path and delete the file
		String name = mBinaryName;
		// clean up variables
		mBinaryName = null;
		// delete from media provider
		int del = MediaUtils.deleteImageFileFromMediaProvider(mInstanceFolder
				+ File.separator + name);
		Log.i(t, "Deleted " + del + " rows from media content provider");
	}

	@Override
	public void clearAnswer() {
		// remove the file
		deleteMedia();
		mImageView.setImageBitmap(null);
		mErrorTextView.setVisibility(View.GONE);

		// reset buttons
		mDrawButton.setText(getContext().getString(R.string.draw_image));
	}

	@Override
	public IAnswerData getAnswer() {
		if (mBinaryName != null) {
			return new StringData(mBinaryName.toString());
		} else {
			return null;
		}
	}

	@Override
	public void setBinaryData(Object answer) {
		// you are replacing an answer. delete the previous image using the
		// content provider.
		if (mBinaryName != null) {
			deleteMedia();
		}

		File newImage = (File) answer;
		if (newImage.exists()) {
			// Add the new image to the Media content provider so that the
			// viewing is fast in Android 2.0+
			ContentValues values = new ContentValues(6);
			values.put(Images.Media.TITLE, newImage.getName());
			values.put(Images.Media.DISPLAY_NAME, newImage.getName());
			values.put(Images.Media.DATE_TAKEN, System.currentTimeMillis());
			values.put(Images.Media.MIME_TYPE, "image/jpeg");
			values.put(Images.Media.DATA, newImage.getAbsolutePath());

			Uri imageURI = getContext().getContentResolver().insert(
					Images.Media.EXTERNAL_CONTENT_URI, values);
			Log.i(t, "Inserting image returned uri = " + imageURI.toString());

			mBinaryName = newImage.getName();
			Log.i(t, "Setting current answer to " + newImage.getName());
		} else {
			Log.e(t, "NO IMAGE EXISTS at: " + newImage.getAbsolutePath());
		}

		Collect.getInstance().getFormController().setIndexWaitingForData(null);
	}

	@Override
	public void setFocus(Context context) {
		// Hide the soft keyboard if it's showing.
		InputMethodManager inputManager = (InputMethodManager) context
				.getSystemService(Context.INPUT_METHOD_SERVICE);
		inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
	}

	@Override
	public boolean isWaitingForBinaryData() {
		return mPrompt.getIndex().equals(
				Collect.getInstance().getFormController()
						.getIndexWaitingForData());
	}

	@Override
	public void cancelWaitingForBinaryData() {
		Collect.getInstance().getFormController().setIndexWaitingForData(null);
	}

	@Override
	public void setOnLongClickListener(OnLongClickListener l) {
		mDrawButton.setOnLongClickListener(l);
		if (mImageView != null) {
			mImageView.setOnLongClickListener(l);
		}
	}

	@Override
	public void cancelLongPress() {
		super.cancelLongPress();
		mDrawButton.cancelLongPress();
		if (mImageView != null) {
			mImageView.cancelLongPress();
		}
	}

}

/*
 * Copyright (C) 2009 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.content.Context;
import android.util.Log;

import org.javarosa.core.model.Constants;
import org.javarosa.form.api.FormEntryPrompt;

import java.util.Locale;

/**
 * Convenience class that handles creation of widgets.
 *
 * @author Carl Hartung (carlhartung@gmail.com)
 */
public class WidgetFactory {

    /**
     * Returns the appropriate QuestionWidget for the given FormEntryPrompt.
     *
     * @param fep prompt element to be rendered
     * @param context Android context
     * @param readOnlyOverride a flag to be ORed with JR readonly attribute.
     */
    static public QuestionWidget createWidgetFromPrompt(FormEntryPrompt fep, Context context, boolean readOnlyOverride) {

    	// get appearance hint and clean it up so it is lower case and never null...
        String appearance = fep.getAppearanceHint();
        if ( appearance == null ) appearance = "";
        // for now, all appearance tags are in english...
        appearance = appearance.toLowerCase(Locale.ENGLISH);

        QuestionWidget questionWidget;
        switch (fep.getControlType()) {
            case Constants.CONTROL_INPUT:
                switch (fep.getDataType()) {
                    case Constants.DATATYPE_DATE_TIME:
                        questionWidget = new DateTimeWidget(context, fep);
                        break;
                    case Constants.DATATYPE_DATE:
                        questionWidget = new DateWidget(context, fep);
                        break;
                    case Constants.DATATYPE_TIME:
                        questionWidget = new TimeWidget(context, fep);
                        break;
                    case Constants.DATATYPE_DECIMAL:
                    	if ( appearance.startsWith("ex:") ) {
                            questionWidget = new ExDecimalWidget(context, fep);
                        } else if (appearance.equals("bearing")) {
                            questionWidget = new BearingWidget(context, fep);
                        } else {
                            questionWidget = new DecimalWidget(context, fep, readOnlyOverride);
                        }
                        break;
                    case Constants.DATATYPE_INTEGER:
                    	if ( appearance.startsWith("ex:") ) {
                    		questionWidget = new ExIntegerWidget(context, fep);
                    	} else {
                    		questionWidget = new IntegerWidget(context, fep, readOnlyOverride);
                    	}
                        break;
                    case Constants.DATATYPE_GEOPOINT:
                        questionWidget = new GeoPointWidget(context, fep);
                        break;
                    case Constants.DATATYPE_BARCODE:
                        questionWidget = new BarcodeWidget(context, fep);
                        break;
                    case Constants.DATATYPE_TEXT:
                    	String query = fep.getQuestion().getAdditionalAttribute(null, "query");
                        if (query != null) {
                            questionWidget = new ItemsetWidget(context, fep, readOnlyOverride);
                        } else if (appearance.startsWith("printer")) {
                            questionWidget = new ExPrinterWidget(context, fep);
                        } else if (appearance.startsWith("ex:")) {
                            questionWidget = new ExStringWidget(context, fep);
                        } else if (appearance.equals("numbers")) {
                            questionWidget = new StringNumberWidget(context, fep, readOnlyOverride);
                        } else if (appearance.equals("url")) {
                            questionWidget = new UrlWidget(context, fep);
                        } else {
                            questionWidget = new StringWidget(context, fep, readOnlyOverride);
                        }
                        break;
                    default:
                        questionWidget = new StringWidget(context, fep, readOnlyOverride);
                        break;
                }
                break;
            case Constants.CONTROL_IMAGE_CHOOSE:
            	if (appearance.equals("web")) {
            		questionWidget = new ImageWebViewWidget(context, fep);
        		} else if(appearance.equals("signature")) {
            		questionWidget = new SignatureWidget(context, fep);
            	} else if(appearance.equals("annotate")) {
            		questionWidget = new AnnotateWidget(context, fep);
            	} else if(appearance.equals("draw")) {
            		questionWidget = new DrawWidget(context, fep);
            	} else if(appearance.startsWith("align:")) {
            		questionWidget = new AlignedImageWidget(context, fep);
            	} else {
            		questionWidget = new ImageWidget(context, fep);
            	}
                break;
            case Constants.CONTROL_AUDIO_CAPTURE:
                questionWidget = new AudioWidget(context, fep);
                break;
            case Constants.CONTROL_VIDEO_CAPTURE:
                questionWidget = new VideoWidget(context, fep);
                break;
            case Constants.CONTROL_SELECT_ONE:
								// SurveyCTO-revised support for dynamic select content (from .csv files)
								// consider traditional ODK appearance to be first word in appearance string
                if (appearance.startsWith("compact") || appearance.startsWith("quickcompact")) {
                    int numColumns = -1;
                    try {
                    	String firstWord = appearance.split("\\s+")[0];
                    	int idx = firstWord.indexOf("-");
                    	if ( idx != -1 ) {
                    		numColumns =
                    				Integer.parseInt(firstWord.substring(idx + 1));
                    	}
                    } catch (Exception e) {
                        // Do nothing, leave numColumns as -1
                        Log.e("WidgetFactory", "Exception parsing numColumns");
                    }

                    if (appearance.startsWith("quick")) {
                        questionWidget = new GridWidget(context, fep, numColumns, true);
                    } else {
                        questionWidget = new GridWidget(context, fep, numColumns, false);
                    }
                } else if (appearance.startsWith("minimal")) {
                    questionWidget = new SpinnerWidget(context, fep);
                }
                // else if (appearance != null && appearance.contains("autocomplete")) {
                // String filterType = null;
                // try {
                // filterType = appearance.substring(appearance.indexOf('-') + 1);
                // } catch (Exception e) {
                // // Do nothing, leave filerType null
                // Log.e("WidgetFactory", "Exception parsing filterType");
                // }
                // questionWidget = new AutoCompleteWidget(context, fep, filterType);
                //
                // }
                else if (appearance.startsWith("quick")) {
                    questionWidget = new SelectOneAutoAdvanceWidget(context, fep);
                } else if (appearance.equals("list-nolabel")) {
                    questionWidget = new ListWidget(context, fep, false);
                } else if (appearance.equals("list")) {
                    questionWidget = new ListWidget(context, fep, true);
                } else if (appearance.equals("label")) {
                    questionWidget = new LabelWidget(context, fep);
                } else {
                    questionWidget = new SelectOneWidget(context, fep);
                }
                break;
            case Constants.CONTROL_SELECT_MULTI:
								// SurveyCTO-revised support for dynamic select content (from .csv files)
								// consider traditional ODK appearance to be first word in appearance string
                if (appearance.startsWith("compact")) {
                    int numColumns = -1;
                    try {
                    	String firstWord = appearance.split("\\s+")[0];
                    	int idx = firstWord.indexOf("-");
                    	if ( idx != -1 ) {
                    		numColumns =
                    				Integer.parseInt(firstWord.substring(idx + 1));
                    	}
                    } catch (Exception e) {
                        // Do nothing, leave numColumns as -1
                        Log.e("WidgetFactory", "Exception parsing numColumns");
                    }

                    questionWidget = new GridMultiWidget(context, fep, numColumns);
                } else if (appearance.startsWith("minimal")) {
                    questionWidget = new SpinnerMultiWidget(context, fep);
                } else if (appearance.startsWith("list-nolabel")) {
                    questionWidget = new ListMultiWidget(context, fep, false);
                } else if (appearance.startsWith("list")) {
                    questionWidget = new ListMultiWidget(context, fep, true);
                } else if (appearance.startsWith("label")) {
                    questionWidget = new LabelWidget(context, fep);
                } else {
                    questionWidget = new SelectMultiWidget(context, fep);
                }
                break;
            case Constants.CONTROL_TRIGGER:
                questionWidget = new TriggerWidget(context, fep);
                break;
            default:
                questionWidget = new StringWidget(context, fep, readOnlyOverride);
                break;
        }
        return questionWidget;
    }

}

/*
 * Copyright (C) 2011 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Typeface;
import android.util.Log;
import android.util.TypedValue;
import android.view.Display;
import android.view.Gravity;
import android.view.View;
import android.view.WindowManager;
import android.view.inputmethod.InputMethodManager;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageView;
import android.widget.ImageView.ScaleType;
import android.widget.LinearLayout;
import android.widget.RadioButton;
import android.widget.RelativeLayout;
import android.widget.TextView;

import org.javarosa.core.model.SelectChoice;
import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.SelectOneData;
import org.javarosa.core.model.data.helper.Selection;
import org.javarosa.core.reference.InvalidReferenceException;
import org.javarosa.core.reference.ReferenceManager;
import org.javarosa.form.api.FormEntryCaption;
import org.javarosa.form.api.FormEntryPrompt;
import org.javarosa.xpath.expr.XPathFuncExpr;
import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.external.ExternalDataUtil;
import org.odk.collect.android.external.ExternalSelectChoice;
import org.odk.collect.android.utilities.FileUtils;

import java.io.File;
import java.util.ArrayList;
import java.util.Vector;

/**
 * ListWidget handles select-one fields using radio buttons. The radio buttons are aligned
 * horizontally. They are typically meant to be used in a field list, where multiple questions with
 * the same multiple choice answers can sit on top of each other and make a grid of buttons that is
 * easy to navigate quickly. Optionally, you can turn off the labels. This would be done if a label
 * widget was at the top of your field list to provide the labels. If audio or video are specified
 * in the select answers they are ignored.
 * 
 * @author Jeff Beorse (jeff@beorse.net)
 */
public class ListWidget extends QuestionWidget implements OnCheckedChangeListener {
    private static final String t = "ListWidget";

    // Holds the entire question and answers. It is a horizontally aligned linear layout
    // needed because it is created in the super() constructor via addQuestionText() call.
    LinearLayout questionLayout;

    Vector<SelectChoice> mItems; // may take a while to compute
    
    ArrayList<RadioButton> buttons;

    public ListWidget(Context context, FormEntryPrompt prompt, boolean displayLabel) {
        super(context, prompt);

        // SurveyCTO-added support for dynamic select content (from .csv files)
        XPathFuncExpr xPathFuncExpr = ExternalDataUtil.getSearchXPathExpression(prompt.getAppearanceHint());
        if (xPathFuncExpr != null) {
            mItems = ExternalDataUtil.populateExternalChoices(prompt, xPathFuncExpr);
        } else {
            mItems = prompt.getSelectChoices();
        }
        buttons = new ArrayList<RadioButton>();

        // Layout holds the horizontal list of buttons
        LinearLayout buttonLayout = new LinearLayout(context);

        String s = null;
        if (prompt.getAnswerValue() != null) {
            s = ((Selection) prompt.getAnswerValue().getValue()).getValue();
        }

        if (mItems != null) {
            for (int i = 0; i < mItems.size(); i++) {
                RadioButton r = new RadioButton(getContext());

                r.setId(QuestionWidget.newUniqueId());
                r.setTag(Integer.valueOf(i));
                r.setEnabled(!prompt.isReadOnly());
                r.setFocusable(!prompt.isReadOnly());

                buttons.add(r);

                if (mItems.get(i).getValue().equals(s)) {
                    r.setChecked(true);
                }
                r.setOnCheckedChangeListener(this);

                String imageURI;
                if (mItems.get(i) instanceof ExternalSelectChoice) {
                    imageURI = ((ExternalSelectChoice) mItems.get(i)).getImage();
                } else {
                    imageURI = prompt.getSpecialFormSelectChoiceText(mItems.get(i), FormEntryCaption.TEXT_FORM_IMAGE);
                }

                // build image view (if an image is provided)
                ImageView mImageView = null;
                TextView mMissingImage = null;

                final int labelId = QuestionWidget.newUniqueId();
                
                // Now set up the image view
                String errorMsg = null;
                if (imageURI != null) {
                    try {
                        String imageFilename =
                            ReferenceManager._().DeriveReference(imageURI).getLocalURI();
                        final File imageFile = new File(imageFilename);
                        if (imageFile.exists()) {
                            Bitmap b = null;
                            try {
                                Display display =
                                    ((WindowManager) getContext().getSystemService(
                                        Context.WINDOW_SERVICE)).getDefaultDisplay();
                                int screenWidth = display.getWidth();
                                int screenHeight = display.getHeight();
                                b =
                                    FileUtils.getBitmapScaledToDisplay(imageFile, screenHeight,
                                        screenWidth);
                            } catch (OutOfMemoryError e) {
                                errorMsg = "ERROR: " + e.getMessage();
                            }

                            if (b != null) {
                                mImageView = new ImageView(getContext());
                                mImageView.setPadding(2, 2, 2, 2);
                                mImageView.setAdjustViewBounds(true);
                                mImageView.setImageBitmap(b);
                                mImageView.setId(labelId);
                            } else if (errorMsg == null) {
                                // An error hasn't been logged and loading the image failed, so it's
                                // likely
                                // a bad file.
                                errorMsg = getContext().getString(R.string.file_invalid, imageFile);

                            }
                        } else if (errorMsg == null) {
                            // An error hasn't been logged. We should have an image, but the file
                            // doesn't
                            // exist.
                            errorMsg = getContext().getString(R.string.file_missing, imageFile);
                        }

                        if (errorMsg != null) {
                            // errorMsg is only set when an error has occured
                            Log.e(t, errorMsg);
                            mMissingImage = new TextView(getContext());
                            mMissingImage.setText(errorMsg);

                            mMissingImage.setPadding(2, 2, 2, 2);
                            mMissingImage.setId(labelId);
                        }
                    } catch (InvalidReferenceException e) {
                        Log.e(t, "image invalid reference exception");
                        e.printStackTrace();
                    }
                } else {
                    // There's no imageURI listed, so just ignore it.
                }

                // build text label. Don't assign the text to the built in label to he
                // button because it aligns horizontally, and we want the label on top
                TextView label = new TextView(getContext());
                label.setText(prompt.getSelectChoiceText(mItems.get(i)));
                label.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
                label.setGravity(Gravity.CENTER_HORIZONTAL);
                if (!displayLabel) {
                    label.setVisibility(View.GONE);
                }

                // answer layout holds the label text/image on top and the radio button on bottom
                RelativeLayout answer = new RelativeLayout(getContext());
                RelativeLayout.LayoutParams headerParams =
                        new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
                headerParams.addRule(RelativeLayout.ALIGN_PARENT_TOP);
                headerParams.addRule(RelativeLayout.CENTER_HORIZONTAL);
                
                RelativeLayout.LayoutParams buttonParams =
                        new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
                buttonParams.addRule(RelativeLayout.CENTER_HORIZONTAL);

                if (mImageView != null) {
                	mImageView.setScaleType(ScaleType.CENTER);
                    if (!displayLabel) {
                        mImageView.setVisibility(View.GONE);
                    }
                    answer.addView(mImageView, headerParams);
                } else if (mMissingImage != null) {
                    answer.addView(mMissingImage, headerParams);
                } else {
                    if (displayLabel) {
                    	label.setId(labelId);
                        answer.addView(label, headerParams);
                    }

                }
                if ( displayLabel ) {
                	buttonParams.addRule(RelativeLayout.BELOW, labelId );
                }
                answer.addView(r, buttonParams);
                answer.setPadding(4, 0, 4, 0);

                // Each button gets equal weight
                LinearLayout.LayoutParams answerParams =
                    new LinearLayout.LayoutParams(LayoutParams.FILL_PARENT,
                            LayoutParams.WRAP_CONTENT);
                answerParams.weight = 1;

                buttonLayout.addView(answer, answerParams);

            }
        }

        // Align the buttons so that they appear horizonally and are right justified
        // buttonLayout.setGravity(Gravity.RIGHT);
        buttonLayout.setOrientation(LinearLayout.HORIZONTAL);
        // LinearLayout.LayoutParams params = new
        // LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
        // buttonLayout.setLayoutParams(params);

        // The buttons take up the right half of the screen
        LinearLayout.LayoutParams buttonParams =
            new LinearLayout.LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT);
        buttonParams.weight = 1;

        // questionLayout is created and populated with the question text in the
        // super() constructor via a call to addQuestionText
        questionLayout.addView(buttonLayout, buttonParams);
        addView(questionLayout);

    }


    @Override
    public void clearAnswer() {
        for (RadioButton button : this.buttons) {
            if (button.isChecked()) {
                button.setChecked(false);
                return;
            }
        }
    }


    @Override
    public IAnswerData getAnswer() {
        int i = getCheckedId();
        if (i == -1) {
            return null;
        } else {
            SelectChoice sc = mItems.elementAt(i);
            return new SelectOneData(new Selection(sc));
        }
    }


    @Override
    public void setFocus(Context context) {
        // Hide the soft keyboard if it's showing.
        InputMethodManager inputManager =
            (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
        inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
    }


    public int getCheckedId() {
    	for (int i=0; i < buttons.size(); ++i ) {
    		RadioButton button = buttons.get(i);
    		if (button.isChecked()) {
    			return i;
    		}
    	}
        return -1;
    }


    @Override
    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
        if (!isChecked) {
            // If it got unchecked, we don't care.
            return;
        }

        for (RadioButton button : this.buttons) {
            if (button.isChecked() && !(buttonView == button)) {
                button.setChecked(false);
            }
        }
       	Collect.getInstance().getActivityLogger().logInstanceAction(this, "onCheckedChanged", 
    			mItems.get((Integer)buttonView.getTag()).getValue(), mPrompt.getIndex());
    }


    // Override QuestionWidget's add question text. Build it the same
    // but add it to the relative layout
    protected void addQuestionText(FormEntryPrompt p) {

        // Add the text view. Textview always exists, regardless of whether there's text.
        TextView questionText = new TextView(getContext());
        questionText.setText(p.getLongText());
        questionText.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mQuestionFontsize);
        questionText.setTypeface(null, Typeface.BOLD);
        questionText.setPadding(0, 0, 0, 7);
        questionText.setId(QuestionWidget.newUniqueId()); // assign random id

        // Wrap to the size of the parent view
        questionText.setHorizontallyScrolling(false);

        if (p.getLongText() == null) {
            questionText.setVisibility(GONE);
        }

        // Put the question text on the left half of the screen
        LinearLayout.LayoutParams labelParams =
            new LinearLayout.LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT);
        labelParams.weight = 1;

        questionLayout = new LinearLayout(getContext());
        questionLayout.setOrientation(LinearLayout.HORIZONTAL);

        questionLayout.addView(questionText, labelParams);
    }


    @Override
    public void setOnLongClickListener(OnLongClickListener l) {
        for (RadioButton r : buttons) {
            r.setOnLongClickListener(l);
        }
    }


    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        for (RadioButton r : buttons) {
            r.cancelLongPress();
        }
    }

}

/*
 * Copyright (C) 2009 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.content.Context;
import android.content.res.Configuration;
import android.text.InputFilter;
import android.text.InputType;
import android.text.method.DigitsKeyListener;
import android.util.TypedValue;

import org.javarosa.core.model.data.DecimalData;
import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.form.api.FormEntryPrompt;

import java.text.NumberFormat;

/**
 * A widget that restricts values to floating point numbers.
 * 
 * @author Carl Hartung (carlhartung@gmail.com)
 */
public class DecimalWidget extends StringWidget {

	private Double getDoubleAnswerValue() {
		IAnswerData dataHolder = mPrompt.getAnswerValue();
        Double d = null;
        if (dataHolder != null) {
        	Object dataValue = dataHolder.getValue();
        	if ( dataValue != null ) {
        		if (dataValue instanceof Integer){
	                d =  Double.valueOf(((Integer)dataValue).intValue());
	            } else {
	                d =  (Double) dataValue;
	            }
        	}
        }
        return d;
	}
	
    public DecimalWidget(Context context, FormEntryPrompt prompt, boolean readOnlyOverride) {
        super(context, prompt, readOnlyOverride, true);

        // formatting
        mAnswer.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
        mAnswer.setInputType(InputType.TYPE_NUMBER_FLAG_DECIMAL);
//
//        // needed to make long readonly text scroll
//        mAnswer.setHorizontallyScrolling(false);
//        mAnswer.setSingleLine(false);

        // only numbers are allowed
        mAnswer.setRawInputType(Configuration.KEYBOARD_12KEY);
        mAnswer.setKeyListener(new DigitsKeyListener(true, true));

        // only 15 characters allowed
        InputFilter[] fa = new InputFilter[1];
        fa[0] = new InputFilter.LengthFilter(15);
        mAnswer.setFilters(fa);

        Double d = getDoubleAnswerValue();

        NumberFormat nf = NumberFormat.getNumberInstance();
        nf.setMaximumFractionDigits(15);
        nf.setMaximumIntegerDigits(15);
        nf.setGroupingUsed(false);
        if (d != null) {
        	// truncate to 15 digits max...
            String dString = nf.format(d);
            d = Double.parseDouble(dString.replace(',', '.'));
            mAnswer.setText(d.toString());
        }

        // disable if read only
        if (prompt.isReadOnly()) {
            setBackgroundDrawable(null);
            setFocusable(false);
            setClickable(false);
        }
        
        setupChangeListener();
    }


    @Override
    public IAnswerData getAnswer() {
    	clearFocus();
        String s = mAnswer.getText().toString();
        if (s == null || s.equals("")) {
            return null;
        } else {
            try {
                return new DecimalData(Double.valueOf(s).doubleValue());
            } catch (Exception NumberFormatException) {
                return null;
            }
        }
    }

}

/*
 * Copyright (C) 2009 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.content.Context;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.View;
import android.view.inputmethod.InputMethodManager;
import android.widget.CheckBox;
import android.widget.LinearLayout;
import android.widget.TextView;

import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.StringData;
import org.javarosa.form.api.FormEntryPrompt;
import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;

/**
 * Widget that allows user to scan barcodes and add them to the form.
 * 
 * @author Yaw Anokwa (yanokwa@gmail.com)
 */
public class TriggerWidget extends QuestionWidget {

    private CheckBox mTriggerButton;
    private TextView mStringAnswer;
    private static final String mOK = "OK";

    private FormEntryPrompt mPrompt;


    public FormEntryPrompt getPrompt() {
        return mPrompt;
    }


    public TriggerWidget(Context context, FormEntryPrompt prompt) {
        super(context, prompt);
        mPrompt = prompt;

        this.setOrientation(LinearLayout.VERTICAL);

        mTriggerButton = new CheckBox(getContext());
        mTriggerButton.setId(QuestionWidget.newUniqueId());
        mTriggerButton.setText(getContext().getString(R.string.trigger));
        mTriggerButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
        // mActionButton.setPadding(20, 20, 20, 20);
        mTriggerButton.setEnabled(!prompt.isReadOnly());

        mTriggerButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                if (mTriggerButton.isChecked()) {
                    mStringAnswer.setText(mOK);
                	Collect.getInstance().getActivityLogger().logInstanceAction(TriggerWidget.this, "triggerButton", 
                			"OK", mPrompt.getIndex());
                } else {
                    mStringAnswer.setText(null);
                	Collect.getInstance().getActivityLogger().logInstanceAction(TriggerWidget.this, "triggerButton", 
                			"null", mPrompt.getIndex());
                }
            }
        });

        mStringAnswer = new TextView(getContext());
        mStringAnswer.setId(QuestionWidget.newUniqueId());
        mStringAnswer.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
        mStringAnswer.setGravity(Gravity.CENTER);

        String s = prompt.getAnswerText();
        if (s != null) {
            if (s.equals(mOK)) {
                mTriggerButton.setChecked(true);
            } else {
                mTriggerButton.setChecked(false);
            }
            mStringAnswer.setText(s);

        }

        // finish complex layout
        this.addView(mTriggerButton);
        // this.addView(mStringAnswer);
    }


    @Override
    public void clearAnswer() {
        mStringAnswer.setText(null);
        mTriggerButton.setChecked(false);
    }


    @Override
    public IAnswerData getAnswer() {
        String s = mStringAnswer.getText().toString();
        if (s == null || s.equals("")) {
            return null;
        } else {
            return new StringData(s);
        }
    }


    @Override
    public void setFocus(Context context) {
        // Hide the soft keyboard if it's showing.
        InputMethodManager inputManager =
            (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
        inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
    }


    @Override
    public void setOnLongClickListener(OnLongClickListener l) {
        mTriggerButton.setOnLongClickListener(l);
        mStringAnswer.setOnLongClickListener(l);
    }


    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        mTriggerButton.cancelLongPress();
        mStringAnswer.cancelLongPress();
    }

}

/*
 * Copyright (C) 2011 University of Washington
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package org.odk.collect.android.widgets;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Typeface;
import android.util.Log;
import android.util.TypedValue;
import android.view.Display;
import android.view.Gravity;
import android.view.View;
import android.view.WindowManager;
import android.view.inputmethod.InputMethodManager;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.ImageView;
import android.widget.ImageView.ScaleType;
import android.widget.LinearLayout;
import android.widget.RelativeLayout;
import android.widget.TextView;

import org.javarosa.core.model.SelectChoice;
import org.javarosa.core.model.data.IAnswerData;
import org.javarosa.core.model.data.SelectMultiData;
import org.javarosa.core.model.data.helper.Selection;
import org.javarosa.core.reference.InvalidReferenceException;
import org.javarosa.core.reference.ReferenceManager;
import org.javarosa.form.api.FormEntryCaption;
import org.javarosa.form.api.FormEntryPrompt;
import org.javarosa.xpath.expr.XPathFuncExpr;
import org.odk.collect.android.R;
import org.odk.collect.android.application.Collect;
import org.odk.collect.android.external.ExternalDataUtil;
import org.odk.collect.android.external.ExternalSelectChoice;
import org.odk.collect.android.utilities.FileUtils;

import java.io.File;
import java.util.ArrayList;
import java.util.Vector;

/**
 * ListMultiWidget handles multiple selection fields using check boxes. The check boxes are aligned
 * horizontally. They are typically meant to be used in a field list, where multiple questions with
 * the same multiple choice answers can sit on top of each other and make a grid of buttons that is
 * easy to navigate quickly. Optionally, you can turn off the labels. This would be done if a label
 * widget was at the top of your field list to provide the labels. If audio or video are specified
 * in the select answers they are ignored. This class is almost identical to ListWidget, except it
 * uses checkboxes. It also did not require a custom clickListener class.
 * 
 * @author Jeff Beorse (jeff@beorse.net)
 */
public class ListMultiWidget extends QuestionWidget {
    private static final String t = "ListMultiWidget";

    // Holds the entire question and answers. It is a horizontally aligned linear layout
    // needed because it is created in the super() constructor via addQuestionText() call.
    LinearLayout questionLayout;

    private boolean mCheckboxInit = true;
    
    private Vector<SelectChoice> mItems; // may take a while to compute...

    private ArrayList<CheckBox> mCheckboxes;


    @SuppressWarnings("unchecked")
    public ListMultiWidget(Context context, FormEntryPrompt prompt, boolean displayLabel) {
        super(context, prompt);

        // SurveyCTO-added support for dynamic select content (from .csv files)
        XPathFuncExpr xPathFuncExpr = ExternalDataUtil.getSearchXPathExpression(prompt.getAppearanceHint());
        if (xPathFuncExpr != null) {
            mItems = ExternalDataUtil.populateExternalChoices(prompt, xPathFuncExpr);
        } else {
            mItems = prompt.getSelectChoices();
        }
        mCheckboxes = new ArrayList<CheckBox>();
        mPrompt = prompt;

        // Layout holds the horizontal list of buttons
        LinearLayout buttonLayout = new LinearLayout(context);

        Vector<Selection> ve = new Vector<Selection>();
        if (prompt.getAnswerValue() != null) {
            ve = (Vector<Selection>) prompt.getAnswerValue().getValue();
        }

        if (mItems != null) {
            for (int i = 0; i < mItems.size(); i++) {
                CheckBox c = new CheckBox(getContext());
                c.setTag(Integer.valueOf(i));
                c.setId(QuestionWidget.newUniqueId());
                c.setFocusable(!prompt.isReadOnly());
                c.setEnabled(!prompt.isReadOnly());
                for (int vi = 0; vi < ve.size(); vi++) {
                    // match based on value, not key
                    if (mItems.get(i).getValue().equals(ve.elementAt(vi).getValue())) {
                        c.setChecked(true);
                        break;
                    }

                }
                mCheckboxes.add(c);

                // when clicked, check for readonly before toggling
                c.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
                    @Override
                    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
                        if (!mCheckboxInit && mPrompt.isReadOnly()) {
                            if (buttonView.isChecked()) {
                                buttonView.setChecked(false);
                               	Collect.getInstance().getActivityLogger().logInstanceAction(this, "onItemClick.deselect", 
                            			mItems.get((Integer)buttonView.getTag()).getValue(), mPrompt.getIndex());
                            } else {
                                buttonView.setChecked(true);
                               	Collect.getInstance().getActivityLogger().logInstanceAction(this, "onItemClick.select", 
                            			mItems.get((Integer)buttonView.getTag()).getValue(), mPrompt.getIndex());
                            }
                        }
                    }
                });

                String imageURI;
                if (mItems.get(i) instanceof ExternalSelectChoice) {
                    imageURI = ((ExternalSelectChoice) mItems.get(i)).getImage();
                } else {
                    imageURI = prompt.getSpecialFormSelectChoiceText(mItems.get(i), FormEntryCaption.TEXT_FORM_IMAGE);
                }

                // build image view (if an image is provided)
                ImageView mImageView = null;
                TextView mMissingImage = null;

                final int labelId = QuestionWidget.newUniqueId();

                // Now set up the image view
                String errorMsg = null;
                if (imageURI != null) {
                    try {
                        String imageFilename =
                            ReferenceManager._().DeriveReference(imageURI).getLocalURI();
                        final File imageFile = new File(imageFilename);
                        if (imageFile.exists()) {
                            Bitmap b = null;
                            try {
                                Display display =
                                    ((WindowManager) getContext().getSystemService(
                                        Context.WINDOW_SERVICE)).getDefaultDisplay();
                                int screenWidth = display.getWidth();
                                int screenHeight = display.getHeight();
                                b =
                                    FileUtils.getBitmapScaledToDisplay(imageFile, screenHeight,
                                        screenWidth);
                            } catch (OutOfMemoryError e) {
                                errorMsg = "ERROR: " + e.getMessage();
                            }

                            if (b != null) {
                                mImageView = new ImageView(getContext());
                                mImageView.setPadding(2, 2, 2, 2);
                                mImageView.setAdjustViewBounds(true);
                                mImageView.setImageBitmap(b);
                                mImageView.setId(labelId);
                            } else if (errorMsg == null) {
                                // An error hasn't been logged and loading the image failed, so it's
                                // likely
                                // a bad file.
                                errorMsg = getContext().getString(R.string.file_invalid, imageFile);

                            }
                        } else if (errorMsg == null) {
                            // An error hasn't been logged. We should have an image, but the file
                            // doesn't
                            // exist.
                            errorMsg = getContext().getString(R.string.file_missing, imageFile);
                        }

                        if (errorMsg != null) {
                            // errorMsg is only set when an error has occured
                            Log.e(t, errorMsg);
                            mMissingImage = new TextView(getContext());
                            mMissingImage.setText(errorMsg);

                            mMissingImage.setPadding(2, 2, 2, 2);
                            mMissingImage.setId(labelId);
                        }
                    } catch (InvalidReferenceException e) {
                        Log.e(t, "image invalid reference exception");
                        e.printStackTrace();
                    }
                } else {
                    // There's no imageURI listed, so just ignore it.
                }

                // build text label. Don't assign the text to the built in label to he
                // button because it aligns horizontally, and we want the label on top
                TextView label = new TextView(getContext());
                label.setText(prompt.getSelectChoiceText(mItems.get(i)));
                label.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mAnswerFontsize);
                label.setGravity(Gravity.CENTER_HORIZONTAL);
                if (!displayLabel) {
                    label.setVisibility(View.GONE);
                }

                // answer layout holds the label text/image on top and the radio button on bottom
                RelativeLayout answer = new RelativeLayout(getContext());
                RelativeLayout.LayoutParams headerParams =
                        new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
                headerParams.addRule(RelativeLayout.ALIGN_PARENT_TOP);
                headerParams.addRule(RelativeLayout.CENTER_HORIZONTAL);
                
                RelativeLayout.LayoutParams buttonParams =
                        new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
                buttonParams.addRule(RelativeLayout.CENTER_HORIZONTAL);

                if (mImageView != null) {
                	mImageView.setScaleType(ScaleType.CENTER);
                    if (!displayLabel) {
                        mImageView.setVisibility(View.GONE);
                    }
                    answer.addView(mImageView, headerParams);
                } else if (mMissingImage != null) {
                    answer.addView(mMissingImage, headerParams);
                } else {
                    if (displayLabel) {
                    	label.setId(labelId);
                        answer.addView(label, headerParams);
                    }

                }
                if (displayLabel) {
                	buttonParams.addRule(RelativeLayout.BELOW, labelId);
                }
                answer.addView(c, buttonParams);
                answer.setPadding(4, 0, 4, 0);

                // /Each button gets equal weight
                LinearLayout.LayoutParams answerParams =
                    new LinearLayout.LayoutParams(LayoutParams.FILL_PARENT,
                            LayoutParams.WRAP_CONTENT);
                answerParams.weight = 1;

                buttonLayout.addView(answer, answerParams);

            }
        }

        // Align the buttons so that they appear horizonally and are right justified
        // buttonLayout.setGravity(Gravity.RIGHT);
        buttonLayout.setOrientation(LinearLayout.HORIZONTAL);
        // LinearLayout.LayoutParams params = new
        // LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
        // buttonLayout.setLayoutParams(params);

        // The buttons take up the right half of the screen
        LinearLayout.LayoutParams buttonParams =
            new LinearLayout.LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT);
        buttonParams.weight = 1;

        questionLayout.addView(buttonLayout, buttonParams);
        addView(questionLayout);

    }


    @Override
    public void clearAnswer() {
        for (int i = 0; i < mCheckboxes.size(); i++) {
        	CheckBox c = mCheckboxes.get(i);
            if (c.isChecked()) {
                c.setChecked(false);
            }
        }
    }


    @Override
    public IAnswerData getAnswer() {
        Vector<Selection> vc = new Vector<Selection>();
        for (int i = 0; i < mCheckboxes.size(); i++) {
        	CheckBox c = mCheckboxes.get(i);
            if (c.isChecked()) {
                vc.add(new Selection(mItems.get(i)));
            }
        }

        if (vc.size() == 0) {
            return null;
        } else {
            return new SelectMultiData(vc);
        }

    }


    @Override
    public void setFocus(Context context) {
        // Hide the soft keyboard if it's showing.
        InputMethodManager inputManager =
            (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
        inputManager.hideSoftInputFromWindow(this.getWindowToken(), 0);
    }


    // Override QuestionWidget's add question text. Build it the same
    // but add it to the questionLayout
    protected void addQuestionText(FormEntryPrompt p) {

        // Add the text view. Textview always exists, regardless of whether there's text.
    	TextView questionText = new TextView(getContext());
        questionText.setText(p.getLongText());
        questionText.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mQuestionFontsize);
        questionText.setTypeface(null, Typeface.BOLD);
        questionText.setPadding(0, 0, 0, 7);
        questionText.setId(QuestionWidget.newUniqueId()); // assign random id

        // Wrap to the size of the parent view
        questionText.setHorizontallyScrolling(false);

        if (p.getLongText() == null) {
            questionText.setVisibility(GONE);
        }

        // Put the question text on the left half of the screen
        LinearLayout.LayoutParams labelParams =
            new LinearLayout.LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT);
        labelParams.weight = 1;

        questionLayout = new LinearLayout(getContext());
        questionLayout.setOrientation(LinearLayout.HORIZONTAL);

        questionLayout.addView(questionText, labelParams);
    }


    @Override
    public void setOnLongClickListener(OnLongClickListener l) {
        for (CheckBox c : mCheckboxes) {
            c.setOnLongClickListener(l);
        }
    }


    @Override
    public void cancelLongPress() {
        super.cancelLongPress();
        for (CheckBox c : mCheckboxes) {
            c.cancelLongPress();
        }
    }
}
